<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","access_control.rs"],"content":"use alloy::{\n    hex,\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n};\nuse e2e::{constructor, receipt, Account};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n    contract AccessControl {\n        function hasRole(bytes32 role, address account) public view virtual returns (bool hasRole);\n        function getRoleAdmin(bytes32 role) public view virtual returns (bytes32 role);\n        function grantRole(bytes32 role, address account) public virtual;\n        function revokeRole(bytes32 role, address account) public virtual;\n        function renounceRole(bytes32 role, address callerConfirmation) public virtual;\n        function setRoleAdmin(bytes32 role, bytes32 adminRole) public virtual;\n    }\n);\n\nconst DEFAULT_ADMIN_ROLE: [u8; 32] =\n    openzeppelin_stylus::access::control::AccessControl::DEFAULT_ADMIN_ROLE;\n// There's no way to query constants of a Stylus contract, so this one is\n// hard-coded :(\nconst ROLE: [u8; 32] =\n    keccak_const::Keccak256::new().update(b\"TRANSFER_ROLE\").finalize();\nconst NEW_ADMIN_ROLE: [u8; 32] =\n    hex!(\"879ce0d4bfd332649ca3552efe772a38d64a315eb70ab69689fd309c735946b5\");\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"AccessControl\", run).await\n}\n\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_addr = alice.address();\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let bob = Account::new().await?;\n    let bob_addr = bob.address();\n    let bob_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(bob.signer.clone()))\n        .on_http(bob.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice, cache_opt).await?;\n\n    let contract = AccessControl::new(contract_addr, \u0026alice_wallet);\n    let contract_bob = AccessControl::new(contract_addr, \u0026bob_wallet);\n\n    // IMPORTANT: Order matters!\n    use AccessControl::*;\n    #[rustfmt::skip]\n    let receipts = vec![\n        (hasRoleCall::SIGNATURE, receipt!(contract.hasRole(DEFAULT_ADMIN_ROLE.into(), alice_addr))?),\n        (getRoleAdminCall::SIGNATURE, receipt!(contract.getRoleAdmin(ROLE.into()))?),\n        (revokeRoleCall::SIGNATURE, receipt!(contract.revokeRole(ROLE.into(), alice_addr))?),\n        (grantRoleCall::SIGNATURE, receipt!(contract.grantRole(ROLE.into(), bob_addr))?),\n        (renounceRoleCall::SIGNATURE, receipt!(contract_bob.renounceRole(ROLE.into(), bob_addr))?),\n        (setRoleAdminCall::SIGNATURE, receipt!(contract.setRoleAdmin(ROLE.into(), NEW_ADMIN_ROLE.into()))?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(\n        account,\n        \"access-control\",\n        Some(constructor!(account.address())),\n        cache_opt,\n    )\n    .await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","erc1155.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n    uint,\n};\nuse e2e::{receipt, Account};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n    contract Erc1155 {\n        function balanceOf(address account, uint256 id) external view returns (uint256 balance);\n        function balanceOfBatch(address[] accounts, uint256[] ids) external view returns (uint256[] memory balances);\n        function isApprovedForAll(address account, address operator) external view returns (bool approved);\n        function setApprovalForAll(address operator, bool approved) external;\n        function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) external;\n        function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data) external;\n        function mint(address to, uint256 id, uint256 amount, bytes memory data) external;\n        function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external;\n        function burn(address account, uint256 id, uint256 value) external;\n        function burnBatch(address account, uint256[] memory ids, uint256[] memory values) external;\n    }\n);\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"Erc1155\", run).await\n}\n\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_addr = alice.address();\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let bob = Account::new().await?;\n    let bob_addr = bob.address();\n    let bob_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(bob.signer.clone()))\n        .on_http(bob.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice, cache_opt).await?;\n\n    let contract = Erc1155::new(contract_addr, \u0026alice_wallet);\n    let contract_bob = Erc1155::new(contract_addr, \u0026bob_wallet);\n\n    let token_1 = uint!(1_U256);\n    let token_2 = uint!(2_U256);\n    let token_3 = uint!(3_U256);\n    let token_4 = uint!(4_U256);\n\n    let value_1 = uint!(100_U256);\n    let value_2 = uint!(200_U256);\n    let value_3 = uint!(300_U256);\n    let value_4 = uint!(400_U256);\n\n    let ids = vec![token_1, token_2, token_3, token_4];\n    let values = vec![value_1, value_2, value_3, value_4];\n\n    let data: alloy_primitives::Bytes = vec![].into();\n\n    // IMPORTANT: Order matters!\n    use Erc1155::*;\n    #[rustfmt::skip]\n    let receipts = vec![\n        (mintCall::SIGNATURE, receipt!(contract.mint(alice_addr, token_1, value_1, data.clone()))?),\n        (mintBatchCall::SIGNATURE, receipt!(contract.mintBatch(alice_addr, ids.clone(), values.clone(), data.clone()))?),\n        (balanceOfCall::SIGNATURE, receipt!(contract.balanceOf(alice_addr, token_1))?),\n        (balanceOfBatchCall::SIGNATURE, receipt!(contract.balanceOfBatch(vec![alice_addr, bob_addr], vec![token_1, token_2]))?),\n        (setApprovalForAllCall::SIGNATURE, receipt!(contract.setApprovalForAll(bob_addr, true))?),\n        (isApprovedForAllCall::SIGNATURE, receipt!(contract.isApprovedForAll(alice_addr, bob_addr))?),\n        (safeTransferFromCall::SIGNATURE, receipt!(contract.safeTransferFrom(alice_addr, bob_addr, token_1, value_1, data.clone()))?),\n        (safeBatchTransferFromCall::SIGNATURE, receipt!(contract.safeBatchTransferFrom(alice_addr, bob_addr, ids.clone(), values.clone(), data))?),\n        // We should burn Bob's tokens on behalf of Bob, not Alice.\n        (burnCall::SIGNATURE, receipt!(contract_bob.burn(bob_addr, token_1, value_1))?),\n        (burnBatchCall::SIGNATURE, receipt!(contract_bob.burnBatch(bob_addr, ids, values))?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(account, \"erc1155\", None, cache_opt).await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","erc1155_metadata_uri.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n    uint,\n};\nuse e2e::{constructor, receipt, Account};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n    contract Erc1155MetadataUri {\n        function uri(uint256 id) external view returns (string memory uri);\n        function setTokenURI(uint256 tokenId, string memory tokenURI) external;\n        function setBaseURI(string memory tokenURI) external;\n    }\n);\n\nconst URI: \u0026str = \"https://github.com/OpenZeppelin/rust-contracts-stylus\";\nconst BASE_URI: \u0026str = \"https://github.com\";\nconst TOKEN_URI: \u0026str = \"/some/token/uri\";\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"Erc1155MetadataUri\", run).await\n}\n\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice, cache_opt).await?;\n\n    let contract = Erc1155MetadataUri::new(contract_addr, \u0026alice_wallet);\n\n    let token_id = uint!(1_U256);\n\n    // IMPORTANT: Order matters!\n    use Erc1155MetadataUri::*;\n    #[rustfmt::skip]\n    let receipts = vec![\n        (setTokenURICall::SIGNATURE, receipt!(contract.setTokenURI(token_id, TOKEN_URI.to_owned()))?),\n        (setBaseURICall::SIGNATURE, receipt!(contract.setBaseURI(BASE_URI.to_owned()))?),\n        (uriCall::SIGNATURE, receipt!(contract.uri(token_id))?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(\n        account,\n        \"erc1155-metadata-uri\",\n        Some(constructor!(URI.to_string())),\n        cache_opt,\n    )\n    .await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","erc1155_supply.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n    uint,\n};\nuse e2e::{receipt, Account};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n    contract Erc1155Supply {\n        function mint(address to, uint256 id, uint256 amount, bytes memory data) external;\n        function totalSupply(uint256 id) external view returns (uint256);\n        function totalSupply() external view returns (uint256);\n        function exists(uint256 id) external view returns (bool);\n    }\n);\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"Erc1155Supply\", run).await\n}\n\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_addr = alice.address();\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice, cache_opt).await?;\n\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice_wallet);\n\n    let token = uint!(1_U256);\n    let value = uint!(100_U256);\n\n    // IMPORTANT: Order matters!\n    use Erc1155Supply::*;\n    #[rustfmt::skip]\n    let receipts = vec![\n        (mintCall::SIGNATURE, receipt!(contract.mint(alice_addr, token, value, vec![].into()))?),\n        (existsCall::SIGNATURE, receipt!(contract.exists(token))?),\n        (totalSupply_0Call::SIGNATURE, receipt!(contract.totalSupply_0(token))?),\n        (totalSupply_1Call::SIGNATURE, receipt!(contract.totalSupply_1())?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(account, \"erc1155-supply\", None, cache_opt).await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","erc20.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n    uint,\n};\nuse alloy_primitives::U256;\nuse e2e::{constructor, receipt, Account};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n    contract Erc20 {\n        function name() external view returns (string name);\n        function symbol() external view returns (string symbol);\n        function decimals() external view returns (uint8 decimals);\n        function totalSupply() external view returns (uint256 totalSupply);\n        function balanceOf(address account) external view returns (uint256 balance);\n        function allowance(address owner, address spender) external view returns (uint256 allowance);\n\n        function cap() public view virtual returns (uint256 cap);\n\n        function mint(address account, uint256 amount) external;\n        function burn(uint256 amount) external;\n        function burnFrom(address account, uint256 amount) external;\n\n        function transfer(address recipient, uint256 amount) external returns (bool);\n        function approve(address spender, uint256 amount) external returns (bool);\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    }\n);\n\nconst TOKEN_NAME: \u0026str = \"Test Token\";\nconst TOKEN_SYMBOL: \u0026str = \"TTK\";\nconst CAP: U256 = uint!(1_000_000_U256);\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"Erc20\", run).await\n}\n\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_addr = alice.address();\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let bob = Account::new().await?;\n    let bob_addr = bob.address();\n    let bob_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(bob.signer.clone()))\n        .on_http(bob.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice, cache_opt).await?;\n\n    let contract = Erc20::new(contract_addr, \u0026alice_wallet);\n    let contract_bob = Erc20::new(contract_addr, \u0026bob_wallet);\n\n    // IMPORTANT: Order matters!\n    use Erc20::*;\n    #[rustfmt::skip]\n    let receipts = vec![\n        (nameCall::SIGNATURE, receipt!(contract.name())?),\n        (symbolCall::SIGNATURE, receipt!(contract.symbol())?),\n        (decimalsCall::SIGNATURE, receipt!(contract.decimals())?),\n        (totalSupplyCall::SIGNATURE, receipt!(contract.totalSupply())?),\n        (balanceOfCall::SIGNATURE, receipt!(contract.balanceOf(alice_addr))?),\n        (allowanceCall::SIGNATURE, receipt!(contract.allowance(alice_addr, bob_addr))?),\n        (capCall::SIGNATURE, receipt!(contract.cap())?),\n        (mintCall::SIGNATURE, receipt!(contract.mint(alice_addr, uint!(10_U256)))?),\n        (burnCall::SIGNATURE, receipt!(contract.burn(uint!(1_U256)))?),\n        (transferCall::SIGNATURE, receipt!(contract.transfer(bob_addr, uint!(1_U256)))?),\n        (approveCall::SIGNATURE, receipt!(contract.approve(bob_addr, uint!(5_U256)))?),\n        (burnFromCall::SIGNATURE, receipt!(contract_bob.burnFrom(alice_addr, uint!(1_U256)))?),\n        (transferFromCall::SIGNATURE, receipt!(contract_bob.transferFrom(alice_addr, bob_addr, uint!(4_U256)))?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(\n        account,\n        \"erc20\",\n        Some(constructor!(\n            TOKEN_NAME.to_string(),\n            TOKEN_SYMBOL.to_string(),\n            CAP\n        )),\n        cache_opt,\n    )\n    .await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","erc6909.rs"],"content":"// benches/src/erc6909.rs\n\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse stylus_sdk::testing::TestVM;\nuse alloy_primitives::{Address, U256};\nuse openzeppelin_stylus::token::erc6909::{\n    extensions::{token_supply::Erc6909Supply, metadata_uri::Erc6909MetadataUri},\n    traits::{IErc6909, IErc6909Mintable, IErc6909Burnable, IErc6909Supply, IErc6909MetadataUri},\n};\n\nfn bench_mint(c: \u0026mut Criterion) {\n    let vm = TestVM::default();\n    let mut token = Erc6909Supply::from(\u0026vm);\n    let alice = Address::new([0xAA; 20]);\n    c.bench_function(\"erc6909 mint\", |b| {\n        b.iter(|| {\n            token\n                .mint(\n                    black_box(alice),\n                    black_box(U256::from(1u64)),\n                    black_box(U256::from(1u64)),\n                )\n                .unwrap();\n        })\n    });\n}\n\nfn bench_approve(c: \u0026mut Criterion) {\n    let vm = TestVM::default();\n    let mut token = Erc6909Supply::from(\u0026vm);\n    let owner   = Address::new([0xAA; 20]);\n    let spender = Address::new([0xBB; 20]);\n    let id      = U256::from(1u64);\n    c.bench_function(\"erc6909 approve\", |b| {\n        b.iter(|| {\n            token\n                .approve(\n                    black_box(owner),\n                    black_box(spender),\n                    black_box(id),\n                    black_box(U256::from(1u64)),\n                )\n                .unwrap();\n        })\n    });\n}\n\nfn bench_transfer(c: \u0026mut Criterion) {\n    let vm = TestVM::default();\n    let mut token = Erc6909Supply::from(\u0026vm);\n    let alice = Address::new([0xAA; 20]);\n    let bob   = Address::new([0xBB; 20]);\n    let id    = U256::from(1u64);\n    // seed one token so the transfer will actually do work\n    token.mint(alice, id, U256::from(1u64)).unwrap();\n    c.bench_function(\"erc6909 transfer\", |b| {\n        b.iter(|| {\n            token\n                .transfer(\n                    black_box(alice),\n                    black_box(bob),\n                    black_box(id),\n                    black_box(U256::from(1u64)),\n                )\n                .unwrap();\n        })\n    });\n}\n\nfn bench_transfer_from(c: \u0026mut Criterion) {\n    let vm = TestVM::default();\n    let mut token = Erc6909Supply::from(\u0026vm);\n    let alice = Address::new([0xAA; 20]);\n    let bob   = Address::new([0xBB; 20]);\n    let id    = U256::from(1u64);\n    token.mint(alice, id, U256::from(1u64)).unwrap();\n    token.approve(alice, bob, id, U256::from(1u64)).unwrap();\n    c.bench_function(\"erc6909 transfer_from\", |b| {\n        b.iter(|| {\n            token\n                .transfer_from(\n                    black_box(bob),\n                    black_box(alice),\n                    black_box(bob),\n                    black_box(id),\n                    black_box(U256::from(1u64)),\n                )\n                .unwrap();\n        })\n    });\n}\n\nfn bench_burn(c: \u0026mut Criterion) {\n    let vm = TestVM::default();\n    let mut token = Erc6909Supply::from(\u0026vm);\n    let alice = Address::new([0xAA; 20]);\n    let id    = U256::from(1u64);\n    token.mint(alice, id, U256::from(1u64)).unwrap();\n    c.bench_function(\"erc6909 burn\", |b| {\n        b.iter(|| {\n            token\n                .burn(\n                    black_box(alice),\n                    black_box(id),\n                    black_box(U256::from(1u64)),\n                )\n                .unwrap();\n        })\n    });\n}\n\nfn bench_set_token_uri(c: \u0026mut Criterion) {\n    let vm = TestVM::default();\n    let mut meta = Erc6909MetadataUri::from(\u0026vm);\n    let caller = Address::new([0xAA; 20]);\n    let id     = U256::from(1u64);\n    let uri    = b\"https://token/1\".to_vec();\n    c.bench_function(\"erc6909 set_token_uri\", |b| {\n        b.iter(|| {\n            meta\n                .set_token_uri(\n                    black_box(caller),\n                    black_box(id),\n                    black_box(uri.clone()),\n                )\n                .unwrap();\n        })\n    });\n}\n\nfn bench_token_uri(c: \u0026mut Criterion) {\n    let vm = TestVM::default();\n    let mut meta = Erc6909MetadataUri::from(\u0026vm);\n    let caller = Address::new([0xAA; 20]);\n    let id     = U256::from(1u64);\n    let uri    = b\"https://token/1\".to_vec();\n    // pre-seed one URI so reads actually traverse storage\n    meta.set_token_uri(caller, id, uri.clone()).unwrap();\n    c.bench_function(\"erc6909 token_uri\", |b| {\n        b.iter(|| {\n            let _ = meta.token_uri(black_box(id));\n        })\n    });\n}\n\n// If you implement an enumerable extension, add two more benches here:\n// fn bench_total_ids(c: \u0026mut Criterion) { … }\n// fn bench_id_by_index(c: \u0026mut Criterion) { … }\n\ncriterion_group!(\n    erc6909_benches,\n    bench_mint,\n    bench_approve,\n    bench_transfer,\n    bench_transfer_from,\n    bench_burn,\n    bench_set_token_uri,\n    bench_token_uri,\n);\ncriterion_main!(erc6909_benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","erc721.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n    uint,\n};\nuse e2e::{receipt, Account};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n    contract Erc721 {\n        function balanceOf(address owner) external view returns (uint256 balance);\n        function approve(address to, uint256 tokenId) external;\n        function getApproved(uint256 tokenId) external view returns (address approved);\n        function isApprovedForAll(address owner, address operator) external view returns (bool approved);\n        function ownerOf(uint256 tokenId) external view returns (address ownerOf);\n        function safeTransferFrom(address from, address to, uint256 tokenId) external;\n        function setApprovalForAll(address operator, bool approved) external;\n        function totalSupply() external view returns (uint256 totalSupply);\n        function transferFrom(address from, address to, uint256 tokenId) external;\n        function mint(address to, uint256 tokenId) external;\n        function burn(uint256 tokenId) external;\n    }\n);\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"Erc721\", run).await\n}\n\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_addr = alice.address();\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let bob = Account::new().await?;\n    let bob_addr = bob.address();\n\n    let contract_addr = deploy(\u0026alice, cache_opt).await?;\n\n    let contract = Erc721::new(contract_addr, \u0026alice_wallet);\n\n    let token_1 = uint!(1_U256);\n    let token_2 = uint!(2_U256);\n    let token_3 = uint!(3_U256);\n    let token_4 = uint!(4_U256);\n\n    receipt!(contract.mint(alice_addr, token_2))?;\n    receipt!(contract.mint(alice_addr, token_3))?;\n    receipt!(contract.mint(alice_addr, token_4))?;\n\n    // IMPORTANT: Order matters!\n    use Erc721::*;\n    #[rustfmt::skip]\n    let receipts = vec![\n        (balanceOfCall::SIGNATURE, receipt!(contract.balanceOf(alice_addr))?),\n        (approveCall::SIGNATURE, receipt!(contract.approve(bob_addr, token_2))?),\n        (getApprovedCall::SIGNATURE, receipt!(contract.getApproved(token_2))?),\n        (isApprovedForAllCall::SIGNATURE, receipt!(contract.isApprovedForAll(alice_addr, bob_addr))?),\n        (ownerOfCall::SIGNATURE, receipt!(contract.ownerOf(token_2))?),\n        (safeTransferFromCall::SIGNATURE, receipt!(contract.safeTransferFrom(alice_addr, bob_addr, token_3))?),\n        (setApprovalForAllCall::SIGNATURE, receipt!(contract.setApprovalForAll(bob_addr, true))?),\n        (totalSupplyCall::SIGNATURE, receipt!(contract.totalSupply())?),\n        (transferFromCall::SIGNATURE, receipt!(contract.transferFrom(alice_addr, bob_addr, token_4))?),\n        (mintCall::SIGNATURE, receipt!(contract.mint(alice_addr, token_1))?),\n        (burnCall::SIGNATURE, receipt!(contract.burn(token_1))?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(account, \"erc721\", None, cache_opt).await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","lib.rs"],"content":"use std::process::Command;\n\nuse alloy::primitives::Address;\nuse alloy_primitives::U128;\nuse e2e::{Account, Constructor};\nuse eyre::WrapErr;\nuse serde::Deserialize;\n\npub mod access_control;\npub mod erc1155;\npub mod erc1155_metadata_uri;\npub mod erc1155_supply;\npub mod erc20;\npub mod erc721;\npub mod merkle_proofs;\npub mod ownable;\npub mod pedersen;\npub mod poseidon;\npub mod poseidon_asm_sol;\npub mod poseidon_sol;\npub mod report;\npub mod vesting_wallet;\n\n#[derive(Debug, Deserialize)]\nstruct ArbOtherFields {\n    #[serde(rename = \"gasUsedForL1\")]\n    gas_used_for_l1: U128,\n    #[allow(dead_code)]\n    #[serde(rename = \"l1BlockNumber\")]\n    l1_block_number: String,\n}\n\n/// Optimisation options for the contract.\n///\n/// Cache or cache optimized WASM.\n#[derive(Clone)]\npub enum Opt {\n    None,\n    Cache,\n    CacheWasmOpt,\n}\n\nasync fn deploy(\n    account: \u0026Account,\n    contract_name: \u0026str,\n    constructor: Option\u003cConstructor\u003e,\n    opt: Opt,\n) -\u003e eyre::Result\u003cAddress\u003e {\n    let manifest_dir =\n        std::env::current_dir().context(\"should get current dir from env\")?;\n\n    let contract_type = match opt {\n        Opt::CacheWasmOpt =\u003e \"example_opt\",\n        Opt::None | Opt::Cache =\u003e \"example\",\n    };\n\n    let wasm_path = manifest_dir\n        .join(\"target\")\n        .join(\"wasm32-unknown-unknown\")\n        .join(\"release\")\n        .join(format!(\n            \"{}_{}.wasm\",\n            contract_name.replace('-', \"_\"),\n            contract_type\n        ));\n\n    let deployer = match constructor {\n        Some(constructor) =\u003e {\n            account.as_deployer().with_constructor(constructor)\n        }\n        None =\u003e account.as_deployer(),\n    };\n\n    let address = deployer.deploy_wasm(\u0026wasm_path).await?.contract_address;\n\n    match opt {\n        Opt::Cache | Opt::CacheWasmOpt =\u003e {\n            cache_contract(account, address, 0)?;\n        }\n        Opt::None =\u003e {}\n    }\n\n    Ok(address)\n}\n\n/// Try to cache a contract on the stylus network.\n/// Already cached contracts won't be cached, and this function will not return\n/// an error.\n/// Output will be forwarded to the child process.\nfn cache_contract(\n    account: \u0026Account,\n    contract_addr: Address,\n    bid: u32,\n) -\u003e eyre::Result\u003c()\u003e {\n    // We don't need a status code.\n    // Since it is not zero when the contract is already cached.\n    Command::new(\"cargo\")\n        .args([\"stylus\", \"cache\", \"bid\"])\n        .args([\"-e\", \u0026env(\"RPC_URL\")?])\n        .args([\"--private-key\", \u0026format!(\"0x{}\", account.pk())])\n        .arg(contract_addr.to_string())\n        .arg(bid.to_string())\n        .status()\n        .context(\"failed to execute `cargo stylus cache bid` command\")?;\n    Ok(())\n}\n\n/// Load the `name` environment variable.\nfn env(name: \u0026str) -\u003e eyre::Result\u003cString\u003e {\n    std::env::var(name).wrap_err(format!(\"failed to load {name}\"))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","main.rs"],"content":"use benches::{\n    access_control, erc1155, erc1155_metadata_uri, erc20, erc721,\n    merkle_proofs, ownable, pedersen, poseidon, poseidon_asm_sol, poseidon_sol,\n    report::BenchmarkReport,\n};\nuse futures::FutureExt;\nuse itertools::Itertools;\n\n#[tokio::main]\nasync fn main() -\u003e eyre::Result\u003c()\u003e {\n    let benchmarks = [\n        access_control::bench().boxed(),\n        erc20::bench().boxed(),\n        erc721::bench().boxed(),\n        merkle_proofs::bench().boxed(),\n        ownable::bench().boxed(),\n        erc1155::bench().boxed(),\n        erc1155_metadata_uri::bench().boxed(),\n        pedersen::bench().boxed(),\n        poseidon_sol::bench().boxed(),\n        poseidon_asm_sol::bench().boxed(),\n        poseidon::bench().boxed(),\n    ];\n\n    // Run benchmarks max 3 at the same time.\n    // Otherwise, nitro test node can overload and revert transaction.\n    const MAX_PARALLEL: usize = 3;\n    let mut report = BenchmarkReport::default();\n    for chunk in \u0026benchmarks.into_iter().chunks(MAX_PARALLEL) {\n        report = futures::future::try_join_all(chunk)\n            .await?\n            .into_iter()\n            .fold(report, BenchmarkReport::merge_with);\n    }\n\n    println!();\n    println!(\"{report}\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","merkle_proofs.rs"],"content":"use alloy::{\n    hex,\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n};\nuse e2e::{receipt, Account};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n    contract Verifier {\n        function verify(bytes32[] proof, bytes32 root, bytes32 leaf) external pure returns (bool);\n\n        function multiProofVerify(\n            bytes32[] memory proof,\n            bool[] memory proofFlags,\n            bytes32 root,\n            bytes32[] memory leaves\n        ) external pure returns (bool);\n    }\n);\n\n/// Shorthand for converting from an array of hex literals to an array of\n/// fixed 32-bytes slices.\nmacro_rules! bytes_array {\n    ($($s:literal),* $(,)?) =\u003e {\n        [\n            $(alloy::hex!($s),)*\n        ]\n    };\n}\n\nconst ROOT: [u8; 32] =\n    hex!(\"bb439f2cd52c20cd5a0d2a9fc43acc94e44c58b6b8907626f15d43e2b6fa4599\");\nconst LEAF: [u8; 32] =\n    hex!(\"ae5a6b19bb2927169dcf59f1e0fab3ef5a58264f24afc950c8921dd0018613e1\");\nconst PROOF: [[u8; 32]; 16] = bytes_array! {\n    \"ae59450ef5e421fa6543f57de8ac9a2e71072669e7dfa4b939b3cb08040c3172\",\n    \"812723c39e2874b3ee1e91b19c0ae36cec8f16968292e5cd8d63dc820e4c880e\",\n    \"206c4b19563946e4049473bfa67040a9ae95be0afdb147074759501ad1b7cd99\",\n    \"9e7c6c195b5e5ea9ed0bf2a03cb9807ad610ad09d8bd19f7f2ee4972829e8e98\",\n    \"74e58acd9bfd0778bf2d85fb4bc5532078a9519e84cae147a1794d4be857a476\",\n    \"c4a1dadd851264dc68a0143b92933885ee987ce9bd88592fb7ef283d7e4d9b38\",\n    \"740787cebe5fdf6a4696191d58e90964022bdc07bbcb4da85fcba3a25a310cfb\",\n    \"06ca1871c30b7a4dea60f7739a75b3b376d4277dd15827780e4474b17cb8d42f\",\n    \"06acc609483fc476b7b6e81b185ad5380135b3166a092b489b760f05424b8bec\",\n    \"7164e2347a3b0349f77cdcdba42de9496fb7da1f40666a7f2e862a0ced0cf687\",\n    \"a6e400012f156c6bf518255107bc0eefb8678d8ae4bd35b820b397edd21b45f4\",\n    \"9cd2fab756b8e5b4a4749c472d35107d520a841c4f4a5c5c7cdebf61b299f981\",\n    \"30b7394a87d2cb2a4fb5530a0bc78bda42d55075019f5c210c43167ba8138393\",\n    \"af02b07c5c611f8aa1609e9962668de34a571a32d16e95bf0c90bb15cb78f019\",\n    \"dff6a4f635ef79dec68385c4246179534dbd031e7f6ab527a25c73e46b40a7ca\",\n    \"fd47b6c292f51911e8dfdc3e4f8bd127773b17f25b7a554beaa8741e99c41208\",\n};\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"MerkleProofs\", run).await\n}\n\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice, cache_opt).await?;\n\n    let contract = Verifier::new(contract_addr, \u0026alice_wallet);\n\n    let proof = PROOF.map(|h| h.into()).to_vec();\n\n    let receipts = vec![(\n        Verifier::verifyCall::SIGNATURE,\n        receipt!(contract.verify(proof, ROOT.into(), LEAF.into()))?,\n    )];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(account, \"merkle-proofs\", None, cache_opt).await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","ownable.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n};\nuse e2e::{constructor, receipt, Account};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n    contract Ownable {\n        function owner() external view returns (address owner);\n        function renounceOwnership() external onlyOwner;\n        function transferOwnership(address newOwner) external;\n    }\n);\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"Ownable\", run).await\n}\n\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let bob = Account::new().await?;\n    let bob_addr = bob.address();\n    let bob_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(bob.signer.clone()))\n        .on_http(bob.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice, cache_opt).await?;\n\n    let contract = Ownable::new(contract_addr, \u0026alice_wallet);\n    let contract_bob = Ownable::new(contract_addr, \u0026bob_wallet);\n\n    // IMPORTANT: Order matters!\n    use Ownable::*;\n    #[rustfmt::skip]\n    let receipts = vec![\n        (ownerCall::SIGNATURE, receipt!(contract.owner())?),\n        (transferOwnershipCall::SIGNATURE, receipt!(contract.transferOwnership(bob_addr))?),\n        (renounceOwnershipCall::SIGNATURE, receipt!(contract_bob.renounceOwnership())?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(\n        account,\n        \"ownable\",\n        Some(constructor!(account.address())),\n        cache_opt,\n    )\n    .await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","pedersen.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n};\nuse e2e::{receipt, Account};\nuse openzeppelin_crypto::arithmetic::{\n    uint::{from_str_hex, U256},\n    BigInteger,\n};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n   contract PedersenExample {\n        #[derive(Debug)]\n        function hash(uint256[2] memory inputs) external view returns (uint256 hash);\n    }\n);\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"Pedersen\", run).await\n}\n\nfn to_alloy_u256(value: \u0026U256) -\u003e alloy_primitives::U256 {\n    alloy_primitives::U256::from_le_slice(\u0026value.into_bytes_le())\n}\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice, cache_opt).await?;\n\n    let contract = PedersenExample::new(contract_addr, \u0026alice_wallet);\n\n    let input_1 = to_alloy_u256(\u0026from_str_hex(\n        \"3d937c035c878245caf64531a5756109c53068da139362728feb561405371cb\",\n    ));\n    let input_2 = to_alloy_u256(\u0026from_str_hex(\n        \"208a0a10250e382e1e4bbe2880906c2791bf6275695e02fbbc6aeff9cd8b31a\",\n    ));\n\n    #[rustfmt::skip]\n    let receipts = vec![\n        (PedersenExample::hashCall::SIGNATURE, receipt!(contract.hash([input_1, input_2]))?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(account, \"pedersen\", None, cache_opt).await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","poseidon.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n};\nuse alloy_primitives::uint;\nuse e2e::{receipt, Account};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n   contract PoseidonExample {\n        #[derive(Debug)]\n        function hash(uint256[2] memory inputs) external view returns (uint256 hash);\n    }\n);\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"Poseidon\", run).await\n}\n\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice, cache_opt).await?;\n\n    let contract = PoseidonExample::new(contract_addr, \u0026alice_wallet);\n\n    #[rustfmt::skip]\n    let receipts = vec![\n        (PoseidonExample::hashCall::SIGNATURE, receipt!(contract.hash([uint!(123_U256), uint!(123456_U256)]))?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(account, \"poseidon\", None, cache_opt).await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","poseidon_asm_sol.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n};\nuse alloy_primitives::uint;\nuse e2e::{receipt, Account};\n\nuse crate::report::{ContractReport, FunctionReport};\n\nsol!(\n    #[sol(rpc)]\n   contract PoseidonExample {\n        #[derive(Debug)]\n        function hash(uint256[2] memory inputs) external view returns (uint256 hash);\n    }\n);\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    let reports = run().await?;\n    let report = reports.into_iter().try_fold(\n        ContractReport::new(\"Sol:Asm:Poseidon\"),\n        ContractReport::add,\n    )?;\n\n    Ok(report)\n}\n\npub async fn run() -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice).await?;\n\n    let contract = PoseidonExample::new(contract_addr, \u0026alice_wallet);\n\n    #[rustfmt::skip]\n    let receipts = vec![\n        (PoseidonExample::hashCall::SIGNATURE, receipt!(contract.hash([uint!(123_U256), uint!(123456_U256)]))?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\npub async fn deploy(account: \u0026Account) -\u003e eyre::Result\u003cAddress\u003e {\n    let contract = PoseidonT3::deploy(\u0026account.wallet).await?;\n    Ok(*contract.address())\n}\n\n// https://github.com/chancehudson/poseidon-solidity/blob/main/contracts/PoseidonT3.sol\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc 0.8.24+commit.e11b9ed9\n    #[sol(rpc, bytecode=\"615db161004d600b8282823980515f1a6073146041577f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b305f52607381538281f3fe7300000000000000000000000000000000000000003014608060405260043610610034575f3560e01c8063561558fe14610038575b5f80fd5b610052600480360381019061004d9190615d28565b610068565b60405161005f9190615d62565b60405180910390f35b5f7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000017f2b90bba00fca0589f617e7dcbfe82e0df706ab640ceb247b791a93b74e36736d7f101071f0032379b697315876690f053d148d4e109f5fb065c8aacc55a0f89bfa7f19a3fc0a56702bf417ba7fee3802593fa644470307043f7773279cd71d25d5e07ef1445235f2148c5986587169fc1bcd887b08d4d00868df5696fff40956e8648460805106017f08dff3487e8ac99e1f29a058d0fa80b930c728730b7ab36ce879f3890ecf73f58560a05106018582830986838883840909925086828309905086828883840909915086868309877f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085097f2229fe5e63f56eef4bfba02c26292de10ac2b2b045e6184acff16e4660c05f6b01017f2f27be690fdaee46c3ce28f7532b13c856c35342c84bda6e20966310fadc01d001905086858309877f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385097f2949435275a29cdbffe3e4101a45669873f9408a5d11e21b4ec6edf8501eee4d01017f2b2ae1acf68b7b8d2416bebf3d4f6234b763fe04b8043ee48b8327bebca16cf20187858409887f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291186097f20c290a7269657965092ef5700a447f5bc2c41dfca932f527cb2600ac9bcfefb01017f0319d062072bef7ecca5eac06f97d4d55952c175ab6b03eae64b44c7dbf11cfa018883840989848b83840909935089838409905089838b83840909925089828309905089828b838409099150898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f28813dcaebaeaa828a376df87af4a63bc8b7bf27ad49c6298ef7b387bf28526d019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f2727673b2ccbc903f181bf38e1c1d40d2033865200c352bc150928adddf9cb78019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f234ec45ca27727c2e74abd2b2a1494cd6efbd43e340587d6b8fb9e31e65cc63201945089818209935089818b86870909905089868709935089868b86870909955089858609935089858b868709099450898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f15b52534031ae18f7f862cb2cf7cf760ab10a8150a337b1ccd99ff6e8797d428019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f0dc8fad6d9e4b35f5ed9a3d186b79ce38e0e8a8d1b58b132d701d4eecf68d1f6019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f1bcd95ffc211fbca600f705fad3fb567ea4eb378f62e1fec97805518a47e4d9c01915089848509905089848b83840909935089838409905089838b83840909925089828309905089828b838409099150898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f10520b0ab721cadfe9eff81b016fc34dc76da36c2578937817cb978d069de559019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1f6d48149b8e7f7d9b257d8ed5fbbaf42932498075fed0ace88a9eb81f5627f6019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1d9655f652309014d29e00ef35a2089bfff8dc1c816f0dc9ca34bdb5460c870501945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f04df5a56ff95bcafb051f7b1cd43a99ba731ff67e47032058fe3d4185697cc7d019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f0672d995f8fff640151b3d290cedaf148690a10a8c8424a7f6ec282b6e4be828019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f099952b414884454b21200d7ffafdd5f0c9a9dcc06f2708e9fc1d8209b5c75b901915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f052cba2255dfd00c7c483143ba8d469448e43586a9b4cd9183fd0e843a6b9fa6019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0b8badee690adb8eb0bd74712b7999af82de55707251ad7716077cb93c464ddc019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f119b1590f13307af5a1ee651020c07c749c15d60683a8050b963d0a8e4b2bdd101945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f03150b7cd6d5d17b2529d36be0f67b832c4acfc884ef4ee5ce15be0bfb4a8d09019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2cc6182c5e14546e3cf1951f173912355374efb83d80898abe69cb317c9ea565019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017e5032551e6378c450cfe129a404b3764218cadedac14e2b92d2cd73111bf0f901915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f233237e3289baa34bb147e972ebcb9516469c399fcc069fb88f9da2cc28276b5019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f05c8f4f4ebd4a6e3c980d31674bfbe6323037f21b34ae5a4e80c2d4c24d60280019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f0a7b1db13042d396ba05d818a319f25252bcf35ef3aeed91ee1f09b2590fc65b01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2a73b71f9b210cf5b14296572c9d32dbf156e2b086ff47dc5df542365a404ec0019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1ac9b0417abcc9a1935107e9ffc91dc3ec18f2c4dbe7f22976a760bb5c50c460019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f12c0339ae08374823fabb076707ef479269f3e4d6cb104349015ee046dc93fc001915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0b7475b102a165ad7f5b18db4e1e704f52900aa3253baac68246682e56e9a28e019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f037c2849e191ca3edb1c5e49f6e8b8917c843e379366f2ea32ab3aa88d7f8448019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f05a6811f8556f014e92674661e217e9bd5206c5c93a07dc145fdb176a716346f01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f29a795e7d98028946e947b75d54e9f044076e87a7b2883b47b675ef5f38bd66e019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f20439a0c84b322eb45a3857afc18f5826e8c7382c8a1585c507be199981fd22f019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2e0ba8d94d9ecf4a94ec2050c7371ff1bb50f27799a84b6d4a2a6f2a0982c88701915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f143fd115ce08fb27ca38eb7cce822b4517822cd2109048d2e6d0ddcca17d71c8019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0c64cbecb1c734b857968dbbdcf813cdf8611659323dbcbfc84323623be9caf1019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f028a305847c683f646fca925c163ff5ae74f348d62c2b670f1426cef9403da5301945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2e4ef510ff0b6fda5fa940ab4c4380f26a6bcb64d89427b824d6755b5db9e30c019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017e81c95bc43384e663d79270c956ce3b8925b4f6d033b078b96384f50579400e019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2ed5f0c91cbd9749187e2fade687e05ee2491b349c039a0bba8a9f4023a0bb3801915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f30509991f88da3504bbf374ed5aae2f03448a22c76234c8c990f01f33a735206019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1c3f20fd55409a53221b7c4d49a356b9f0a1119fb2067b41a7529094424ec6ad019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f10b4e7f3ab5df003049514459b6e18eec46bb2213e8e131e170887b47ddcb96c01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2a1982979c3ff7f43ddd543d891c2abddd80f804c077d775039aa3502e43adef019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1c74ee64f15e1db6feddbead56d6d55dba431ebc396c9af95cad0f1315bd5c91019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f07533ec850ba7f98eab9303cace01b4b9e4f2e8b82708cfa9c2fe45a0ae146a001915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f21576b438e500449a151e4eeaf17b154285c68f42d42c1808a11abf3764c0750019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f2f17c0559b8fe79608ad5ca193d62f10bce8384c815f0906743d6930836d4a9e019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f2d477e3862d07708a79e8aae946170bc9775a4201318474ae665b0b1b7e2730e01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f162f5243967064c390e095577984f291afba2266c38f5abcd89be0f5b2747eab019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2b4cb233ede9ba48264ecd2c8ae50d1ad7a8596a87f29f8a7777a70092393311019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2c8fbcb2dd8573dc1dbaf8f4622854776db2eece6d85c4cf4254e7c35e03b07a01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f1d6f347725e4816af2ff453f0cd56b199e1b61e9f601e9ade5e88db870949da9019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f204b0c397f4ebe71ebc2d8b3df5b913df9e6ac02b68d31324cd49af5c4565529019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f0c4cb9dc3c4fd8174f1149b3c63c3c2f9ecb827cd7dc25534ff8fb75bc79c50201945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f174ad61a1448c899a25416474f4930301e5c49475279e0639a616ddc45bc7b54019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1a96177bcf4d8d89f759df4ec2f3cde2eaaa28c177cc0fa13a9816d49a38d2ef019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f066d04b24331d71cd0ef8054bc60c4ff05202c126a233c1a8242ace360b8a30a01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f2a4c4fc6ec0b0cf52195782871c6dd3b381cc65f72e02ad527037a62aa1bd804019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f13ab2d136ccf37d447e9f2e14a7cedc95e727f8446f6d9d7e55afc01219fd649019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1121552fca26061619d24d843dc82769c1b04fcec26f55194c2e3e869acc6a9a01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017eef653322b13d6c889bc81715c37d77a6cd267d595c4a8909a5546c7c97cff1019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f0e25483e45a665208b261d8ba74051e6400c776d652595d9845aca35d8a397d3019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f29f536dcb9dd7682245264659e15d88e395ac3d4dde92d8c46448db979eeba8901915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f2a56ef9f2c53febadfda33575dbdbd885a124e2780bbea170e456baace0fa5be019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1c8361c78eb5cf5decfb7a2d17b5c409f2ae2999a46762e8ee416240a8cb9af1019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f151aff5f38b20a0fc0473089aaf0206b83e8e68a764507bfd3d0ab4be74319c501945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f04c6187e41ed881dc1b239c88f7f9d43a9f52fc8c8b6cdd1e76e47615b51f100019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f13b37bd80f4d27fb10d84331f6fb6d534b81c61ed15776449e801b7ddc9c2967019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f01a5c536273c2d9df578bfbd32c17b7a2ce3664c2a52032c9321ceb1c4e8a8e401915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f2ab3561834ca73835ad05f5d7acb950b4a9a2c666b9726da832239065b7c3b02019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1d4d8ec291e720db200fe6d686c0d613acaf6af4e95d3bf69f7ed516a597b646019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f041294d2cc484d228f5784fe7919fd2bb925351240a04b711514c9c80b65af1d01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f154ac98e01708c611c4fa715991f004898f57939d126e392042971dd90e81fc6019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f0b339d8acca7d4f83eedd84093aef51050b3684c88f8b0b04524563bc6ea4da4019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f0955e49e6610c94254a4f84cfbab344598f0e71eaff4a7dd81ed95b50839c82e01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f06746a6156eba54426b9e22206f15abca9a6f41e6f535c6f3525401ea0654626019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0f18f5a0ecd1423c496f3820c549c27838e5790e2bd0a196ac917c7ff32077fb019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f04f6eeca1751f7308ac59eff5beb261e4bb563583ede7bc92a738223d6f76e1301945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2b56973364c4c4f5c1a3ec4da3cdce038811eb116fb3e45bc1768d26fc0b3758019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f123769dd49d5b054dcd76b89804b1bcb8e1392b385716a5d83feb65d437f29ef019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2147b424fc48c80a88ee52b91169aacea989f6446471150994257b2fb01c63e901915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0fdc1f58548b85701a6c5505ea332a29647e6f34ad4243c2ea54ad897cebe54d019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f12373a8251fea004df68abcf0f7786d4bceff28c5dbbe0c3944f685cc0a0b1f2019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f21e4f4ea5f35f85bad7ea52ff742c9e8a642756b6af44203dd8a1f35c1a9003501945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f16243916d69d2ca3dfb4722224d4c462b57366492f45e90d8a81934f1bc3b147019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1efbe46dd7a578b4f66f9adbc88b4378abc21566e1a0453ca13a4159cac04ac2019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f07ea5e8537cf5dd08886020e23a7f387d468d5525be66f853b672cc96a88969a01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f05a8c4f9968b8aa3b7b478a30f9a5b63650f19a75e7ce11ca9fe16c0b76c00bc019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f20f057712cc21654fbfe59bd345e8dac3f7818c701b9c7882d9d57b72a32e83f019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f04a12ededa9dfd689672f8c67fee31636dcd8e88d01d49019bd90b33eb33db6901945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f27e88d8c15f37dcee44f1e5425a51decbd136ce5091a6767e49ec9544ccd101a019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2feed17b84285ed9b8a5c8c5e95a41f66e096619a7703223176c41ee433de4d1019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f1ed7cc76edf45c7c404241420f729cf394e5942911312a0d6972b8bd53aff2b801915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f15742e99b9bfa323157ff8c586f5660eac6783476144cdcadf2874be45466b1a019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1aac285387f65e82c895fc6887ddf40577107454c6ec0317284f033f27d0c785019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f25851c3c845d4790f9ddadbdb6057357832e2e7a49775f71ec75a96554d67c7701945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f15a5821565cc2ec2ce78457db197edf353b7ebba2c5523370ddccc3d9f146a67019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2411d57a4813b9980efa7e31a1db5966dcf64f36044277502f15485f28c71727019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017e2e6f8d6520cd4713e335b8c0b6d2e647e9a98e12f4cd2558828b5ef6cb4c9b01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f2ff7bc8f4380cde997da00b616b0fcd1af8f0e91e2fe1ed7398834609e0315d2019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017eb9831b948525595ee02724471bcd182e9521f6b7bb68f1e93be4febb0d3cbe019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f0a2f53768b8ebf6a86913b0e57c04e011ca408648a4743a87d77adbf0c9c351201945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017e248156142fd0373a479f91ff239e960f599ff7e94be69b7f2a290305e1198d019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f171d5620b87bfb1328cf8c02ab3f0c9a397196aa6a542c2350eb512a2b2bcda9019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f170a4f55536f7dc970087c7c10d6fad760c952172dd54dd99d1045e4ec34a80801915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f29aba33f799fe66c2ef3134aea04336ecc37e38c1cd211ba482eca17e2dbfae1019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1e9bc179a4fdd758fdd1bb1945088d47e70d114a03f6a0e8b5ba650369e64973019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1dd269799b660fad58f7f4892dfb0b5afeaad869a9c4b44f9c9e1c43bdaf8f0901945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f22cdbc8b70117ad1401181d02e15459e7ccd426fe869c7c95d1dd2cb0f24af38019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f0ef042e454771c533a9f57a55c503fcefd3150f52ed94a7cd5ba93b9c7dacefd019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f11609e06ad6c8fe2f287f3036037e8851318e8b08a0359a03b304ffca62e828401915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f1166d9e554616dba9e753eea427c17b7fecd58c076dfe42708b08f5b783aa9af019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f2de52989431a859593413026354413db177fbf4cd2ac0b56f855a888357ee466019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f3006eb4ffc7a85819a6da492f3a8ac1df51aee5b17b8e89d74bf01cf5f71e9ad01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2af41fbb61ba8a80fdcf6fff9e3f6f422993fe8f0a4639f962344c8225145086019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f119e684de476155fe5a6b41a8ebc85db8718ab27889e85e781b214bace4827c3019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f1835b786e2e8925e188bea59ae363537b51248c23828f047cff784b97b3fd80001915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f28201a34c594dfa34d794996c6433a20d152bac2a7905c926c40e285ab32eeb6019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f083efd7a27d1751094e80fefaf78b000864c82eb571187724a761f88c22cc4e7019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f0b6f88a3577199526158e61ceea27be811c16df7774dd8519e079564f61fd13b01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f0ec868e6d15e51d9644f66e1d6471a94589511ca00d29e1014390e6ee4254f5b019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2af33e3f866771271ac0c9b3ed2e1142ecd3e74b939cd40d00d937ab84c98591019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f0b520211f904b5e7d09b5d961c6ace7734568c547dd6858b364ce5e47951f17801915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0b2d722d0919a1aad8db58f10062a92ea0c56ac4270e822cca228620188a1d40019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1f790d4d7f8cf094d980ceb37c2453e957b54a9991ca38bbe0061d1ed6e562d4019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f0171eb95dfbf7d1eaea97cd385f780150885c16235a2a6a8da92ceb01e50423301945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f0c2d0e3b5fd57549329bf6885da66b9b790b40defd2c8650762305381b168873019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1162fb28689c27154e5a8228b4e72b377cbcafa589e283c35d3803054407a18d019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2f1459b65dee441b64ad386a91e8310f282c5a92a89e19921623ef8249711bc001915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f1e6ff3216b688c3d996d74367d5cd4c1bc489d46754eb712c243f70d1b53cfbb019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f01ca8be73832b8d0681487d27d157802d741a6f36cdc2a0576881f9326478875019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1f7735706ffe9fc586f976d5bdf223dc680286080b10cea00b9b5de315f9650e01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2522b60f4ea3307640a0c2dce041fba921ac10a3d5f096ef4745ca838285f019019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f23f0bee001b1029d5255075ddc957f833418cad4f52b6c3f8ce16c235572575b019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2bc1ae8b8ddbb81fcaac2d44555ed5685d142633e9df905f66d9401093082d5901915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0f9406b8296564a37304507b8dba3ed162371273a07b1fc98011fcd6ad72205f019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f2360a8eb0cc7defa67b72998de90714e17e75b174a52ee4acb126c8cd995f0a8019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f15871a5cddead976804c803cbaef255eb4815a5e96df8b006dcbbc2767f8894801945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f193a56766998ee9e0a8652dd2f3b1da0362f4f54f72379544f957ccdeefb420f019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2a394a43934f86982f9be56ff4fab1703b2e63c8ad334834e4309805e777ae0f019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f1859954cfeb8695f3e8b635dcb345192892cd11223443ba7b4166e8876c0d14201915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f04e1181763050e58013444dbcb99f1902b11bc25d90bbdca408d3819f4fed32b019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0fdb253dee83869d40c335ea64de8c5bb10eb82db08b5e8b1f5e5552bfd05f23019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f058cbe8a9a5027bdaa4efb623adead6275f08686f1c08984a9d7c5bae9b4f1c001945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f1382edce9971e186497eadb1aeb1f52b23b4b83bef023ab0d15228b4cceca59a019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f03464990f045c6ee0819ca51fd11b0be7f61b8eb99f14b77e1e6634601d9e8b5019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f23f7bfc8720dc296fff33b41f98ff83c6fcab4605db2eb5aaa5bc137aeb70a5801915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0a59a158e3eec2117e6e94e7f0e9decf18c3ffd5e1531a9219636158bbaf62f2019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f06ec54c80381c052b58bf23b312ffd3ce2c4eba065420af8f4c23ed0075fd07b019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f118872dc832e0eb5476b56648e867ec8b09340f7a7bcb1b4962f0ff9ed1f9d0101945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f13d69fa127d834165ad5c7cba7ad59ed52e0b0f0e42d7fea95e1906b520921b1019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f169a177f63ea681270b1c6877a73d21bde143942fb71dc55fd8a49f19f10c77b019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f04ef51591c6ead97ef42f287adce40d93abeb032b922f66ffb7e9a5a7450544d01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f256e175a1dc079390ecd7ca703fb2e3b19ec61805d4f03ced5f45ee6dd0f69ec019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f30102d28636abd5fe5f2af412ff6004f75cc360d3205dd2da002813d3e2ceeb2019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f10998e42dfcd3bbf1c0714bc73eb1bf40443a3fa99bef4a31fd31be182fcc79201945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f193edd8e9fcf3d7625fa7d24b598a1d89f3362eaf4d582efecad76f879e36860019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f18168afd34f2d915d0368ce80b7b3347d1c7a561ce611425f2664d7aa51f0b5d019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f29383c01ebd3b6ab0c017656ebe658b6a328ec77bc33626e29e2e95b33ea611101915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f10646d2f2603de39a1f4ae5e7771a64a702db6e86fb76ab600bf573f9010c711019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0beb5e07d1b27145f575f1395a55bf132f90c25b40da7b3864d0242dcb1117fb019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f16d685252078c133dc0d3ecad62b5c8830f95bb2e54b59abdffbf018d96fa33601945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f0a6abd1d833938f33c74154e0404b4b40a555bbbec21ddfafd672dd62047f01a019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1a679f5d36eb7b5c8ea12a4c2dedc8feb12dffeec450317270a6f19b34cf1860019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f0980fb233bd456c23974d50e0ebfde4726a423eada4e8f6ffbc7592e3f1b93d601915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f161b42232e61b84cbf1810af93a38fc0cece3d5628c9282003ebacb5c312c72b019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0ada10a90c7f0520950f7d47a60d5e6a493f09787f1564e5d09203db47de1a0b019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1a730d372310ba82320345a29ac4238ed3f07a8a2b4e121bb50ddb9af407f45101945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2c8120f268ef054f817064c369dda7ea908377feaba5c4dffbda10ef58e8c556019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1c7c8824f758753fa57c00789c684217b930e95313bcb73e6e7b8649a4968f70019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2cd9ed31f5f8691c8e39e4077a74faa0f400ad8b491eb3f7b47b27fa3fd1cf7701915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f23ff4f9d46813457cf60d92f57618399a5e022ac321ca550854ae23918a22eea019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f09945a5d147a4f66ceece6405dddd9d0af5a2c5103529407dff1ea58f180426d019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f188d9c528025d4c2b67660c6b771b90f7c7da6eaa29d3f268a6dd223ec6fc63001945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f3050e37996596b7f81f68311431d8734dba7d926d3633595e0c0d8ddf4f0f47f019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f15af1169396830a91600ca8102c35c426ceae5461e3f95d89d829518d30afd78019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f1da6d09885432ea9a06d9f37f873d985dae933e351466b2904284da3320d8acc01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f2796ea90d269af29f5f8acf33921124e4e4fad3dbe658945e546ee411ddaa9cb019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f202d7dd1da0f6b4b0325c8b3307742f01e15612ec8e9304a7cb0319e01d32d60019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f096d6790d05bb759156a952ba263d672a2d7f9c788f4c831a29dace4c0f8be5f01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f054efa1f65b0fce283808965275d877b438da23ce5b13e1963798cb1447d25a4019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1b162f83d917e93edb3308c29802deb9d8aa690113b2e14864ccf6e18e4165f1019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f21e5241e12564dd6fd9f1cdd2a0de39eedfefc1466cc568ec5ceb745a0506edc01915089848509905089848b83840909935089838409905089838b83840909925089828309905089828b838409099150898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f1cfb5662e8cf5ac9226a80ee17b36abecb73ab5f87e161927b4349e10e4bdf08019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0f21177e302a771bbae6d8d1ecb373b62c99af346220ac0129c53f666eb24100019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1671522374606992affb0dd7f71b12bec4236aede6290546bcef7e1f515c232001945089818209935089818b86870909905089868709935089868b86870909955089858609935089858b868709099450898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f0fa3ec5b9488259c2eb4cf24501bfad9be2ec9e42c5cc8ccd419d2a692cad870019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f193c0e04e0bd298357cb266c1506080ed36edce85c648cc085e8c57b1ab54bba019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f102adf8ef74735a27e9128306dcbc3c99f6f7291cd406578ce14ea2adaba68f801915089848509905089848b83840909935089838409905089838b83840909925089828309905089828b838409099150898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0fe0af7858e49859e2a54d6f1ad945b1316aa24bfbdd23ae40a6d0cb70c3eab1019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f216f6717bbc7dedb08536a2220843f4e2da5f1daa9ebdefde8a5ea7344798d22019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1da55cc900f0d21f4a3e694391918a1b3c23b2ac773c6b3ef88e2e422832516101945089818209935089818b86870909905089868709935089868b86870909955089858609935089858b868709099450898a8a87098b7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e089098c7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b85090101065f5260205ff35b5f604051905090565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b615c0182615bbb565b810181811067ffffffffffffffff82111715615c2057615c1f615bcb565b5b80604052505050565b5f615c32615baa565b9050615c3e8282615bf8565b919050565b5f67ffffffffffffffff821115615c5d57615c5c615bcb565b5b602082029050919050565b5f80fd5b5f819050919050565b615c7e81615c6c565b8114615c88575f80fd5b50565b5f81359050615c9981615c75565b92915050565b5f615cb1615cac84615c43565b615c29565b90508060208402830185811115615ccb57615cca615c68565b5b835b81811015615cf45780615ce08882615c8b565b845260208401935050602081019050615ccd565b5050509392505050565b5f82601f830112615d1257615d11615bb7565b5b6002615d1f848285615c9f565b91505092915050565b5f60408284031215615d3d57615d3c615bb3565b5b5f615d4a84828501615cfe565b91505092915050565b615d5c81615c6c565b82525050565b5f602082019050615d755f830184615d53565b9291505056fea26469706673582212205804906cb58c598b5f3037e4c176401bf08eb520cb7f07159ad241d501f2495c64736f6c634300081a0033\")]\n    library PoseidonT3 {\n      uint constant M00 = 0x109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b;\n      uint constant M01 = 0x2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771;\n      uint constant M02 = 0x143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7;\n      uint constant M10 = 0x16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e0;\n      uint constant M11 = 0x2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe23;\n      uint constant M12 = 0x176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee2911;\n\n      // See here for a simplified implementation: https://github.com/vimwitch/poseidon-solidity/blob/e57becdabb65d99fdc586fe1e1e09e7108202d53/contracts/Poseidon.sol#L40\n      // Inspired by: https://github.com/iden3/circomlibjs/blob/v0.0.8/src/poseidon_slow.js\n      function hash(uint[2] memory) public pure returns (uint) {\n        assembly {\n          let F := 21888242871839275222246405745257275088548364400416034343698204186575808495617\n          let M20 := 0x2b90bba00fca0589f617e7dcbfe82e0df706ab640ceb247b791a93b74e36736d\n          let M21 := 0x101071f0032379b697315876690f053d148d4e109f5fb065c8aacc55a0f89bfa\n          let M22 := 0x19a3fc0a56702bf417ba7fee3802593fa644470307043f7773279cd71d25d5e0\n\n          // load the inputs from memory\n          let state1 := add(mod(mload(0x80), F), 0x00f1445235f2148c5986587169fc1bcd887b08d4d00868df5696fff40956e864)\n          let state2 := add(mod(mload(0xa0), F), 0x08dff3487e8ac99e1f29a058d0fa80b930c728730b7ab36ce879f3890ecf73f5)\n          let scratch0 := mulmod(state1, state1, F)\n          state1 := mulmod(mulmod(scratch0, scratch0, F), state1, F)\n          scratch0 := mulmod(state2, state2, F)\n          state2 := mulmod(mulmod(scratch0, scratch0, F), state2, F)\n          scratch0 := add(\n            0x2f27be690fdaee46c3ce28f7532b13c856c35342c84bda6e20966310fadc01d0,\n            add(add(15452833169820924772166449970675545095234312153403844297388521437673434406763, mulmod(state1, M10, F)), mulmod(state2, M20, F))\n          )\n          let scratch1 := add(\n            0x2b2ae1acf68b7b8d2416bebf3d4f6234b763fe04b8043ee48b8327bebca16cf2,\n            add(add(18674271267752038776579386132900109523609358935013267566297499497165104279117, mulmod(state1, M11, F)), mulmod(state2, M21, F))\n          )\n          let scratch2 := add(\n            0x0319d062072bef7ecca5eac06f97d4d55952c175ab6b03eae64b44c7dbf11cfa,\n            add(add(14817777843080276494683266178512808687156649753153012854386334860566696099579, mulmod(state1, M12, F)), mulmod(state2, M22, F))\n          )\n          let state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := mulmod(scratch1, scratch1, F)\n          scratch1 := mulmod(mulmod(state0, state0, F), scratch1, F)\n          state0 := mulmod(scratch2, scratch2, F)\n          scratch2 := mulmod(mulmod(state0, state0, F), scratch2, F)\n          state0 := add(0x28813dcaebaeaa828a376df87af4a63bc8b7bf27ad49c6298ef7b387bf28526d, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x2727673b2ccbc903f181bf38e1c1d40d2033865200c352bc150928adddf9cb78, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x234ec45ca27727c2e74abd2b2a1494cd6efbd43e340587d6b8fb9e31e65cc632, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := mulmod(state1, state1, F)\n          state1 := mulmod(mulmod(scratch0, scratch0, F), state1, F)\n          scratch0 := mulmod(state2, state2, F)\n          state2 := mulmod(mulmod(scratch0, scratch0, F), state2, F)\n          scratch0 := add(0x15b52534031ae18f7f862cb2cf7cf760ab10a8150a337b1ccd99ff6e8797d428, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x0dc8fad6d9e4b35f5ed9a3d186b79ce38e0e8a8d1b58b132d701d4eecf68d1f6, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x1bcd95ffc211fbca600f705fad3fb567ea4eb378f62e1fec97805518a47e4d9c, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := mulmod(scratch1, scratch1, F)\n          scratch1 := mulmod(mulmod(state0, state0, F), scratch1, F)\n          state0 := mulmod(scratch2, scratch2, F)\n          scratch2 := mulmod(mulmod(state0, state0, F), scratch2, F)\n          state0 := add(0x10520b0ab721cadfe9eff81b016fc34dc76da36c2578937817cb978d069de559, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x1f6d48149b8e7f7d9b257d8ed5fbbaf42932498075fed0ace88a9eb81f5627f6, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x1d9655f652309014d29e00ef35a2089bfff8dc1c816f0dc9ca34bdb5460c8705, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x04df5a56ff95bcafb051f7b1cd43a99ba731ff67e47032058fe3d4185697cc7d, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x0672d995f8fff640151b3d290cedaf148690a10a8c8424a7f6ec282b6e4be828, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x099952b414884454b21200d7ffafdd5f0c9a9dcc06f2708e9fc1d8209b5c75b9, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x052cba2255dfd00c7c483143ba8d469448e43586a9b4cd9183fd0e843a6b9fa6, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x0b8badee690adb8eb0bd74712b7999af82de55707251ad7716077cb93c464ddc, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x119b1590f13307af5a1ee651020c07c749c15d60683a8050b963d0a8e4b2bdd1, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x03150b7cd6d5d17b2529d36be0f67b832c4acfc884ef4ee5ce15be0bfb4a8d09, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x2cc6182c5e14546e3cf1951f173912355374efb83d80898abe69cb317c9ea565, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x005032551e6378c450cfe129a404b3764218cadedac14e2b92d2cd73111bf0f9, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x233237e3289baa34bb147e972ebcb9516469c399fcc069fb88f9da2cc28276b5, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x05c8f4f4ebd4a6e3c980d31674bfbe6323037f21b34ae5a4e80c2d4c24d60280, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x0a7b1db13042d396ba05d818a319f25252bcf35ef3aeed91ee1f09b2590fc65b, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x2a73b71f9b210cf5b14296572c9d32dbf156e2b086ff47dc5df542365a404ec0, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x1ac9b0417abcc9a1935107e9ffc91dc3ec18f2c4dbe7f22976a760bb5c50c460, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x12c0339ae08374823fabb076707ef479269f3e4d6cb104349015ee046dc93fc0, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x0b7475b102a165ad7f5b18db4e1e704f52900aa3253baac68246682e56e9a28e, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x037c2849e191ca3edb1c5e49f6e8b8917c843e379366f2ea32ab3aa88d7f8448, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x05a6811f8556f014e92674661e217e9bd5206c5c93a07dc145fdb176a716346f, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x29a795e7d98028946e947b75d54e9f044076e87a7b2883b47b675ef5f38bd66e, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x20439a0c84b322eb45a3857afc18f5826e8c7382c8a1585c507be199981fd22f, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x2e0ba8d94d9ecf4a94ec2050c7371ff1bb50f27799a84b6d4a2a6f2a0982c887, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x143fd115ce08fb27ca38eb7cce822b4517822cd2109048d2e6d0ddcca17d71c8, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x0c64cbecb1c734b857968dbbdcf813cdf8611659323dbcbfc84323623be9caf1, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x028a305847c683f646fca925c163ff5ae74f348d62c2b670f1426cef9403da53, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x2e4ef510ff0b6fda5fa940ab4c4380f26a6bcb64d89427b824d6755b5db9e30c, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x0081c95bc43384e663d79270c956ce3b8925b4f6d033b078b96384f50579400e, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x2ed5f0c91cbd9749187e2fade687e05ee2491b349c039a0bba8a9f4023a0bb38, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x30509991f88da3504bbf374ed5aae2f03448a22c76234c8c990f01f33a735206, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x1c3f20fd55409a53221b7c4d49a356b9f0a1119fb2067b41a7529094424ec6ad, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x10b4e7f3ab5df003049514459b6e18eec46bb2213e8e131e170887b47ddcb96c, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x2a1982979c3ff7f43ddd543d891c2abddd80f804c077d775039aa3502e43adef, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x1c74ee64f15e1db6feddbead56d6d55dba431ebc396c9af95cad0f1315bd5c91, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x07533ec850ba7f98eab9303cace01b4b9e4f2e8b82708cfa9c2fe45a0ae146a0, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x21576b438e500449a151e4eeaf17b154285c68f42d42c1808a11abf3764c0750, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x2f17c0559b8fe79608ad5ca193d62f10bce8384c815f0906743d6930836d4a9e, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x2d477e3862d07708a79e8aae946170bc9775a4201318474ae665b0b1b7e2730e, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x162f5243967064c390e095577984f291afba2266c38f5abcd89be0f5b2747eab, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x2b4cb233ede9ba48264ecd2c8ae50d1ad7a8596a87f29f8a7777a70092393311, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x2c8fbcb2dd8573dc1dbaf8f4622854776db2eece6d85c4cf4254e7c35e03b07a, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x1d6f347725e4816af2ff453f0cd56b199e1b61e9f601e9ade5e88db870949da9, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x204b0c397f4ebe71ebc2d8b3df5b913df9e6ac02b68d31324cd49af5c4565529, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x0c4cb9dc3c4fd8174f1149b3c63c3c2f9ecb827cd7dc25534ff8fb75bc79c502, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x174ad61a1448c899a25416474f4930301e5c49475279e0639a616ddc45bc7b54, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x1a96177bcf4d8d89f759df4ec2f3cde2eaaa28c177cc0fa13a9816d49a38d2ef, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x066d04b24331d71cd0ef8054bc60c4ff05202c126a233c1a8242ace360b8a30a, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x2a4c4fc6ec0b0cf52195782871c6dd3b381cc65f72e02ad527037a62aa1bd804, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x13ab2d136ccf37d447e9f2e14a7cedc95e727f8446f6d9d7e55afc01219fd649, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x1121552fca26061619d24d843dc82769c1b04fcec26f55194c2e3e869acc6a9a, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x00ef653322b13d6c889bc81715c37d77a6cd267d595c4a8909a5546c7c97cff1, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x0e25483e45a665208b261d8ba74051e6400c776d652595d9845aca35d8a397d3, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x29f536dcb9dd7682245264659e15d88e395ac3d4dde92d8c46448db979eeba89, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x2a56ef9f2c53febadfda33575dbdbd885a124e2780bbea170e456baace0fa5be, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x1c8361c78eb5cf5decfb7a2d17b5c409f2ae2999a46762e8ee416240a8cb9af1, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x151aff5f38b20a0fc0473089aaf0206b83e8e68a764507bfd3d0ab4be74319c5, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x04c6187e41ed881dc1b239c88f7f9d43a9f52fc8c8b6cdd1e76e47615b51f100, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x13b37bd80f4d27fb10d84331f6fb6d534b81c61ed15776449e801b7ddc9c2967, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x01a5c536273c2d9df578bfbd32c17b7a2ce3664c2a52032c9321ceb1c4e8a8e4, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x2ab3561834ca73835ad05f5d7acb950b4a9a2c666b9726da832239065b7c3b02, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x1d4d8ec291e720db200fe6d686c0d613acaf6af4e95d3bf69f7ed516a597b646, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x041294d2cc484d228f5784fe7919fd2bb925351240a04b711514c9c80b65af1d, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x154ac98e01708c611c4fa715991f004898f57939d126e392042971dd90e81fc6, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x0b339d8acca7d4f83eedd84093aef51050b3684c88f8b0b04524563bc6ea4da4, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x0955e49e6610c94254a4f84cfbab344598f0e71eaff4a7dd81ed95b50839c82e, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x06746a6156eba54426b9e22206f15abca9a6f41e6f535c6f3525401ea0654626, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x0f18f5a0ecd1423c496f3820c549c27838e5790e2bd0a196ac917c7ff32077fb, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x04f6eeca1751f7308ac59eff5beb261e4bb563583ede7bc92a738223d6f76e13, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x2b56973364c4c4f5c1a3ec4da3cdce038811eb116fb3e45bc1768d26fc0b3758, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x123769dd49d5b054dcd76b89804b1bcb8e1392b385716a5d83feb65d437f29ef, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x2147b424fc48c80a88ee52b91169aacea989f6446471150994257b2fb01c63e9, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x0fdc1f58548b85701a6c5505ea332a29647e6f34ad4243c2ea54ad897cebe54d, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x12373a8251fea004df68abcf0f7786d4bceff28c5dbbe0c3944f685cc0a0b1f2, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x21e4f4ea5f35f85bad7ea52ff742c9e8a642756b6af44203dd8a1f35c1a90035, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x16243916d69d2ca3dfb4722224d4c462b57366492f45e90d8a81934f1bc3b147, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x1efbe46dd7a578b4f66f9adbc88b4378abc21566e1a0453ca13a4159cac04ac2, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x07ea5e8537cf5dd08886020e23a7f387d468d5525be66f853b672cc96a88969a, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x05a8c4f9968b8aa3b7b478a30f9a5b63650f19a75e7ce11ca9fe16c0b76c00bc, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x20f057712cc21654fbfe59bd345e8dac3f7818c701b9c7882d9d57b72a32e83f, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x04a12ededa9dfd689672f8c67fee31636dcd8e88d01d49019bd90b33eb33db69, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x27e88d8c15f37dcee44f1e5425a51decbd136ce5091a6767e49ec9544ccd101a, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x2feed17b84285ed9b8a5c8c5e95a41f66e096619a7703223176c41ee433de4d1, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x1ed7cc76edf45c7c404241420f729cf394e5942911312a0d6972b8bd53aff2b8, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x15742e99b9bfa323157ff8c586f5660eac6783476144cdcadf2874be45466b1a, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x1aac285387f65e82c895fc6887ddf40577107454c6ec0317284f033f27d0c785, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x25851c3c845d4790f9ddadbdb6057357832e2e7a49775f71ec75a96554d67c77, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x15a5821565cc2ec2ce78457db197edf353b7ebba2c5523370ddccc3d9f146a67, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x2411d57a4813b9980efa7e31a1db5966dcf64f36044277502f15485f28c71727, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x002e6f8d6520cd4713e335b8c0b6d2e647e9a98e12f4cd2558828b5ef6cb4c9b, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x2ff7bc8f4380cde997da00b616b0fcd1af8f0e91e2fe1ed7398834609e0315d2, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x00b9831b948525595ee02724471bcd182e9521f6b7bb68f1e93be4febb0d3cbe, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x0a2f53768b8ebf6a86913b0e57c04e011ca408648a4743a87d77adbf0c9c3512, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x00248156142fd0373a479f91ff239e960f599ff7e94be69b7f2a290305e1198d, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x171d5620b87bfb1328cf8c02ab3f0c9a397196aa6a542c2350eb512a2b2bcda9, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x170a4f55536f7dc970087c7c10d6fad760c952172dd54dd99d1045e4ec34a808, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x29aba33f799fe66c2ef3134aea04336ecc37e38c1cd211ba482eca17e2dbfae1, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x1e9bc179a4fdd758fdd1bb1945088d47e70d114a03f6a0e8b5ba650369e64973, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x1dd269799b660fad58f7f4892dfb0b5afeaad869a9c4b44f9c9e1c43bdaf8f09, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x22cdbc8b70117ad1401181d02e15459e7ccd426fe869c7c95d1dd2cb0f24af38, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x0ef042e454771c533a9f57a55c503fcefd3150f52ed94a7cd5ba93b9c7dacefd, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x11609e06ad6c8fe2f287f3036037e8851318e8b08a0359a03b304ffca62e8284, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x1166d9e554616dba9e753eea427c17b7fecd58c076dfe42708b08f5b783aa9af, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x2de52989431a859593413026354413db177fbf4cd2ac0b56f855a888357ee466, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x3006eb4ffc7a85819a6da492f3a8ac1df51aee5b17b8e89d74bf01cf5f71e9ad, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x2af41fbb61ba8a80fdcf6fff9e3f6f422993fe8f0a4639f962344c8225145086, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x119e684de476155fe5a6b41a8ebc85db8718ab27889e85e781b214bace4827c3, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x1835b786e2e8925e188bea59ae363537b51248c23828f047cff784b97b3fd800, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x28201a34c594dfa34d794996c6433a20d152bac2a7905c926c40e285ab32eeb6, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x083efd7a27d1751094e80fefaf78b000864c82eb571187724a761f88c22cc4e7, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x0b6f88a3577199526158e61ceea27be811c16df7774dd8519e079564f61fd13b, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x0ec868e6d15e51d9644f66e1d6471a94589511ca00d29e1014390e6ee4254f5b, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x2af33e3f866771271ac0c9b3ed2e1142ecd3e74b939cd40d00d937ab84c98591, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x0b520211f904b5e7d09b5d961c6ace7734568c547dd6858b364ce5e47951f178, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x0b2d722d0919a1aad8db58f10062a92ea0c56ac4270e822cca228620188a1d40, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x1f790d4d7f8cf094d980ceb37c2453e957b54a9991ca38bbe0061d1ed6e562d4, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x0171eb95dfbf7d1eaea97cd385f780150885c16235a2a6a8da92ceb01e504233, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x0c2d0e3b5fd57549329bf6885da66b9b790b40defd2c8650762305381b168873, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x1162fb28689c27154e5a8228b4e72b377cbcafa589e283c35d3803054407a18d, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x2f1459b65dee441b64ad386a91e8310f282c5a92a89e19921623ef8249711bc0, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x1e6ff3216b688c3d996d74367d5cd4c1bc489d46754eb712c243f70d1b53cfbb, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x01ca8be73832b8d0681487d27d157802d741a6f36cdc2a0576881f9326478875, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x1f7735706ffe9fc586f976d5bdf223dc680286080b10cea00b9b5de315f9650e, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x2522b60f4ea3307640a0c2dce041fba921ac10a3d5f096ef4745ca838285f019, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x23f0bee001b1029d5255075ddc957f833418cad4f52b6c3f8ce16c235572575b, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x2bc1ae8b8ddbb81fcaac2d44555ed5685d142633e9df905f66d9401093082d59, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x0f9406b8296564a37304507b8dba3ed162371273a07b1fc98011fcd6ad72205f, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x2360a8eb0cc7defa67b72998de90714e17e75b174a52ee4acb126c8cd995f0a8, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x15871a5cddead976804c803cbaef255eb4815a5e96df8b006dcbbc2767f88948, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x193a56766998ee9e0a8652dd2f3b1da0362f4f54f72379544f957ccdeefb420f, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x2a394a43934f86982f9be56ff4fab1703b2e63c8ad334834e4309805e777ae0f, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x1859954cfeb8695f3e8b635dcb345192892cd11223443ba7b4166e8876c0d142, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x04e1181763050e58013444dbcb99f1902b11bc25d90bbdca408d3819f4fed32b, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x0fdb253dee83869d40c335ea64de8c5bb10eb82db08b5e8b1f5e5552bfd05f23, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x058cbe8a9a5027bdaa4efb623adead6275f08686f1c08984a9d7c5bae9b4f1c0, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x1382edce9971e186497eadb1aeb1f52b23b4b83bef023ab0d15228b4cceca59a, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x03464990f045c6ee0819ca51fd11b0be7f61b8eb99f14b77e1e6634601d9e8b5, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x23f7bfc8720dc296fff33b41f98ff83c6fcab4605db2eb5aaa5bc137aeb70a58, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x0a59a158e3eec2117e6e94e7f0e9decf18c3ffd5e1531a9219636158bbaf62f2, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x06ec54c80381c052b58bf23b312ffd3ce2c4eba065420af8f4c23ed0075fd07b, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x118872dc832e0eb5476b56648e867ec8b09340f7a7bcb1b4962f0ff9ed1f9d01, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x13d69fa127d834165ad5c7cba7ad59ed52e0b0f0e42d7fea95e1906b520921b1, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x169a177f63ea681270b1c6877a73d21bde143942fb71dc55fd8a49f19f10c77b, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x04ef51591c6ead97ef42f287adce40d93abeb032b922f66ffb7e9a5a7450544d, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x256e175a1dc079390ecd7ca703fb2e3b19ec61805d4f03ced5f45ee6dd0f69ec, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x30102d28636abd5fe5f2af412ff6004f75cc360d3205dd2da002813d3e2ceeb2, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x10998e42dfcd3bbf1c0714bc73eb1bf40443a3fa99bef4a31fd31be182fcc792, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x193edd8e9fcf3d7625fa7d24b598a1d89f3362eaf4d582efecad76f879e36860, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x18168afd34f2d915d0368ce80b7b3347d1c7a561ce611425f2664d7aa51f0b5d, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x29383c01ebd3b6ab0c017656ebe658b6a328ec77bc33626e29e2e95b33ea6111, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x10646d2f2603de39a1f4ae5e7771a64a702db6e86fb76ab600bf573f9010c711, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x0beb5e07d1b27145f575f1395a55bf132f90c25b40da7b3864d0242dcb1117fb, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x16d685252078c133dc0d3ecad62b5c8830f95bb2e54b59abdffbf018d96fa336, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x0a6abd1d833938f33c74154e0404b4b40a555bbbec21ddfafd672dd62047f01a, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x1a679f5d36eb7b5c8ea12a4c2dedc8feb12dffeec450317270a6f19b34cf1860, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x0980fb233bd456c23974d50e0ebfde4726a423eada4e8f6ffbc7592e3f1b93d6, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x161b42232e61b84cbf1810af93a38fc0cece3d5628c9282003ebacb5c312c72b, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x0ada10a90c7f0520950f7d47a60d5e6a493f09787f1564e5d09203db47de1a0b, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x1a730d372310ba82320345a29ac4238ed3f07a8a2b4e121bb50ddb9af407f451, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x2c8120f268ef054f817064c369dda7ea908377feaba5c4dffbda10ef58e8c556, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x1c7c8824f758753fa57c00789c684217b930e95313bcb73e6e7b8649a4968f70, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x2cd9ed31f5f8691c8e39e4077a74faa0f400ad8b491eb3f7b47b27fa3fd1cf77, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x23ff4f9d46813457cf60d92f57618399a5e022ac321ca550854ae23918a22eea, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x09945a5d147a4f66ceece6405dddd9d0af5a2c5103529407dff1ea58f180426d, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x188d9c528025d4c2b67660c6b771b90f7c7da6eaa29d3f268a6dd223ec6fc630, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x3050e37996596b7f81f68311431d8734dba7d926d3633595e0c0d8ddf4f0f47f, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x15af1169396830a91600ca8102c35c426ceae5461e3f95d89d829518d30afd78, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x1da6d09885432ea9a06d9f37f873d985dae933e351466b2904284da3320d8acc, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := add(0x2796ea90d269af29f5f8acf33921124e4e4fad3dbe658945e546ee411ddaa9cb, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x202d7dd1da0f6b4b0325c8b3307742f01e15612ec8e9304a7cb0319e01d32d60, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x096d6790d05bb759156a952ba263d672a2d7f9c788f4c831a29dace4c0f8be5f, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := add(0x054efa1f65b0fce283808965275d877b438da23ce5b13e1963798cb1447d25a4, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x1b162f83d917e93edb3308c29802deb9d8aa690113b2e14864ccf6e18e4165f1, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x21e5241e12564dd6fd9f1cdd2a0de39eedfefc1466cc568ec5ceb745a0506edc, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := mulmod(scratch1, scratch1, F)\n          scratch1 := mulmod(mulmod(state0, state0, F), scratch1, F)\n          state0 := mulmod(scratch2, scratch2, F)\n          scratch2 := mulmod(mulmod(state0, state0, F), scratch2, F)\n          state0 := add(0x1cfb5662e8cf5ac9226a80ee17b36abecb73ab5f87e161927b4349e10e4bdf08, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x0f21177e302a771bbae6d8d1ecb373b62c99af346220ac0129c53f666eb24100, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x1671522374606992affb0dd7f71b12bec4236aede6290546bcef7e1f515c2320, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := mulmod(state1, state1, F)\n          state1 := mulmod(mulmod(scratch0, scratch0, F), state1, F)\n          scratch0 := mulmod(state2, state2, F)\n          state2 := mulmod(mulmod(scratch0, scratch0, F), state2, F)\n          scratch0 := add(0x0fa3ec5b9488259c2eb4cf24501bfad9be2ec9e42c5cc8ccd419d2a692cad870, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n          scratch1 := add(0x193c0e04e0bd298357cb266c1506080ed36edce85c648cc085e8c57b1ab54bba, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n          scratch2 := add(0x102adf8ef74735a27e9128306dcbc3c99f6f7291cd406578ce14ea2adaba68f8, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n          state0 := mulmod(scratch0, scratch0, F)\n          scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n          state0 := mulmod(scratch1, scratch1, F)\n          scratch1 := mulmod(mulmod(state0, state0, F), scratch1, F)\n          state0 := mulmod(scratch2, scratch2, F)\n          scratch2 := mulmod(mulmod(state0, state0, F), scratch2, F)\n          state0 := add(0x0fe0af7858e49859e2a54d6f1ad945b1316aa24bfbdd23ae40a6d0cb70c3eab1, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n          state1 := add(0x216f6717bbc7dedb08536a2220843f4e2da5f1daa9ebdefde8a5ea7344798d22, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n          state2 := add(0x1da55cc900f0d21f4a3e694391918a1b3c23b2ac773c6b3ef88e2e4228325161, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n          scratch0 := mulmod(state0, state0, F)\n          state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n          scratch0 := mulmod(state1, state1, F)\n          state1 := mulmod(mulmod(scratch0, scratch0, F), state1, F)\n          scratch0 := mulmod(state2, state2, F)\n          state2 := mulmod(mulmod(scratch0, scratch0, F), state2, F)\n\n          mstore(0x0, mod(add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)), F))\n\n          return(0, 0x20)\n        }\n      }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","poseidon_sol.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet},\n    primitives::Address,\n    providers::ProviderBuilder,\n    sol,\n    sol_types::SolCall,\n};\nuse alloy_primitives::uint;\nuse e2e::{receipt, Account};\n\nuse crate::report::{ContractReport, FunctionReport};\n\nsol!(\n    #[sol(rpc)]\n   contract PoseidonExample {\n        #[derive(Debug)]\n        function hash(uint256[2] memory inputs) external view returns (uint256 hash);\n    }\n);\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    let reports = run().await?;\n    let report = reports\n        .into_iter()\n        .try_fold(ContractReport::new(\"Sol:Poseidon\"), ContractReport::add)?;\n\n    Ok(report)\n}\n\npub async fn run() -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice).await?;\n\n    let contract = PoseidonExample::new(contract_addr, \u0026alice_wallet);\n\n    #[rustfmt::skip]\n    let receipts = vec![\n        (PoseidonExample::hashCall::SIGNATURE, receipt!(contract.hash([uint!(123_U256), uint!(123456_U256)]))?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\npub async fn deploy(account: \u0026Account) -\u003e eyre::Result\u003cAddress\u003e {\n    let contract = PoseidonT3::deploy(\u0026account.wallet).await?;\n    Ok(*contract.address())\n}\n\n// https://github.com/chancehudson/poseidon-solidity/blob/e57becdabb65d99fdc586fe1e1e09e7108202d53/contracts/Poseidon.sol#L40\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc 0.8.24+commit.e11b9ed9\n    #[sol(rpc, bytecode=\"608060405234801561000f575f80fd5b506128a28061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610034575f3560e01c8063561558fe146100385780638cc13d8a14610068575b5f80fd5b610052600480360381019061004d919061268f565b610098565b60405161005f91906126c9565b60405180910390f35b610082600480360381019061007d91906126e2565b61246b565b60405161008f91906126c9565b60405180910390f35b5f806040518061186001604052807f0ee9a592ba9a9518d05986d656f40c2114c4993c11bb29938d21d47304cd8e6e81526020017ef1445235f2148c5986587169fc1bcd887b08d4d00868df5696fff40956e86481526020017f08dff3487e8ac99e1f29a058d0fa80b930c728730b7ab36ce879f3890ecf73f581526020017f2f27be690fdaee46c3ce28f7532b13c856c35342c84bda6e20966310fadc01d081526020017f2b2ae1acf68b7b8d2416bebf3d4f6234b763fe04b8043ee48b8327bebca16cf281526020017f0319d062072bef7ecca5eac06f97d4d55952c175ab6b03eae64b44c7dbf11cfa81526020017f28813dcaebaeaa828a376df87af4a63bc8b7bf27ad49c6298ef7b387bf28526d81526020017f2727673b2ccbc903f181bf38e1c1d40d2033865200c352bc150928adddf9cb7881526020017f234ec45ca27727c2e74abd2b2a1494cd6efbd43e340587d6b8fb9e31e65cc63281526020017f15b52534031ae18f7f862cb2cf7cf760ab10a8150a337b1ccd99ff6e8797d42881526020017f0dc8fad6d9e4b35f5ed9a3d186b79ce38e0e8a8d1b58b132d701d4eecf68d1f681526020017f1bcd95ffc211fbca600f705fad3fb567ea4eb378f62e1fec97805518a47e4d9c81526020017f10520b0ab721cadfe9eff81b016fc34dc76da36c2578937817cb978d069de55981526020017f1f6d48149b8e7f7d9b257d8ed5fbbaf42932498075fed0ace88a9eb81f5627f681526020017f1d9655f652309014d29e00ef35a2089bfff8dc1c816f0dc9ca34bdb5460c870581526020017f04df5a56ff95bcafb051f7b1cd43a99ba731ff67e47032058fe3d4185697cc7d81526020017f0672d995f8fff640151b3d290cedaf148690a10a8c8424a7f6ec282b6e4be82881526020017f099952b414884454b21200d7ffafdd5f0c9a9dcc06f2708e9fc1d8209b5c75b981526020017f052cba2255dfd00c7c483143ba8d469448e43586a9b4cd9183fd0e843a6b9fa681526020017f0b8badee690adb8eb0bd74712b7999af82de55707251ad7716077cb93c464ddc81526020017f119b1590f13307af5a1ee651020c07c749c15d60683a8050b963d0a8e4b2bdd181526020017f03150b7cd6d5d17b2529d36be0f67b832c4acfc884ef4ee5ce15be0bfb4a8d0981526020017f2cc6182c5e14546e3cf1951f173912355374efb83d80898abe69cb317c9ea56581526020017e5032551e6378c450cfe129a404b3764218cadedac14e2b92d2cd73111bf0f981526020017f233237e3289baa34bb147e972ebcb9516469c399fcc069fb88f9da2cc28276b581526020017f05c8f4f4ebd4a6e3c980d31674bfbe6323037f21b34ae5a4e80c2d4c24d6028081526020017f0a7b1db13042d396ba05d818a319f25252bcf35ef3aeed91ee1f09b2590fc65b81526020017f2a73b71f9b210cf5b14296572c9d32dbf156e2b086ff47dc5df542365a404ec081526020017f1ac9b0417abcc9a1935107e9ffc91dc3ec18f2c4dbe7f22976a760bb5c50c46081526020017f12c0339ae08374823fabb076707ef479269f3e4d6cb104349015ee046dc93fc081526020017f0b7475b102a165ad7f5b18db4e1e704f52900aa3253baac68246682e56e9a28e81526020017f037c2849e191ca3edb1c5e49f6e8b8917c843e379366f2ea32ab3aa88d7f844881526020017f05a6811f8556f014e92674661e217e9bd5206c5c93a07dc145fdb176a716346f81526020017f29a795e7d98028946e947b75d54e9f044076e87a7b2883b47b675ef5f38bd66e81526020017f20439a0c84b322eb45a3857afc18f5826e8c7382c8a1585c507be199981fd22f81526020017f2e0ba8d94d9ecf4a94ec2050c7371ff1bb50f27799a84b6d4a2a6f2a0982c88781526020017f143fd115ce08fb27ca38eb7cce822b4517822cd2109048d2e6d0ddcca17d71c881526020017f0c64cbecb1c734b857968dbbdcf813cdf8611659323dbcbfc84323623be9caf181526020017f028a305847c683f646fca925c163ff5ae74f348d62c2b670f1426cef9403da5381526020017f2e4ef510ff0b6fda5fa940ab4c4380f26a6bcb64d89427b824d6755b5db9e30c81526020017e81c95bc43384e663d79270c956ce3b8925b4f6d033b078b96384f50579400e81526020017f2ed5f0c91cbd9749187e2fade687e05ee2491b349c039a0bba8a9f4023a0bb3881526020017f30509991f88da3504bbf374ed5aae2f03448a22c76234c8c990f01f33a73520681526020017f1c3f20fd55409a53221b7c4d49a356b9f0a1119fb2067b41a7529094424ec6ad81526020017f10b4e7f3ab5df003049514459b6e18eec46bb2213e8e131e170887b47ddcb96c81526020017f2a1982979c3ff7f43ddd543d891c2abddd80f804c077d775039aa3502e43adef81526020017f1c74ee64f15e1db6feddbead56d6d55dba431ebc396c9af95cad0f1315bd5c9181526020017f07533ec850ba7f98eab9303cace01b4b9e4f2e8b82708cfa9c2fe45a0ae146a081526020017f21576b438e500449a151e4eeaf17b154285c68f42d42c1808a11abf3764c075081526020017f2f17c0559b8fe79608ad5ca193d62f10bce8384c815f0906743d6930836d4a9e81526020017f2d477e3862d07708a79e8aae946170bc9775a4201318474ae665b0b1b7e2730e81526020017f162f5243967064c390e095577984f291afba2266c38f5abcd89be0f5b2747eab81526020017f2b4cb233ede9ba48264ecd2c8ae50d1ad7a8596a87f29f8a7777a7009239331181526020017f2c8fbcb2dd8573dc1dbaf8f4622854776db2eece6d85c4cf4254e7c35e03b07a81526020017f1d6f347725e4816af2ff453f0cd56b199e1b61e9f601e9ade5e88db870949da981526020017f204b0c397f4ebe71ebc2d8b3df5b913df9e6ac02b68d31324cd49af5c456552981526020017f0c4cb9dc3c4fd8174f1149b3c63c3c2f9ecb827cd7dc25534ff8fb75bc79c50281526020017f174ad61a1448c899a25416474f4930301e5c49475279e0639a616ddc45bc7b5481526020017f1a96177bcf4d8d89f759df4ec2f3cde2eaaa28c177cc0fa13a9816d49a38d2ef81526020017f066d04b24331d71cd0ef8054bc60c4ff05202c126a233c1a8242ace360b8a30a81526020017f2a4c4fc6ec0b0cf52195782871c6dd3b381cc65f72e02ad527037a62aa1bd80481526020017f13ab2d136ccf37d447e9f2e14a7cedc95e727f8446f6d9d7e55afc01219fd64981526020017f1121552fca26061619d24d843dc82769c1b04fcec26f55194c2e3e869acc6a9a81526020017eef653322b13d6c889bc81715c37d77a6cd267d595c4a8909a5546c7c97cff181526020017f0e25483e45a665208b261d8ba74051e6400c776d652595d9845aca35d8a397d381526020017f29f536dcb9dd7682245264659e15d88e395ac3d4dde92d8c46448db979eeba8981526020017f2a56ef9f2c53febadfda33575dbdbd885a124e2780bbea170e456baace0fa5be81526020017f1c8361c78eb5cf5decfb7a2d17b5c409f2ae2999a46762e8ee416240a8cb9af181526020017f151aff5f38b20a0fc0473089aaf0206b83e8e68a764507bfd3d0ab4be74319c581526020017f04c6187e41ed881dc1b239c88f7f9d43a9f52fc8c8b6cdd1e76e47615b51f10081526020017f13b37bd80f4d27fb10d84331f6fb6d534b81c61ed15776449e801b7ddc9c296781526020017f01a5c536273c2d9df578bfbd32c17b7a2ce3664c2a52032c9321ceb1c4e8a8e481526020017f2ab3561834ca73835ad05f5d7acb950b4a9a2c666b9726da832239065b7c3b0281526020017f1d4d8ec291e720db200fe6d686c0d613acaf6af4e95d3bf69f7ed516a597b64681526020017f041294d2cc484d228f5784fe7919fd2bb925351240a04b711514c9c80b65af1d81526020017f154ac98e01708c611c4fa715991f004898f57939d126e392042971dd90e81fc681526020017f0b339d8acca7d4f83eedd84093aef51050b3684c88f8b0b04524563bc6ea4da481526020017f0955e49e6610c94254a4f84cfbab344598f0e71eaff4a7dd81ed95b50839c82e81526020017f06746a6156eba54426b9e22206f15abca9a6f41e6f535c6f3525401ea065462681526020017f0f18f5a0ecd1423c496f3820c549c27838e5790e2bd0a196ac917c7ff32077fb81526020017f04f6eeca1751f7308ac59eff5beb261e4bb563583ede7bc92a738223d6f76e1381526020017f2b56973364c4c4f5c1a3ec4da3cdce038811eb116fb3e45bc1768d26fc0b375881526020017f123769dd49d5b054dcd76b89804b1bcb8e1392b385716a5d83feb65d437f29ef81526020017f2147b424fc48c80a88ee52b91169aacea989f6446471150994257b2fb01c63e981526020017f0fdc1f58548b85701a6c5505ea332a29647e6f34ad4243c2ea54ad897cebe54d81526020017f12373a8251fea004df68abcf0f7786d4bceff28c5dbbe0c3944f685cc0a0b1f281526020017f21e4f4ea5f35f85bad7ea52ff742c9e8a642756b6af44203dd8a1f35c1a9003581526020017f16243916d69d2ca3dfb4722224d4c462b57366492f45e90d8a81934f1bc3b14781526020017f1efbe46dd7a578b4f66f9adbc88b4378abc21566e1a0453ca13a4159cac04ac281526020017f07ea5e8537cf5dd08886020e23a7f387d468d5525be66f853b672cc96a88969a81526020017f05a8c4f9968b8aa3b7b478a30f9a5b63650f19a75e7ce11ca9fe16c0b76c00bc81526020017f20f057712cc21654fbfe59bd345e8dac3f7818c701b9c7882d9d57b72a32e83f81526020017f04a12ededa9dfd689672f8c67fee31636dcd8e88d01d49019bd90b33eb33db6981526020017f27e88d8c15f37dcee44f1e5425a51decbd136ce5091a6767e49ec9544ccd101a81526020017f2feed17b84285ed9b8a5c8c5e95a41f66e096619a7703223176c41ee433de4d181526020017f1ed7cc76edf45c7c404241420f729cf394e5942911312a0d6972b8bd53aff2b881526020017f15742e99b9bfa323157ff8c586f5660eac6783476144cdcadf2874be45466b1a81526020017f1aac285387f65e82c895fc6887ddf40577107454c6ec0317284f033f27d0c78581526020017f25851c3c845d4790f9ddadbdb6057357832e2e7a49775f71ec75a96554d67c7781526020017f15a5821565cc2ec2ce78457db197edf353b7ebba2c5523370ddccc3d9f146a6781526020017f2411d57a4813b9980efa7e31a1db5966dcf64f36044277502f15485f28c7172781526020017e2e6f8d6520cd4713e335b8c0b6d2e647e9a98e12f4cd2558828b5ef6cb4c9b81526020017f2ff7bc8f4380cde997da00b616b0fcd1af8f0e91e2fe1ed7398834609e0315d281526020017eb9831b948525595ee02724471bcd182e9521f6b7bb68f1e93be4febb0d3cbe81526020017f0a2f53768b8ebf6a86913b0e57c04e011ca408648a4743a87d77adbf0c9c351281526020017e248156142fd0373a479f91ff239e960f599ff7e94be69b7f2a290305e1198d81526020017f171d5620b87bfb1328cf8c02ab3f0c9a397196aa6a542c2350eb512a2b2bcda981526020017f170a4f55536f7dc970087c7c10d6fad760c952172dd54dd99d1045e4ec34a80881526020017f29aba33f799fe66c2ef3134aea04336ecc37e38c1cd211ba482eca17e2dbfae181526020017f1e9bc179a4fdd758fdd1bb1945088d47e70d114a03f6a0e8b5ba650369e6497381526020017f1dd269799b660fad58f7f4892dfb0b5afeaad869a9c4b44f9c9e1c43bdaf8f0981526020017f22cdbc8b70117ad1401181d02e15459e7ccd426fe869c7c95d1dd2cb0f24af3881526020017f0ef042e454771c533a9f57a55c503fcefd3150f52ed94a7cd5ba93b9c7dacefd81526020017f11609e06ad6c8fe2f287f3036037e8851318e8b08a0359a03b304ffca62e828481526020017f1166d9e554616dba9e753eea427c17b7fecd58c076dfe42708b08f5b783aa9af81526020017f2de52989431a859593413026354413db177fbf4cd2ac0b56f855a888357ee46681526020017f3006eb4ffc7a85819a6da492f3a8ac1df51aee5b17b8e89d74bf01cf5f71e9ad81526020017f2af41fbb61ba8a80fdcf6fff9e3f6f422993fe8f0a4639f962344c822514508681526020017f119e684de476155fe5a6b41a8ebc85db8718ab27889e85e781b214bace4827c381526020017f1835b786e2e8925e188bea59ae363537b51248c23828f047cff784b97b3fd80081526020017f28201a34c594dfa34d794996c6433a20d152bac2a7905c926c40e285ab32eeb681526020017f083efd7a27d1751094e80fefaf78b000864c82eb571187724a761f88c22cc4e781526020017f0b6f88a3577199526158e61ceea27be811c16df7774dd8519e079564f61fd13b81526020017f0ec868e6d15e51d9644f66e1d6471a94589511ca00d29e1014390e6ee4254f5b81526020017f2af33e3f866771271ac0c9b3ed2e1142ecd3e74b939cd40d00d937ab84c9859181526020017f0b520211f904b5e7d09b5d961c6ace7734568c547dd6858b364ce5e47951f17881526020017f0b2d722d0919a1aad8db58f10062a92ea0c56ac4270e822cca228620188a1d4081526020017f1f790d4d7f8cf094d980ceb37c2453e957b54a9991ca38bbe0061d1ed6e562d481526020017f0171eb95dfbf7d1eaea97cd385f780150885c16235a2a6a8da92ceb01e50423381526020017f0c2d0e3b5fd57549329bf6885da66b9b790b40defd2c8650762305381b16887381526020017f1162fb28689c27154e5a8228b4e72b377cbcafa589e283c35d3803054407a18d81526020017f2f1459b65dee441b64ad386a91e8310f282c5a92a89e19921623ef8249711bc081526020017f1e6ff3216b688c3d996d74367d5cd4c1bc489d46754eb712c243f70d1b53cfbb81526020017f01ca8be73832b8d0681487d27d157802d741a6f36cdc2a0576881f932647887581526020017f1f7735706ffe9fc586f976d5bdf223dc680286080b10cea00b9b5de315f9650e81526020017f2522b60f4ea3307640a0c2dce041fba921ac10a3d5f096ef4745ca838285f01981526020017f23f0bee001b1029d5255075ddc957f833418cad4f52b6c3f8ce16c235572575b81526020017f2bc1ae8b8ddbb81fcaac2d44555ed5685d142633e9df905f66d9401093082d5981526020017f0f9406b8296564a37304507b8dba3ed162371273a07b1fc98011fcd6ad72205f81526020017f2360a8eb0cc7defa67b72998de90714e17e75b174a52ee4acb126c8cd995f0a881526020017f15871a5cddead976804c803cbaef255eb4815a5e96df8b006dcbbc2767f8894881526020017f193a56766998ee9e0a8652dd2f3b1da0362f4f54f72379544f957ccdeefb420f81526020017f2a394a43934f86982f9be56ff4fab1703b2e63c8ad334834e4309805e777ae0f81526020017f1859954cfeb8695f3e8b635dcb345192892cd11223443ba7b4166e8876c0d14281526020017f04e1181763050e58013444dbcb99f1902b11bc25d90bbdca408d3819f4fed32b81526020017f0fdb253dee83869d40c335ea64de8c5bb10eb82db08b5e8b1f5e5552bfd05f2381526020017f058cbe8a9a5027bdaa4efb623adead6275f08686f1c08984a9d7c5bae9b4f1c081526020017f1382edce9971e186497eadb1aeb1f52b23b4b83bef023ab0d15228b4cceca59a81526020017f03464990f045c6ee0819ca51fd11b0be7f61b8eb99f14b77e1e6634601d9e8b581526020017f23f7bfc8720dc296fff33b41f98ff83c6fcab4605db2eb5aaa5bc137aeb70a5881526020017f0a59a158e3eec2117e6e94e7f0e9decf18c3ffd5e1531a9219636158bbaf62f281526020017f06ec54c80381c052b58bf23b312ffd3ce2c4eba065420af8f4c23ed0075fd07b81526020017f118872dc832e0eb5476b56648e867ec8b09340f7a7bcb1b4962f0ff9ed1f9d0181526020017f13d69fa127d834165ad5c7cba7ad59ed52e0b0f0e42d7fea95e1906b520921b181526020017f169a177f63ea681270b1c6877a73d21bde143942fb71dc55fd8a49f19f10c77b81526020017f04ef51591c6ead97ef42f287adce40d93abeb032b922f66ffb7e9a5a7450544d81526020017f256e175a1dc079390ecd7ca703fb2e3b19ec61805d4f03ced5f45ee6dd0f69ec81526020017f30102d28636abd5fe5f2af412ff6004f75cc360d3205dd2da002813d3e2ceeb281526020017f10998e42dfcd3bbf1c0714bc73eb1bf40443a3fa99bef4a31fd31be182fcc79281526020017f193edd8e9fcf3d7625fa7d24b598a1d89f3362eaf4d582efecad76f879e3686081526020017f18168afd34f2d915d0368ce80b7b3347d1c7a561ce611425f2664d7aa51f0b5d81526020017f29383c01ebd3b6ab0c017656ebe658b6a328ec77bc33626e29e2e95b33ea611181526020017f10646d2f2603de39a1f4ae5e7771a64a702db6e86fb76ab600bf573f9010c71181526020017f0beb5e07d1b27145f575f1395a55bf132f90c25b40da7b3864d0242dcb1117fb81526020017f16d685252078c133dc0d3ecad62b5c8830f95bb2e54b59abdffbf018d96fa33681526020017f0a6abd1d833938f33c74154e0404b4b40a555bbbec21ddfafd672dd62047f01a81526020017f1a679f5d36eb7b5c8ea12a4c2dedc8feb12dffeec450317270a6f19b34cf186081526020017f0980fb233bd456c23974d50e0ebfde4726a423eada4e8f6ffbc7592e3f1b93d681526020017f161b42232e61b84cbf1810af93a38fc0cece3d5628c9282003ebacb5c312c72b81526020017f0ada10a90c7f0520950f7d47a60d5e6a493f09787f1564e5d09203db47de1a0b81526020017f1a730d372310ba82320345a29ac4238ed3f07a8a2b4e121bb50ddb9af407f45181526020017f2c8120f268ef054f817064c369dda7ea908377feaba5c4dffbda10ef58e8c55681526020017f1c7c8824f758753fa57c00789c684217b930e95313bcb73e6e7b8649a4968f7081526020017f2cd9ed31f5f8691c8e39e4077a74faa0f400ad8b491eb3f7b47b27fa3fd1cf7781526020017f23ff4f9d46813457cf60d92f57618399a5e022ac321ca550854ae23918a22eea81526020017f09945a5d147a4f66ceece6405dddd9d0af5a2c5103529407dff1ea58f180426d81526020017f188d9c528025d4c2b67660c6b771b90f7c7da6eaa29d3f268a6dd223ec6fc63081526020017f3050e37996596b7f81f68311431d8734dba7d926d3633595e0c0d8ddf4f0f47f81526020017f15af1169396830a91600ca8102c35c426ceae5461e3f95d89d829518d30afd7881526020017f1da6d09885432ea9a06d9f37f873d985dae933e351466b2904284da3320d8acc81526020017f2796ea90d269af29f5f8acf33921124e4e4fad3dbe658945e546ee411ddaa9cb81526020017f202d7dd1da0f6b4b0325c8b3307742f01e15612ec8e9304a7cb0319e01d32d6081526020017f096d6790d05bb759156a952ba263d672a2d7f9c788f4c831a29dace4c0f8be5f81526020017f054efa1f65b0fce283808965275d877b438da23ce5b13e1963798cb1447d25a481526020017f1b162f83d917e93edb3308c29802deb9d8aa690113b2e14864ccf6e18e4165f181526020017f21e5241e12564dd6fd9f1cdd2a0de39eedfefc1466cc568ec5ceb745a0506edc81526020017f1cfb5662e8cf5ac9226a80ee17b36abecb73ab5f87e161927b4349e10e4bdf0881526020017f0f21177e302a771bbae6d8d1ecb373b62c99af346220ac0129c53f666eb2410081526020017f1671522374606992affb0dd7f71b12bec4236aede6290546bcef7e1f515c232081526020017f0fa3ec5b9488259c2eb4cf24501bfad9be2ec9e42c5cc8ccd419d2a692cad87081526020017f193c0e04e0bd298357cb266c1506080ed36edce85c648cc085e8c57b1ab54bba81526020017f102adf8ef74735a27e9128306dcbc3c99f6f7291cd406578ce14ea2adaba68f881526020017f0fe0af7858e49859e2a54d6f1ad945b1316aa24bfbdd23ae40a6d0cb70c3eab181526020017f216f6717bbc7dedb08536a2220843f4e2da5f1daa9ebdefde8a5ea7344798d2281526020017f1da55cc900f0d21f4a3e694391918a1b3c23b2ac773c6b3ef88e2e422832516181525090505f80845f60028110611da657611da561270d565b5b602002015190505f85600160028110611dc257611dc161270d565b5b602002015190505f80875f60028110611dde57611ddd61270d565b5b602002015190505f88600160028110611dfa57611df961270d565b5b602002015190505f5b60396008611e119190612767565b8160ff16101561245b577f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000180611e4a57611e4961279a565b5b885f60038460ff16611e5c91906127c7565b611e669190612767565b60c38110611e7757611e7661270d565b5b6020020151850896507f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000180611eaf57611eae61279a565b5b88600160038460ff16611ec291906127c7565b611ecc9190612767565b60c38110611edd57611edc61270d565b5b6020020151840895507f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000180611f1557611f1461279a565b5b88600260038460ff16611f2891906127c7565b611f329190612767565b60c38110611f4357611f4261270d565b5b602002015183089450611f558761246b565b965060026008611f659190612808565b8160ff161080611f915750603960026008611f809190612808565b611f8a9190612767565b8160ff1610155b15611fad57611f9f8661246b565b9550611faa8561246b565b94505b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000180611fdc57611fdb61279a565b5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061200b5761200a61279a565b5b7f2b90bba00fca0589f617e7dcbfe82e0df706ab640ceb247b791a93b74e36736d87097f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061205d5761205c61279a565b5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061208c5761208b61279a565b5b7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e08a097f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806120de576120dd61279a565b5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061210d5761210c61279a565b5b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b8d095f08080893507f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806121655761216461279a565b5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806121945761219361279a565b5b7f101071f0032379b697315876690f053d148d4e109f5fb065c8aacc55a0f89bfa87097f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806121e6576121e561279a565b5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806122155761221461279a565b5b7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe238a097f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806122675761226661279a565b5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806122965761229561279a565b5b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd7718d095f08080892507f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806122ee576122ed61279a565b5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061231d5761231c61279a565b5b7f19a3fc0a56702bf417ba7fee3802593fa644470307043f7773279cd71d25d5e087097f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061236f5761236e61279a565b5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061239e5761239d61279a565b5b7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee29118a097f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806123f0576123ef61279a565b5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061241f5761241e61279a565b5b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a78d095f0808089150808061245390612844565b915050611e03565b5082975050505050505050919050565b5f807f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061249c5761249b61279a565b5b83840990505f7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806124d1576124d061279a565b5b82830990507f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806125055761250461279a565b5b81850992505050919050565b5f604051905090565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b61256882612522565b810181811067ffffffffffffffff8211171561258757612586612532565b5b80604052505050565b5f612599612511565b90506125a5828261255f565b919050565b5f67ffffffffffffffff8211156125c4576125c3612532565b5b602082029050919050565b5f80fd5b5f819050919050565b6125e5816125d3565b81146125ef575f80fd5b50565b5f81359050612600816125dc565b92915050565b5f612618612613846125aa565b612590565b90508060208402830185811115612632576126316125cf565b5b835b8181101561265b578061264788826125f2565b845260208401935050602081019050612634565b5050509392505050565b5f82601f8301126126795761267861251e565b5b6002612686848285612606565b91505092915050565b5f604082840312156126a4576126a361251a565b5b5f6126b184828501612665565b91505092915050565b6126c3816125d3565b82525050565b5f6020820190506126dc5f8301846126ba565b92915050565b5f602082840312156126f7576126f661251a565b5b5f612704848285016125f2565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612771826125d3565b915061277c836125d3565b92508282019050808211156127945761279361273a565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6127d1826125d3565b91506127dc836125d3565b92508282026127ea816125d3565b915082820484148315176128015761280061273a565b5b5092915050565b5f612812826125d3565b915061281d836125d3565b92508261282d5761282c61279a565b5b828204905092915050565b5f60ff82169050919050565b5f61284e82612838565b915060ff82036128615761286061273a565b5b60018201905091905056fea2646970667358221220bbca6b465040aed1280d5f1c36307be5f51332df0a9b378c08219b2d27168faa64736f6c63430008180033\")]\n    contract PoseidonT3 {\n      uint constant F = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n      uint constant ROUNDS_F = 8;\n      uint constant ROUNDS_P = 57;\n      uint constant T = 3;\n\n      uint constant M00 = 0x109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b;\n      uint constant M01 = 0x2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771;\n      uint constant M02 = 0x143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7;\n      uint constant M10 = 0x16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e0;\n      uint constant M11 = 0x2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe23;\n      uint constant M12 = 0x176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee2911;\n      uint constant M20 = 0x2b90bba00fca0589f617e7dcbfe82e0df706ab640ceb247b791a93b74e36736d;\n      uint constant M21 = 0x101071f0032379b697315876690f053d148d4e109f5fb065c8aacc55a0f89bfa;\n      uint constant M22 = 0x19a3fc0a56702bf417ba7fee3802593fa644470307043f7773279cd71d25d5e0;\n\n      // Based on https://github.com/chancehudson/poseidon-solidity/blob/e57becdabb65d99fdc586fe1e1e09e7108202d53/contracts/Poseidon.sol\n      function hash(uint[2] memory inputs) public pure returns (uint) {\n        uint[195] memory C = [0x0ee9a592ba9a9518d05986d656f40c2114c4993c11bb29938d21d47304cd8e6e, 0x00f1445235f2148c5986587169fc1bcd887b08d4d00868df5696fff40956e864, 0x08dff3487e8ac99e1f29a058d0fa80b930c728730b7ab36ce879f3890ecf73f5, 0x2f27be690fdaee46c3ce28f7532b13c856c35342c84bda6e20966310fadc01d0, 0x2b2ae1acf68b7b8d2416bebf3d4f6234b763fe04b8043ee48b8327bebca16cf2, 0x0319d062072bef7ecca5eac06f97d4d55952c175ab6b03eae64b44c7dbf11cfa, 0x28813dcaebaeaa828a376df87af4a63bc8b7bf27ad49c6298ef7b387bf28526d, 0x2727673b2ccbc903f181bf38e1c1d40d2033865200c352bc150928adddf9cb78, 0x234ec45ca27727c2e74abd2b2a1494cd6efbd43e340587d6b8fb9e31e65cc632, 0x15b52534031ae18f7f862cb2cf7cf760ab10a8150a337b1ccd99ff6e8797d428, 0x0dc8fad6d9e4b35f5ed9a3d186b79ce38e0e8a8d1b58b132d701d4eecf68d1f6, 0x1bcd95ffc211fbca600f705fad3fb567ea4eb378f62e1fec97805518a47e4d9c, 0x10520b0ab721cadfe9eff81b016fc34dc76da36c2578937817cb978d069de559, 0x1f6d48149b8e7f7d9b257d8ed5fbbaf42932498075fed0ace88a9eb81f5627f6, 0x1d9655f652309014d29e00ef35a2089bfff8dc1c816f0dc9ca34bdb5460c8705, 0x04df5a56ff95bcafb051f7b1cd43a99ba731ff67e47032058fe3d4185697cc7d, 0x0672d995f8fff640151b3d290cedaf148690a10a8c8424a7f6ec282b6e4be828, 0x099952b414884454b21200d7ffafdd5f0c9a9dcc06f2708e9fc1d8209b5c75b9, 0x052cba2255dfd00c7c483143ba8d469448e43586a9b4cd9183fd0e843a6b9fa6, 0x0b8badee690adb8eb0bd74712b7999af82de55707251ad7716077cb93c464ddc, 0x119b1590f13307af5a1ee651020c07c749c15d60683a8050b963d0a8e4b2bdd1, 0x03150b7cd6d5d17b2529d36be0f67b832c4acfc884ef4ee5ce15be0bfb4a8d09, 0x2cc6182c5e14546e3cf1951f173912355374efb83d80898abe69cb317c9ea565, 0x005032551e6378c450cfe129a404b3764218cadedac14e2b92d2cd73111bf0f9, 0x233237e3289baa34bb147e972ebcb9516469c399fcc069fb88f9da2cc28276b5, 0x05c8f4f4ebd4a6e3c980d31674bfbe6323037f21b34ae5a4e80c2d4c24d60280, 0x0a7b1db13042d396ba05d818a319f25252bcf35ef3aeed91ee1f09b2590fc65b, 0x2a73b71f9b210cf5b14296572c9d32dbf156e2b086ff47dc5df542365a404ec0, 0x1ac9b0417abcc9a1935107e9ffc91dc3ec18f2c4dbe7f22976a760bb5c50c460, 0x12c0339ae08374823fabb076707ef479269f3e4d6cb104349015ee046dc93fc0, 0x0b7475b102a165ad7f5b18db4e1e704f52900aa3253baac68246682e56e9a28e, 0x037c2849e191ca3edb1c5e49f6e8b8917c843e379366f2ea32ab3aa88d7f8448, 0x05a6811f8556f014e92674661e217e9bd5206c5c93a07dc145fdb176a716346f, 0x29a795e7d98028946e947b75d54e9f044076e87a7b2883b47b675ef5f38bd66e, 0x20439a0c84b322eb45a3857afc18f5826e8c7382c8a1585c507be199981fd22f, 0x2e0ba8d94d9ecf4a94ec2050c7371ff1bb50f27799a84b6d4a2a6f2a0982c887, 0x143fd115ce08fb27ca38eb7cce822b4517822cd2109048d2e6d0ddcca17d71c8, 0x0c64cbecb1c734b857968dbbdcf813cdf8611659323dbcbfc84323623be9caf1, 0x028a305847c683f646fca925c163ff5ae74f348d62c2b670f1426cef9403da53, 0x2e4ef510ff0b6fda5fa940ab4c4380f26a6bcb64d89427b824d6755b5db9e30c, 0x0081c95bc43384e663d79270c956ce3b8925b4f6d033b078b96384f50579400e, 0x2ed5f0c91cbd9749187e2fade687e05ee2491b349c039a0bba8a9f4023a0bb38, 0x30509991f88da3504bbf374ed5aae2f03448a22c76234c8c990f01f33a735206, 0x1c3f20fd55409a53221b7c4d49a356b9f0a1119fb2067b41a7529094424ec6ad, 0x10b4e7f3ab5df003049514459b6e18eec46bb2213e8e131e170887b47ddcb96c, 0x2a1982979c3ff7f43ddd543d891c2abddd80f804c077d775039aa3502e43adef, 0x1c74ee64f15e1db6feddbead56d6d55dba431ebc396c9af95cad0f1315bd5c91, 0x07533ec850ba7f98eab9303cace01b4b9e4f2e8b82708cfa9c2fe45a0ae146a0, 0x21576b438e500449a151e4eeaf17b154285c68f42d42c1808a11abf3764c0750, 0x2f17c0559b8fe79608ad5ca193d62f10bce8384c815f0906743d6930836d4a9e, 0x2d477e3862d07708a79e8aae946170bc9775a4201318474ae665b0b1b7e2730e, 0x162f5243967064c390e095577984f291afba2266c38f5abcd89be0f5b2747eab, 0x2b4cb233ede9ba48264ecd2c8ae50d1ad7a8596a87f29f8a7777a70092393311, 0x2c8fbcb2dd8573dc1dbaf8f4622854776db2eece6d85c4cf4254e7c35e03b07a, 0x1d6f347725e4816af2ff453f0cd56b199e1b61e9f601e9ade5e88db870949da9, 0x204b0c397f4ebe71ebc2d8b3df5b913df9e6ac02b68d31324cd49af5c4565529, 0x0c4cb9dc3c4fd8174f1149b3c63c3c2f9ecb827cd7dc25534ff8fb75bc79c502, 0x174ad61a1448c899a25416474f4930301e5c49475279e0639a616ddc45bc7b54, 0x1a96177bcf4d8d89f759df4ec2f3cde2eaaa28c177cc0fa13a9816d49a38d2ef, 0x066d04b24331d71cd0ef8054bc60c4ff05202c126a233c1a8242ace360b8a30a, 0x2a4c4fc6ec0b0cf52195782871c6dd3b381cc65f72e02ad527037a62aa1bd804, 0x13ab2d136ccf37d447e9f2e14a7cedc95e727f8446f6d9d7e55afc01219fd649, 0x1121552fca26061619d24d843dc82769c1b04fcec26f55194c2e3e869acc6a9a, 0x00ef653322b13d6c889bc81715c37d77a6cd267d595c4a8909a5546c7c97cff1, 0x0e25483e45a665208b261d8ba74051e6400c776d652595d9845aca35d8a397d3, 0x29f536dcb9dd7682245264659e15d88e395ac3d4dde92d8c46448db979eeba89, 0x2a56ef9f2c53febadfda33575dbdbd885a124e2780bbea170e456baace0fa5be, 0x1c8361c78eb5cf5decfb7a2d17b5c409f2ae2999a46762e8ee416240a8cb9af1, 0x151aff5f38b20a0fc0473089aaf0206b83e8e68a764507bfd3d0ab4be74319c5, 0x04c6187e41ed881dc1b239c88f7f9d43a9f52fc8c8b6cdd1e76e47615b51f100, 0x13b37bd80f4d27fb10d84331f6fb6d534b81c61ed15776449e801b7ddc9c2967, 0x01a5c536273c2d9df578bfbd32c17b7a2ce3664c2a52032c9321ceb1c4e8a8e4, 0x2ab3561834ca73835ad05f5d7acb950b4a9a2c666b9726da832239065b7c3b02, 0x1d4d8ec291e720db200fe6d686c0d613acaf6af4e95d3bf69f7ed516a597b646, 0x041294d2cc484d228f5784fe7919fd2bb925351240a04b711514c9c80b65af1d, 0x154ac98e01708c611c4fa715991f004898f57939d126e392042971dd90e81fc6, 0x0b339d8acca7d4f83eedd84093aef51050b3684c88f8b0b04524563bc6ea4da4, 0x0955e49e6610c94254a4f84cfbab344598f0e71eaff4a7dd81ed95b50839c82e, 0x06746a6156eba54426b9e22206f15abca9a6f41e6f535c6f3525401ea0654626, 0x0f18f5a0ecd1423c496f3820c549c27838e5790e2bd0a196ac917c7ff32077fb, 0x04f6eeca1751f7308ac59eff5beb261e4bb563583ede7bc92a738223d6f76e13, 0x2b56973364c4c4f5c1a3ec4da3cdce038811eb116fb3e45bc1768d26fc0b3758, 0x123769dd49d5b054dcd76b89804b1bcb8e1392b385716a5d83feb65d437f29ef, 0x2147b424fc48c80a88ee52b91169aacea989f6446471150994257b2fb01c63e9, 0x0fdc1f58548b85701a6c5505ea332a29647e6f34ad4243c2ea54ad897cebe54d, 0x12373a8251fea004df68abcf0f7786d4bceff28c5dbbe0c3944f685cc0a0b1f2, 0x21e4f4ea5f35f85bad7ea52ff742c9e8a642756b6af44203dd8a1f35c1a90035, 0x16243916d69d2ca3dfb4722224d4c462b57366492f45e90d8a81934f1bc3b147, 0x1efbe46dd7a578b4f66f9adbc88b4378abc21566e1a0453ca13a4159cac04ac2, 0x07ea5e8537cf5dd08886020e23a7f387d468d5525be66f853b672cc96a88969a, 0x05a8c4f9968b8aa3b7b478a30f9a5b63650f19a75e7ce11ca9fe16c0b76c00bc, 0x20f057712cc21654fbfe59bd345e8dac3f7818c701b9c7882d9d57b72a32e83f, 0x04a12ededa9dfd689672f8c67fee31636dcd8e88d01d49019bd90b33eb33db69, 0x27e88d8c15f37dcee44f1e5425a51decbd136ce5091a6767e49ec9544ccd101a, 0x2feed17b84285ed9b8a5c8c5e95a41f66e096619a7703223176c41ee433de4d1, 0x1ed7cc76edf45c7c404241420f729cf394e5942911312a0d6972b8bd53aff2b8, 0x15742e99b9bfa323157ff8c586f5660eac6783476144cdcadf2874be45466b1a, 0x1aac285387f65e82c895fc6887ddf40577107454c6ec0317284f033f27d0c785, 0x25851c3c845d4790f9ddadbdb6057357832e2e7a49775f71ec75a96554d67c77, 0x15a5821565cc2ec2ce78457db197edf353b7ebba2c5523370ddccc3d9f146a67, 0x2411d57a4813b9980efa7e31a1db5966dcf64f36044277502f15485f28c71727, 0x002e6f8d6520cd4713e335b8c0b6d2e647e9a98e12f4cd2558828b5ef6cb4c9b, 0x2ff7bc8f4380cde997da00b616b0fcd1af8f0e91e2fe1ed7398834609e0315d2, 0x00b9831b948525595ee02724471bcd182e9521f6b7bb68f1e93be4febb0d3cbe, 0x0a2f53768b8ebf6a86913b0e57c04e011ca408648a4743a87d77adbf0c9c3512, 0x00248156142fd0373a479f91ff239e960f599ff7e94be69b7f2a290305e1198d, 0x171d5620b87bfb1328cf8c02ab3f0c9a397196aa6a542c2350eb512a2b2bcda9, 0x170a4f55536f7dc970087c7c10d6fad760c952172dd54dd99d1045e4ec34a808, 0x29aba33f799fe66c2ef3134aea04336ecc37e38c1cd211ba482eca17e2dbfae1, 0x1e9bc179a4fdd758fdd1bb1945088d47e70d114a03f6a0e8b5ba650369e64973, 0x1dd269799b660fad58f7f4892dfb0b5afeaad869a9c4b44f9c9e1c43bdaf8f09, 0x22cdbc8b70117ad1401181d02e15459e7ccd426fe869c7c95d1dd2cb0f24af38, 0x0ef042e454771c533a9f57a55c503fcefd3150f52ed94a7cd5ba93b9c7dacefd, 0x11609e06ad6c8fe2f287f3036037e8851318e8b08a0359a03b304ffca62e8284, 0x1166d9e554616dba9e753eea427c17b7fecd58c076dfe42708b08f5b783aa9af, 0x2de52989431a859593413026354413db177fbf4cd2ac0b56f855a888357ee466, 0x3006eb4ffc7a85819a6da492f3a8ac1df51aee5b17b8e89d74bf01cf5f71e9ad, 0x2af41fbb61ba8a80fdcf6fff9e3f6f422993fe8f0a4639f962344c8225145086, 0x119e684de476155fe5a6b41a8ebc85db8718ab27889e85e781b214bace4827c3, 0x1835b786e2e8925e188bea59ae363537b51248c23828f047cff784b97b3fd800, 0x28201a34c594dfa34d794996c6433a20d152bac2a7905c926c40e285ab32eeb6, 0x083efd7a27d1751094e80fefaf78b000864c82eb571187724a761f88c22cc4e7, 0x0b6f88a3577199526158e61ceea27be811c16df7774dd8519e079564f61fd13b, 0x0ec868e6d15e51d9644f66e1d6471a94589511ca00d29e1014390e6ee4254f5b, 0x2af33e3f866771271ac0c9b3ed2e1142ecd3e74b939cd40d00d937ab84c98591, 0x0b520211f904b5e7d09b5d961c6ace7734568c547dd6858b364ce5e47951f178, 0x0b2d722d0919a1aad8db58f10062a92ea0c56ac4270e822cca228620188a1d40, 0x1f790d4d7f8cf094d980ceb37c2453e957b54a9991ca38bbe0061d1ed6e562d4, 0x0171eb95dfbf7d1eaea97cd385f780150885c16235a2a6a8da92ceb01e504233, 0x0c2d0e3b5fd57549329bf6885da66b9b790b40defd2c8650762305381b168873, 0x1162fb28689c27154e5a8228b4e72b377cbcafa589e283c35d3803054407a18d, 0x2f1459b65dee441b64ad386a91e8310f282c5a92a89e19921623ef8249711bc0, 0x1e6ff3216b688c3d996d74367d5cd4c1bc489d46754eb712c243f70d1b53cfbb, 0x01ca8be73832b8d0681487d27d157802d741a6f36cdc2a0576881f9326478875, 0x1f7735706ffe9fc586f976d5bdf223dc680286080b10cea00b9b5de315f9650e, 0x2522b60f4ea3307640a0c2dce041fba921ac10a3d5f096ef4745ca838285f019, 0x23f0bee001b1029d5255075ddc957f833418cad4f52b6c3f8ce16c235572575b, 0x2bc1ae8b8ddbb81fcaac2d44555ed5685d142633e9df905f66d9401093082d59, 0x0f9406b8296564a37304507b8dba3ed162371273a07b1fc98011fcd6ad72205f, 0x2360a8eb0cc7defa67b72998de90714e17e75b174a52ee4acb126c8cd995f0a8, 0x15871a5cddead976804c803cbaef255eb4815a5e96df8b006dcbbc2767f88948, 0x193a56766998ee9e0a8652dd2f3b1da0362f4f54f72379544f957ccdeefb420f, 0x2a394a43934f86982f9be56ff4fab1703b2e63c8ad334834e4309805e777ae0f, 0x1859954cfeb8695f3e8b635dcb345192892cd11223443ba7b4166e8876c0d142, 0x04e1181763050e58013444dbcb99f1902b11bc25d90bbdca408d3819f4fed32b, 0x0fdb253dee83869d40c335ea64de8c5bb10eb82db08b5e8b1f5e5552bfd05f23, 0x058cbe8a9a5027bdaa4efb623adead6275f08686f1c08984a9d7c5bae9b4f1c0, 0x1382edce9971e186497eadb1aeb1f52b23b4b83bef023ab0d15228b4cceca59a, 0x03464990f045c6ee0819ca51fd11b0be7f61b8eb99f14b77e1e6634601d9e8b5, 0x23f7bfc8720dc296fff33b41f98ff83c6fcab4605db2eb5aaa5bc137aeb70a58, 0x0a59a158e3eec2117e6e94e7f0e9decf18c3ffd5e1531a9219636158bbaf62f2, 0x06ec54c80381c052b58bf23b312ffd3ce2c4eba065420af8f4c23ed0075fd07b, 0x118872dc832e0eb5476b56648e867ec8b09340f7a7bcb1b4962f0ff9ed1f9d01, 0x13d69fa127d834165ad5c7cba7ad59ed52e0b0f0e42d7fea95e1906b520921b1, 0x169a177f63ea681270b1c6877a73d21bde143942fb71dc55fd8a49f19f10c77b, 0x04ef51591c6ead97ef42f287adce40d93abeb032b922f66ffb7e9a5a7450544d, 0x256e175a1dc079390ecd7ca703fb2e3b19ec61805d4f03ced5f45ee6dd0f69ec, 0x30102d28636abd5fe5f2af412ff6004f75cc360d3205dd2da002813d3e2ceeb2, 0x10998e42dfcd3bbf1c0714bc73eb1bf40443a3fa99bef4a31fd31be182fcc792, 0x193edd8e9fcf3d7625fa7d24b598a1d89f3362eaf4d582efecad76f879e36860, 0x18168afd34f2d915d0368ce80b7b3347d1c7a561ce611425f2664d7aa51f0b5d, 0x29383c01ebd3b6ab0c017656ebe658b6a328ec77bc33626e29e2e95b33ea6111, 0x10646d2f2603de39a1f4ae5e7771a64a702db6e86fb76ab600bf573f9010c711, 0x0beb5e07d1b27145f575f1395a55bf132f90c25b40da7b3864d0242dcb1117fb, 0x16d685252078c133dc0d3ecad62b5c8830f95bb2e54b59abdffbf018d96fa336, 0x0a6abd1d833938f33c74154e0404b4b40a555bbbec21ddfafd672dd62047f01a, 0x1a679f5d36eb7b5c8ea12a4c2dedc8feb12dffeec450317270a6f19b34cf1860, 0x0980fb233bd456c23974d50e0ebfde4726a423eada4e8f6ffbc7592e3f1b93d6, 0x161b42232e61b84cbf1810af93a38fc0cece3d5628c9282003ebacb5c312c72b, 0x0ada10a90c7f0520950f7d47a60d5e6a493f09787f1564e5d09203db47de1a0b, 0x1a730d372310ba82320345a29ac4238ed3f07a8a2b4e121bb50ddb9af407f451, 0x2c8120f268ef054f817064c369dda7ea908377feaba5c4dffbda10ef58e8c556, 0x1c7c8824f758753fa57c00789c684217b930e95313bcb73e6e7b8649a4968f70, 0x2cd9ed31f5f8691c8e39e4077a74faa0f400ad8b491eb3f7b47b27fa3fd1cf77, 0x23ff4f9d46813457cf60d92f57618399a5e022ac321ca550854ae23918a22eea, 0x09945a5d147a4f66ceece6405dddd9d0af5a2c5103529407dff1ea58f180426d, 0x188d9c528025d4c2b67660c6b771b90f7c7da6eaa29d3f268a6dd223ec6fc630, 0x3050e37996596b7f81f68311431d8734dba7d926d3633595e0c0d8ddf4f0f47f, 0x15af1169396830a91600ca8102c35c426ceae5461e3f95d89d829518d30afd78, 0x1da6d09885432ea9a06d9f37f873d985dae933e351466b2904284da3320d8acc, 0x2796ea90d269af29f5f8acf33921124e4e4fad3dbe658945e546ee411ddaa9cb, 0x202d7dd1da0f6b4b0325c8b3307742f01e15612ec8e9304a7cb0319e01d32d60, 0x096d6790d05bb759156a952ba263d672a2d7f9c788f4c831a29dace4c0f8be5f, 0x054efa1f65b0fce283808965275d877b438da23ce5b13e1963798cb1447d25a4, 0x1b162f83d917e93edb3308c29802deb9d8aa690113b2e14864ccf6e18e4165f1, 0x21e5241e12564dd6fd9f1cdd2a0de39eedfefc1466cc568ec5ceb745a0506edc, 0x1cfb5662e8cf5ac9226a80ee17b36abecb73ab5f87e161927b4349e10e4bdf08, 0x0f21177e302a771bbae6d8d1ecb373b62c99af346220ac0129c53f666eb24100, 0x1671522374606992affb0dd7f71b12bec4236aede6290546bcef7e1f515c2320, 0x0fa3ec5b9488259c2eb4cf24501bfad9be2ec9e42c5cc8ccd419d2a692cad870, 0x193c0e04e0bd298357cb266c1506080ed36edce85c648cc085e8c57b1ab54bba, 0x102adf8ef74735a27e9128306dcbc3c99f6f7291cd406578ce14ea2adaba68f8, 0x0fe0af7858e49859e2a54d6f1ad945b1316aa24bfbdd23ae40a6d0cb70c3eab1, 0x216f6717bbc7dedb08536a2220843f4e2da5f1daa9ebdefde8a5ea7344798d22, 0x1da55cc900f0d21f4a3e694391918a1b3c23b2ac773c6b3ef88e2e4228325161];\n\n        uint state0 = 0;\n        uint state1 = inputs[0];\n        uint state2 = inputs[1];\n        uint swap0 = 0;\n        uint swap1 = inputs[0];\n        uint swap2 = inputs[1];\n        for (uint8 r = 0; r \u003c ROUNDS_F + ROUNDS_P; r++) {\n          state0 = addmod(swap0, C[r * T + 0], F);\n          state1 = addmod(swap1, C[r * T + 1], F);\n          state2 = addmod(swap2, C[r * T + 2], F);\n\n          state0 = pow5mod(state0);\n          if (r \u003c ROUNDS_F / 2 || r \u003e= ROUNDS_F / 2 + ROUNDS_P) {\n            state1 = pow5mod(state1);\n            state2 = pow5mod(state2);\n          }\n\n          swap0 = addmod(addmod(addmod(0, mulmod(state0, M00, F), F), mulmod(state1, M10, F), F), mulmod(state2, M20, F), F);\n          swap1 = addmod(addmod(addmod(0, mulmod(state0, M01, F), F), mulmod(state1, M11, F), F), mulmod(state2, M21, F), F);\n          swap2 = addmod(addmod(addmod(0, mulmod(state0, M02, F), F), mulmod(state1, M12, F), F), mulmod(state2, M22, F), F);\n        }\n        return swap0;\n      }\n\n      function pow5mod(uint i) public pure returns (uint) {\n        uint a = mulmod(i, i, F);\n        uint c = mulmod(a, a, F);\n        return mulmod(i, c, F);\n      }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","report.rs"],"content":"use std::{collections::HashMap, fmt::Display, future::Future};\n\nuse alloy::network::AnyTransactionReceipt;\n\nuse crate::{ArbOtherFields, Opt};\n\nconst SEPARATOR: \u0026str = \"::\";\n\n#[derive(Debug)]\npub struct FunctionReport {\n    sig: String,\n    gas: u128,\n}\n\nimpl FunctionReport {\n    pub(crate) fn new(\n        receipt: (\u0026str, AnyTransactionReceipt),\n    ) -\u003e eyre::Result\u003cSelf\u003e {\n        Ok(FunctionReport {\n            sig: receipt.0.to_owned(),\n            gas: get_l2_gas_used(\u0026receipt.1)?,\n        })\n    }\n}\n\n#[derive(Debug)]\npub struct ContractReport {\n    contract: String,\n    functions: Vec\u003cFunctionReport\u003e,\n    functions_cached: Vec\u003cFunctionReport\u003e,\n    functions_wasm_opt_cached: Vec\u003cFunctionReport\u003e,\n}\n\nimpl ContractReport {\n    pub async fn generate\u003c\n        F: Future\u003cOutput = eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e\u003e,\n    \u003e(\n        name: \u0026str,\n        run: impl Fn(Opt) -\u003e F,\n    ) -\u003e eyre::Result\u003cContractReport\u003e {\n        let reports = run(Opt::None).await?;\n        let report = reports\n            .into_iter()\n            .try_fold(ContractReport::new(name), ContractReport::add)?;\n\n        let cached_reports = run(Opt::Cache).await?;\n        let report = cached_reports\n            .into_iter()\n            .try_fold(report, ContractReport::add_cached)?;\n\n        let wasm_opt_cached_reports = run(Opt::CacheWasmOpt).await?;\n        let report = wasm_opt_cached_reports\n            .into_iter()\n            .try_fold(report, ContractReport::add_wasm_opt_cached)?;\n\n        Ok(report)\n    }\n\n    pub fn new(contract: \u0026str) -\u003e Self {\n        ContractReport {\n            contract: contract.to_owned(),\n            functions: vec![],\n            functions_cached: vec![],\n            functions_wasm_opt_cached: vec![],\n        }\n    }\n\n    pub fn add(mut self, fn_report: FunctionReport) -\u003e eyre::Result\u003cSelf\u003e {\n        self.functions.push(fn_report);\n        Ok(self)\n    }\n\n    pub fn add_cached(\n        mut self,\n        fn_report: FunctionReport,\n    ) -\u003e eyre::Result\u003cSelf\u003e {\n        self.functions_cached.push(fn_report);\n        Ok(self)\n    }\n\n    pub fn add_wasm_opt_cached(\n        mut self,\n        fn_report: FunctionReport,\n    ) -\u003e eyre::Result\u003cSelf\u003e {\n        self.functions_wasm_opt_cached.push(fn_report);\n        Ok(self)\n    }\n\n    fn signature_max_len(\u0026self) -\u003e usize {\n        let prefix_len = self.contract.len() + SEPARATOR.len();\n        self.functions\n            .iter()\n            .map(|FunctionReport { sig: name, .. }| prefix_len + name.len())\n            .max()\n            .unwrap_or_default()\n    }\n\n    fn gas_max_len(\u0026self) -\u003e usize {\n        self.functions\n            .iter()\n            .map(|FunctionReport { gas, .. }| gas.to_string().len())\n            .max()\n            .unwrap_or_default()\n    }\n\n    fn gas_cached_max_len(\u0026self) -\u003e usize {\n        self.functions_cached\n            .iter()\n            .map(|FunctionReport { gas, .. }| gas.to_string().len())\n            .max()\n            .unwrap_or_default()\n    }\n\n    fn gas_wasm_opt_cached_max_len(\u0026self) -\u003e usize {\n        self.functions_wasm_opt_cached\n            .iter()\n            .map(|FunctionReport { gas, .. }| gas.to_string().len())\n            .max()\n            .unwrap_or_default()\n    }\n}\n\n#[derive(Debug, Default)]\npub struct BenchmarkReport(Vec\u003cContractReport\u003e);\n\nimpl BenchmarkReport {\n    pub fn merge_with(mut self, report: ContractReport) -\u003e Self {\n        self.0.push(report);\n        self\n    }\n\n    pub fn column_width(\n        \u0026self,\n        column_value: impl FnMut(\u0026ContractReport) -\u003e usize,\n        header: \u0026str,\n    ) -\u003e usize {\n        self.0\n            .iter()\n            .map(column_value)\n            .chain(std::iter::once(header.len()))\n            .max()\n            .unwrap_or_default()\n    }\n}\n\nimpl Display for BenchmarkReport {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        const HEADER_SIG: \u0026str = \"Contract::function\";\n        const HEADER_WASM_OPT_GAS_CACHED: \u0026str = \"WASM Opt \u0026 Cached\";\n        const HEADER_GAS_CACHED: \u0026str = \"Cached\";\n        const HEADER_GAS: \u0026str = \"Not Cached\";\n\n        // Calculating the width of table columns.\n        let width1 =\n            self.column_width(ContractReport::signature_max_len, HEADER_SIG);\n        let width2 = self.column_width(\n            ContractReport::gas_wasm_opt_cached_max_len,\n            HEADER_WASM_OPT_GAS_CACHED,\n        );\n        let width3 = self.column_width(\n            ContractReport::gas_cached_max_len,\n            HEADER_GAS_CACHED,\n        );\n        let width4 = self.column_width(ContractReport::gas_max_len, HEADER_GAS);\n\n        // Print headers for the table columns.\n        writeln!(\n            f,\n            \"| {HEADER_SIG:\u003cwidth1$} | {HEADER_WASM_OPT_GAS_CACHED:\u003ewidth2$} | {HEADER_GAS_CACHED:\u003ewidth3$} | {HEADER_GAS:\u003ewidth4$} |\"\n        )?;\n        writeln!(\n            f,\n            \"| {:-\u003ewidth1$} | {:-\u003ewidth2$} | {:-\u003ewidth3$} | {:-\u003ewidth4$} |\",\n            \"\", \"\", \"\", \"\",\n        )?;\n\n        // Merging a non-cached gas report with a cached one.\n        for report in \u0026self.0 {\n            let prefix = format!(\"{}{SEPARATOR}\", report.contract);\n\n            let wasm_opt_cached: HashMap\u003c_, _\u003e = report\n                .functions_wasm_opt_cached\n                .iter()\n                .map(|func| (\u0026*func.sig, func.gas))\n                .collect();\n\n            let gas_cached: HashMap\u003c_, _\u003e = report\n                .functions_cached\n                .iter()\n                .map(|func| (\u0026*func.sig, func.gas))\n                .collect();\n\n            for report in \u0026report.functions {\n                let sig = \u0026*report.sig;\n                let gas_wasm_opt_cached = wasm_opt_cached\n                    .get(sig)\n                    .map(u128::to_string)\n                    .unwrap_or(\"—\".to_string());\n                let gas_cached = gas_cached\n                    .get(sig)\n                    .map(u128::to_string)\n                    .unwrap_or(\"—\".to_string());\n                let gas = \u0026report.gas;\n\n                let full_sig = format!(\"{prefix}{sig}\");\n                writeln!(\n                    f,\n                    \"| {full_sig:\u003cwidth1$} | {gas_wasm_opt_cached:\u003ewidth2$} | {gas_cached:\u003ewidth3$} | {gas:\u003ewidth4$} |\"\n                )?;\n            }\n        }\n\n        Ok(())\n    }\n}\n\nconst BASE_GAS_FEE: u128 = 21_000;\n\nfn get_l2_gas_used(receipt: \u0026AnyTransactionReceipt) -\u003e eyre::Result\u003cu128\u003e {\n    let l2_gas = receipt.gas_used;\n    let arb_fields: ArbOtherFields = receipt.other.deserialize_as()?;\n    let l1_gas = arb_fields.gas_used_for_l1.to::\u003cu128\u003e();\n    Ok(l2_gas - l1_gas - BASE_GAS_FEE)\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","benches","src","vesting_wallet.rs"],"content":"use alloy::{\n    network::{AnyNetwork, EthereumWallet, TransactionBuilder},\n    primitives::Address,\n    providers::{Provider, ProviderBuilder},\n    rpc::types::{serde_helpers::WithOtherFields, TransactionRequest},\n    sol,\n    sol_types::SolCall,\n    uint,\n};\nuse alloy_primitives::U256;\nuse e2e::{constructor, receipt, Account};\n\nuse crate::{\n    report::{ContractReport, FunctionReport},\n    Opt,\n};\n\nsol!(\n    #[sol(rpc)]\n    contract VestingWallet {\n        function owner() public view virtual returns (address owner);\n        function start() external view returns (uint256 start);\n        function duration() external view returns (uint256 duration);\n        function end() external view returns (uint256 end);\n        function released() external view returns (uint256 released);\n        function released(address token) external view returns (uint256 released);\n        function releasable() external view returns (uint256 releasable);\n        function releasable(address token) external view returns (uint256 releasable);\n        function release() external;\n        function release(address token) external;\n        function vestedAmount(uint64 timestamp) external view returns (uint256 vestedAmount);\n        function vestedAmount(address token, uint64 timestamp) external view returns (uint256 vestedAmount);\n    }\n\n    #[sol(rpc)]\n    contract Erc20 {\n        function mint(address account, uint256 amount) external;\n    }\n);\n\nconst START_TIMESTAMP: u64 = 1000;\nconst DURATION_SECONDS: u64 = 1000;\n\nconst TOKEN_NAME: \u0026str = \"Test Token\";\nconst TOKEN_SYMBOL: \u0026str = \"TTK\";\nconst CAP: U256 = uint!(1_000_000_U256);\n\npub async fn bench() -\u003e eyre::Result\u003cContractReport\u003e {\n    ContractReport::generate(\"VestingWallet\", run).await\n}\n\npub async fn run(cache_opt: Opt) -\u003e eyre::Result\u003cVec\u003cFunctionReport\u003e\u003e {\n    let alice = Account::new().await?;\n    let alice_wallet = ProviderBuilder::new()\n        .network::\u003cAnyNetwork\u003e()\n        .with_recommended_fillers()\n        .wallet(EthereumWallet::from(alice.signer.clone()))\n        .on_http(alice.url().parse()?);\n\n    let contract_addr = deploy(\u0026alice, cache_opt.clone()).await?;\n    let erc20_addr = deploy_token(\u0026alice, cache_opt).await?;\n\n    let contract = VestingWallet::new(contract_addr, \u0026alice_wallet);\n    let erc20 = Erc20::new(erc20_addr, \u0026alice_wallet);\n\n    let tx: WithOtherFields\u003cTransactionRequest\u003e = WithOtherFields {\n        inner: TransactionRequest::default()\n            .with_from(alice.address())\n            .with_to(contract_addr)\n            .with_value(uint!(1000_U256)),\n        other: Default::default(),\n    };\n\n    alice_wallet.send_transaction(tx).await?.watch().await?;\n    receipt!(erc20.mint(contract_addr, uint!(1000_U256)))?;\n\n    // IMPORTANT: Order matters!\n    use VestingWallet::*;\n    #[rustfmt::skip]\n    let receipts = vec![\n        (startCall::SIGNATURE, receipt!(contract.start())?),\n        (durationCall::SIGNATURE, receipt!(contract.duration())?),\n        (endCall::SIGNATURE, receipt!(contract.end())?),\n        (released_0Call::SIGNATURE, receipt!(contract.released_0())?),\n        (released_1Call::SIGNATURE, receipt!(contract.released_1(erc20_addr))?),\n        (releasable_0Call::SIGNATURE, receipt!(contract.releasable_0())?),\n        (releasable_1Call::SIGNATURE, receipt!(contract.releasable_1(erc20_addr))?),\n        (release_0Call::SIGNATURE, receipt!(contract.release_0())?),\n        (release_1Call::SIGNATURE, receipt!(contract.release_1(erc20_addr))?),\n        (vestedAmount_0Call::SIGNATURE, receipt!(contract.vestedAmount_0(START_TIMESTAMP))?),\n        (vestedAmount_1Call::SIGNATURE, receipt!(contract.vestedAmount_1(erc20_addr, START_TIMESTAMP))?),\n    ];\n\n    receipts\n        .into_iter()\n        .map(FunctionReport::new)\n        .collect::\u003ceyre::Result\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\nasync fn deploy(account: \u0026Account, cache_opt: Opt) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(\n        account,\n        \"vesting-wallet\",\n        Some(constructor!(\n            account.address(),\n            START_TIMESTAMP,\n            DURATION_SECONDS\n        )),\n        cache_opt,\n    )\n    .await\n}\n\nasync fn deploy_token(\n    account: \u0026Account,\n    cache_opt: Opt,\n) -\u003e eyre::Result\u003cAddress\u003e {\n    crate::deploy(\n        account,\n        \"erc20\",\n        Some(constructor!(\n            TOKEN_NAME.to_string(),\n            TOKEN_SYMBOL.to_string(),\n            CAP\n        )),\n        cache_opt,\n    )\n    .await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","benches","erc6909_core.rs"],"content":"// use criterion::{black_box, criterion_group, criterion_main, Criterion};\n// use stylus_sdk::testing::TestVM;\n// use openzeppelin_stylus::token::erc6909::{\n//     erc6909::Erc6909,\n//     traits::{IErc6909, IErc6909Mintable, IErc6909Burnable},\n// };\n// use alloy_primitives::{Address, U256};\n\n// fn setup() -\u003e (Erc6909, Address, Address, U256) {\n//     let vm    = TestVM::default();\n//     let mut token = Erc6909::from(\u0026vm);\n//     let alice = Address::new([0xAA; 20]);\n//     let bob   = Address::new([0xBB; 20]);\n//     let id    = U256::from(1u64);\n//     (token, alice, bob, id)\n// }\n\n// pub fn bench_approve(c: \u0026mut Criterion) {\n//     let (mut t, alice, bob, id) = setup();\n//     c.bench_function(\"erc6909 approve\", |b| {\n//         b.iter(|| {\n//             t.approve(\n//                 black_box(alice),\n//                 black_box(bob),\n//                 black_box(id),\n//                 black_box(U256::from(42u64)),\n//             ).unwrap();\n//         })\n//     });\n// }\n\n// pub fn bench_transfer(c: \u0026mut Criterion) {\n//     let (mut t, alice, bob, id) = setup();\n//     // give alice some balance\n//     t.mint(alice, alice, id, U256::from(100u64)).unwrap();\n//     c.bench_function(\"erc6909 transfer\", |b| {\n//         b.iter(|| {\n//             t.transfer(\n//                 black_box(alice),\n//                 black_box(bob),\n//                 black_box(id),\n//                 black_box(U256::from(1u64)),\n//             ).unwrap();\n//         })\n//     });\n// }\n\n// pub fn bench_transfer_from(c: \u0026mut Criterion) {\n//     let (mut t, alice, bob, id) = setup();\n//     t.mint(alice, alice, id, U256::from(100u64)).unwrap();\n//     t.approve(alice, bob, id, U256::from(50u64)).unwrap();\n//     c.bench_function(\"erc6909 transfer_from\", |b| {\n//         b.iter(|| {\n//             t.transfer_from(\n//                 black_box(bob),\n//                 black_box(alice),\n//                 black_box(bob),\n//                 black_box(id),\n//                 black_box(U256::from(1u64)),\n//             ).unwrap();\n//         })\n//     });\n// }\n\n// pub fn bench_burn(c: \u0026mut Criterion) {\n//     let (mut t, alice, _bob, id) = setup();\n//     t.mint(alice, alice, id, U256::from(100u64)).unwrap();\n//     c.bench_function(\"erc6909 burn\", |b| {\n//         b.iter(|| {\n//             t.burn(\n//                 black_box(alice),\n//                 black_box(alice),\n//                 black_box(id),\n//                 black_box(U256::from(1u64)),\n//             ).unwrap();\n//         })\n//     });\n// }\n\n// criterion_group!(core_benches, bench_approve, bench_transfer, bench_transfer_from, bench_burn);\n// criterion_main!(core_benches);\n\n// benches/erc6909_core.rs\n// use criterion::{black_box, criterion_group, criterion_main, Criterion};\n// use stylus_sdk::testing::TestVM;\n// use alloy_primitives::{Address, U256};\n\n// use openzeppelin_stylus::token::erc6909::Erc6909Core;               // your core type\n// use openzeppelin_stylus::token::erc6909::traits::IErc6909Core;    // approve/transfer/burn\n\n// fn setup() -\u003e (Erc6909Core, Address, Address, U256) {\n//     let vm = TestVM::default();\n//     let token = Erc6909Core::from(\u0026vm);\n//     let alice = Address::new([0xAA; 20]);\n//     let bob   = Address::new([0xBB; 20]);\n//     let id    = U256::from(1);\n//     // give alice some balance:\n//     token.mint(alice, id, U256::from(100u64)).unwrap();\n//     (token, alice, bob, id)\n// }\n\n// fn bench_approve(c: \u0026mut Criterion) {\n//     let (mut token, alice, bob, id) = setup();\n//     c.bench_function(\"erc6909_core approve\", |b| {\n//         b.iter(|| {\n//             token\n//                 .approve(\n//                     black_box(alice),\n//                     black_box(bob),\n//                     black_box(id),\n//                     black_box(U256::from(50u64)),\n//                 )\n//                 .unwrap();\n//         })\n//     });\n// }\n\n// fn bench_transfer(c: \u0026mut Criterion) {\n//     let (mut token, alice, bob, id) = setup();\n//     c.bench_function(\"erc6909_core transfer\", |b| {\n//         b.iter(|| {\n//             token\n//                 .transfer(\n//                     black_box(alice),\n//                     black_box(bob),\n//                     black_box(id),\n//                     black_box(U256::from(10u64)),\n//                 )\n//                 .unwrap();\n//         })\n//     });\n// }\n\n// fn bench_transfer_from(c: \u0026mut Criterion) {\n//     let (mut token, alice, bob, id) = setup();\n//     // pre-approve bob to move on behalf of alice\n//     token\n//         .approve(alice, bob, id, U256::from(20u64))\n//         .unwrap();\n//     c.bench_function(\"erc6909_core transfer_from\", |b| {\n//         b.iter(|| {\n//             token\n//                 .transfer_from(\n//                     black_box(bob),\n//                     black_box(alice),\n//                     black_box(bob),\n//                     black_box(id),\n//                     black_box(U256::from(5u64)),\n//                 )\n//                 .unwrap();\n//         })\n//     });\n// }\n\n// fn bench_burn(c: \u0026mut Criterion) {\n//     let (mut token, alice, _bob, id) = setup();\n//     c.bench_function(\"erc6909_core burn\", |b| {\n//         b.iter(|| {\n//             token\n//                 .burn(\n//                     black_box(alice),\n//                     black_box(id),\n//                     black_box(U256::from(5u64)),\n//                 )\n//                 .unwrap();\n//         })\n//     });\n// }\n\n// // once you’ve wired-up metadata:\n// fn bench_set_token_uri(c: \u0026mut Criterion) {\n//     let (mut token, _alice, _bob, id) = setup();\n//     let uri = black_box(b\"http://example.com/\".repeat(10));  // 110 bytes\n//     c.bench_function(\"erc6909_core set_token_uri(100B)\", |b| {\n//         b.iter(|| {\n//             token\n//                 .set_token_uri(black_box(id), uri.clone())\n//                 .unwrap();\n//         })\n//     });\n// }\n\n// fn bench_token_uri(c: \u0026mut Criterion) {\n//     let (mut token, _alice, _bob, id) = setup();\n//     let uri: Vec\u003cu8\u003e = vec![b'x'; 100];\n//     token.set_token_uri(id, uri.clone()).unwrap();\n//     c.bench_function(\"erc6909_core token_uri(100B)\", |b| {\n//         b.iter(|| {\n//             black_box(token.token_uri(black_box(id)));\n//         })\n//     });\n// }\n\n// criterion_group!(\n//     core_benches,\n//     bench_approve,\n//     bench_transfer,\n//     bench_transfer_from,\n//     bench_burn,\n//     bench_set_token_uri,\n//     bench_token_uri,\n// );\n// criterion_main!(core_benches);\n\n\n\n\n// benches/erc6909_core.rs\n\n// use criterion::{black_box, criterion_group, criterion_main, Criterion};\n// use stylus_sdk::testing::TestVM;\n// use alloy_primitives::{Address, U256};\n\n// // Core ERC-6909 implementation and its traits\n// use openzeppelin_stylus::token::erc6909::Erc6909;\n// use openzeppelin_stylus::token::erc6909::traits::{\n//     IErc6909,\n//     IErc6909Mintable,\n//     IErc6909Burnable,\n// };\n\n// /// Sets up a fresh token instance and mints initial balance for `alice`.\n// fn setup() -\u003e (Erc6909, Address, Address, U256) {\n//     let vm = TestVM::default();\n//     let mut token = Erc6909::from(\u0026vm);\n//     let alice = Address::new([0xAA; 20]);\n//     let bob = Address::new([0xBB; 20]);\n//     let id = U256::from(1u64);\n//     // Provide Alice with some initial supply to allow transfers/burns\n//     token.mint(alice, alice, id, U256::from(100u64)).unwrap();\n//     (token, alice, bob, id)\n// }\n\n// fn bench_approve(c: \u0026mut Criterion) {\n//     let (mut token, alice, bob, id) = setup();\n//     c.bench_function(\"erc6909_core approve\", |b| {\n//         b.iter(|| {\n//             token\n//                 .approve(\n//                     black_box(alice),\n//                     black_box(bob),\n//                     black_box(id),\n//                     black_box(U256::from(50u64)),\n//                 )\n//                 .unwrap();\n//         });\n//     });\n// }\n\n// fn bench_transfer(c: \u0026mut Criterion) {\n//     let (mut token, alice, bob, id) = setup();\n//     c.bench_function(\"erc6909_core transfer\", |b| {\n//         b.iter(|| {\n//             token\n//                 .transfer(\n//                     black_box(alice),\n//                     black_box(bob),\n//                     black_box(id),\n//                     black_box(U256::from(10u64)),\n//                 )\n//                 .unwrap();\n//         });\n//     });\n// }\n\n// fn bench_transfer_from(c: \u0026mut Criterion) {\n//     let (mut token, alice, bob, id) = setup();\n//     // Pre-approve Bob to move Alice's tokens\n//     token\n//         .approve(alice, bob, id, U256::from(20u64))\n//         .unwrap();\n//     c.bench_function(\"erc6909_core transfer_from\", |b| {\n//         b.iter(|| {\n//             token\n//                 .transfer_from(\n//                     black_box(bob),\n//                     black_box(alice),\n//                     black_box(bob),\n//                     black_box(id),\n//                     black_box(U256::from(5u64)),\n//                 )\n//                 .unwrap();\n//         });\n//     });\n// }\n\n// fn bench_burn(c: \u0026mut Criterion) {\n//     let (mut token, alice, _, id) = setup();\n//     c.bench_function(\"erc6909_core burn\", |b| {\n//         b.iter(|| {\n//             // re-mint for each iteration to avoid insufficient balance\n//             token.mint(alice, alice, id, U256::from(10u64)).unwrap();\n//             token\n//                 .burn(\n//                     black_box(alice),\n//                     black_box(alice),\n//                     black_box(id),\n//                     black_box(U256::from(5u64)),\n//                 )\n//                 .unwrap();\n//         });\n//     });\n// }\n// // Core doesn’t include metadata; metadata benchmarks live in erc6909_metadata.rs\n\n// criterion_group!(\n//     core_benches,\n//     bench_approve,\n//     bench_transfer,\n//     bench_transfer_from,\n//     bench_burn,\n// );\n// criterion_main!(core_benches);\n\n\n// benches/erc6909_core.rs THE LAST VERSION WORKING PERFECT\n\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse stylus_sdk::testing::TestVM;\nuse alloy_primitives::{Address, U256};\n\n// Core ERC-6909 implementation and its traits\nuse openzeppelin_stylus::token::erc6909::Erc6909;\nuse openzeppelin_stylus::token::erc6909::traits::{\n    IErc6909,\n    IErc6909Mintable,\n    IErc6909Burnable,\n};\n\n/// Sets up a fresh token instance and mints initial balance for `alice`.\nfn setup() -\u003e (Erc6909, Address, Address, U256) {\n    let vm = TestVM::default();\n    let mut token = Erc6909::from(\u0026vm);\n    let alice = Address::new([0xAA; 20]);\n    let bob = Address::new([0xBB; 20]);\n    let id = U256::from(1u64);\n    // Provide Alice with some initial supply to allow operations\n    token.mint(alice, alice, id, U256::from(100u64)).unwrap();\n    (token, alice, bob, id)\n}\n\nfn bench_approve(c: \u0026mut Criterion) {\n    let (mut token, alice, bob, id) = setup();\n    c.bench_function(\"erc6909_core approve\", |b| {\n        b.iter(|| {\n            token\n                .approve(\n                    black_box(alice),\n                    black_box(bob),\n                    black_box(id),\n                    black_box(U256::from(50u64)),\n                )\n                .unwrap();\n        })\n    });\n}\n\nfn bench_transfer(c: \u0026mut Criterion) {\n    let (mut token, alice, bob, id) = setup();\n    c.bench_function(\"erc6909_core transfer\", |b| {\n        b.iter(|| {\n            // Re-mint for each iteration to maintain balance\n            token.mint(alice, alice, id, U256::from(10u64)).unwrap();\n            token\n                .transfer(\n                    black_box(alice),\n                    black_box(bob),\n                    black_box(id),\n                    black_box(U256::from(10u64)),\n                )\n                .unwrap();\n        })\n    });\n}\n\nfn bench_transfer_from(c: \u0026mut Criterion) {\n    let (mut token, alice, bob, id) = setup();\n    c.bench_function(\"erc6909_core transfer_from\", |b| {\n        b.iter(|| {\n            // Reset state each iteration: mint and approve\n            token.mint(alice, alice, id, U256::from(10u64)).unwrap();\n            token.approve(alice, bob, id, U256::from(20u64)).unwrap();\n            token\n                .transfer_from(\n                    black_box(bob),\n                    black_box(alice),\n                    black_box(bob),\n                    black_box(id),\n                    black_box(U256::from(5u64)),\n                )\n                .unwrap();\n        })\n    });\n}\n\nfn bench_burn(c: \u0026mut Criterion) {\n    let (mut token, alice, _, id) = setup();\n    c.bench_function(\"erc6909_core burn\", |b| {\n        b.iter(|| {\n            // Reset state each iteration: mint then burn\n            token.mint(alice, alice, id, U256::from(10u64)).unwrap();\n            token\n                .burn(\n                    black_box(alice),\n                    black_box(alice),\n                    black_box(id),\n                    black_box(U256::from(5u64)),\n                )\n                .unwrap();\n        })\n    });\n}\n\ncriterion_group!(\n    core_benches,\n    bench_approve,\n    bench_transfer,\n    bench_transfer_from,\n    bench_burn\n);\ncriterion_main!(core_benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","benches","erc6909_enumerable.rs"],"content":"// contracts/src/token/erc6909/extensions/enumerable.rs\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse alloy_primitives::U256;\n\n/// A minimal in-memory implementation of the enumerable API.\nstruct InMemoryEnumerable {\n    all_ids: Vec\u003cU256\u003e,\n}\n\nimpl InMemoryEnumerable {\n    fn new() -\u003e Self {\n        Self { all_ids: Vec::new() }\n    }\n\n    fn record_id(\u0026mut self, id: U256) {\n        if !self.all_ids.contains(\u0026id) {\n            self.all_ids.push(id);\n        }\n    }\n\n    fn total_ids(\u0026self) -\u003e U256 {\n        U256::from(self.all_ids.len())\n    }\n\n    fn id_by_index(\u0026self, index: U256) -\u003e U256 {\n        // Convert U256 index to usize by taking low 8 bytes\n        let raw: [u8; 32] = index.to_le_bytes();\n        let idx_bytes: [u8; 8] = raw[0..8].try_into().expect(\"slice with incorrect length\");\n        let idx = u64::from_le_bytes(idx_bytes) as usize;\n        if idx \u003c self.all_ids.len() {\n            self.all_ids[idx]\n        } else {\n            U256::ZERO\n        }\n    }\n}\n\nfn setup() -\u003e InMemoryEnumerable {\n    let mut ext = InMemoryEnumerable::new();\n    for i in 1..=100u64 {\n        ext.record_id(U256::from(i));\n    }\n    ext\n}\n\nfn bench_total_ids(c: \u0026mut Criterion) {\n    let ext = setup();\n    c.bench_function(\"erc6909_enum total_ids (100)\", |b| {\n        b.iter(|| {\n            black_box(ext.total_ids());\n        })\n    });\n}\n\nfn bench_id_by_index(c: \u0026mut Criterion) {\n    let ext = setup();\n    c.bench_function(\"erc6909_enum id_by_index (50)\", |b| {\n        b.iter(|| {\n            // Convert U256 index to usize by taking low 8 bytes\n            let raw: [u8; 32] = black_box(U256::from(50)).to_le_bytes();\n            let idx_bytes: [u8; 8] = raw[0..8].try_into().unwrap();\n            let idx = u64::from_le_bytes(idx_bytes) as usize;\n            black_box(ext.id_by_index(U256::from(idx as u64)));\n        })\n    });\n}\n\ncriterion_group!(enum_benches, bench_total_ids, bench_id_by_index);\ncriterion_main!(enum_benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","benches","erc6909_metadata.rs"],"content":"// benches/erc6909_metadata.rs\n\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse stylus_sdk::testing::TestVM;\nuse alloy_primitives::{Address, U256};\n\n// point at your library crate, not `crate::…`\nuse openzeppelin_stylus::token::erc6909::extensions::metadata_uri::Erc6909MetadataUri;\nuse openzeppelin_stylus::token::erc6909::traits::IErc6909MetadataUri;\n\nfn setup() -\u003e (Erc6909MetadataUri, Address, U256) {\n    let vm = TestVM::default();\n    let ext = Erc6909MetadataUri::from(\u0026vm);\n    let caller = Address::new([0xAA; 20]);\n    let id = U256::from(1u64);\n    (ext, caller, id)\n}\n\nfn bench_set_uri_100b(c: \u0026mut Criterion) {\n    let (mut ext, caller, id) = setup();\n    let uri = vec![b'a'; 100];\n    c.bench_function(\"erc6909_metadata set_token_uri (100 B)\", |b| {\n        b.iter(|| {\n            ext.set_token_uri(\n                black_box(caller),\n                black_box(id),\n                black_box(uri.clone()),\n            )\n            .unwrap();\n        })\n    });\n}\n\nfn bench_get_uri_100b(c: \u0026mut Criterion) {\n    let (mut ext, caller, id) = setup();\n    let uri = vec![b'b'; 100];\n    ext.set_token_uri(caller, id, uri.clone()).unwrap();\n    c.bench_function(\"erc6909_metadata token_uri (100 B)\", |b| {\n        b.iter(|| {\n            black_box(ext.token_uri(black_box(id)));\n        })\n    });\n}\n\ncriterion_group!(metadata_benches, bench_set_uri_100b, bench_get_uri_100b);\ncriterion_main!(metadata_benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","benches","erc6909_supply.rs"],"content":"// benches/erc6909_supply.rs\n\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse stylus_sdk::testing::TestVM;\nuse alloy_primitives::{Address, U256};\n\n// Import the supply extension and mint/burn traits\nuse openzeppelin_stylus::token::erc6909::extensions::token_supply::Erc6909Supply;\nuse openzeppelin_stylus::token::erc6909::traits::{\n    IErc6909Supply,\n    IErc6909Mintable,\n    IErc6909Burnable,\n};\n\n/// Returns (token, caller, recipient, token_id)\nfn setup() -\u003e (Erc6909Supply, Address, Address, U256) {\n    let vm = TestVM::default();\n    let token = Erc6909Supply::from(\u0026vm);\n    let caller = Address::new([0xAA; 20]);\n    let recipient = Address::new([0xBB; 20]);\n    let id = U256::from(1u64);\n    (token, caller, recipient, id)\n}\n\nfn bench_supply_mint(c: \u0026mut Criterion) {\n    let (mut token, caller, recipient, id) = setup();\n    c.bench_function(\"erc6909_supply mint\", |b| {\n        b.iter(|| {\n            token\n                .mint(\n                    black_box(caller),\n                    black_box(recipient),\n                    black_box(id),\n                    black_box(U256::from(10u64)),\n                )\n                .unwrap();\n        })\n    });\n}\n\nfn bench_supply_burn(c: \u0026mut Criterion) {\n    let (mut token, caller, recipient, id) = setup();\n    c.bench_function(\"erc6909_supply burn\", |b| {\n        b.iter(|| {\n            // re-mint then burn each iteration to avoid balance depletion\n            token.mint(caller, recipient, id, U256::from(20u64)).unwrap();\n            token.burn(\n                black_box(caller),\n                black_box(recipient),\n                black_box(id),\n                black_box(U256::from(5u64)),\n            )\n            .unwrap();\n        })\n    });\n}\n\nfn bench_supply_total(c: \u0026mut Criterion) {\n    let (mut token, caller, recipient, id) = setup();\n    // Pre-mint supply\n    token.mint(caller, recipient, id, U256::from(123u64)).unwrap();\n    c.bench_function(\"erc6909_supply total_supply\", |b| {\n        b.iter(|| {\n            black_box(token.total_supply(black_box(id)));\n        })\n    });\n}\n\ncriterion_group!(supply_benches, bench_supply_mint, bench_supply_burn, bench_supply_total);\ncriterion_main!(supply_benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","examples","erc6909-extensions.rs"],"content":"use stylus_sdk::testing::TestVM;\nuse alloy_primitives::{Address, U256};\n\n// core + the three extensions\nuse openzeppelin_stylus::token::erc6909::{\n    Erc6909,                                    // if you need core directly\n    extensions::{\n        token_supply::Erc6909Supply,\n        metadata_uri::Erc6909MetadataUri,\n        enumerable::Erc6909Enumerable,\n    },\n};\nuse openzeppelin_stylus::token::erc6909::traits::{\n    IErc6909Mintable, IErc6909Supply,\n    IErc6909MetadataUri, IErc6909Enumerable,\n};\n\nfn main() {\n    let vm = TestVM::default();\n    let alice = Address::new([0xAA; 20]);\n    let id    = U256::from(42u64);\n    let amount = U256::from(100u64);\n\n    // ── Supply extension ───────────────────────────────\n    let mut supply = Erc6909Supply::from(\u0026vm);\n    supply.mint(alice, alice, id, amount).unwrap();\n    assert_eq!(supply.total_supply(id), amount);\n    println!(\" ✔ total supply = {}\", supply.total_supply(id));\n\n    // ── Metadata extension ────────────────────────────\n    let mut uri_ext = Erc6909MetadataUri::from(\u0026vm);\n    let uri = b\"https://example.com/42\".to_vec();\n    uri_ext.set_token_uri(alice, id, uri.clone()).unwrap();\n    assert_eq!(uri_ext.token_uri(id), uri);\n    println!(\" ✔ metadata URI = {:?}\", uri_ext.token_uri(id));\n\n    // ── Enumerable extension ──────────────────────────\n    let mut enum_ext = Erc6909Enumerable::from(\u0026vm);\n    // we have to record that `id` was minted; in real you’d hook this in _mint\n    enum_ext._record_id(id);\n    assert_eq!(enum_ext.total_ids(), U256::ONE);\n    assert_eq!(enum_ext.id_by_index(U256::ZERO), id);\n    println!(\" ✔ enumerable id[0] = {:?}\", enum_ext.id_by_index(U256::ZERO));\n\n    println!(\"✅ all three ERC-6909 extensions example OK\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","examples","erc6909-supply.rs"],"content":"// use core::str::FromStr;\n// use alloy_primitives::{Address, U256};\n// use openzeppelin_stylus::token::erc6909::{\n//     extensions::token_supply::Erc6909Supply,\n//     traits::IErc6909Supply,\n// };\n// use stylus_sdk::testing::TestVM;\n// use openzeppelin_stylus::token::erc6909::traits::IErc6909Mintable;\n\n\n// fn main() {\n//     // 1) spin up an in-memory VM\n//     let vm = TestVM::default();\n\n//     // 2) instantiate our extension-backed contract\n//     let mut token = Erc6909Supply::from(\u0026vm);\n\n//     // 3) a test address\n//     let alice = Address::new([0xAA; 20]);\n\n//     // 4) prepare ID and amount\n//     let id     = U256::from_str(\"42\").unwrap();\n//     let amount = U256::from_str(\"100\").unwrap();\n\n//     // 5) mint and check total supply\n//     token.mint(alice, alice, id, amount).unwrap();\n//     assert_eq!(token.total_supply(id), amount);\n\n//     println!(\"Alice balance is {}\", token.total_supply(id));\n//     println!(\"✅ erc6909-supply example OK\");\n// }\n\n// examples/erc6909-supply.rs\n\nuse core::str::FromStr;\nuse alloy_primitives::{Address, U256};\nuse openzeppelin_stylus::token::erc6909::{\n    extensions::token_supply::Erc6909Supply,\n    traits::IErc6909Supply,\n};\nuse openzeppelin_stylus::token::erc6909::traits::IErc6909Mintable;\nuse stylus_sdk::testing::TestVM;\n\nfn main() {\n    // 1) spin up an in-memory VM\n    let vm = TestVM::default();\n\n    // 2) instantiate our extension-backed contract\n    let mut token = Erc6909Supply::from(\u0026vm);\n\n    // 3) a test address (Alice)\n    let alice = Address::new([0xAA; 20]);\n\n    // 4) prepare ID and amount\n    let id     = U256::from_str(\"42\").unwrap();\n    let amount = U256::from_str(\"100\").unwrap();\n\n    // 5) mint and check total supply\n    //    — caller = alice, recipient = alice\n    token.mint(alice, alice, id, amount).unwrap();\n    assert_eq!(token.total_supply(id), amount);\n\n    println!(\"Alice total supply for ID {} is {}\", id, token.total_supply(id));\n    println!(\"✅ erc6909-supply example OK\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","access","control.rs"],"content":"//! Contract module that allows children to implement role-based access control\n//! mechanisms.\n//!\n//! This is a lightweight version that doesn't allow enumerating role members\n//! except through off-chain means by accessing the contract event logs.\n//!\n//! Roles are referred to by their `bytes32` identifier. These should be exposed\n//! in the external API and be unique. The best way to achieve this is by using\n//! `pub const` hash digests:\n//!\n//! ```no_run\n//! pub const MY_ROLE: [u8; 32] =\n//!     keccak_const::Keccak256::new().update(b\"MY_ROLE\").finalize();\n//! ```\n//!\n//! Roles can be used to represent a set of permissions. To restrict access to a\n//! function call, use [`IAccessControl::has_role`]:\n//!\n//! ```rust,ignore\n//! pub fn foo() {\n//!   assert!(self.has_role(MY_ROLE.into(), msg::sender()));\n//!   // ...\n//! }\n//! ```\n//!\n//! Roles can be granted and revoked dynamically via the\n//! [`IAccessControl::grant_role`] and [`IAccessControl::revoke_role`]\n//! functions. Each role has an associated admin role, and only accounts that\n//! have a `role`'s `admin_role` can call [`IAccessControl::grant_role`] and\n//! [`IAccessControl::revoke_role`].\n//!\n//! By default, the admin role for all roles is\n//! [`AccessControl::DEFAULT_ADMIN_ROLE`], which means that only accounts with\n//! this role will be able to grant or revoke other roles. More complex role\n//! relationships can be created by using [`AccessControl::_set_role_admin`].\n//!\n//! WARNING: The [`AccessControl::DEFAULT_ADMIN_ROLE`] is also its own admin: it\n//! has permission to grant and revoke this role. Extra precautions should be\n//! taken to secure accounts that have been granted it. We recommend using\n//! `AccessControlDefaultAdminRules` to enforce additional security measures for\n//! this role.\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{Address, FixedBytes, B256};\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{\n    call::MethodError,\n    evm, msg,\n    prelude::*,\n    storage::{StorageBool, StorageFixedBytes, StorageMap},\n};\n\nuse crate::utils::introspection::erc165::IErc165;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when `new_admin_role` is set as `role`'s admin role, replacing\n        /// `previous_admin_role`.\n        ///\n        /// `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n        /// `RoleAdminChanged` not being emitted signaling this.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previous_admin_role, bytes32 indexed new_admin_role);\n        /// Emitted when `account` is granted `role`.\n        ///\n        /// `sender` is the account that originated the contract call. This account\n        /// bears the admin role (for the granted role).\n        /// Expected in cases where the role was granted using the internal\n        /// [`AccessControl::grant_role`].\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n        /// Emitted when `account` is revoked `role`.\n        ///\n        /// `sender` is the account that originated the contract call:\n        ///   - if using `revoke_role`, it is the admin role bearer.\n        ///   - if using `renounce_role`, it is the role bearer (i.e. `account`).\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    }\n\n    sol! {\n        /// The `account` is missing a role.\n        ///\n        /// * `account` - Account that was found to not be authorized.\n        /// * `needed_role` - The missing role.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error AccessControlUnauthorizedAccount(address account, bytes32 needed_role);\n        /// The caller of a function is not the expected one.\n        ///\n        /// NOTE: Don't confuse with [`AccessControlUnauthorizedAccount`].\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error AccessControlBadConfirmation();\n    }\n}\n\n/// An error that occurred in the implementation of an [`AccessControl`]\n/// contract.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// The caller account is missing a role.\n    UnauthorizedAccount(AccessControlUnauthorizedAccount),\n    /// The caller of a function is not the expected one.\n    BadConfirmation(AccessControlBadConfirmation),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of a [`RoleData`] contract.\n///\n/// Stores information about a specific role.\n#[storage]\npub struct RoleData {\n    /// Whether an account is member of a certain role.\n    pub has_role: StorageMap\u003cAddress, StorageBool\u003e,\n    /// The admin role for this role.\n    pub admin_role: StorageFixedBytes\u003c32\u003e,\n}\n\n/// State of an [`AccessControl`] contract.\n#[storage]\npub struct AccessControl {\n    /// Role identifier -\u003e Role information.\n    pub(crate) roles: StorageMap\u003cFixedBytes\u003c32\u003e, RoleData\u003e,\n}\n\n/// Interface for an [`AccessControl`] contract.\n#[interface_id]\npub trait IAccessControl {\n    /// The error type associated with this interface implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns `true` if `account` has been granted `role`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `role` - The role identifier.\n    /// * `account` - The account to check for membership.\n    fn has_role(\u0026self, role: B256, account: Address) -\u003e bool;\n\n    /// Checks if [`msg::sender`] has been granted `role`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `role` - The role identifier.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::UnauthorizedAccount`] - If [`msg::sender`] has not been\n    ///   granted `role`.\n    fn only_role(\u0026self, role: B256) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Returns the admin role that controls `role`. See\n    /// [`IAccessControl::grant_role`] and [`IAccessControl::revoke_role`].\n    ///\n    /// To change a role's admin, use [`AccessControl::_set_role_admin`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `role` - The role identifier.\n    fn get_role_admin(\u0026self, role: B256) -\u003e B256;\n\n    /// Grants `role` to `account`.\n    ///\n    /// If `account` had not been already granted `role`, emits a\n    /// [`RoleGranted`] event.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `role` - The role identifier.\n    /// * `account` - The account which will be granted the role.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::UnauthorizedAccount`] - If [`msg::sender`] has not been\n    ///   granted `role`.\n    ///\n    /// # Events\n    ///\n    /// * [`RoleGranted`]\n    fn grant_role(\n        \u0026mut self,\n        role: B256,\n        account: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Revokes `role` from `account`.\n    ///\n    /// If `account` had been granted `role`, emits a [`RoleRevoked`] event.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `role` - The role identifier.\n    /// * `account` - The account which will be revoked the role.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::UnauthorizedAccount`] - If [`msg::sender`] has not been\n    ///   granted `role`.\n    ///\n    /// # Events\n    ///\n    /// * [`RoleRevoked`].\n    fn revoke_role(\n        \u0026mut self,\n        role: B256,\n        account: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Revokes `role` from the calling account.\n    ///\n    /// Roles are often managed via [`Self::grant_role`] and\n    /// [`Self::revoke_role`]: this function's purpose is to provide a mechanism\n    /// for accounts to lose their privileges if they are compromised (such as\n    /// when a trusted device is misplaced).\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `role` - The role identifier.\n    /// * `confirmation` - The account which will be revoked the role.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::BadConfirmation`]  - If [`msg::sender`] is not the\n    ///   `confirmation` address.\n    ///\n    /// # Events\n    ///\n    /// * [`RoleRevoked`] - If the calling account has its `role` revoked.\n    fn renounce_role(\n        \u0026mut self,\n        role: B256,\n        confirmation: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\n#[public]\n#[implements(IAccessControl\u003cError = Error\u003e, IErc165)]\nimpl AccessControl {}\n\n#[public]\nimpl IAccessControl for AccessControl {\n    type Error = Error;\n\n    fn has_role(\u0026self, role: B256, account: Address) -\u003e bool {\n        self.roles.getter(role).has_role.get(account)\n    }\n\n    fn only_role(\u0026self, role: B256) -\u003e Result\u003c(), Self::Error\u003e {\n        self._check_role(role, msg::sender())\n    }\n\n    fn get_role_admin(\u0026self, role: B256) -\u003e B256 {\n        self.roles.getter(role).admin_role.get()\n    }\n\n    fn grant_role(\n        \u0026mut self,\n        role: B256,\n        account: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let admin_role = self.get_role_admin(role);\n        self.only_role(admin_role)?;\n        self._grant_role(role, account);\n        Ok(())\n    }\n\n    fn revoke_role(\n        \u0026mut self,\n        role: B256,\n        account: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let admin_role = self.get_role_admin(role);\n        self.only_role(admin_role)?;\n        self._revoke_role(role, account);\n        Ok(())\n    }\n\n    fn renounce_role(\n        \u0026mut self,\n        role: B256,\n        confirmation: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        if msg::sender() != confirmation {\n            return Err(Error::BadConfirmation(\n                AccessControlBadConfirmation {},\n            ));\n        }\n\n        self._revoke_role(role, confirmation);\n        Ok(())\n    }\n}\n\nimpl AccessControl {\n    /// The default admin role. `[0; 32]` by default.\n    pub const DEFAULT_ADMIN_ROLE: [u8; 32] = [0; 32];\n\n    /// Sets `admin_role` as `role`'s admin role.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `role` - The identifier of the role we are changing the admin to.\n    /// * `new_admin_role` - The new admin role.\n    ///\n    /// # Events\n    ///\n    /// * [`RoleAdminChanged`].\n    pub fn _set_role_admin(\u0026mut self, role: B256, new_admin_role: B256) {\n        let previous_admin_role = self.get_role_admin(role);\n        self.roles.setter(role).admin_role.set(new_admin_role);\n        evm::log(RoleAdminChanged {\n            role,\n            previous_admin_role,\n            new_admin_role,\n        });\n    }\n\n    /// Checks if `account` has been granted `role`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `role` - The role identifier.\n    /// * `account` - The account to check for membership.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::UnauthorizedAccount`] - If [`msg::sender`] has not been\n    ///   granted `role`.\n    pub fn _check_role(\n        \u0026self,\n        role: B256,\n        account: Address,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !self.has_role(role, account) {\n            return Err(Error::UnauthorizedAccount(\n                AccessControlUnauthorizedAccount { account, needed_role: role },\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// Attempts to grant `role` to `account` and returns a boolean indicating\n    /// if `role` was granted.\n    ///\n    /// Internal function without access restriction.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `role` - The role identifier.\n    /// * `account` - The account which will be granted the role.\n    ///\n    /// # Events\n    ///\n    /// * [`RoleGranted`].\n    pub fn _grant_role(\u0026mut self, role: B256, account: Address) -\u003e bool {\n        if self.has_role(role, account) {\n            false\n        } else {\n            self.roles.setter(role).has_role.insert(account, true);\n            evm::log(RoleGranted { role, account, sender: msg::sender() });\n            true\n        }\n    }\n\n    /// Attempts to revoke `role` from `account` and returns a boolean\n    /// indicating if `role` was revoked.\n    ///\n    /// Internal function without access restriction.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `role` - The role identifier.\n    /// * `account` - The account which will be granted the role.\n    ///\n    /// # Events\n    ///\n    /// * [`RoleRevoked`].\n    pub fn _revoke_role(\u0026mut self, role: B256, account: Address) -\u003e bool {\n        if self.has_role(role, account) {\n            self.roles.setter(role).has_role.insert(account, false);\n            evm::log(RoleRevoked { role, account, sender: msg::sender() });\n            true\n        } else {\n            false\n        }\n    }\n}\n\n#[public]\nimpl IErc165 for AccessControl {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IAccessControl\u003e::interface_id() == interface_id\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use motsu::prelude::Contract;\n    use stylus_sdk::{\n        alloy_primitives::{Address, FixedBytes},\n        prelude::*,\n    };\n\n    use super::{AccessControl, Error, IAccessControl};\n    use crate::utils::introspection::erc165::IErc165;\n\n    /// Shorthand for declaring variables converted from a hex literal to a\n    /// fixed 32-byte slice;\n    macro_rules! roles {\n        ($($var:ident = $hex:literal);* $(;)?) =\u003e {\n            $(\n                const $var: [u8; 32] = alloy_primitives::hex!($hex);\n            )*\n        };\n    }\n\n    roles! {\n        ROLE       = \"ed9ea7bc2a13bc59432ab07436e7f7f5450f82d4b48c401bed177bfaf36b1873\";\n        OTHER_ROLE = \"879ce0d4bfd332649ca3552efe772a38d64a315eb70ab69689fd309c735946b5\";\n    }\n\n    const DEFAULT_ADMIN_ROLE: [u8; 32] = AccessControl::DEFAULT_ADMIN_ROLE;\n\n    unsafe impl TopLevelStorage for AccessControl {}\n\n    #[motsu::test]\n    fn default_role_is_default_admin(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n    ) {\n        let role_admin = contract.sender(alice).get_role_admin(ROLE.into());\n        assert_eq!(role_admin, DEFAULT_ADMIN_ROLE);\n    }\n\n    #[motsu::test]\n    fn default_admin_roles_admin_is_itself(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n    ) {\n        let role_admin =\n            contract.sender(alice).get_role_admin(DEFAULT_ADMIN_ROLE.into());\n        assert_eq!(role_admin, DEFAULT_ADMIN_ROLE);\n    }\n\n    #[motsu::test]\n    fn non_admin_cannot_grant_role_to_others(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let err =\n            contract.sender(alice).grant_role(ROLE.into(), bob).unwrap_err();\n        assert!(matches!(err, Error::UnauthorizedAccount(_)));\n    }\n\n    #[motsu::test]\n    fn accounts_can_be_granted_roles_multiple_times(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._grant_role(DEFAULT_ADMIN_ROLE.into(), alice);\n\n        contract.sender(alice).grant_role(ROLE.into(), bob).unwrap();\n        contract.sender(alice).grant_role(ROLE.into(), bob).unwrap();\n        let has_role = contract.sender(alice).has_role(ROLE.into(), bob);\n        assert!(has_role);\n    }\n\n    #[motsu::test]\n    fn not_granted_roles_can_be_revoked(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._grant_role(DEFAULT_ADMIN_ROLE.into(), alice);\n\n        let has_role = contract.sender(alice).has_role(ROLE.into(), bob);\n        assert!(!has_role);\n        contract.sender(alice).revoke_role(ROLE.into(), bob).unwrap();\n        let has_role = contract.sender(alice).has_role(ROLE.into(), bob);\n        assert!(!has_role);\n    }\n\n    #[motsu::test]\n    fn admin_can_revoke_role(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._grant_role(DEFAULT_ADMIN_ROLE.into(), alice);\n        contract.sender(alice).grant_role(ROLE.into(), bob).unwrap();\n\n        let has_role = contract.sender(alice).has_role(ROLE.into(), bob);\n        assert!(has_role);\n        contract.sender(alice).revoke_role(ROLE.into(), bob).unwrap();\n        let has_role = contract.sender(alice).has_role(ROLE.into(), bob);\n        assert!(!has_role);\n    }\n\n    #[motsu::test]\n    fn non_admin_cannot_revoke_role(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(bob)._grant_role(ROLE.into(), bob);\n\n        let has_role = contract.sender(alice).has_role(ROLE.into(), bob);\n        assert!(has_role);\n        let err =\n            contract.sender(alice).revoke_role(ROLE.into(), bob).unwrap_err();\n        assert!(matches!(err, Error::UnauthorizedAccount(_)));\n    }\n\n    #[motsu::test]\n    fn roles_can_be_revoked_multiple_times(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._grant_role(DEFAULT_ADMIN_ROLE.into(), alice);\n\n        contract.sender(alice).revoke_role(ROLE.into(), bob).unwrap();\n        contract.sender(alice).revoke_role(ROLE.into(), bob).unwrap();\n        let has_role = contract.sender(alice).has_role(ROLE.into(), bob);\n        assert!(!has_role);\n    }\n\n    #[motsu::test]\n    fn bearer_can_renounce_role(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n    ) {\n        contract.sender(alice)._grant_role(ROLE.into(), alice);\n\n        let has_role = contract.sender(alice).has_role(ROLE.into(), alice);\n        assert!(has_role);\n        contract.sender(alice).renounce_role(ROLE.into(), alice).unwrap();\n        let has_role = contract.sender(alice).has_role(ROLE.into(), alice);\n        assert!(!has_role);\n    }\n\n    #[motsu::test]\n    fn only_sender_can_renounce(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._grant_role(ROLE.into(), alice);\n        let err =\n            contract.sender(alice).renounce_role(ROLE.into(), bob).unwrap_err();\n        assert!(matches!(err, Error::BadConfirmation(_)));\n    }\n\n    #[motsu::test]\n    fn roles_can_be_renounced_multiple_times(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._grant_role(ROLE.into(), alice);\n\n        contract.sender(alice).renounce_role(ROLE.into(), alice).unwrap();\n        contract.sender(alice).renounce_role(ROLE.into(), alice).unwrap();\n        let has_role = contract.sender(alice).has_role(ROLE.into(), bob);\n        assert!(!has_role);\n    }\n\n    #[motsu::test]\n    fn a_roles_admin_role_can_change(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n    ) {\n        contract.sender(alice)._set_role_admin(ROLE.into(), OTHER_ROLE.into());\n        contract.sender(alice)._grant_role(OTHER_ROLE.into(), alice);\n\n        let admin_role = contract.sender(alice).get_role_admin(ROLE.into());\n        assert_eq!(admin_role, OTHER_ROLE);\n    }\n\n    #[motsu::test]\n    fn the_new_admin_can_grant_roles(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._set_role_admin(ROLE.into(), OTHER_ROLE.into());\n        contract.sender(alice)._grant_role(OTHER_ROLE.into(), alice);\n\n        contract.sender(alice).grant_role(ROLE.into(), bob).unwrap();\n        let has_role = contract.sender(alice).has_role(ROLE.into(), bob);\n        assert!(has_role);\n    }\n\n    #[motsu::test]\n    fn the_new_admin_can_revoke_roles(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._set_role_admin(ROLE.into(), OTHER_ROLE.into());\n        contract.sender(alice)._grant_role(OTHER_ROLE.into(), alice);\n        contract.sender(alice)._grant_role(OTHER_ROLE.into(), bob);\n\n        contract.sender(alice).revoke_role(ROLE.into(), bob).unwrap();\n        let has_role = contract.sender(alice).has_role(ROLE.into(), bob);\n        assert!(!has_role);\n    }\n\n    #[motsu::test]\n    fn previous_admins_no_longer_grant_roles(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._grant_role(ROLE.into(), alice);\n        contract.sender(alice)._set_role_admin(ROLE.into(), OTHER_ROLE.into());\n\n        let err =\n            contract.sender(alice).grant_role(ROLE.into(), bob).unwrap_err();\n        assert!(matches!(err, Error::UnauthorizedAccount(_)));\n    }\n\n    #[motsu::test]\n    fn previous_admins_no_longer_revoke_roles(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._grant_role(ROLE.into(), alice);\n        contract.sender(alice)._set_role_admin(ROLE.into(), OTHER_ROLE.into());\n\n        let err =\n            contract.sender(alice).revoke_role(ROLE.into(), bob).unwrap_err();\n        assert!(matches!(err, Error::UnauthorizedAccount(_)));\n    }\n\n    #[motsu::test]\n    fn does_not_revert_if_sender_has_role(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n    ) {\n        contract.sender(alice)._grant_role(ROLE.into(), alice);\n\n        contract.sender(alice)._check_role(ROLE.into(), alice).unwrap();\n    }\n\n    #[motsu::test]\n    fn reverts_if_sender_doesnt_have_role(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n    ) {\n        let err =\n            contract.sender(alice)._check_role(ROLE.into(), alice).unwrap_err();\n        assert!(matches!(err, Error::UnauthorizedAccount(_)));\n        let err = contract\n            .sender(alice)\n            ._check_role(OTHER_ROLE.into(), alice)\n            .unwrap_err();\n        assert!(matches!(err, Error::UnauthorizedAccount(_)));\n    }\n\n    #[motsu::test]\n    fn internal_grant_role_true_if_no_role(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let role_granted = contract.sender(alice)._grant_role(ROLE.into(), bob);\n        assert!(role_granted);\n    }\n\n    #[motsu::test]\n    fn internal_grant_role_false_if_role(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._grant_role(ROLE.into(), bob);\n\n        let role_granted = contract.sender(alice)._grant_role(ROLE.into(), bob);\n        assert!(!role_granted);\n    }\n\n    #[motsu::test]\n    fn internal_revoke_role_true_if_role(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.sender(alice)._grant_role(ROLE.into(), bob);\n\n        let role_revoked =\n            contract.sender(alice)._revoke_role(ROLE.into(), bob);\n        assert!(role_revoked);\n    }\n\n    #[motsu::test]\n    fn internal_revoke_role_false_if_no_role(\n        contract: Contract\u003cAccessControl\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let role_revoked =\n            contract.sender(alice)._revoke_role(ROLE.into(), bob);\n        assert!(!role_revoked);\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cAccessControl as IAccessControl\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0x7965db0b_u32.into();\n        assert_ne!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cAccessControl\u003e, alice: Address) {\n        assert!(contract.sender(alice).supports_interface(\n            \u003cAccessControl as IAccessControl\u003e::interface_id()\n        ));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cAccessControl as IErc165\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":61}},{"line":264,"address":[],"length":0,"stats":{"Line":244}},{"line":267,"address":[],"length":0,"stats":{"Line":13}},{"line":268,"address":[],"length":0,"stats":{"Line":52}},{"line":271,"address":[],"length":0,"stats":{"Line":21}},{"line":272,"address":[],"length":0,"stats":{"Line":63}},{"line":275,"address":[],"length":0,"stats":{"Line":6}},{"line":280,"address":[],"length":0,"stats":{"Line":24}},{"line":281,"address":[],"length":0,"stats":{"Line":20}},{"line":282,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":7}},{"line":291,"address":[],"length":0,"stats":{"Line":28}},{"line":292,"address":[],"length":0,"stats":{"Line":23}},{"line":293,"address":[],"length":0,"stats":{"Line":5}},{"line":297,"address":[],"length":0,"stats":{"Line":4}},{"line":302,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":1}},{"line":304,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":5}},{"line":329,"address":[],"length":0,"stats":{"Line":20}},{"line":330,"address":[],"length":0,"stats":{"Line":20}},{"line":331,"address":[],"length":0,"stats":{"Line":10}},{"line":332,"address":[],"length":0,"stats":{"Line":10}},{"line":333,"address":[],"length":0,"stats":{"Line":5}},{"line":334,"address":[],"length":0,"stats":{"Line":5}},{"line":350,"address":[],"length":0,"stats":{"Line":16}},{"line":355,"address":[],"length":0,"stats":{"Line":48}},{"line":356,"address":[],"length":0,"stats":{"Line":6}},{"line":357,"address":[],"length":0,"stats":{"Line":6}},{"line":361,"address":[],"length":0,"stats":{"Line":10}},{"line":378,"address":[],"length":0,"stats":{"Line":23}},{"line":379,"address":[],"length":0,"stats":{"Line":92}},{"line":380,"address":[],"length":0,"stats":{"Line":2}},{"line":382,"address":[],"length":0,"stats":{"Line":21}},{"line":402,"address":[],"length":0,"stats":{"Line":10}},{"line":403,"address":[],"length":0,"stats":{"Line":40}},{"line":404,"address":[],"length":0,"stats":{"Line":16}},{"line":405,"address":[],"length":0,"stats":{"Line":12}},{"line":406,"address":[],"length":0,"stats":{"Line":4}},{"line":408,"address":[],"length":0,"stats":{"Line":6}},{"line":415,"address":[],"length":0,"stats":{"Line":3}},{"line":416,"address":[],"length":0,"stats":{"Line":3}},{"line":417,"address":[],"length":0,"stats":{"Line":2}}],"covered":43,"coverable":45},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","access","mod.rs"],"content":"//! Contracts implementing access control mechanisms.\npub mod control;\npub mod ownable;\npub mod ownable_two_step;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","access","ownable.rs"],"content":"//! Contract module which provides a basic access control mechanism, where\n//! there is an account (an owner) that can be granted exclusive access to\n//! specific functions.\n//!\n//! The initial owner is set to the address provided by the deployer. This can\n//! later be changed with [`Ownable::transfer_ownership`].\n//!\n//! This module is used through inheritance. It will make available the\n//! [`Ownable::only_owner`] function, which can be called to restrict operations\n//! to the owner.\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{Address, FixedBytes};\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{\n    call::MethodError, evm, msg, prelude::*, storage::StorageAddress,\n};\n\nuse crate::utils::introspection::erc165::IErc165;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when ownership gets transferred between accounts.\n        ///\n        /// * `previous_owner` - Address of the previous owner.\n        /// * `new_owner` - Address of the new owner.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event OwnershipTransferred(address indexed previous_owner, address indexed new_owner);\n    }\n\n    sol! {\n        /// The caller account is not authorized to perform an operation.\n        ///\n        /// * `account` - Account that was found to not be authorized.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error OwnableUnauthorizedAccount(address account);\n        /// The owner is not a valid owner account. (eg. [`Address::ZERO`])\n        ///\n        /// * `owner` - Account that's not allowed to become the owner.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error OwnableInvalidOwner(address owner);\n    }\n}\n\n/// An error that occurred in the implementation of an [`Ownable`] contract.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// The caller account is not authorized to perform an operation.\n    UnauthorizedAccount(OwnableUnauthorizedAccount),\n    /// The owner is not a valid owner account. (eg. [`Address::ZERO`])\n    InvalidOwner(OwnableInvalidOwner),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of an [`Ownable`] contract.\n#[storage]\npub struct Ownable {\n    /// The current owner of this contract.\n    pub(crate) owner: StorageAddress,\n}\n\n/// Interface for an [`Ownable`] contract.\n#[interface_id]\npub trait IOwnable {\n    /// The error type associated to the trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns the address of the current owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    #[must_use]\n    fn owner(\u0026self) -\u003e Address;\n\n    /// Transfers ownership of the contract to a new account (`new_owner`).\n    /// Can only be called by the current owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `new_owner` - The next owner of this contract.\n    ///\n    /// # Errors\n    ///\n    /// * [`OwnableInvalidOwner`] - If `new_owner` is the [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`OwnershipTransferred`].\n    fn transfer_ownership(\n        \u0026mut self,\n        new_owner: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Leaves the contract without owner. It will not be possible to call\n    /// functions that require `only_owner`. Can only be called by the current\n    /// owner.\n    ///\n    /// NOTE: Renouncing ownership will leave the contract without an owner,\n    /// thereby disabling any functionality that is only available to the owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::UnauthorizedAccount`] - If not called by the owner.\n    ///\n    /// # Events\n    ///\n    /// * [`OwnershipTransferred`].\n    fn renounce_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\n#[public]\n#[implements(IOwnable\u003cError = Error\u003e, IErc165)]\nimpl Ownable {\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `initial_owner` - The initial owner of this contract.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidOwner`] - If initial owner is [`Address::ZERO`].\n    #[constructor]\n    pub fn constructor(\u0026mut self, initial_owner: Address) -\u003e Result\u003c(), Error\u003e {\n        if initial_owner.is_zero() {\n            return Err(Error::InvalidOwner(OwnableInvalidOwner {\n                owner: Address::ZERO,\n            }));\n        }\n        self._transfer_ownership(initial_owner);\n        Ok(())\n    }\n}\n\n#[public]\nimpl IOwnable for Ownable {\n    type Error = Error;\n\n    fn owner(\u0026self) -\u003e Address {\n        self.owner.get()\n    }\n\n    fn transfer_ownership(\n        \u0026mut self,\n        new_owner: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.only_owner()?;\n\n        if new_owner.is_zero() {\n            return Err(Error::InvalidOwner(OwnableInvalidOwner {\n                owner: Address::ZERO,\n            }));\n        }\n\n        self._transfer_ownership(new_owner);\n\n        Ok(())\n    }\n\n    fn renounce_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        self.only_owner()?;\n        self._transfer_ownership(Address::ZERO);\n        Ok(())\n    }\n}\n\nimpl Ownable {\n    /// Checks if the [`msg::sender`] is set as the owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::UnauthorizedAccount`] - If called by any account other than\n    ///   the owner.\n    pub fn only_owner(\u0026self) -\u003e Result\u003c(), Error\u003e {\n        let account = msg::sender();\n        if self.owner() != account {\n            return Err(Error::UnauthorizedAccount(\n                OwnableUnauthorizedAccount { account },\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// Transfers ownership of the contract to a new account (`new_owner`).\n    /// Internal function without access restriction.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `new_owner` - Account that is going to be the next owner.\n    ///\n    /// # Events\n    ///\n    /// * [`OwnershipTransferred`].\n    pub fn _transfer_ownership(\u0026mut self, new_owner: Address) {\n        let previous_owner = self.owner.get();\n        self.owner.set(new_owner);\n        evm::log(OwnershipTransferred { previous_owner, new_owner });\n    }\n}\n\n#[public]\nimpl IErc165 for Ownable {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IOwnable\u003e::interface_id() == interface_id\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use motsu::prelude::Contract;\n    use stylus_sdk::{\n        alloy_primitives::{Address, FixedBytes},\n        prelude::*,\n    };\n\n    use super::{Error, IOwnable, Ownable};\n    use crate::utils::introspection::erc165::IErc165;\n\n    unsafe impl TopLevelStorage for Ownable {}\n\n    #[motsu::test]\n    fn reads_owner(contract: Contract\u003cOwnable\u003e, alice: Address) {\n        contract.init(alice, |contract| contract.owner.set(alice));\n        let owner = contract.sender(alice).owner();\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn transfers_ownership(\n        contract: Contract\u003cOwnable\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| contract.owner.set(alice));\n\n        contract\n            .sender(alice)\n            .transfer_ownership(bob)\n            .expect(\"should transfer ownership\");\n        let owner = contract.sender(alice).owner();\n        assert_eq!(owner, bob);\n    }\n\n    #[motsu::test]\n    fn prevents_non_owners_from_transferring(\n        contract: Contract\u003cOwnable\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| contract.owner.set(bob));\n\n        let err = contract.sender(alice).transfer_ownership(bob).unwrap_err();\n        assert!(matches!(err, Error::UnauthorizedAccount(_)));\n    }\n\n    #[motsu::test]\n    fn prevents_reaching_stuck_state(\n        contract: Contract\u003cOwnable\u003e,\n        alice: Address,\n    ) {\n        contract.init(alice, |contract| contract.owner.set(alice));\n\n        let err = contract\n            .sender(alice)\n            .transfer_ownership(Address::ZERO)\n            .unwrap_err();\n        assert!(matches!(err, Error::InvalidOwner(_)));\n    }\n\n    #[motsu::test]\n    fn loses_ownership_after_renouncing(\n        contract: Contract\u003cOwnable\u003e,\n        alice: Address,\n    ) {\n        contract.init(alice, |contract| contract.owner.set(alice));\n\n        contract\n            .sender(alice)\n            .renounce_ownership()\n            .expect(\"should renounce ownership\");\n        let owner = contract.sender(alice).owner();\n        assert_eq!(owner, Address::ZERO);\n    }\n\n    #[motsu::test]\n    fn prevents_non_owners_from_renouncing(\n        contract: Contract\u003cOwnable\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| contract.owner.set(bob));\n\n        let err = contract.sender(alice).renounce_ownership().unwrap_err();\n        assert!(matches!(err, Error::UnauthorizedAccount(_)));\n    }\n\n    #[motsu::test]\n    fn recovers_access_using_internal_transfer(\n        contract: Contract\u003cOwnable\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| contract.owner.set(bob));\n\n        contract.sender(alice)._transfer_ownership(bob);\n        let owner = contract.sender(alice).owner();\n        assert_eq!(owner, bob);\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cOwnable as IOwnable\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0xe083076_u32.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cOwnable\u003e, alice: Address) {\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cOwnable as IOwnable\u003e::interface_id()));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cOwnable as IErc165\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":31}},{"line":159,"address":[],"length":0,"stats":{"Line":62}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":7}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":5}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":14}},{"line":198,"address":[],"length":0,"stats":{"Line":28}},{"line":199,"address":[],"length":0,"stats":{"Line":14}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":7}},{"line":220,"address":[],"length":0,"stats":{"Line":21}},{"line":221,"address":[],"length":0,"stats":{"Line":21}},{"line":222,"address":[],"length":0,"stats":{"Line":14}},{"line":228,"address":[],"length":0,"stats":{"Line":8}},{"line":229,"address":[],"length":0,"stats":{"Line":8}},{"line":230,"address":[],"length":0,"stats":{"Line":6}}],"covered":22,"coverable":28},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","access","ownable_two_step.rs"],"content":"//! Contract module which provides an access control mechanism, where\n//! there is an account (an owner) that can be granted exclusive access to\n//! specific functions.\n//!\n//! This extension of the `Ownable` contract includes a two-step mechanism to\n//! transfer ownership, where the new owner must call\n//! [`Ownable2Step::accept_ownership`] in order to replace the old one. This can\n//! help prevent common mistakes, such as transfers of ownership to\n//! incorrect accounts, or to contracts that are unable to interact with the\n//! permission system.\n//!\n//! The initial owner is set to the address provided by the deployer. This can\n//! later be changed with [`Ownable2Step::transfer_ownership`] and\n//! [`Ownable2Step::accept_ownership`].\n//!\n//! This module uses [`Ownable`] as a member, and makes all its public functions\n//! available.\n\nuse alloc::{vec, vec::Vec};\nuse core::ops::{Deref, DerefMut};\n\nuse alloy_primitives::{Address, FixedBytes};\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{evm, msg, prelude::*, storage::StorageAddress};\n\nuse crate::{\n    access::ownable::{self, IOwnable, Ownable},\n    utils::introspection::erc165::IErc165,\n};\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when ownership transfer starts.\n        ///\n        /// * `previous_owner` - Address of the previous owner.\n        /// * `new_owner` - Address of the new owner, to which the ownership\n        ///   will be transferred.\n        event OwnershipTransferStarted(\n            address indexed previous_owner,\n            address indexed new_owner\n        );\n\n    }\n}\n\n/// State of an [`Ownable2Step`] contract.\n#[storage]\npub struct Ownable2Step {\n    /// [`Ownable`] contract.\n    // We leave the parent [`Ownable`] contract instance public, so that\n    // inheritting contract have access to its internal functions.\n    pub ownable: Ownable,\n    /// Pending owner of the contract.\n    pub(crate) pending_owner: StorageAddress,\n}\n\nimpl Deref for Ownable2Step {\n    type Target = Ownable;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.ownable\n    }\n}\n\nimpl DerefMut for Ownable2Step {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.ownable\n    }\n}\n\n/// Interface for an [`Ownable2Step`] contract.\n#[interface_id]\npub trait IOwnable2Step {\n    /// The error type associated to the trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns the address of the current owner.\n    ///\n    /// Re-export of [`Ownable::owner`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn owner(\u0026self) -\u003e Address;\n\n    /// Returns the address of the pending owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn pending_owner(\u0026self) -\u003e Address;\n\n    /// Starts the ownership transfer of the contract to a new account.\n    /// Replaces the pending transfer if there is one. Can only be called by the\n    /// current owner.\n    ///\n    /// Setting `new_owner` to [`Address::ZERO`] is allowed; this can be used\n    /// to cancel an initiated ownership transfer.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `new_owner` - The next owner of this contract.\n    ///\n    /// # Errors\n    ///\n    /// * [`ownable::Error::UnauthorizedAccount`] - If called by any account\n    ///   other than the owner.\n    ///\n    /// # Events\n    ///\n    /// * [`OwnershipTransferStarted`].\n    fn transfer_ownership(\n        \u0026mut self,\n        new_owner: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Accepts the ownership of the contract.\n    /// Can only be called by the pending owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`ownable::Error::UnauthorizedAccount`] - If called by any account\n    ///   other than the pending owner.\n    ///\n    /// # Events\n    ///\n    /// * [`crate::access::ownable::OwnershipTransferred`].\n    fn accept_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Leaves the contract without owner. It will not be possible to call\n    /// [`Ownable::only_owner`] functions. Can only be called by the current\n    /// owner.\n    ///\n    /// NOTE: Renouncing ownership will leave the contract without an owner,\n    /// thereby disabling any functionality that is only available to the owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`ownable::Error::UnauthorizedAccount`] - If not called by the owner.\n    ///\n    /// # Events\n    ///\n    /// * [`crate::access::ownable::OwnershipTransferred`].\n    fn renounce_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\n#[public]\n#[implements(IOwnable2Step\u003cError = ownable::Error\u003e, IErc165)]\nimpl Ownable2Step {\n    /// See [`Ownable::constructor`].\n    #[allow(clippy::missing_errors_doc)]\n    #[constructor]\n    pub fn constructor(\n        \u0026mut self,\n        initial_owner: Address,\n    ) -\u003e Result\u003c(), ownable::Error\u003e {\n        self.ownable.constructor(initial_owner)\n    }\n}\n\n#[public]\nimpl IOwnable2Step for Ownable2Step {\n    type Error = ownable::Error;\n\n    fn owner(\u0026self) -\u003e Address {\n        self.ownable.owner()\n    }\n\n    fn pending_owner(\u0026self) -\u003e Address {\n        self.pending_owner.get()\n    }\n\n    fn transfer_ownership(\n        \u0026mut self,\n        new_owner: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.ownable.only_owner()?;\n        self.pending_owner.set(new_owner);\n\n        let current_owner = self.owner();\n        evm::log(OwnershipTransferStarted {\n            previous_owner: current_owner,\n            new_owner,\n        });\n        Ok(())\n    }\n\n    fn accept_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        let sender = msg::sender();\n        let pending_owner = self.pending_owner();\n        if sender != pending_owner {\n            return Err(ownable::Error::UnauthorizedAccount(\n                ownable::OwnableUnauthorizedAccount { account: sender },\n            ));\n        }\n        self._transfer_ownership(sender);\n        Ok(())\n    }\n\n    fn renounce_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        self.ownable.only_owner()?;\n        self._transfer_ownership(Address::ZERO);\n        Ok(())\n    }\n}\n\nimpl Ownable2Step {\n    /// Transfers ownership of the contract to a new account (`new_owner`) and\n    /// sets [`Self::pending_owner`] to [`Address::ZERO`] to avoid situations\n    /// where the transfer has been completed or the current owner renounces,\n    /// but [`Self::pending_owner`] can still accept ownership.\n    ///\n    /// Internal function without access restriction.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `new_owner` - Account that's gonna be the next owner.\n    ///\n    /// # Events\n    ///\n    /// * [`crate::access::ownable::OwnershipTransferred`].\n    fn _transfer_ownership(\u0026mut self, new_owner: Address) {\n        self.pending_owner.set(Address::ZERO);\n        self.ownable._transfer_ownership(new_owner);\n    }\n}\n\n#[public]\nimpl IErc165 for Ownable2Step {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IOwnable2Step\u003e::interface_id() == interface_id\n            || self.ownable.supports_interface(interface_id)\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use motsu::prelude::Contract;\n    use stylus_sdk::{\n        alloy_primitives::{Address, FixedBytes},\n        prelude::*,\n    };\n\n    use super::*;\n\n    unsafe impl TopLevelStorage for Ownable2Step {}\n\n    #[motsu::test]\n    fn reads_owner(contract: Contract\u003cOwnable2Step\u003e, alice: Address) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(alice);\n        });\n        let owner = contract.sender(alice).owner();\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn reads_pending_owner(\n        contract: Contract\u003cOwnable2Step\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.pending_owner.set(bob);\n        });\n\n        let pending_owner = contract.sender(alice).pending_owner();\n        assert_eq!(pending_owner, bob);\n    }\n\n    #[motsu::test]\n    fn initiates_ownership_transfer(\n        contract: Contract\u003cOwnable2Step\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(alice);\n        });\n\n        contract\n            .sender(alice)\n            .transfer_ownership(bob)\n            .expect(\"should initiate ownership transfer\");\n\n        assert_eq!(contract.sender(alice).owner(), alice);\n    }\n\n    #[motsu::test]\n    fn prevents_non_owners_from_initiating_transfer(\n        contract: Contract\u003cOwnable2Step\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(bob);\n        });\n\n        let err = contract.sender(alice).transfer_ownership(dave).unwrap_err();\n        assert!(matches!(\n            err,\n            ownable::Error::UnauthorizedAccount(ownable::OwnableUnauthorizedAccount {\n                account\n            }) if account == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn accepts_ownership(\n        contract: Contract\u003cOwnable2Step\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(bob);\n            contract.pending_owner.set(alice);\n        });\n\n        contract\n            .sender(alice)\n            .accept_ownership()\n            .expect(\"should accept ownership\");\n        assert_eq!(contract.sender(alice).owner(), alice);\n        assert_eq!(contract.sender(alice).pending_owner(), Address::ZERO);\n    }\n\n    #[motsu::test]\n    fn prevents_non_pending_owner_from_accepting(\n        contract: Contract\u003cOwnable2Step\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(bob);\n            contract.pending_owner.set(dave);\n        });\n\n        let err = contract.sender(alice).accept_ownership().unwrap_err();\n        assert!(matches!(\n            err,\n            ownable::Error::UnauthorizedAccount(ownable::OwnableUnauthorizedAccount {\n                account\n            }) if account == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn completes_two_step_ownership_transfer(\n        contract: Contract\u003cOwnable2Step\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(alice);\n        });\n\n        contract\n            .sender(alice)\n            .transfer_ownership(bob)\n            .expect(\"should initiate ownership transfer\");\n        assert_eq!(contract.sender(alice).pending_owner(), bob);\n\n        contract\n            .sender(bob)\n            .accept_ownership()\n            .expect(\"should accept ownership\");\n\n        assert_eq!(contract.sender(alice).owner(), bob);\n        assert_eq!(contract.sender(alice).pending_owner(), Address::ZERO);\n    }\n\n    #[motsu::test]\n    fn renounces_ownership(contract: Contract\u003cOwnable2Step\u003e, alice: Address) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(alice);\n        });\n\n        contract\n            .sender(alice)\n            .renounce_ownership()\n            .expect(\"should renounce ownership\");\n        assert_eq!(contract.sender(alice).owner(), Address::ZERO);\n    }\n\n    #[motsu::test]\n    fn prevents_non_owners_from_renouncing(\n        contract: Contract\u003cOwnable2Step\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(bob);\n        });\n\n        let err = contract.sender(alice).renounce_ownership().unwrap_err();\n        assert!(matches!(\n            err,\n            ownable::Error::UnauthorizedAccount(ownable::OwnableUnauthorizedAccount {\n                account\n            }) if account == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn cancels_transfer_on_renounce(\n        contract: Contract\u003cOwnable2Step\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(alice);\n            contract.pending_owner.set(bob);\n        });\n\n        contract\n            .sender(alice)\n            .renounce_ownership()\n            .expect(\"should renounce ownership\");\n        assert_eq!(contract.sender(alice).owner(), Address::ZERO);\n        assert_eq!(contract.sender(alice).pending_owner(), Address::ZERO);\n    }\n\n    #[motsu::test]\n    fn allows_owner_to_cancel_transfer(\n        contract: Contract\u003cOwnable2Step\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(alice);\n            contract.pending_owner.set(bob);\n        });\n\n        contract\n            .sender(alice)\n            .transfer_ownership(Address::ZERO)\n            .expect(\"should cancel transfer\");\n        assert_eq!(contract.sender(alice).pending_owner(), Address::ZERO);\n        assert_eq!(contract.sender(alice).owner(), alice);\n    }\n\n    #[motsu::test]\n    fn allows_owner_to_overwrite_transfer(\n        contract: Contract\u003cOwnable2Step\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.ownable.owner.set(alice);\n        });\n\n        contract\n            .sender(alice)\n            .transfer_ownership(bob)\n            .expect(\"should initiate ownership transfer\");\n        assert_eq!(contract.sender(alice).pending_owner(), bob);\n\n        contract\n            .sender(alice)\n            .transfer_ownership(dave)\n            .expect(\"should overwrite transfer\");\n        assert_eq!(contract.sender(alice).pending_owner(), dave);\n        assert_eq!(contract.sender(alice).owner(), alice);\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cOwnable2Step as IOwnable2Step\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0x94be5999_u32.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cOwnable2Step\u003e, alice: Address) {\n        assert!(contract.sender(alice).supports_interface(\n            \u003cOwnable2Step as IOwnable2Step\u003e::interface_id()\n        ));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cOwnable as IOwnable\u003e::interface_id()));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cOwnable2Step as IErc165\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":13}},{"line":179,"address":[],"length":0,"stats":{"Line":26}},{"line":182,"address":[],"length":0,"stats":{"Line":11}},{"line":183,"address":[],"length":0,"stats":{"Line":22}},{"line":186,"address":[],"length":0,"stats":{"Line":6}},{"line":190,"address":[],"length":0,"stats":{"Line":13}},{"line":191,"address":[],"length":0,"stats":{"Line":5}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":9}},{"line":204,"address":[],"length":0,"stats":{"Line":3}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":7}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":4}},{"line":237,"address":[],"length":0,"stats":{"Line":8}},{"line":238,"address":[],"length":0,"stats":{"Line":12}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":245,"address":[],"length":0,"stats":{"Line":4}},{"line":246,"address":[],"length":0,"stats":{"Line":3}},{"line":247,"address":[],"length":0,"stats":{"Line":1}}],"covered":23,"coverable":29},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","finance","mod.rs"],"content":"//! Primitives for financial systems.\npub mod vesting_wallet;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","finance","vesting_wallet.rs"],"content":"//! A vesting wallet handles the vesting of Ether and ERC-20 tokens for a given\n//! beneficiary.\n//!\n//! A vesting wallet is an ownable contract that can receive native currency and\n//! [`crate::token::erc20::Erc20`] tokens, and release these assets to the\n//! wallet owner, also referred to as \"beneficiary\", according to a vesting\n//! schedule.\n//!\n//! Any assets transferred to this contract will follow the vesting schedule as\n//! if they were locked from the beginning. Consequently, if the vesting has\n//! already started, any amount of tokens sent to this contract will (at least\n//! partly) be immediately releasable.\n//!\n//! By setting the duration to 0, one can configure this contract to behave like\n//! an asset timelock that hold tokens for a beneficiary until a specified time.\n//!\n//! NOTE: Since the wallet is [`Ownable`], and ownership\n//! can be transferred, it is possible to sell unvested tokens. Preventing this\n//! in a smart contract is difficult, considering that: 1) a beneficiary address\n//! could be a counterfactually deployed contract, 2) there is likely to be a\n//! migration path for EOAs to become contracts in the near future.\n//!\n//! NOTE: When using this contract with any token whose balance is adjusted\n//! automatically (i.e. a rebase token), make sure to account the supply/balance\n//! adjustment in the vesting schedule to ensure the vested amount is as\n//! intended.\n\nuse alloc::{\n    string::{String, ToString},\n    vec,\n    vec::Vec,\n};\n\nuse alloy_primitives::{Address, FixedBytes, U256, U64};\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{\n    block,\n    call::{call, Call, MethodError},\n    contract, evm, function_selector,\n    prelude::*,\n    storage::{StorageMap, StorageU256, StorageU64},\n};\n\nuse crate::{\n    access::ownable::{self, IOwnable, Ownable},\n    token::erc20::{\n        interface::Erc20Interface,\n        utils::{safe_erc20, ISafeErc20, SafeErc20},\n    },\n    utils::{introspection::erc165::IErc165, math::storage::AddAssignChecked},\n};\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when `amount` of Ether has been released.\n        ///\n        /// * `amount` - Total Ether released.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event EtherReleased(uint256 amount);\n\n        /// Emitted when `amount` of ERC-20 `token` has been released.\n        ///\n        /// * `token` - Address of the token being released.\n        /// * `amount` - Number of tokens released.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event ERC20Released(address indexed token, uint256 amount);\n    }\n\n    sol! {\n        /// Indicates an error related to the underlying Ether transfer.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ReleaseEtherFailed(string reason);\n\n        /// Indicates that a low-level call failed.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error FailedCall();\n\n        /// The token address is not valid (eg. [`Address::ZERO`]).\n        ///\n        /// * `token` - Address of the token being released.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error InvalidToken(address token);\n    }\n}\n\n/// An error that occurred in the [`VestingWallet`] contract.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// The caller account is not authorized to perform an operation.\n    UnauthorizedAccount(ownable::OwnableUnauthorizedAccount),\n    /// The owner is not a valid owner account. (eg. [`Address::ZERO`]).\n    InvalidOwner(ownable::OwnableInvalidOwner),\n    /// Indicates an error related to the underlying Ether transfer.\n    ReleaseEtherFailed(ReleaseEtherFailed),\n    /// Indicates that a low-level call failed.\n    FailedCall(FailedCall),\n    /// An operation with an ERC-20 token failed.\n    SafeErc20FailedOperation(safe_erc20::SafeErc20FailedOperation),\n    /// Indicates a failed [`ISafeErc20::safe_decrease_allowance`] request.\n    SafeErc20FailedDecreaseAllowance(\n        safe_erc20::SafeErc20FailedDecreaseAllowance,\n    ),\n    /// The token address is not valid. (eg. [`Address::ZERO`]).\n    InvalidToken(InvalidToken),\n}\n\nimpl From\u003cownable::Error\u003e for Error {\n    fn from(value: ownable::Error) -\u003e Self {\n        match value {\n            ownable::Error::UnauthorizedAccount(e) =\u003e {\n                Error::UnauthorizedAccount(e)\n            }\n            ownable::Error::InvalidOwner(e) =\u003e Error::InvalidOwner(e),\n        }\n    }\n}\n\nimpl From\u003cstylus_sdk::call::Error\u003e for Error {\n    fn from(value: stylus_sdk::call::Error) -\u003e Self {\n        match value {\n            stylus_sdk::call::Error::AbiDecodingFailed(_) =\u003e {\n                Error::FailedCall(FailedCall {})\n            }\n            stylus_sdk::call::Error::Revert(reason) =\u003e {\n                Error::ReleaseEtherFailed(ReleaseEtherFailed {\n                    reason: String::from_utf8_lossy(\u0026reason).to_string(),\n                })\n            }\n        }\n    }\n}\n\nimpl From\u003csafe_erc20::Error\u003e for Error {\n    fn from(value: safe_erc20::Error) -\u003e Self {\n        match value {\n            safe_erc20::Error::SafeErc20FailedOperation(e) =\u003e {\n                Error::SafeErc20FailedOperation(e)\n            }\n            safe_erc20::Error::SafeErc20FailedDecreaseAllowance(e) =\u003e {\n                Error::SafeErc20FailedDecreaseAllowance(e)\n            }\n        }\n    }\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of a [`VestingWallet`] Contract.\n#[storage]\npub struct VestingWallet {\n    /// [`Ownable`] contract.\n    // We leave the parent [`Ownable`] contract instance public, so that\n    // inheritting contract have access to its internal functions.\n    pub ownable: Ownable,\n    /// Amount of Ether already released.\n    pub(crate) released: StorageU256,\n    /// Amount of ERC-20 tokens already released.\n    pub(crate) erc20_released: StorageMap\u003cAddress, StorageU256\u003e,\n    /// Start timestamp.\n    pub(crate) start: StorageU64,\n    /// Vesting duration.\n    pub(crate) duration: StorageU64,\n    /// [`SafeErc20`] contract.\n    safe_erc20: SafeErc20,\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for VestingWallet {}\n\n/// Required interface of a [`VestingWallet`] compliant contract.\n#[interface_id]\npub trait IVestingWallet {\n    /// The error type associated to this trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns the address of the current owner.\n    ///\n    /// Re-export of [`Ownable::owner`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn owner(\u0026self) -\u003e Address;\n\n    /// Transfers ownership of the contract to a new account (`new_owner`). Can\n    /// only be called by the current owner.\n    ///\n    /// Re-export of [`Ownable::transfer_ownership`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `new_owner` - The next owner of this contract.\n    ///\n    /// # Errors\n    ///\n    /// * [`ownable::Error::UnauthorizedAccount`] - If called by any account\n    ///   other than the owner.\n    /// * [`ownable::Error::InvalidOwner`] - If `new_owner` is the\n    ///   [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`ownable::OwnershipTransferred`].\n    fn transfer_ownership(\n        \u0026mut self,\n        new_owner: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Leaves the contract without owner. It will not be possible to call\n    /// [`Ownable::only_owner`] functions. Can only be called by the current\n    /// owner.\n    ///\n    /// Re-export of [`Ownable::renounce_ownership`].\n    ///\n    /// NOTE: Renouncing ownership will leave the contract without an owner,\n    /// thereby disabling any functionality that is only available to the owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`ownable::Error::UnauthorizedAccount`] - If not called by the owner.\n    ///\n    /// # Events\n    ///\n    /// * [`ownable::OwnershipTransferred`].\n    fn renounce_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Getter for the start timestamp.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn start(\u0026self) -\u003e U256;\n\n    /// Getter for the vesting duration.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn duration(\u0026self) -\u003e U256;\n\n    /// Getter for the end timestamp.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn end(\u0026self) -\u003e U256;\n\n    /// Amount of Ether already released.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    #[selector(name = \"released\")]\n    fn released_eth(\u0026self) -\u003e U256;\n\n    /// Amount of token already released.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token` - Address of the token being released.\n    #[selector(name = \"released\")]\n    fn released_erc20(\u0026self, token: Address) -\u003e U256;\n\n    /// Getter for the amount of releasable Ether.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    ///\n    /// # Panics\n    ///\n    /// * If total allocation exceeds [`U256::MAX`].\n    /// * If scaled, total allocation (mid calculation) exceeds [`U256::MAX`].\n    #[selector(name = \"releasable\")]\n    fn releasable_eth(\u0026self) -\u003e U256;\n\n    /// Getter for the amount of releasable `token` tokens. `token` should be\n    /// the address of an ERC-20 contract.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token` - Address of the releasable token.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidToken`] - If the `token` address is not a contract.\n    ///\n    /// # Panics\n    ///\n    /// * If total allocation exceeds [`U256::MAX`].\n    /// * If scaled, total allocation (mid calculation) exceeds [`U256::MAX`].\n    #[selector(name = \"releasable\")]\n    fn releasable_erc20(\u0026mut self, token: Address)\n        -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Release the native tokens (Ether) that have already vested.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::ReleaseEtherFailed`] - If Ether transfer fails.\n    ///\n    /// # Events\n    ///\n    /// * [`EtherReleased`].\n    ///\n    /// # Panics\n    ///\n    /// * If total allocation exceeds [`U256::MAX`].\n    /// * If scaled total allocation (mid calculation) exceeds [`U256::MAX`].\n    #[selector(name = \"release\")]\n    fn release_eth(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Release the tokens that have already vested.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token` - Address of the token being released.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidToken`] -  If the `token` address is not a contract.\n    /// * [`safe_erc20::Error::SafeErc20FailedOperation`] - If the contract\n    ///   fails to execute the call.\n    ///\n    /// # Events\n    ///\n    /// * [`ERC20Released`].\n    ///\n    /// # Panics\n    ///\n    /// * If total allocation exceeds [`U256::MAX`].\n    /// * If scaled, total allocation (mid calculation) exceeds [`U256::MAX`].\n    #[selector(name = \"release\")]\n    fn release_erc20(\u0026mut self, token: Address) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Calculates the amount of Ether that has already vested.\n    /// The Default implementation is a linear vesting curve.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `timestamp` - Point in time for which to check the vested amount.\n    ///\n    /// # Panics\n    ///\n    /// * If total allocation exceeds [`U256::MAX`].\n    /// * If scaled, total allocation (mid calculation) exceeds [`U256::MAX`].\n    #[selector(name = \"vestedAmount\")]\n    fn vested_amount_eth(\u0026self, timestamp: u64) -\u003e U256;\n\n    /// Calculates the amount of tokens that has already vested.\n    /// The Default implementation is a linear vesting curve.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token` - Address of the token being released.\n    /// * `timestamp` - Point in time for which to check the vested amount.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidToken`] - If the `token` address is not a contract.\n    ///\n    /// # Panics\n    ///\n    /// * If total allocation exceeds [`U256::MAX`].\n    /// * If scaled, total allocation (mid calculation) exceeds [`U256::MAX`].\n    #[selector(name = \"vestedAmount\")]\n    fn vested_amount_erc20(\n        \u0026mut self,\n        token: Address,\n        timestamp: u64,\n    ) -\u003e Result\u003cU256, Self::Error\u003e;\n}\n\n#[public]\n#[implements(IVestingWallet\u003cError = Error\u003e, IErc165)]\nimpl VestingWallet {\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `beneficiary` - The wallet owner.\n    /// * `start_timestamp` - The point in time when token vesting starts.\n    /// * `duration_seconds` - The vesting duration in seconds.\n    ///\n    /// # Errors\n    ///\n    /// * [`ownable::Error::InvalidOwner`] - If beneficiary is\n    ///   [`Address::ZERO`].\n    #[constructor]\n    pub fn constructor(\n        \u0026mut self,\n        beneficiary: Address,\n        start_timestamp: U64,\n        duration_seconds: U64,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self.ownable.constructor(beneficiary)?;\n        self.start.set(start_timestamp);\n        self.duration.set(duration_seconds);\n        Ok(())\n    }\n\n    /// The contract should be able to receive Eth.\n    ///\n    /// # Errors\n    ///\n    /// * If the transaction includes data (non-zero calldata).\n    /// * If the contract doesn't have enough gas to execute the function.\n    #[receive]\n    pub fn receive(\u0026mut self) -\u003e Result\u003c(), Vec\u003cu8\u003e\u003e {\n        Ok(())\n    }\n}\n\n#[public]\nimpl IVestingWallet for VestingWallet {\n    type Error = Error;\n\n    fn owner(\u0026self) -\u003e Address {\n        self.ownable.owner()\n    }\n\n    fn transfer_ownership(\n        \u0026mut self,\n        new_owner: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.ownable.transfer_ownership(new_owner)?)\n    }\n\n    fn renounce_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.ownable.renounce_ownership()?)\n    }\n\n    fn start(\u0026self) -\u003e U256 {\n        U256::from(self.start.get())\n    }\n\n    fn duration(\u0026self) -\u003e U256 {\n        U256::from(self.duration.get())\n    }\n\n    fn end(\u0026self) -\u003e U256 {\n        // SAFETY: both `start` and `duration` are stored as [`U64`], so they\n        // cannot exceed [`U256::MAX`].\n        self.start() + self.duration()\n    }\n\n    #[selector(name = \"released\")]\n    fn released_eth(\u0026self) -\u003e U256 {\n        self.released.get()\n    }\n\n    #[selector(name = \"released\")]\n    fn released_erc20(\u0026self, token: Address) -\u003e U256 {\n        self.erc20_released.get(token)\n    }\n\n    #[selector(name = \"releasable\")]\n    fn releasable_eth(\u0026self) -\u003e U256 {\n        // SAFETY: total vested amount is by definition greater than or equal to\n        // the released amount.\n        self.vested_amount_eth(block::timestamp()) - self.released_eth()\n    }\n\n    #[selector(name = \"releasable\")]\n    fn releasable_erc20(\n        \u0026mut self,\n        token: Address,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        let vested = self.vested_amount_erc20(token, block::timestamp())?;\n        // SAFETY: total vested amount is by definition greater than or equal to\n        // the released amount.\n        Ok(vested - self.released_erc20(token))\n    }\n\n    #[selector(name = \"release\")]\n    fn release_eth(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        let amount = self.releasable_eth();\n\n        self.released.add_assign_checked(\n            amount,\n            \"total released should not exceed `U256::MAX`\",\n        );\n\n        let owner = self.ownable.owner();\n\n        call(Call::new_in(self).value(amount), owner, \u0026[])?;\n\n        evm::log(EtherReleased { amount });\n\n        Ok(())\n    }\n\n    #[selector(name = \"release\")]\n    fn release_erc20(\u0026mut self, token: Address) -\u003e Result\u003c(), Self::Error\u003e {\n        let amount = self.releasable_erc20(token)?;\n        let owner = self.ownable.owner();\n\n        self.erc20_released.setter(token).add_assign_checked(\n            amount,\n            \"total released should not exceed `U256::MAX`\",\n        );\n\n        self.safe_erc20.safe_transfer(token, owner, amount)?;\n\n        evm::log(ERC20Released { token, amount });\n\n        Ok(())\n    }\n\n    #[selector(name = \"vestedAmount\")]\n    fn vested_amount_eth(\u0026self, timestamp: u64) -\u003e U256 {\n        let total_allocation = contract::balance()\n            .checked_add(self.released_eth())\n            .expect(\"total allocation should not exceed `U256::MAX`\");\n\n        self.vesting_schedule(total_allocation, U64::from(timestamp))\n    }\n\n    #[selector(name = \"vestedAmount\")]\n    fn vested_amount_erc20(\n        \u0026mut self,\n        token: Address,\n        timestamp: u64,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        let erc20 = Erc20Interface::new(token);\n        let balance = erc20\n            .balance_of(Call::new_in(self), contract::address())\n            .map_err(|_| InvalidToken { token })?;\n\n        let total_allocation = balance\n            .checked_add(self.released_erc20(token))\n            .expect(\"total allocation should not exceed `U256::MAX`\");\n\n        Ok(self.vesting_schedule(total_allocation, U64::from(timestamp)))\n    }\n}\n\nimpl VestingWallet {\n    /// Virtual implementation of the vesting formula. This returns the amount\n    /// vested, as a function of time, for an asset given its total\n    /// historical allocation.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `total_allocation` - Total vested amount.\n    /// * `timestamp` - Point in time for which to calculate the vested amount.\n    ///\n    /// # Panics\n    ///\n    /// * If scaled, total allocation (mid calculation) exceeds [`U256::MAX`].\n    fn vesting_schedule(\u0026self, total_allocation: U256, timestamp: U64) -\u003e U256 {\n        let timestamp = U256::from(timestamp);\n\n        if timestamp \u003c self.start() {\n            U256::ZERO\n        } else if timestamp \u003e= self.end() {\n            total_allocation\n        } else {\n            // SAFETY: `timestamp` is guaranteed to be greater than\n            // `self.start()` as checked by earlier bounds.\n            let elapsed = timestamp - self.start();\n\n            let scaled_allocation = total_allocation\n                .checked_mul(elapsed)\n                .expect(\"scaled allocation exceeds `U256::MAX`\");\n\n            // SAFETY: `self.duration()` is non-zero. If `self.duration()` were\n            // zero, then `end == start`, meaning that `timestamp \u003e= self.end()`\n            // and the function would have returned earlier.\n            scaled_allocation / self.duration()\n        }\n    }\n}\n\n#[public]\nimpl IErc165 for VestingWallet {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IVestingWallet\u003e::interface_id() == interface_id\n            || self.ownable.supports_interface(interface_id)\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use motsu::prelude::Contract;\n    use stylus_sdk::{\n        alloy_primitives::{uint, Address, FixedBytes, U256, U64},\n        block,\n    };\n\n    use super::*;\n    use crate::token::erc20::Erc20;\n\n    const BALANCE: u64 = 1000;\n\n    const DURATION: u64 = 4 * 365 * 86400; // 4 years\n\n    fn start() -\u003e u64 {\n        block::timestamp() + 3600 // 1 hour\n    }\n\n    impl VestingWallet {\n        fn init(\u0026mut self, start: u64, duration: u64) -\u003e (U64, U64) {\n            let start = U64::from(start);\n            let duration = U64::from(duration);\n            self.start.set(start);\n            self.duration.set(duration);\n            (start, duration)\n        }\n    }\n\n    #[motsu::test]\n    fn reads_start(contract: Contract\u003cVestingWallet\u003e, alice: Address) {\n        let (start, _) = contract.sender(alice).init(start(), DURATION);\n        assert_eq!(U256::from(start), contract.sender(alice).start());\n    }\n\n    #[motsu::test]\n    fn reads_duration(contract: Contract\u003cVestingWallet\u003e, alice: Address) {\n        let (_, duration) = contract.sender(alice).init(0, DURATION);\n        assert_eq!(U256::from(duration), contract.sender(alice).duration());\n    }\n\n    #[motsu::test]\n    fn reads_end(contract: Contract\u003cVestingWallet\u003e, alice: Address) {\n        let (start, duration) = contract.sender(alice).init(start(), DURATION);\n\n        assert_eq!(U256::from(start + duration), contract.sender(alice).end());\n    }\n\n    #[motsu::test]\n    fn reads_max_end(contract: Contract\u003cVestingWallet\u003e, alice: Address) {\n        contract.sender(alice).init(u64::MAX, u64::MAX);\n        assert_eq!(\n            U256::from(U64::MAX) + U256::from(U64::MAX),\n            contract.sender(alice).end()\n        );\n    }\n\n    #[motsu::test]\n    fn gets_vesting_schedule(\n        contract: Contract\u003cVestingWallet\u003e,\n        alice: Address,\n    ) {\n        let (start, duration) = contract.sender(alice).init(start(), DURATION);\n\n        let one = uint!(1_U256);\n        let two = uint!(2_U256);\n\n        assert_eq!(\n            U256::ZERO,\n            contract.sender(alice).vesting_schedule(two, start - U64::from(1))\n        );\n        assert_eq!(\n            one,\n            contract\n                .sender(alice)\n                .vesting_schedule(two, start + duration / U64::from(2))\n        );\n        assert_eq!(\n            two,\n            contract.sender(alice).vesting_schedule(two, start + duration)\n        );\n        assert_eq!(\n            two,\n            contract\n                .sender(alice)\n                .vesting_schedule(two, start + duration + U64::from(1))\n        );\n    }\n\n    #[motsu::test]\n    fn gets_vesting_schedule_zero_duration(\n        contract: Contract\u003cVestingWallet\u003e,\n        alice: Address,\n    ) {\n        let (start, _) = contract.sender(alice).init(start(), 0);\n\n        let two = uint!(2_U256);\n\n        assert_eq!(\n            U256::ZERO,\n            contract.sender(alice).vesting_schedule(two, start - U64::from(1))\n        );\n        assert_eq!(two, contract.sender(alice).vesting_schedule(two, start));\n        assert_eq!(\n            two,\n            contract.sender(alice).vesting_schedule(two, start + U64::from(1))\n        );\n    }\n\n    #[motsu::test]\n    fn check_vested_amount_erc20(\n        vesting_wallet: Contract\u003cVestingWallet\u003e,\n        erc20: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        vesting_wallet.sender(alice).init(start(), DURATION);\n        erc20\n            .sender(alice)\n            ._mint(vesting_wallet.address(), U256::from(BALANCE))\n            .unwrap();\n\n        let start = start();\n        for i in 0..64 {\n            let timestamp = i * DURATION / 60 + start;\n            let expected_amount = U256::from(std::cmp::min(\n                BALANCE,\n                BALANCE * (timestamp - start) / DURATION,\n            ));\n\n            let vested_amount = vesting_wallet\n                .sender(alice)\n                .vested_amount_erc20(erc20.address(), timestamp)\n                .unwrap();\n            assert_eq!(\n                expected_amount, vested_amount,\n                \"\\n---\\ni: {i}\\nstart: {start}\\ntimestamp: {timestamp}\\n---\\n\"\n            );\n        }\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cVestingWallet as IVestingWallet\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0x23a2649d_u32.into();\n        assert_ne!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cVestingWallet\u003e, alice: Address) {\n        assert!(contract.sender(alice).supports_interface(\n            \u003cVestingWallet as IVestingWallet\u003e::interface_id()\n        ));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cVestingWallet as IErc165\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":204}},{"line":464,"address":[],"length":0,"stats":{"Line":612}},{"line":467,"address":[],"length":0,"stats":{"Line":133}},{"line":468,"address":[],"length":0,"stats":{"Line":399}},{"line":471,"address":[],"length":0,"stats":{"Line":71}},{"line":474,"address":[],"length":0,"stats":{"Line":213}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":64}},{"line":484,"address":[],"length":0,"stats":{"Line":192}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":64}},{"line":555,"address":[],"length":0,"stats":{"Line":192}},{"line":556,"address":[],"length":0,"stats":{"Line":128}},{"line":557,"address":[],"length":0,"stats":{"Line":256}},{"line":558,"address":[],"length":0,"stats":{"Line":64}},{"line":582,"address":[],"length":0,"stats":{"Line":71}},{"line":583,"address":[],"length":0,"stats":{"Line":213}},{"line":585,"address":[],"length":0,"stats":{"Line":142}},{"line":586,"address":[],"length":0,"stats":{"Line":2}},{"line":587,"address":[],"length":0,"stats":{"Line":69}},{"line":588,"address":[],"length":0,"stats":{"Line":8}},{"line":592,"address":[],"length":0,"stats":{"Line":61}},{"line":608,"address":[],"length":0,"stats":{"Line":3}},{"line":609,"address":[],"length":0,"stats":{"Line":3}},{"line":610,"address":[],"length":0,"stats":{"Line":2}},{"line":611,"address":[],"length":0,"stats":{"Line":1}}],"covered":24,"coverable":71},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","lib.rs"],"content":"/*!\n# OpenZeppelin Contracts for Stylus\n\nA library for secure smart contract development written in Rust for\n[Arbitrum Stylus](https://docs.arbitrum.io/stylus/gentle-introduction).\nThis library offers common smart contract primitives and affordances that take\nadvantage of the nature of Stylus.\n\n## Usage\n\nTo start using it, add `openzeppelin-stylus` to your `Cargo.toml`, or simply run\n`cargo add openzeppelin-stylus`.\n\n```toml\n[dependencies]\nopenzeppelin-stylus = \"x.x.x\"\n```\n\nWe recommend pinning to a specific version -- expect rapid iteration.\n\nOnce defined as a dependency, use one of our pre-defined implementations by\nimporting them:\n\n```ignore\nuse openzeppelin_stylus::token::erc20::{self, Erc20, IErc20};\nuse stylus_sdk::{\n    alloy_primitives::{Address, U256},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct MyContract {\n    pub erc20: Erc20,\n}\n\n#[public]\n#[implements(IErc20\u003cError = erc20::Error\u003e)]\nimpl MyContract {}\n\n#[public]\nimpl IErc20 for MyContract {\n    type Error = erc20::Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.erc20.total_supply()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.erc20.balance_of(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.erc20.transfer(to, value)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.erc20.allowance(owner, spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.erc20.approve(spender, value)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.erc20.transfer_from(from, to, value)\n    }\n}\n```\n*/\n\n#![allow(\n    clippy::module_name_repetitions,\n    clippy::used_underscore_items,\n    deprecated\n)]\n#![cfg_attr(not(any(test, feature = \"export-abi\")), no_std, no_main)]\n#![cfg_attr(coverage_nightly, feature(coverage_attribute))]\n#![deny(rustdoc::broken_intra_doc_links)]\nextern crate alloc;\n\npub mod access;\npub mod finance;\npub mod token;\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","common","erc2981.rs"],"content":"//! Implementation of the NFT Royalty Standard, a standardized way to retrieve\n//! royalty payment information.\n//!\n//! Royalty information can be specified globally for all token ids via\n//! [`Erc2981::_set_default_royalty`], and/or individually for specific token\n//! ids via [`Erc2981::_set_token_royalty`]. The latter takes precedence over\n//! the first.\n//!\n//! Royalty is specified as a fraction of sale price.\n//! [`Erc2981::fee_denominator`] is overridable but defaults to 10000, meaning\n//! the fee is specified in basis points by default.\n//!\n//! IMPORTANT: ERC-2981 only specifies a way to signal royalty information and\n//! does not enforce its payment.\n//!\n//! See \u003chttps://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments\u003e in the ERC.\n//! Marketplaces are expected to voluntarily pay royalties together with sales,\n//! but note that this standard is not yet widely supported.\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{aliases::U96, Address, FixedBytes, U256};\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{\n    call::MethodError,\n    prelude::*,\n    storage::{StorageAddress, StorageMap},\n};\n\nuse crate::utils::{\n    introspection::erc165::IErc165,\n    structs::checkpoints::{Size, S160},\n};\n\ntype StorageU96 = \u003cS160 as Size\u003e::KeyStorage;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Indicates that the default royalty set is invalid\n        /// (eg. (`numerator` / `denominator`) \u003e= 1).\n        ///\n        /// * `numerator` - Numerator in fraction of royalty.\n        /// * `denomimator` - Denominator in fraction of royalty.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n\n        /// Indicates that the default royalty `receiver` is invalid.\n        ///\n        /// * `receiver` - Address to which royalty is sent.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n\n        /// Indicates that the royalty set for a specific `token_id` is invalid\n        /// (eg. (`numerator` / `denominator`) \u003e= 1).\n        ///\n        /// * `token_id` - Id of a token.\n        /// * `numerator` - Numerator in fraction of royalty.\n        /// * `denomimator` - Denominator in fraction of royalty.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC2981InvalidTokenRoyalty(uint256 token_id, uint256 numerator, uint256 denominator);\n\n        /// Indicates that the royalty receiver for `token_id` is invalid.\n        ///\n        /// * `token_id` - Id of a token.\n        /// * `receiver` - Address to which royalty is sent.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC2981InvalidTokenRoyaltyReceiver(uint256 token_id, address receiver);\n\n    }\n}\n\n/// An [`Erc2981`] error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates that the default royalty set is invalid\n    /// (eg. (`numerator` / `denominator`) \u003e= 1).\n    InvalidDefaultRoyalty(ERC2981InvalidDefaultRoyalty),\n\n    /// Indicates that the default royalty `receiver` is invalid.\n    InvalidDefaultRoyaltyReceiver(ERC2981InvalidDefaultRoyaltyReceiver),\n\n    /// Indicates that the royalty set for a specific `token_id` is invalid\n    /// (eg. (`numerator` / `denominator`) \u003e= 1).\n    InvalidTokenRoyalty(ERC2981InvalidTokenRoyalty),\n\n    /// Indicates that the royalty receiver for `token_id` is invalid.\n    InvalidTokenRoyaltyReceiver(ERC2981InvalidTokenRoyaltyReceiver),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// Struct for Royalty Information of tokens.\n#[storage]\n#[derive(Erase)]\npub struct RoyaltyInfo {\n    /// The receiver address for royalty.\n    receiver: StorageAddress,\n    /// Fraction of royalty for receiver.\n    royalty_fraction: StorageU96,\n}\n\n/// State of an [`Erc2981`] contract.\n#[storage]\npub struct Erc2981 {\n    /// The default royalty information for all tokens.\n    pub(crate) default_royalty_info: RoyaltyInfo,\n    /// The royalty information for a particular token.\n    pub(crate) token_royalty_info: StorageMap\u003cU256, RoyaltyInfo\u003e,\n    /// The fee denominator for royalty fraction.\n    /// Should be set in the constructor.\n    pub fee_denominator: StorageU96,\n}\n\n/// Interface for the NFT Royalty Standard.\n///\n/// A standardized way to retrieve royalty payment information for non-fungible\n/// tokens (NFTs) to enable universal support for royalty payments across all\n/// NFT marketplaces and ecosystem participants.\n#[interface_id]\npub trait IErc2981: IErc165 {\n    /// Returns how much royalty is owed and to whom, based on a sale price that\n    /// may be denominated in any unit of exchange.\n    ///\n    /// The royalty amount is denominated and should be paid in that same unit\n    /// of exchange.\n    ///\n    /// NOTE: ERC-2981 allows setting the royalty to 100% of the price.\n    /// In that case all the price would be sent to the royalty receiver and 0\n    /// tokens to the seller. Contracts dealing with royalty should consider\n    /// empty transfers.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token_id` - Id of a token.\n    /// * `sale_price` - The sale price of the token.\n    ///\n    /// # Panics\n    ///\n    /// * If `sale_price` * `royalty_fraction` overflows.\n    /// * If [`Erc2981::_fee_denominator()`] is zero.\n    fn royalty_info(\u0026self, token_id: U256, sale_price: U256)\n        -\u003e (Address, U256);\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for Erc2981 {}\n\n#[public]\n#[implements(IErc2981, IErc165)]\nimpl Erc2981 {}\n\n#[public]\nimpl IErc2981 for Erc2981 {\n    fn royalty_info(\n        \u0026self,\n        token_id: U256,\n        sale_price: U256,\n    ) -\u003e (Address, U256) {\n        let royalty_info = self.token_royalty_info.get(token_id);\n        let (royalty_receiver, royalty_fraction) =\n            if royalty_info.receiver.get().is_zero() {\n                (\n                    \u0026self.default_royalty_info.receiver,\n                    \u0026self.default_royalty_info.royalty_fraction,\n                )\n            } else {\n                (\u0026royalty_info.receiver, \u0026royalty_info.royalty_fraction)\n            };\n\n        let royalty_amount = sale_price\n            .checked_mul(U256::from(royalty_fraction.get()))\n            .expect(\n                \"multiplication overflowed in `royalty_amount` calculation.\",\n            )\n            .checked_div(U256::from(self._fee_denominator()))\n            .expect(\"division by zero in `royalty_amount` calculation.\");\n\n        (royalty_receiver.get(), royalty_amount)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc2981 {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IErc2981\u003e::interface_id() == interface_id\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\nimpl Erc2981 {\n    /// Fetches the denominator with which to interpret the fee set\n    /// in [`Self::_set_token_royalty`] and [`Self::_set_default_royalty`] as a\n    /// fraction of the sale price.\n    ///\n    /// Defaults to 10000 so fees are expressed in basis points, but\n    /// may be customized in the constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    #[must_use]\n    pub fn _fee_denominator(\u0026self) -\u003e U96 {\n        self.fee_denominator.get()\n    }\n\n    /// Sets the royalty information that all ids in this contract\n    /// will default to.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `receiver` - Address to receive the royalty.\n    /// * `fee_numerator` - Fraction of royalty to be given to receiver.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidDefaultRoyalty`] - If `fee_numerator` \u003e denominator.\n    /// * [`Error::InvalidDefaultRoyaltyReceiver`] - If `receiver` is\n    ///   [`Address::ZERO`].\n    pub fn _set_default_royalty(\n        \u0026mut self,\n        receiver: Address,\n        fee_numerator: U96,\n    ) -\u003e Result\u003c(), Error\u003e {\n        let denominator = self._fee_denominator();\n\n        if fee_numerator \u003e denominator {\n            return Err(Error::InvalidDefaultRoyalty(\n                ERC2981InvalidDefaultRoyalty {\n                    numerator: U256::from(fee_numerator),\n                    denominator: U256::from(denominator),\n                },\n            ));\n        }\n\n        if receiver.is_zero() {\n            return Err(Error::InvalidDefaultRoyaltyReceiver(\n                ERC2981InvalidDefaultRoyaltyReceiver { receiver },\n            ));\n        }\n\n        self.default_royalty_info.receiver.set(receiver);\n        self.default_royalty_info.royalty_fraction.set(fee_numerator);\n\n        Ok(())\n    }\n\n    /// Removes default royalty information.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    pub fn _delete_default_royalty(\u0026mut self) {\n        self.default_royalty_info.erase();\n    }\n\n    /// Sets the royalty information for a specific `token_id`,\n    /// overriding the global default.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token_id` - Id of a token.\n    /// * `receiver` - Address to receive the royalty.\n    /// * `fee_numerator` - Fraction of royalty to be given to receiver.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidTokenRoyalty`] - If `fee_numerator` \u003e\n    ///   [`Self::_fee_denominator()`].\n    /// * [`Error::InvalidTokenRoyaltyReceiver`] - If `receiver` is\n    ///   [`Address::ZERO`].\n    pub fn _set_token_royalty(\n        \u0026mut self,\n        token_id: U256,\n        receiver: Address,\n        fee_numerator: U96,\n    ) -\u003e Result\u003c(), Error\u003e {\n        let denominator = self._fee_denominator();\n        if fee_numerator \u003e denominator {\n            return Err(Error::InvalidTokenRoyalty(\n                ERC2981InvalidTokenRoyalty {\n                    token_id,\n                    numerator: U256::from(fee_numerator),\n                    denominator: U256::from(denominator),\n                },\n            ));\n        }\n\n        if receiver.is_zero() {\n            return Err(Error::InvalidTokenRoyaltyReceiver(\n                ERC2981InvalidTokenRoyaltyReceiver { token_id, receiver },\n            ));\n        }\n\n        let mut token_royalty_info = self.token_royalty_info.setter(token_id);\n        token_royalty_info.receiver.set(receiver);\n        token_royalty_info.royalty_fraction.set(fee_numerator);\n\n        Ok(())\n    }\n\n    /// Resets royalty information for the token id back to the\n    /// global default.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token_id` - Id of the token.\n    pub fn _reset_token_royalty(\u0026mut self, token_id: U256) {\n        self.token_royalty_info.delete(token_id);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::uint;\n    use motsu::prelude::*;\n\n    use super::*;\n    use crate::utils::introspection::erc165::IErc165;\n\n    const TOKEN_ID: U256 = uint!(1_U256);\n    const SALE_PRICE: U256 = uint!(1000_U256);\n    const DEFAULT_FEE_NUMERATOR: U96 = uint!(9000_U96);\n    const DEFAULT_FEE_DENOMINATOR: U96 = uint!(10000_U96);\n\n    // DEFAULT ROYALTY TESTS\n    #[motsu::test]\n    fn fee_denominator_is_set_in_constructor(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        let fee_denominator = uint!(6000_U96);\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(fee_denominator);\n        });\n\n        assert_eq!(contract.sender(bob)._fee_denominator(), fee_denominator);\n    }\n\n    #[motsu::test]\n    fn royalty_info_default_royalty_is_same_for_all_tokens(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should update default royalty\");\n\n        let token_id_2 = uint!(2_U256);\n\n        let (royalty_receiver, royalty_amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        let (royalty_receiver_2, royalty_amount_2) =\n            contract.sender(bob).royalty_info(token_id_2, SALE_PRICE);\n\n        assert_eq!(royalty_receiver, royalty_receiver_2);\n        assert_eq!(royalty_amount, royalty_amount_2);\n    }\n\n    #[motsu::test]\n    fn royalty_info_with_token_specific_fee_numerator(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should set default royalty\");\n\n        let (royalty_receiver, royalty_amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert_eq!(bob, royalty_receiver);\n        assert_eq!(uint!(900_U256), royalty_amount);\n\n        let new_fraction = uint!(8000_U96);\n\n        contract\n            .sender(bob)\n            ._set_token_royalty(TOKEN_ID, bob, new_fraction)\n            .expect(\"should update token royalty\");\n\n        let (royalty_receiver, royalty_amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert_eq!(bob, royalty_receiver);\n        assert_eq!(uint!(800_U256), royalty_amount);\n    }\n\n    #[motsu::test]\n    fn royalty_info_with_different_token_royaltyes_for_different_tokens(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should set default royalty\");\n\n        let token_id_2 = uint!(2_U256);\n        let new_fraction = uint!(8000_U96);\n\n        contract\n            .sender(bob)\n            ._set_token_royalty(TOKEN_ID, bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should update token royalty\");\n\n        contract\n            .sender(bob)\n            ._set_token_royalty(token_id_2, dave, new_fraction)\n            .expect(\"should update token royalty\");\n\n        let (royalty_receiver, royalty_amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert_eq!(bob, royalty_receiver);\n        assert_eq!(uint!(900_U256), royalty_amount);\n\n        let (royalty_receiver_2, royalty_amount_2) =\n            contract.sender(bob).royalty_info(token_id_2, SALE_PRICE);\n\n        assert_eq!(dave, royalty_receiver_2);\n        assert_eq!(uint!(800_U256), royalty_amount_2);\n    }\n\n    #[motsu::test]\n    fn royalty_info_with_almost_maximum_fee_numerator_value(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        let almost_max_numerator = DEFAULT_FEE_DENOMINATOR - uint!(1_U96);\n\n        contract\n            .sender(bob)\n            ._set_token_royalty(TOKEN_ID, bob, almost_max_numerator)\n            .expect(\"should set token royalty to almost maximum\");\n\n        let (receiver, amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert_eq!(bob, receiver);\n        assert_eq!(SALE_PRICE - uint!(1_U256), amount);\n    }\n\n    #[motsu::test]\n    fn royalty_info_royalty_amount_equals_sale_price_when_royalty_fraction_is_100_percent(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, DEFAULT_FEE_DENOMINATOR)\n            .expect(\"should set default royalty to 100%\");\n\n        let (receiver, amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert_eq!(bob, receiver);\n        assert_eq!(SALE_PRICE, amount);\n    }\n\n    #[motsu::test]\n    fn royalty_info_royalty_amount_is_zero_when_royalty_fraction_is_zero(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, U96::ZERO)\n            .expect(\"should set default royalty to 0%\");\n\n        let (receiver, amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert_eq!(bob, receiver);\n        assert_eq!(U256::ZERO, amount);\n    }\n\n    #[motsu::test]\n    fn royalty_info_for_non_existent_token_uses_default_royalty(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should set default royalty\");\n\n        let non_existent_token_id = uint!(999_U256);\n        let (receiver, royalty_amount) = contract\n            .sender(bob)\n            .royalty_info(non_existent_token_id, SALE_PRICE);\n\n        assert_eq!(bob, receiver);\n        assert_eq!(uint!(900_U256), royalty_amount);\n    }\n\n    #[motsu::test]\n    fn royalty_info_returns_zero_royalty_when_zero_sale_price(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should set default royalty\");\n\n        let (receiver, amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, U256::ZERO);\n\n        assert_eq!(bob, receiver);\n        assert_eq!(U256::ZERO, amount);\n    }\n\n    #[motsu::test]\n    fn royalty_info_with_no_royaltyes_set_returns_zero_address_and_amount(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        // Don't set any royaltyes\n\n        let (receiver, royalty_amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert!(receiver.is_zero());\n        assert_eq!(U256::ZERO, royalty_amount);\n    }\n\n    #[motsu::test]\n    fn set_default_royalty_reverts_if_invalid_receiver(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        let err = contract\n            .sender(bob)\n            ._set_default_royalty(Address::ZERO, DEFAULT_FEE_NUMERATOR)\n            .expect_err(\"should return `Error::InvalidDefaultRoyaltyReceiver`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidDefaultRoyaltyReceiver(\n                ERC2981InvalidDefaultRoyaltyReceiver {\n                    receiver: Address::ZERO\n                }\n            )\n        ));\n    }\n\n    #[motsu::test]\n    fn set_default_royalty_reverts_if_invalid_fee_numerator(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        let new_fee_numerator = uint!(11000_U96);\n\n        let err = contract\n            .sender(bob)\n            ._set_default_royalty(bob, new_fee_numerator)\n            .expect_err(\"should return `Error::InvalidDefaultRoyalty`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidDefaultRoyalty(ERC2981InvalidDefaultRoyalty {\n                numerator,\n                denominator\n            }) if numerator == U256::from(new_fee_numerator) \u0026\u0026\n            denominator == U256::from(DEFAULT_FEE_DENOMINATOR)\n        ));\n    }\n\n    #[motsu::test]\n    fn delete_default_royalty(contract: Contract\u003cErc2981\u003e, bob: Address) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        // delete without setting any royalties\n        contract.sender(bob)._delete_default_royalty();\n\n        let (royalty_receiver, royalty_amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert!(royalty_receiver.is_zero());\n        assert!(royalty_amount.is_zero());\n\n        // delete after setting royalties\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should set default royalty\");\n\n        contract.sender(bob)._delete_default_royalty();\n\n        let (royalty_receiver, royalty_amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert!(royalty_receiver.is_zero());\n        assert!(royalty_amount.is_zero());\n    }\n\n    #[motsu::test]\n    fn set_token_royalty_reverts_if_invalid_receiver(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        let err = contract\n            .sender(bob)\n            ._set_token_royalty(TOKEN_ID, Address::ZERO, DEFAULT_FEE_NUMERATOR)\n            .expect_err(\"should return `Error::InvalidTokenRoyaltyReceiver`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidTokenRoyaltyReceiver(ERC2981InvalidTokenRoyaltyReceiver{\n                token_id,\n                receiver\n            }) if token_id == TOKEN_ID \u0026\u0026 receiver.is_zero()));\n    }\n\n    #[motsu::test]\n    fn set_token_royalty_reverts_if_invalid_fee_numerator(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        let new_fee_numerator = uint!(11000_U96);\n\n        let err = contract\n            .sender(bob)\n            ._set_token_royalty(TOKEN_ID, bob, new_fee_numerator)\n            .expect_err(\"should return `Error::InvalidTokenRoyalty`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidTokenRoyalty(ERC2981InvalidTokenRoyalty{\n                token_id,\n                numerator,\n                denominator\n        }) if token_id == TOKEN_ID \u0026\u0026 numerator == U256::from(new_fee_numerator) \u0026\u0026\n            denominator == U256::from(DEFAULT_FEE_DENOMINATOR)));\n    }\n\n    #[motsu::test]\n    fn royalty_info_uses_default_royalty_after_resetting_token_royalty(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        let new_numerator = uint!(8000_U96);\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should set default royalty\");\n\n        contract\n            .sender(bob)\n            ._set_token_royalty(TOKEN_ID, dave, new_numerator)\n            .expect(\"should set token royalty\");\n\n        let (royalty_receiver, royalty_amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert_eq!(dave, royalty_receiver);\n        assert_eq!(uint!(800_U256), royalty_amount);\n\n        contract.sender(bob)._reset_token_royalty(TOKEN_ID);\n\n        let (royalty_receiver, royalty_amount) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        assert_eq!(bob, royalty_receiver);\n        assert_eq!(uint!(900_U256), royalty_amount);\n    }\n\n    #[motsu::test]\n    fn reset_token_royalty(contract: Contract\u003cErc2981\u003e, bob: Address) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        let mut contract = contract.sender(bob);\n\n        // Set a token royalty\n        contract\n            ._set_token_royalty(TOKEN_ID, bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should set token royalty\");\n\n        // Reset the token royalty\n        contract._reset_token_royalty(TOKEN_ID);\n\n        // With no default royalty, should return zero address and zero amount\n        let token_royalty = contract.token_royalty_info.get(TOKEN_ID);\n        assert!(token_royalty.receiver.get().is_zero());\n        assert_eq!(U96::ZERO, token_royalty.royalty_fraction.get());\n    }\n\n    #[motsu::test]\n    #[should_panic = \"division by zero in `royalty_amount` calculation.\"]\n    fn royalty_info_reverts_on_division_by_zero_in_default_royalty(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(U96::ZERO);\n        });\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, U96::ZERO)\n            .expect(\"should set default royalty\");\n\n        // should revert on division by zero.\n        _ = contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n    }\n\n    #[motsu::test]\n    #[should_panic = \"multiplication overflowed in `royalty_amount` calculation.\"]\n    fn royalty_info_reverts_on_overflow_in_default_royalty(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should set default royalty\");\n        // should overflow.\n        _ = contract.sender(bob).royalty_info(TOKEN_ID, U256::MAX);\n    }\n\n    #[motsu::test]\n    #[should_panic = \"division by zero in `royalty_amount` calculation.\"]\n    fn royalty_info_reverts_on_division_by_zero_in_token_royalty(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(U96::ZERO);\n        });\n\n        contract\n            .sender(bob)\n            ._set_token_royalty(TOKEN_ID, bob, U96::ZERO)\n            .expect(\"should set default royalty\");\n\n        // should revert on division by zero.\n        _ = contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n    }\n\n    #[motsu::test]\n    #[should_panic = \"multiplication overflowed in `royalty_amount` calculation.\"]\n    fn royalty_info_reverts_on_overflow_in_token_royalty(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        contract\n            .sender(bob)\n            ._set_token_royalty(TOKEN_ID, bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should set token royalty\");\n        // should overflow.\n        _ = contract.sender(bob).royalty_info(TOKEN_ID, U256::MAX);\n    }\n\n    #[motsu::test]\n    fn royalty_info_changes_royalty_calculation_on_fee_denominator_change(\n        contract: Contract\u003cErc2981\u003e,\n        bob: Address,\n    ) {\n        contract.init(bob, |contract| {\n            contract.fee_denominator.set(DEFAULT_FEE_DENOMINATOR);\n        });\n\n        contract\n            .sender(bob)\n            ._set_default_royalty(bob, DEFAULT_FEE_NUMERATOR)\n            .expect(\"should set default royalty\");\n\n        let (_, amount_before) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        // Change denominator to half its value (doubles the royalty percentage)\n        let new_denominator = DEFAULT_FEE_DENOMINATOR / uint!(2_U96);\n        contract.sender(bob).fee_denominator.set(new_denominator);\n\n        let (_, amount_after) =\n            contract.sender(bob).royalty_info(TOKEN_ID, SALE_PRICE);\n\n        // Expect doubled royalty due to halved denominator\n        assert_eq!(amount_before * uint!(2_U256), amount_after);\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc2981 as IErc2981\u003e::interface_id();\n        // Value taken from official EIP\n        // https://eips.ethereum.org/EIPS/eip-2981#checking-if-the-nft-being-sold-on-your-marketplace-implemented-royalties\n        let expected: FixedBytes\u003c4\u003e = 0x2a55205a_u32.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cErc2981\u003e, alice: Address) {\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc2981 as IErc2981\u003e::interface_id()));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc2981 as IErc165\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":22}},{"line":174,"address":[],"length":0,"stats":{"Line":88}},{"line":175,"address":[],"length":0,"stats":{"Line":44}},{"line":176,"address":[],"length":0,"stats":{"Line":22}},{"line":178,"address":[],"length":0,"stats":{"Line":15}},{"line":179,"address":[],"length":0,"stats":{"Line":15}},{"line":182,"address":[],"length":0,"stats":{"Line":7}},{"line":185,"address":[],"length":0,"stats":{"Line":44}},{"line":186,"address":[],"length":0,"stats":{"Line":88}},{"line":190,"address":[],"length":0,"stats":{"Line":88}},{"line":193,"address":[],"length":0,"stats":{"Line":44}},{"line":199,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":217,"address":[],"length":0,"stats":{"Line":45}},{"line":218,"address":[],"length":0,"stats":{"Line":90}},{"line":235,"address":[],"length":0,"stats":{"Line":14}},{"line":240,"address":[],"length":0,"stats":{"Line":42}},{"line":242,"address":[],"length":0,"stats":{"Line":14}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":3}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":4}},{"line":288,"address":[],"length":0,"stats":{"Line":10}},{"line":294,"address":[],"length":0,"stats":{"Line":30}},{"line":295,"address":[],"length":0,"stats":{"Line":10}},{"line":296,"address":[],"length":0,"stats":{"Line":1}},{"line":297,"address":[],"length":0,"stats":{"Line":1}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[],"length":0,"stats":{"Line":1}},{"line":307,"address":[],"length":0,"stats":{"Line":1}},{"line":325,"address":[],"length":0,"stats":{"Line":2}},{"line":326,"address":[],"length":0,"stats":{"Line":6}}],"covered":39,"coverable":41},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","common","mod.rs"],"content":"//! Contracts that are common to multiple token standards.\npub mod erc2981;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc1155","extensions","burnable.rs"],"content":"//! Optional Burnable extension of the ERC-1155 standard.\n\nuse alloc::vec::Vec;\n\nuse alloy_primitives::{Address, U256};\nuse openzeppelin_stylus_proc::interface_id;\nuse stylus_sdk::msg;\n\nuse crate::token::erc1155::{\n    self, ERC1155MissingApprovalForAll, Erc1155, IErc1155,\n};\n\n/// Extension of [`Erc1155`] that allows token holders to destroy both their\n/// own tokens and those that they have been approved to use.\n#[interface_id]\npub trait IErc1155Burnable {\n    /// The error type associated to this trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Destroys a `value` amount of token from `account`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `account` - Account to burn tokens from.\n    /// * `token_id` - Token id to be burnt.\n    /// * `value` - Amount to be burnt.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc1155::Error::MissingApprovalForAll`] - If the caller is not\n    ///   `account` address and the `account` has not been approved.\n    /// * [`erc1155::Error::InvalidSender`] - If `from` is the\n    ///   [`Address::ZERO`].\n    /// * [`erc1155::Error::InsufficientBalance`] - If `value` is greater than\n    ///   the balance of the `from` account.\n    fn burn(\n        \u0026mut self,\n        account: Address,\n        token_id: U256,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Destroys a batch of tokens from `account`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `account` - Accounts to burn tokens from.\n    /// * `token_ids` - All token id to be burnt.\n    /// * `values` - All amount to be burnt.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc1155::Error::MissingApprovalForAll`] - If the caller is not\n    ///   `account` address and the `account` has not been approved.\n    /// * [`erc1155::Error::InvalidSender`] - If `from` is the\n    ///   [`Address::ZERO`].\n    /// * [`erc1155::Error::InvalidArrayLength`] - If length of `ids` is not\n    ///   equal to length of `values`.\n    /// * [`erc1155::Error::InsufficientBalance`] - If any of the `values` is\n    ///   greater than the balance of the respective token from `tokens` of the\n    ///   `from` account.\n    fn burn_batch(\n        \u0026mut self,\n        account: Address,\n        token_ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\nimpl IErc1155Burnable for Erc1155 {\n    type Error = erc1155::Error;\n\n    fn burn(\n        \u0026mut self,\n        account: Address,\n        token_id: U256,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.ensure_approved_or_owner(account)?;\n        self._burn(account, token_id, value)\n    }\n\n    fn burn_batch(\n        \u0026mut self,\n        account: Address,\n        token_ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.ensure_approved_or_owner(account)?;\n        self._burn_batch(account, token_ids, values)\n    }\n}\n\nimpl Erc1155 {\n    fn ensure_approved_or_owner(\n        \u0026self,\n        account: Address,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        let sender = msg::sender();\n        if account != sender \u0026\u0026 !self.is_approved_for_all(account, sender) {\n            return Err(erc1155::Error::MissingApprovalForAll(\n                ERC1155MissingApprovalForAll {\n                    owner: account,\n                    operator: sender,\n                },\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use alloy_primitives::{Address, U256};\n    use motsu::prelude::Contract;\n\n    use super::IErc1155Burnable;\n    use crate::token::erc1155::{\n        tests::{random_token_ids, random_values},\n        ERC1155InsufficientBalance, ERC1155InvalidSender,\n        ERC1155MissingApprovalForAll, Erc1155, Error, IErc1155,\n    };\n\n    fn init(\n        contract: \u0026mut Erc1155,\n        receiver: Address,\n        size: usize,\n    ) -\u003e (Vec\u003cU256\u003e, Vec\u003cU256\u003e) {\n        let token_ids = random_token_ids(size);\n        let values = random_values(size);\n\n        contract\n            ._mint_batch(\n                receiver,\n                token_ids.clone(),\n                values.clone(),\n                \u0026vec![0, 1, 2, 3].into(),\n            )\n            .expect(\"Mint failed\");\n        (token_ids, values)\n    }\n\n    #[motsu::test]\n    fn burns(contract: Contract\u003cErc1155\u003e, alice: Address) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n\n        let initial_balance =\n            contract.sender(alice).balance_of(alice, token_ids[0]);\n        assert_eq!(values[0], initial_balance);\n\n        contract\n            .sender(alice)\n            .burn(alice, token_ids[0], values[0])\n            .expect(\"should burn own tokens\");\n\n        let balance = contract.sender(alice).balance_of(alice, token_ids[0]);\n        assert_eq!(U256::ZERO, balance);\n    }\n\n    #[motsu::test]\n    fn burns_with_approval(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 1));\n\n        let initial_balance =\n            contract.sender(alice).balance_of(bob, token_ids[0]);\n        assert_eq!(values[0], initial_balance);\n\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Bob's tokens to Alice\");\n\n        contract\n            .sender(alice)\n            .burn(bob, token_ids[0], values[0])\n            .expect(\"should burn Bob's token\");\n\n        let balance = contract.sender(alice).balance_of(bob, token_ids[0]);\n        assert_eq!(U256::ZERO, balance);\n    }\n\n    #[motsu::test]\n    fn error_when_missing_approval_burns(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 1));\n\n        let err = contract\n            .sender(alice)\n            .burn(bob, token_ids[0], values[0])\n            .expect_err(\"should not burn tokens without approval\");\n\n        assert!(matches!(\n            err,\n            Error::MissingApprovalForAll(ERC1155MissingApprovalForAll {\n                owner,\n                operator\n            }) if owner == bob \u0026\u0026 operator == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_sender_burns(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n        let invalid_sender = Address::ZERO;\n\n        contract\n            .sender(invalid_sender)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Bob's tokens to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .burn(invalid_sender, token_ids[0], values[0])\n            .expect_err(\"should not burn tokens from the `Address::ZERO`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC1155InvalidSender {\n                sender,\n            }) if sender == invalid_sender\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_insufficient_balance_burn(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n\n        let token_id = token_ids[0];\n        let value = values[0];\n        let to_burn = value + U256::from(1);\n\n        let err = contract\n            .sender(alice)\n            .burn(alice, token_id, to_burn)\n            .expect_err(\"should return `ERC1155InsufficientBalance`\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientBalance(ERC1155InsufficientBalance {\n                sender,\n                balance,\n                needed,\n                token_id,\n            }) if sender == alice \u0026\u0026 balance == value \u0026\u0026 needed == to_burn \u0026\u0026 token_id == token_id\n        ));\n    }\n\n    #[motsu::test]\n    fn burns_batch(contract: Contract\u003cErc1155\u003e, alice: Address) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 4));\n\n        for (\u0026token_id, \u0026value) in token_ids.iter().zip(values.iter()) {\n            let balance = contract.sender(alice).balance_of(alice, token_id);\n            assert_eq!(value, balance);\n        }\n\n        contract\n            .sender(alice)\n            .burn_batch(alice, token_ids.clone(), values.clone())\n            .expect(\"should burn own tokens in batch\");\n\n        for token_id in token_ids {\n            let balance = contract.sender(alice).balance_of(alice, token_id);\n            assert_eq!(U256::ZERO, balance);\n        }\n    }\n\n    #[motsu::test]\n    fn burns_batch_with_approval(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 4));\n\n        for (\u0026token_id, \u0026value) in token_ids.iter().zip(values.iter()) {\n            let balance = contract.sender(alice).balance_of(bob, token_id);\n            assert_eq!(value, balance);\n        }\n\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Bob's tokens to Alice\");\n\n        contract\n            .sender(alice)\n            .burn_batch(bob, token_ids.clone(), values.clone())\n            .expect(\"should burn Bob's tokens in batch\");\n\n        for token_id in token_ids {\n            let balance = contract.sender(alice).balance_of(bob, token_id);\n            assert_eq!(U256::ZERO, balance);\n        }\n    }\n\n    #[motsu::test]\n    fn error_when_missing_approval_burn_batch(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 2));\n\n        let err = contract\n            .sender(alice)\n            .burn_batch(bob, token_ids.clone(), values.clone())\n            .expect_err(\"should not burn tokens in batch without approval\");\n\n        assert!(matches!(\n            err,\n            Error::MissingApprovalForAll(ERC1155MissingApprovalForAll {\n                owner,\n                operator\n            }) if owner == bob \u0026\u0026 operator == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_sender_burn_batch(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 5));\n        let invalid_sender = Address::ZERO;\n\n        contract\n            .sender(invalid_sender)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Bob's tokens to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .burn_batch(invalid_sender, token_ids.clone(), values.clone())\n            .expect_err(\n                \"should not burn tokens in batch from the `Address::ZERO`\",\n            );\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC1155InvalidSender {\n                sender,\n            }) if sender == invalid_sender\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_insufficient_balance_burn_batch(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 5));\n        let to_burn: Vec\u003cU256\u003e =\n            values.iter().map(|v| v + U256::from(1)).collect();\n\n        let err = contract\n            .sender(alice)\n            .burn_batch(alice, token_ids.clone(), to_burn.clone())\n            .expect_err(\"should return `ERC1155InsufficientBalance`\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientBalance(ERC1155InsufficientBalance {\n                sender,\n                balance,\n                needed,\n                token_id,\n            }) if sender == alice \u0026\u0026 balance == values[0] \u0026\u0026 needed == to_burn[0] \u0026\u0026 token_id == token_ids[0]\n        ));\n    }\n}\n","traces":[{"line":75,"address":[],"length":0,"stats":{"Line":5}},{"line":81,"address":[],"length":0,"stats":{"Line":16}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":5}},{"line":91,"address":[],"length":0,"stats":{"Line":16}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":10}},{"line":101,"address":[],"length":0,"stats":{"Line":20}},{"line":102,"address":[],"length":0,"stats":{"Line":28}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}}],"covered":13,"coverable":13},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc1155","extensions","metadata_uri.rs"],"content":"//! Optional URI Metadata of the ERC-1155 standard, as defined\n//! in the [ERC].\n//!\n//! [ERC]: https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions\n\nuse alloc::{string::String, vec, vec::Vec};\n\nuse alloy_primitives::{FixedBytes, U256};\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{prelude::*, storage::StorageString};\n\nuse crate::utils::introspection::erc165::IErc165;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when the URI for token type `id` changes to `value`, if it is\n        /// a non-programmatic URI.\n        ///\n        /// If a [`URI`] event was emitted for `id`, the standard [guarantees] that\n        /// `value` will equal the value returned by [`IErc1155MetadataUri::uri`].\n        ///\n        /// [guarantees]: https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event URI(string value, uint256 indexed id);\n    }\n}\n\n/// State of an [`Erc1155MetadataUri`] contract.\n#[storage]\npub struct Erc1155MetadataUri {\n    /// Used as the URI for all token types by relying on ID substitution,\n    /// e.g. https://token-cdn-domain/{id}.json.\n    pub(crate) uri: StorageString,\n}\n\n/// Interface for the optional metadata functions from the ERC-1155 standard.\n#[interface_id]\npub trait IErc1155MetadataUri {\n    /// Returns the URI for token type `id`.\n    ///\n    /// If the `id` substring is present in the URI, it must be replaced by\n    /// clients with the actual token type ID.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `id` - Token id.\n    fn uri(\u0026self, id: U256) -\u003e String;\n}\n\n#[public]\nimpl IErc1155MetadataUri for Erc1155MetadataUri {\n    /// This implementation returns the same URI for all token types.\n    /// Clients calling this function must replace the `id` substring with\n    /// the actual token type ID.\n    fn uri(\u0026self, _id: U256) -\u003e String {\n        self.uri.get_string()\n    }\n}\n\n#[public]\n#[implements(IErc1155MetadataUri, IErc165)]\nimpl Erc1155MetadataUri {\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `uri` - The token URI.\n    #[constructor]\n    pub fn constructor(\u0026mut self, uri: String) {\n        self.uri.set_str(uri);\n    }\n}\n\n#[public]\nimpl IErc165 for Erc1155MetadataUri {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IErc1155MetadataUri\u003e::interface_id() == interface_id\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use motsu::prelude::Contract;\n    use stylus_sdk::{\n        alloy_primitives::{uint, Address, FixedBytes},\n        prelude::*,\n    };\n\n    use super::{Erc1155MetadataUri, IErc1155MetadataUri, IErc165};\n\n    unsafe impl TopLevelStorage for Erc1155MetadataUri {}\n\n    #[motsu::test]\n    fn uri_ignores_token_id(\n        contract: Contract\u003cErc1155MetadataUri\u003e,\n        alice: Address,\n    ) {\n        let uri = String::from(\"https://token-cdn-domain/\\\\{id\\\\}.json\");\n        contract.init(alice, |contract| {\n            contract.uri.set_str(uri.clone());\n        });\n\n        let token_id = uint!(1_U256);\n        assert_eq!(uri, contract.sender(alice).uri(token_id));\n\n        let token_id = uint!(2_U256);\n        assert_eq!(uri, contract.sender(alice).uri(token_id));\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual =\n            \u003cErc1155MetadataUri as IErc1155MetadataUri\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0x0e89341c_u32.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(\n        contract: Contract\u003cErc1155MetadataUri\u003e,\n        alice: Address,\n    ) {\n        assert!(contract.sender(alice).supports_interface(\n            \u003cErc1155MetadataUri as IErc1155MetadataUri\u003e::interface_id()\n        ));\n        assert!(contract.sender(alice).supports_interface(\n            \u003cErc1155MetadataUri as IErc165\u003e::interface_id()\n        ));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":8}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":85,"address":[],"length":0,"stats":{"Line":2}}],"covered":5,"coverable":7},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc1155","extensions","mod.rs"],"content":"//! Common extensions to the ERC-1155 standard.\npub mod burnable;\npub mod metadata_uri;\npub mod supply;\npub mod uri_storage;\n\npub use burnable::IErc1155Burnable;\npub use metadata_uri::{Erc1155MetadataUri, IErc1155MetadataUri};\npub use supply::{Erc1155Supply, IErc1155Supply};\npub use uri_storage::{Erc1155UriStorage, IErc1155UriStorage};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc1155","extensions","supply.rs"],"content":"//! Extension of ERC-1155 that adds tracking of total supply per token id.\n//!\n//! Useful for scenarios where Fungible and Non-fungible tokens have to be\n//! clearly identified. Note: While a `total_supply` of 1 might mean the\n//! corresponding is an NFT, there are no guarantees that no other tokens\n//! with the same id are not going to be minted.\n//!\n//! NOTE: This contract implies a global limit of 2**256 - 1 to the number\n//! of tokens that can be minted.\n//!\n//! CAUTION: This extension should not be added in an upgrade to an already\n//! deployed contract.\n\nuse alloc::{vec, vec::Vec};\nuse core::ops::{Deref, DerefMut};\n\nuse alloy_primitives::{Address, FixedBytes, U256};\nuse openzeppelin_stylus_proc::interface_id;\nuse stylus_sdk::{\n    abi::Bytes,\n    msg,\n    prelude::*,\n    storage::{StorageMap, StorageU256},\n};\n\nuse crate::{\n    token::erc1155::{self, Erc1155, Error, IErc1155},\n    utils::{\n        introspection::erc165::IErc165,\n        math::storage::{AddAssignChecked, SubAssignUnchecked},\n    },\n};\n\n/// State of an [`Erc1155Supply`] contract.\n#[storage]\npub struct Erc1155Supply {\n    /// [`Erc1155`] contract.\n    pub erc1155: Erc1155,\n    /// Mapping from token id to total supply.\n    pub(crate) total_supply: StorageMap\u003cU256, StorageU256\u003e,\n    /// Total supply of all token ids.\n    pub(crate) total_supply_all: StorageU256,\n}\n\nimpl Deref for Erc1155Supply {\n    type Target = Erc1155;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.erc1155\n    }\n}\n\nimpl DerefMut for Erc1155Supply {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.erc1155\n    }\n}\n\n/// Required interface of a [`Erc1155Supply`] contract.\n#[interface_id]\npub trait IErc1155Supply: IErc165 {\n    /// Total value of tokens in with a given id.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `id` - Token id as a number.\n    fn total_supply(\u0026self, id: U256) -\u003e U256;\n\n    /// Total value of tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    #[selector(name = \"totalSupply\")]\n    fn total_supply_all(\u0026self) -\u003e U256;\n\n    /// Indicates whether any token exist with a given id, or not.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `id` - Token id as a number.\n    fn exists(\u0026self, id: U256) -\u003e bool;\n}\n\n#[public]\n#[implements(IErc1155\u003cError = Error\u003e, IErc1155Supply, IErc165)]\nimpl Erc1155Supply {}\n\n#[public]\nimpl IErc1155Supply for Erc1155Supply {\n    fn total_supply(\u0026self, id: U256) -\u003e U256 {\n        self.total_supply.get(id)\n    }\n\n    fn total_supply_all(\u0026self) -\u003e U256 {\n        self.total_supply_all.get()\n    }\n\n    fn exists(\u0026self, id: U256) -\u003e bool {\n        self.total_supply(id) \u003e U256::ZERO\n    }\n}\n\n#[public]\nimpl IErc1155 for Erc1155Supply {\n    type Error = erc1155::Error;\n\n    fn balance_of(\u0026self, account: Address, id: U256) -\u003e U256 {\n        self.erc1155.balance_of(account, id)\n    }\n\n    fn balance_of_batch(\n        \u0026self,\n        accounts: Vec\u003cAddress\u003e,\n        ids: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003cVec\u003cU256\u003e, Self::Error\u003e {\n        self.erc1155.balance_of_batch(accounts, ids)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.set_approval_for_all(operator, approved)\n    }\n\n    fn is_approved_for_all(\u0026self, account: Address, operator: Address) -\u003e bool {\n        self.erc1155.is_approved_for_all(account, operator)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        id: U256,\n        value: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.authorize_transfer(from)?;\n        self.do_safe_transfer_from(from, to, vec![id], vec![value], \u0026data)\n    }\n\n    fn safe_batch_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.authorize_transfer(from)?;\n        self.do_safe_transfer_from(from, to, ids, values, \u0026data)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc1155Supply {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IErc1155Supply\u003e::interface_id() == interface_id\n            || self.erc1155.supports_interface(interface_id)\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\nimpl Erc1155Supply {\n    /// Creates a `value` amount of tokens of type `id`, and assigns\n    /// them to `to`.\n    ///\n    /// Re-export of [`Erc1155::_mint`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn _mint(\n        \u0026mut self,\n        to: Address,\n        id: U256,\n        value: U256,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        self._do_mint(to, vec![id], vec![value], data)\n    }\n\n    /// Batched version of [`Self::_mint`].\n    ///\n    /// Re-export of [`Erc1155::_mint_batch`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn _mint_batch(\n        \u0026mut self,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        self._do_mint(to, ids, values, data)\n    }\n\n    /// Destroys a `value` amount of tokens of type `id` from `from`.\n    ///\n    /// Re-export of [`Erc1155::_burn`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn _burn(\n        \u0026mut self,\n        from: Address,\n        id: U256,\n        value: U256,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        self._do_burn(from, vec![id], vec![value])\n    }\n\n    /// Batched version of [`Self::_burn`].\n    ///\n    /// Re-export of [`Erc1155::_burn_batch`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn _burn_batch(\n        \u0026mut self,\n        from: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        self._do_burn(from, ids, values)\n    }\n}\n\nimpl Erc1155Supply {\n    /// Extended version of [`Erc1155::_update`] that updates the supply of\n    /// tokens.\n    ///\n    /// NOTE: The ERC-1155 acceptance check is not performed in this function.\n    /// See [`Self::_update_with_acceptance_check`] instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account of the sender.\n    /// * `to` - Account of the recipient.\n    /// * `token_ids` - Array of all token id.\n    /// * `values` - Array of all amount of tokens to be supplied.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc1155::Error::InvalidArrayLength`] - If length of `ids` is not\n    ///   equal to length of `values`.\n    /// * [`erc1155::Error::InsufficientBalance`] - If `value` is greater than\n    ///   the balance of the `from` account.\n    ///\n    /// # Events\n    ///\n    /// * [`erc1155::TransferSingle`] - If the arrays contain one element.\n    /// * [`erc1155::TransferBatch`] - If the arrays contain more than one\n    ///   element.\n    ///\n    /// # Panics\n    ///\n    /// * If updated balance and/or supply exceeds [`U256::MAX`], may happen\n    ///   during the `mint` operation.\n    fn _update(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        self.erc1155._update(from, to, token_ids.clone(), values.clone())?;\n\n        if from.is_zero() {\n            for (\u0026token_id, \u0026value) in token_ids.iter().zip(values.iter()) {\n                self.total_supply.setter(token_id).add_assign_checked(\n                    value,\n                    \"should not exceed `U256::MAX` for `total_supply`\",\n                );\n            }\n\n            let total_mint_value = values.iter().sum();\n            self.total_supply_all.add_assign_checked(\n                total_mint_value,\n                \"should not exceed `U256::MAX` for `total_supply_all`\",\n            );\n        }\n\n        if to.is_zero() {\n            for (token_id, \u0026value) in token_ids.into_iter().zip(values.iter()) {\n                /*\n                 * SAFETY: Overflow not possible:\n                 * values[i] \u003c= balance_of(from, token_ids[i]) \u003c=\n                 * total_supply(token_ids[i])\n                 */\n                self.total_supply.setter(token_id).sub_assign_unchecked(value);\n            }\n\n            let total_burn_value: U256 = values.into_iter().sum();\n            /*\n             * SAFETY: Overflow not possible:\n             * total_burn_value = sum_i(values[i]) \u003c=\n             * sum_i(total_supply(ids[i])) \u003c= total_supply_all\n             */\n            self.total_supply_all.sub_assign_unchecked(total_burn_value);\n        }\n        Ok(())\n    }\n\n    fn _update_with_acceptance_check(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        self._update(from, to, ids.clone(), values.clone())?;\n\n        if !to.is_zero() {\n            self.erc1155._check_on_erc1155_received(\n                msg::sender(),\n                from,\n                to,\n                erc1155::Erc1155ReceiverData::new(ids, values),\n                data.to_vec().into(),\n            )?;\n        }\n\n        Ok(())\n    }\n\n    fn _do_mint(\n        \u0026mut self,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        if to.is_zero() {\n            return Err(erc1155::Error::InvalidReceiver(\n                erc1155::ERC1155InvalidReceiver { receiver: to },\n            ));\n        }\n        self._update_with_acceptance_check(\n            Address::ZERO,\n            to,\n            ids,\n            values,\n            data,\n        )?;\n        Ok(())\n    }\n\n    fn _do_burn(\n        \u0026mut self,\n        from: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        if from.is_zero() {\n            return Err(erc1155::Error::InvalidSender(\n                erc1155::ERC1155InvalidSender { sender: from },\n            ));\n        }\n        self._update_with_acceptance_check(\n            from,\n            Address::ZERO,\n            ids,\n            values,\n            \u0026vec![].into(),\n        )?;\n        Ok(())\n    }\n\n    fn do_safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        if to.is_zero() {\n            return Err(erc1155::Error::InvalidReceiver(\n                erc1155::ERC1155InvalidReceiver { receiver: to },\n            ));\n        }\n        if from.is_zero() {\n            return Err(erc1155::Error::InvalidSender(\n                erc1155::ERC1155InvalidSender { sender: from },\n            ));\n        }\n        self._update_with_acceptance_check(from, to, ids, values, data)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use motsu::prelude::Contract;\n    use stylus_sdk::{\n        alloy_primitives::{fixed_bytes, Address, U256},\n        prelude::*,\n    };\n\n    use super::*;\n    use crate::token::erc1155::{\n        tests::{random_token_ids, random_values},\n        ERC1155InvalidReceiver, ERC1155InvalidSender,\n    };\n\n    unsafe impl TopLevelStorage for Erc1155Supply {}\n\n    fn init(\n        contract: \u0026mut Erc1155Supply,\n        receiver: Address,\n        size: usize,\n    ) -\u003e (Vec\u003cU256\u003e, Vec\u003cU256\u003e) {\n        let token_ids = random_token_ids(size);\n        let values = random_values(size);\n\n        contract\n            ._mint_batch(\n                receiver,\n                token_ids.clone(),\n                values.clone(),\n                \u0026vec![].into(),\n            )\n            .expect(\"should mint\");\n        (token_ids, values)\n    }\n\n    #[motsu::test]\n    fn before_mint(contract: Contract\u003cErc1155Supply\u003e, alice: Address) {\n        let token_id = random_token_ids(1)[0];\n        assert_eq!(U256::ZERO, contract.sender(alice).total_supply(token_id));\n        assert_eq!(U256::ZERO, contract.sender(alice).total_supply_all());\n        assert!(!contract.sender(alice).exists(token_id));\n    }\n\n    #[motsu::test]\n    fn after_mint_single(\n        contract: Contract\u003cErc1155Supply\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 1));\n        assert_eq!(\n            values[0],\n            contract.sender(alice).balance_of(bob, token_ids[0])\n        );\n        assert_eq!(\n            values[0],\n            contract.sender(alice).total_supply(token_ids[0])\n        );\n        assert_eq!(values[0], contract.sender(alice).total_supply_all());\n        assert!(contract.sender(alice).exists(token_ids[0]));\n    }\n\n    #[motsu::test]\n    fn after_mint_batch(\n        contract: Contract\u003cErc1155Supply\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 4));\n        for (\u0026token_id, \u0026value) in token_ids.iter().zip(values.iter()) {\n            assert_eq!(value, contract.sender(alice).balance_of(bob, token_id));\n            assert_eq!(value, contract.sender(alice).total_supply(token_id));\n            assert!(contract.sender(alice).exists(token_id));\n        }\n        let total_supply_all: U256 = values.iter().sum();\n        assert_eq!(total_supply_all, contract.sender(alice).total_supply_all());\n    }\n\n    #[motsu::test]\n    fn mint_reverts_on_invalid_receiver(\n        contract: Contract\u003cErc1155Supply\u003e,\n        alice: Address,\n    ) {\n        let token_id = random_token_ids(1)[0];\n        let two = U256::from(2);\n        let invalid_receiver = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            ._mint(invalid_receiver, token_id, two, \u0026vec![].into())\n            .expect_err(\"should revert with `InvalidReceiver`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC1155InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    #[should_panic = \"should not exceed `U256::MAX` for `total_supply`\"]\n    fn mint_panics_on_total_supply_overflow(\n        contract: Contract\u003cErc1155Supply\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        let token_id = random_token_ids(1)[0];\n        let two = U256::from(2);\n        let three = U256::from(3);\n        contract\n            .sender(alice)\n            ._mint(bob, token_id, U256::MAX / two, \u0026vec![].into())\n            .expect(\"should mint to bob\");\n        contract\n            .sender(alice)\n            ._mint(dave, token_id, U256::MAX / two, \u0026vec![].into())\n            .expect(\"should mint to dave\");\n        // This should panic.\n        _ = contract.sender(alice)._mint(bob, token_id, three, \u0026vec![].into());\n    }\n\n    #[motsu::test]\n    #[should_panic = \"should not exceed `U256::MAX` for `total_supply_all`\"]\n    fn mint_panics_on_total_supply_all_overflow(\n        contract: Contract\u003cErc1155Supply\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let token_ids = random_token_ids(2);\n        contract\n            .sender(alice)\n            ._mint(bob, token_ids[0], U256::MAX, \u0026vec![].into())\n            .expect(\"should mint\");\n        // This should panic.\n        _ = contract.sender(alice)._mint(\n            bob,\n            token_ids[1],\n            U256::from(1),\n            \u0026vec![].into(),\n        );\n    }\n\n    #[motsu::test]\n    fn after_burn_single(\n        contract: Contract\u003cErc1155Supply\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 1));\n        contract\n            .sender(alice)\n            ._burn(bob, token_ids[0], values[0])\n            .expect(\"should burn\");\n\n        assert_eq!(\n            U256::ZERO,\n            contract.sender(alice).total_supply(token_ids[0])\n        );\n        assert_eq!(U256::ZERO, contract.sender(alice).total_supply_all());\n        assert!(!contract.sender(alice).exists(token_ids[0]));\n    }\n\n    #[motsu::test]\n    fn after_burn_batch(\n        contract: Contract\u003cErc1155Supply\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 4));\n        contract\n            .sender(alice)\n            ._burn_batch(bob, token_ids.clone(), values.clone())\n            .expect(\"should burn batch\");\n\n        for \u0026token_id in \u0026token_ids {\n            assert_eq!(\n                U256::ZERO,\n                contract.sender(alice).balance_of(bob, token_id)\n            );\n            assert!(!contract.sender(alice).exists(token_id));\n            assert_eq!(\n                U256::ZERO,\n                contract.sender(alice).total_supply(token_id)\n            );\n        }\n        assert_eq!(U256::ZERO, contract.sender(alice).total_supply_all());\n    }\n\n    #[motsu::test]\n    fn burn_reverts_when_invalid_sender(\n        contract: Contract\u003cErc1155Supply\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 1));\n        let invalid_sender = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            ._burn(invalid_sender, token_ids[0], values[0])\n            .expect_err(\"should not burn token for invalid sender\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC1155InvalidSender {\n                sender\n            }) if sender == invalid_sender\n        ));\n    }\n\n    #[motsu::test]\n    fn supply_unaffected_by_no_op(\n        contract: Contract\u003cErc1155Supply\u003e,\n        alice: Address,\n    ) {\n        let token_ids = random_token_ids(1);\n        let values = random_values(1);\n\n        contract\n            .sender(alice)\n            ._update(Address::ZERO, Address::ZERO, token_ids.clone(), values)\n            .expect(\"should supply\");\n        assert_eq!(\n            U256::ZERO,\n            contract.sender(alice).total_supply(token_ids[0])\n        );\n        assert_eq!(U256::ZERO, contract.sender(alice).total_supply_all());\n        assert!(!contract.sender(alice).exists(token_ids[0]));\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc1155Supply as IErc1155Supply\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = fixed_bytes!(\"0xeac6339d\");\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cErc1155Supply\u003e, alice: Address) {\n        assert!(contract.sender(alice).supports_interface(\n            \u003cErc1155Supply as IErc1155Supply\u003e::interface_id()\n        ));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc1155Supply as IErc165\u003e::interface_id()));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc1155Supply as IErc1155\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":24}},{"line":94,"address":[],"length":0,"stats":{"Line":72}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":101,"address":[],"length":0,"stats":{"Line":12}},{"line":102,"address":[],"length":0,"stats":{"Line":24}},{"line":110,"address":[],"length":0,"stats":{"Line":9}},{"line":111,"address":[],"length":0,"stats":{"Line":36}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":48}},{"line":188,"address":[],"length":0,"stats":{"Line":5}},{"line":195,"address":[],"length":0,"stats":{"Line":30}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":208,"address":[],"length":0,"stats":{"Line":14}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":5}},{"line":257,"address":[],"length":0,"stats":{"Line":13}},{"line":264,"address":[],"length":0,"stats":{"Line":104}},{"line":266,"address":[],"length":0,"stats":{"Line":13}},{"line":267,"address":[],"length":0,"stats":{"Line":49}},{"line":274,"address":[],"length":0,"stats":{"Line":33}},{"line":275,"address":[],"length":0,"stats":{"Line":22}},{"line":276,"address":[],"length":0,"stats":{"Line":11}},{"line":282,"address":[],"length":0,"stats":{"Line":18}},{"line":291,"address":[],"length":0,"stats":{"Line":15}},{"line":297,"address":[],"length":0,"stats":{"Line":9}},{"line":302,"address":[],"length":0,"stats":{"Line":12}},{"line":310,"address":[],"length":0,"stats":{"Line":96}},{"line":312,"address":[],"length":0,"stats":{"Line":12}},{"line":313,"address":[],"length":0,"stats":{"Line":10}},{"line":322,"address":[],"length":0,"stats":{"Line":12}},{"line":325,"address":[],"length":0,"stats":{"Line":11}},{"line":332,"address":[],"length":0,"stats":{"Line":11}},{"line":333,"address":[],"length":0,"stats":{"Line":1}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":344,"address":[],"length":0,"stats":{"Line":10}},{"line":347,"address":[],"length":0,"stats":{"Line":3}},{"line":353,"address":[],"length":0,"stats":{"Line":3}},{"line":354,"address":[],"length":0,"stats":{"Line":1}},{"line":355,"address":[],"length":0,"stats":{"Line":1}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}}],"covered":45,"coverable":67},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc1155","extensions","uri_storage.rs"],"content":"//! ERC-1155 token with storage based token URI management.\n//!\n//! Inspired by the [`crate::token::erc721::extensions::Erc721UriStorage`]\nuse alloc::{string::String, vec, vec::Vec};\n\nuse alloy_primitives::U256;\nuse openzeppelin_stylus_proc::interface_id;\nuse stylus_sdk::{\n    evm,\n    prelude::*,\n    storage::{StorageMap, StorageString},\n};\n\nuse super::metadata_uri::{IErc1155MetadataUri, URI};\n\n/// State of an [`Erc1155UriStorage`] contract.\n#[storage]\npub struct Erc1155UriStorage {\n    /// Optional base URI.\n    pub(crate) base_uri: StorageString,\n    /// Optional mapping for token URIs.\n    pub(crate) token_uris: StorageMap\u003cU256, StorageString\u003e,\n}\n\n/// Interface of an optional extension for ERC-1155 with storage based token URI\n/// management.\n#[interface_id]\npub trait IErc1155UriStorage {\n    /// Returns the Uniform Resource Identifier (URI) for `token_id` token.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token_id` - Id of a token.\n    fn uri(\u0026self, token_id: U256) -\u003e String;\n}\n\nimpl Erc1155UriStorage {\n    /// See [`IErc1155UriStorage::uri`].\n    pub fn uri(\n        \u0026self,\n        token_id: U256,\n        metadata_uri: \u0026impl IErc1155MetadataUri,\n    ) -\u003e String {\n        let token_uri = self.token_uris.get(token_id).get_string();\n\n        if token_uri.is_empty() {\n            metadata_uri.uri(token_id)\n        } else {\n            self.base_uri.get_string() + \u0026token_uri\n        }\n    }\n\n    /// Sets `token_uri` as the tokenURI of `token_id`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token_id` - Id of a token.\n    /// * `token_uri` - URI for the token.\n    /// * `metadata_uri` - Read access to a contract providing\n    ///   [`IErc1155MetadataUri`] interface.\n    ///\n    /// # Events\n    ///\n    /// * [`URI`].\n    pub fn set_token_uri(\n        \u0026mut self,\n        token_id: U256,\n        token_uri: String,\n        metadata_uri: \u0026impl IErc1155MetadataUri,\n    ) {\n        self.token_uris.setter(token_id).set_str(token_uri);\n        evm::log(URI { value: self.uri(token_id, metadata_uri), id: token_id });\n    }\n\n    /// Sets `base_uri` as the `base_uri` for all tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `base_uri` - New base URI.\n    pub fn set_base_uri(\u0026mut self, base_uri: String) {\n        self.base_uri.set_str(base_uri);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{uint, Address};\n    use motsu::prelude::Contract;\n    use stylus_sdk::prelude::*;\n\n    use super::*;\n    use crate::token::erc1155::extensions::Erc1155MetadataUri;\n\n    #[storage]\n    struct Erc1155MetadataExample {\n        pub metadata_uri: Erc1155MetadataUri,\n        pub uri_storage: Erc1155UriStorage,\n    }\n\n    #[public]\n    #[implements(IErc1155UriStorage)]\n    impl Erc1155MetadataExample {}\n\n    #[public]\n    impl IErc1155UriStorage for Erc1155MetadataExample {\n        fn uri(\u0026self, token_id: U256) -\u003e String {\n            self.uri_storage.uri(token_id, \u0026self.metadata_uri)\n        }\n    }\n\n    unsafe impl TopLevelStorage for Erc1155MetadataExample {}\n\n    const TOKEN_ID: U256 = uint!(1_U256);\n\n    #[motsu::test]\n    fn uri_returns_metadata_uri_when_token_uri_is_not_set(\n        contract: Contract\u003cErc1155MetadataExample\u003e,\n        alice: Address,\n    ) {\n        let uri = \"https://some.metadata/token/uri\";\n\n        contract.init(alice, |contract| {\n            contract.metadata_uri.uri.set_str(uri.to_owned());\n        });\n\n        assert_eq!(uri, contract.sender(alice).uri(TOKEN_ID));\n    }\n\n    #[motsu::test]\n    fn uri_returns_empty_string_when_no_uri_is_set(\n        contract: Contract\u003cErc1155MetadataExample\u003e,\n        alice: Address,\n    ) {\n        assert!(contract.sender(alice).uri(TOKEN_ID).is_empty());\n    }\n\n    #[motsu::test]\n    fn uri_returns_token_uri_when_base_uri_is_empty(\n        contract: Contract\u003cErc1155MetadataExample\u003e,\n        alice: Address,\n    ) {\n        let token_uri = \"https://some.short/token/uri\";\n\n        contract.init(alice, |contract| {\n            contract\n                .uri_storage\n                .token_uris\n                .setter(TOKEN_ID)\n                .set_str(token_uri.to_owned());\n        });\n\n        assert_eq!(token_uri, contract.sender(alice).uri(TOKEN_ID));\n    }\n\n    #[motsu::test]\n    fn uri_returns_concatenated_base_uri_and_token_uri(\n        contract: Contract\u003cErc1155MetadataExample\u003e,\n        alice: Address,\n    ) {\n        let base_uri = \"https://some.base.uri\";\n        let token_uri = \"/some/token/uri\";\n\n        contract.init(alice, |contract| {\n            contract.uri_storage.base_uri.set_str(base_uri.to_owned());\n            contract\n                .uri_storage\n                .token_uris\n                .setter(TOKEN_ID)\n                .set_str(token_uri.to_owned());\n        });\n\n        assert_eq!(\n            base_uri.to_string() + token_uri,\n            contract.sender(alice).uri(TOKEN_ID)\n        );\n    }\n\n    #[motsu::test]\n    fn uri_ignores_metadata_uri_when_token_uri_is_set(\n        contract: Contract\u003cErc1155MetadataExample\u003e,\n        alice: Address,\n    ) {\n        let uri = \"https://some.metadata/token/uri\";\n        let token_uri = \"https://some.short/token/uri\";\n\n        contract.init(alice, |contract| {\n            contract.metadata_uri.uri.set_str(uri.to_owned());\n            contract\n                .uri_storage\n                .token_uris\n                .setter(TOKEN_ID)\n                .set_str(token_uri.to_owned());\n        });\n\n        assert_eq!(token_uri, contract.sender(alice).uri(TOKEN_ID));\n    }\n    #[motsu::test]\n    fn test_set_uri(\n        contract: Contract\u003cErc1155MetadataExample\u003e,\n        alice: Address,\n    ) {\n        let uri = \"https://some.metadata/token/uri\";\n        let token_uri = \"https://some.short/token/uri\".to_string();\n\n        contract.init(alice, |contract| {\n            contract.metadata_uri.uri.set_str(uri.to_owned());\n            contract.uri_storage.set_token_uri(\n                TOKEN_ID,\n                token_uri.clone(),\n                \u0026contract.metadata_uri,\n            );\n        });\n\n        assert_eq!(token_uri, contract.sender(alice).uri(TOKEN_ID));\n    }\n    #[motsu::test]\n    fn test_set_base_uri(\n        contract: Contract\u003cErc1155MetadataExample\u003e,\n        alice: Address,\n    ) {\n        let base_uri = \"https://docs.openzeppelin.com/\".to_string();\n        contract.init(alice, |contract| {\n            contract.uri_storage.set_base_uri(base_uri.clone());\n        });\n\n        assert_eq!(\n            base_uri,\n            contract.sender(alice).uri_storage.base_uri.get_string()\n        );\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":7}},{"line":45,"address":[],"length":0,"stats":{"Line":21}},{"line":47,"address":[],"length":0,"stats":{"Line":14}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":5}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":3}}],"covered":10,"coverable":10},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc1155","mod.rs"],"content":"//! Implementation of the ERC-1155 token standard.\nuse alloc::{\n    string::{String, ToString},\n    vec,\n    vec::Vec,\n};\n\nuse alloy_primitives::{Address, FixedBytes, U256};\nuse openzeppelin_stylus_proc::interface_id;\nuse stylus_sdk::{\n    abi::Bytes,\n    call::{self, Call, MethodError},\n    evm, function_selector, msg,\n    prelude::*,\n    storage::{StorageBool, StorageMap, StorageU256},\n};\n\nuse crate::utils::{\n    introspection::erc165::IErc165,\n    math::storage::{AddAssignChecked, SubAssignUnchecked},\n};\n\npub mod extensions;\nmod receiver;\npub use receiver::IERC1155Receiver;\n\n/// The expected value returned from [`IERC1155Receiver::on_erc_1155_received`].\npub const SINGLE_TRANSFER_FN_SELECTOR: [u8; 4] = function_selector!(\n    \"onERC1155Received\",\n    Address,\n    Address,\n    U256,\n    U256,\n    Bytes\n);\n\n/// The expected value returned from\n/// [`IERC1155Receiver::on_erc_1155_batch_received`].\npub const BATCH_TRANSFER_FN_SELECTOR: [u8; 4] = function_selector!(\n    \"onERC1155BatchReceived\",\n    Address,\n    Address,\n    Vec\u003cU256\u003e,\n    Vec\u003cU256\u003e,\n    Bytes\n);\n\npub use sol::*;\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when `value` amount of tokens of type `id` are\n        /// transferred from `from` to `to` by `operator`.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event TransferSingle(\n            address indexed operator,\n            address indexed from,\n            address indexed to,\n            uint256 id,\n            uint256 value\n        );\n\n        /// Equivalent to multiple [`TransferSingle`] events, where `operator`\n        /// `from` and `to` are the same for all transfers.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event TransferBatch(\n            address indexed operator,\n            address indexed from,\n            address indexed to,\n            uint256[] ids,\n            uint256[] values\n        );\n\n        /// Emitted when `account` grants or revokes permission to `operator`\n        /// to transfer their tokens, according to `approved`.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event ApprovalForAll(\n            address indexed account,\n            address indexed operator,\n            bool approved\n        );\n    }\n\n    sol! {\n        /// Indicates an error related to the current `balance` of a `sender`.\n        /// Used in transfers.\n        ///\n        /// * `sender` - Address whose tokens are being transferred.\n        /// * `balance` - Current balance for the interacting account.\n        /// * `needed` - Minimum amount required to perform a transfer.\n        /// * `token_id` - Identifier number of a token.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC1155InsufficientBalance(\n            address sender,\n            uint256 balance,\n            uint256 needed,\n            uint256 token_id\n        );\n\n        /// Indicates a failure with the token `sender`.\n        /// Used in transfers.\n        ///\n        /// * `sender` - Address whose tokens are being transferred.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC1155InvalidSender(address sender);\n\n        /// Indicates a failure with the token `receiver`.\n        /// Used in transfers.\n        ///\n        /// * `receiver` - Address to which tokens are being transferred.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC1155InvalidReceiver(address receiver);\n\n        /// Indicates a failure with the `operator`’s approval.\n        /// Used in transfers.\n        ///\n        /// * `operator` - Address that may be allowed to operate on tokens\n        ///   without being their owner.\n        /// * `owner` - Address of the current owner of a token.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC1155MissingApprovalForAll(address operator, address owner);\n\n        /// Indicates a failure with the `approver` of a token to be approved.\n        /// Used in approvals.\n        ///\n        /// * `approver` - Address initiating an approval operation.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC1155InvalidApprover(address approver);\n\n        /// Indicates a failure with the `operator` to be approved.\n        /// Used in approvals.\n        ///\n        /// * `operator` - Address that may be allowed to operate on tokens\n        /// without being their owner.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC1155InvalidOperator(address operator);\n\n        /// Indicates an array length mismatch between token ids and values in a\n        /// [`IErc1155::safe_batch_transfer_from`] operation.\n        /// Used in batch transfers.\n        ///\n        /// * `ids_length` - Length of the array of token identifiers.\n        /// * `values_length` - Length of the array of token amounts.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC1155InvalidArrayLength(uint256 ids_length, uint256 values_length);\n\n        /// Indicates a failure with the receiver reverting with a reason.\n        ///\n        /// * `reason` - Revert reason.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error InvalidReceiverWithReason(string reason);\n    }\n}\n\n/// An [`Erc1155`] error defined as described in [ERC-6093].\n///\n/// [ERC-6093]: https://eips.ethereum.org/EIPS/eip-6093\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates an error related to the current `balance` of `sender`.\n    /// Used in transfers.\n    InsufficientBalance(ERC1155InsufficientBalance),\n    /// Indicates a failure with the token `sender`. Used in transfers.\n    InvalidSender(ERC1155InvalidSender),\n    /// Indicates a failure with the token `receiver`. Used in transfers.\n    InvalidReceiver(ERC1155InvalidReceiver),\n    /// Indicates a failure with the token `receiver`, with the reason\n    /// specified by it.\n    InvalidReceiverWithReason(InvalidReceiverWithReason),\n    /// Indicates a failure with the `operator`’s approval. Used in transfers.\n    MissingApprovalForAll(ERC1155MissingApprovalForAll),\n    /// Indicates a failure with the `approver` of a token to be approved.\n    /// Used in approvals.\n    InvalidApprover(ERC1155InvalidApprover),\n    /// Indicates a failure with the `operator` to be approved. Used in\n    /// approvals.\n    InvalidOperator(ERC1155InvalidOperator),\n    /// Indicates an array length mismatch between token ids and values in a\n    /// [`Erc1155::safe_batch_transfer_from`] operation.\n    /// Used in batch transfers.\n    InvalidArrayLength(ERC1155InvalidArrayLength),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of an [`Erc1155`] token.\n#[storage]\npub struct Erc1155 {\n    /// Maps users to balances.\n    pub(crate) balances: StorageMap\u003cU256, StorageMap\u003cAddress, StorageU256\u003e\u003e,\n    /// Maps owners to a mapping of operator approvals.\n    pub(crate) operator_approvals:\n        StorageMap\u003cAddress, StorageMap\u003cAddress, StorageBool\u003e\u003e,\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for Erc1155 {}\n\n/// Required interface of an [`Erc1155`] compliant contract.\n#[interface_id]\npub trait IErc1155: IErc165 {\n    /// The error type associated to this ERC-1155 trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns the value of tokens of type `id` owned by `account`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `account` - Account of the token's owner.\n    /// * `id` - Token id as a number.\n    fn balance_of(\u0026self, account: Address, id: U256) -\u003e U256;\n\n    /// Batched version of [`IErc1155::balance_of`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `accounts` - All account of the tokens' owner.\n    /// * `ids` - All token identifiers.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidArrayLength`] -  If the length of `accounts` is not\n    ///   equal to the length of `ids`.\n    fn balance_of_batch(\n        \u0026self,\n        accounts: Vec\u003cAddress\u003e,\n        ids: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003cVec\u003cU256\u003e, Self::Error\u003e;\n\n    /// Grants or revokes permission to `operator`\n    /// to transfer the caller's tokens, according to `approved`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `operator` - Account to add to the set of authorized operators.\n    /// * `approved` - Flag that determines whether or not permission will be\n    ///   granted to `operator`. If true, this means `operator` will be allowed\n    ///   to manage `msg::sender()`'s assets.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidOperator`] - If `operator` is [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`ApprovalForAll`].\n    fn set_approval_for_all(\n        \u0026mut self,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Returns true if `operator` is approved to transfer `account`'s\n    /// tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `account` - Account of the token's owner.\n    /// * `operator` - Account to be checked.\n    fn is_approved_for_all(\u0026self, account: Address, operator: Address) -\u003e bool;\n\n    /// Transfers a `value` amount of tokens of type `id` from `from` to\n    /// `to`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to transfer tokens from.\n    /// * `to` - Account of the recipient.\n    /// * `id` - Token id as a number.\n    /// * `value` - Amount of tokens to be transferred.\n    /// * `data` - Additional data with no specified format, sent in call to\n    ///   `to`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - Returned when `to` is [`Address::ZERO`]\n    ///   or when [`IERC1155Receiver::on_erc_1155_received`] hasn't returned its\n    ///   interface id or returned with error.\n    /// * [`Error::InvalidSender`] - Returned when `from` is [`Address::ZERO`].\n    /// * [`Error::MissingApprovalForAll`] - Returned when `from` is not the\n    ///   caller (`msg::sender()`), and the caller does not have the right to\n    ///   approve.\n    /// * [`Error::InsufficientBalance`] - Returned when `value` is greater than\n    ///   the balance of the `from` account.\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`].\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        id: U256,\n        value: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Batched version of [`IErc1155::safe_transfer_from`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to transfer tokens from.\n    /// * `to` - Account of the recipient.\n    /// * `ids` - Array of all tokens ids.\n    /// * `values` - Array of all amount of tokens to be transferred.\n    /// * `data` - Additional data with no specified format, sent in call to\n    ///   `to`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - Returned when `to` is [`Address::ZERO`]\n    ///   or when [`IERC1155Receiver::on_erc_1155_batch_received`] hasn't\n    ///   returned its interface id or returned with error.\n    /// * [`Error::InvalidSender`] - Returned when `from` is [`Address::ZERO`].\n    /// * [`Error::InvalidArrayLength`] - Returned when the length of `ids` is\n    ///   not equal to the length of `values`.\n    /// * [`Error::InsufficientBalance`] - Returned when any of the `values` is\n    ///   greater than the balance of the `from` account.\n    /// * [`Error::MissingApprovalForAll`] - Returned when `from` is not the\n    ///   caller (`msg::sender()`), and the caller does not have the right to\n    ///   approve.\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`] - If the arrays contain one element.\n    /// * [`TransferBatch`] - If the arrays contain multiple elements.\n\n    fn safe_batch_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\n#[public]\n#[implements(IErc1155\u003cError = Error\u003e, IErc165)]\nimpl Erc1155 {}\n\n#[public]\nimpl IErc1155 for Erc1155 {\n    type Error = Error;\n\n    fn balance_of(\u0026self, account: Address, id: U256) -\u003e U256 {\n        self.balances.get(id).get(account)\n    }\n\n    fn balance_of_batch(\n        \u0026self,\n        accounts: Vec\u003cAddress\u003e,\n        ids: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003cVec\u003cU256\u003e, Self::Error\u003e {\n        Self::require_equal_arrays_length(\u0026ids, \u0026accounts)?;\n\n        let balances: Vec\u003cU256\u003e = accounts\n            .iter()\n            .zip(ids.iter())\n            .map(|(account, token_id)| self.balance_of(*account, *token_id))\n            .collect();\n\n        Ok(balances)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self._set_approval_for_all(msg::sender(), operator, approved)\n    }\n\n    fn is_approved_for_all(\u0026self, account: Address, operator: Address) -\u003e bool {\n        self.operator_approvals.get(account).get(operator)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        id: U256,\n        value: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.authorize_transfer(from)?;\n        self.do_safe_transfer_from(from, to, vec![id], vec![value], \u0026data)\n    }\n\n    fn safe_batch_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.authorize_transfer(from)?;\n        self.do_safe_transfer_from(from, to, ids, values, \u0026data)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc1155 {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IErc1155\u003e::interface_id() == interface_id\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\nimpl Erc1155 {\n    /// Transfers a `value` amount of tokens of type `ids` from `from` to\n    /// `to`. Will mint (or burn) if `from` (or `to`) is the [`Address::ZERO`].\n    ///\n    /// NOTE: The ERC-1155 acceptance check is not performed in this function.\n    /// See [`Self::_update_with_acceptance_check`] instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to transfer tokens from.\n    /// * `to` - Account of the recipient.\n    /// * `ids` - Array of all tokens ids.\n    /// * `values` - Array of all amount of tokens to be transferred.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidArrayLength`] - If length of `ids` is not equal to\n    ///   length of `values`.\n    /// * [`Error::InsufficientBalance`] - If `value` is greater than the\n    ///   balance of the `from` account.\n    ///\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`] - If the arrays contain one element.\n    /// * [`TransferBatch`] - If the arrays contain multiple elements.\n    ///\n    /// # Panics\n    ///\n    /// * If updated balance exceeds [`U256::MAX`], may happen during `mint`\n    ///   operation.\n    fn _update(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003c(), Error\u003e {\n        Self::require_equal_arrays_length(\u0026ids, \u0026values)?;\n\n        let operator = msg::sender();\n\n        for (\u0026token_id, \u0026value) in ids.iter().zip(values.iter()) {\n            self.do_update(from, to, token_id, value)?;\n        }\n\n        if ids.len() == 1 {\n            let id = ids[0];\n            let value = values[0];\n            evm::log(TransferSingle { operator, from, to, id, value });\n        } else {\n            evm::log(TransferBatch { operator, from, to, ids, values });\n        }\n\n        Ok(())\n    }\n\n    /// Version of [`Self::_update`] that performs the token acceptance check by\n    /// calling [`IERC1155Receiver::on_erc_1155_received`] or\n    /// [`IERC1155Receiver::on_erc_1155_batch_received`] on the receiver address\n    /// if it contains code.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to transfer tokens from.\n    /// * `to` - Account of the recipient.\n    /// * `ids` - Array of all token ids.\n    /// * `values` - Array of all amount of tokens to be transferred.\n    /// * `data` - Additional data with no specified format, sent in call to\n    ///   `to`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidArrayLength`] - Returned when length of `ids` is not\n    ///   equal to length of `values`.\n    /// * [`Error::InsufficientBalance`] - Returned when `value` is greater than\n    ///   the balance of the `from` account.\n    /// * [`Error::InvalidReceiver`] - Returned when\n    ///   [`IERC1155Receiver::on_erc_1155_received`] or\n    ///   [`IERC1155Receiver::on_erc_1155_batch_received`] hasn't returned its\n    ///   interface id or returned with error.\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`] - If the arrays contain one element.\n    /// * [`TransferBatch`] - If the arrays contain multiple elements.\n    ///\n    /// # Panics\n    ///\n    /// * If updated balance exceeds [`U256::MAX`], may happen during `mint`\n    ///   operation.\n    fn _update_with_acceptance_check(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self._update(from, to, ids.clone(), values.clone())?;\n\n        if !to.is_zero() {\n            self._check_on_erc1155_received(\n                msg::sender(),\n                from,\n                to,\n                Erc1155ReceiverData::new(ids, values),\n                data.to_vec().into(),\n            )?;\n        }\n\n        Ok(())\n    }\n\n    /// Creates a `value` amount of tokens of type `id`, and assigns\n    /// them to `to`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `id` - Token id.\n    /// * `value` - Amount of tokens to be minted.\n    /// * `data` - Additional data with no specified format, sent in call to\n    ///   `to`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`IERC1155Receiver::on_erc_1155_received`] hasn't returned its\n    ///   interface id or returned with error.\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`].\n    ///\n    /// # Panics\n    ///\n    /// * If updated balance exceeds [`U256::MAX`].\n    pub fn _mint(\n        \u0026mut self,\n        to: Address,\n        id: U256,\n        value: U256,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self._do_mint(to, vec![id], vec![value], data)\n    }\n\n    /// Batched version of [`Self::_mint`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `ids` - Array of all tokens ids to be minted.\n    /// * `values` - Array of all amounts of tokens to be minted.\n    /// * `data` - Additional data with no specified format, sent in call to\n    ///   `to`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] -  If `to` is [`Address::ZERO`].\n    /// * [`Error::InvalidArrayLength`] - If length of `ids` is not equal to\n    ///   length of `values`.\n    /// * [`IERC1155Receiver::on_erc_1155_received`] - If  hasn't returned its\n    /// * [`Error::InvalidReceiver`] - interface id or returned with error.\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`IERC1155Receiver::on_erc_1155_batch_received`] hasn't returned its\n    ///   interface id or returned with error.\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`] - If the arrays contain one element.\n    /// * [`TransferBatch`] - If the arrays contain multiple elements.\n    ///\n    /// # Panics\n    ///\n    /// * If updated balance exceeds [`U256::MAX`].\n    pub fn _mint_batch(\n        \u0026mut self,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self._do_mint(to, ids, values, data)\n    }\n\n    /// Destroys a `value` amount of tokens of type `id` from `from`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to burn tokens from.\n    /// * `id` - Token id to be burnt.\n    /// * `value` - Amount of tokens to be burnt.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSender`] - If `from` is the [`Address::ZERO`].\n    /// * [`Error::InsufficientBalance`]  - If `value` is greater than the\n    ///   balance of the `from` account.\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`].\n\n    pub fn _burn(\n        \u0026mut self,\n        from: Address,\n        id: U256,\n        value: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self._do_burn(from, vec![id], vec![value])\n    }\n\n    /// Batched version of [`Self::_burn`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to burn tokens from.\n    /// * `ids` - Array of all tokens ids to be burnt.\n    /// * `values` - Array of all amounts of tokens to be burnt.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSender`] - If `from` is the [`Address::ZERO`].\n    /// * [`Error::InvalidArrayLength`] - If length of `ids` is not equal to\n    ///   length of `values`.\n    /// * [`Error::InsufficientBalance`] - If any of the `values` is greater\n    ///   than the balance of the respective token from `tokens` of the `from`\n    ///   account.\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`] - If the arrays contain one element.\n    /// * [`TransferBatch`] - If the arrays contain multiple elements.\n\n    pub fn _burn_batch(\n        \u0026mut self,\n        from: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self._do_burn(from, ids, values)\n    }\n\n    /// Approve `operator` to operate on all of `owner` tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `owner` - Tokens owner (`msg::sender`).\n    /// * `operator` - Account to add to the set of authorized operators.\n    /// * `approved` - Flag that determines whether or not permission will be\n    ///   granted to `operator`. If true, this means `operator` will be allowed\n    ///   to manage `owner`'s assets.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidOperator`] - If `operator` is the [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`ApprovalForAll`].\n    fn _set_approval_for_all(\n        \u0026mut self,\n        owner: Address,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if operator.is_zero() {\n            return Err(Error::InvalidOperator(ERC1155InvalidOperator {\n                operator,\n            }));\n        }\n        self.operator_approvals.setter(owner).setter(operator).set(approved);\n        evm::log(ApprovalForAll { account: owner, operator, approved });\n        Ok(())\n    }\n}\n\nimpl Erc1155 {\n    /// Performs an acceptance check for the provided `operator` by calling\n    /// [`IERC1155Receiver::on_erc_1155_received`] in case of single token\n    /// transfer, or [`IERC1155Receiver::on_erc_1155_batch_received`] in\n    /// case of batch transfer on the `to` address.\n    ///\n    /// The acceptance call is not executed and treated as a no-op if the\n    /// target address doesn't contain code (i.e. an EOA). Otherwise,\n    /// the recipient must implement either\n    /// [`IERC1155Receiver::on_erc_1155_received`] for single transfer, or\n    /// [`IERC1155Receiver::on_erc_1155_batch_received`] for a batch transfer,\n    /// and return the acceptance value to accept the transfer.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `operator` - Generally the address that initiated the token transfer\n    ///   (e.g. `msg::sender()`).\n    /// * `from` - Account of the sender.\n    /// * `to` - Account of the recipient.\n    /// * `details` - Details about token transfer, check\n    ///   [`Erc1155ReceiverData`].\n    /// * `data` - Additional data with no specified format, sent in call to\n    ///   `to`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`IERC1155Receiver::on_erc_1155_received`] or\n    ///   [`IERC1155Receiver::on_erc_1155_batch_received`] haven't returned the\n    ///   interface id or returned an error.\n    /// * [`Error::InvalidReceiverWithReason`] - If\n    ///   [`IERC1155Receiver::on_erc_1155_received`] or\n    ///   [`IERC1155Receiver::on_erc_1155_batch_received`] reverted with revert\n    ///   data.\n    fn _check_on_erc1155_received(\n        \u0026mut self,\n        operator: Address,\n        from: Address,\n        to: Address,\n        details: Erc1155ReceiverData,\n        data: alloy_primitives::Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !to.has_code() {\n            return Ok(());\n        }\n\n        let receiver = IERC1155Receiver::new(to);\n        let call = Call::new_in(self);\n        let result = match details.transfer {\n            Transfer::Single { id, value } =\u003e receiver\n                .on_erc_1155_received(call, operator, from, id, value, data),\n\n            Transfer::Batch { ids, values } =\u003e receiver\n                .on_erc_1155_batch_received(\n                    call, operator, from, ids, values, data,\n                ),\n        };\n\n        let id = match result {\n            Ok(id) =\u003e id,\n            Err(e) =\u003e {\n                if let call::Error::Revert(ref reason) = e {\n                    if !reason.is_empty() {\n                        return Err(Error::InvalidReceiverWithReason(\n                            InvalidReceiverWithReason {\n                                reason: String::from_utf8_lossy(reason)\n                                    .to_string(),\n                            },\n                        ));\n                    }\n                }\n\n                // Non-IERC1155Receiver implementer.\n                return Err(ERC1155InvalidReceiver { receiver: to }.into());\n            }\n        };\n\n        // Token rejected.\n        if id != details.receiver_fn_selector {\n            return Err(ERC1155InvalidReceiver { receiver: to }.into());\n        }\n\n        Ok(())\n    }\n\n    /// Creates `values` of tokens specified by `ids`, and assigns\n    /// them to `to`. Performs the token acceptance check by\n    /// calling [`IERC1155Receiver::on_erc_1155_received`] or\n    /// [`IERC1155Receiver::on_erc_1155_batch_received`] on the `to` address if\n    /// it contains code.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `ids` - Array of all token ids to be minted.\n    /// * `values` - Array of all amounts of tokens to be minted.\n    /// * `data` - Additional data with no specified format, sent in call to\n    ///   `to`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`IERC1155Receiver::on_erc_1155_received`] hasn't returned its\n    ///   interface id or returned with error.\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`IERC1155Receiver::on_erc_1155_batch_received`] hasn't returned its\n    ///   interface id or returned with error.\n    /// * [`Error::InvalidArrayLength`] -  If length of `ids` is not equal to\n    ///   length of `values`.\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`] - If the arrays contain one element.\n    /// * [`TransferBatch`] - If the array contain multiple elements.\n    ///\n    /// # Panics\n    ///\n    /// * If updated balance exceeds [`U256::MAX`].\n    fn _do_mint(\n        \u0026mut self,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if to.is_zero() {\n            return Err(Error::InvalidReceiver(ERC1155InvalidReceiver {\n                receiver: to,\n            }));\n        }\n        self._update_with_acceptance_check(\n            Address::ZERO,\n            to,\n            ids,\n            values,\n            data,\n        )?;\n        Ok(())\n    }\n\n    /// Destroys `values` amounts of tokens specified by `ids` from `from`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to burn tokens from.\n    /// * `ids` - Array of all token ids to be burnt.\n    /// * `values` - Array of all amount of tokens to be burnt.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSender`] - If `from` is the [`Address::ZERO`].\n    /// * [`Error::InvalidArrayLength`] - If length of `ids` is not equal to\n    ///   length of `values`.\n    /// * [`Error::InsufficientBalance`] -If any of the `values` is greater than\n    ///   the balance of the respective token from `tokens` of the `from`\n    ///   account.\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`] - If the arrays contain one element.\n    /// * [`TransferBatch`] - If the arrays contain multiple elements.\n\n    fn _do_burn(\n        \u0026mut self,\n        from: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if from.is_zero() {\n            return Err(Error::InvalidSender(ERC1155InvalidSender {\n                sender: from,\n            }));\n        }\n        self._update_with_acceptance_check(\n            from,\n            Address::ZERO,\n            ids,\n            values,\n            \u0026vec![].into(),\n        )?;\n        Ok(())\n    }\n\n    /// Transfers `values` of tokens specified by `ids` from `from` to `to`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to transfer tokens from.\n    /// * `to` - Account of the recipient.\n    /// * `ids` - Array of all token ids.\n    /// * `values` - Array of all amount of tokens to be transferred.\n    /// * `data` - Additional data with no specified format, sent in call to\n    ///   `to`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If `to` is the [`Address::ZERO`].\n    /// * [`Error::InvalidSender`] - If `from` is the [`Address::ZERO`].\n    /// * [`Error::InvalidArrayLength`] - If length of `ids` is not equal to\n    ///   length of `values`.\n    /// * [`Error::InsufficientBalance`] - If `value` is greater than the\n    ///   balance of the `from` account.\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`IERC1155Receiver::on_erc_1155_received`] hasn't returned its\n    ///   interface id or returned with error.\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`IERC1155Receiver::on_erc_1155_batch_received`] hasn't returned its\n    ///   interface id or returned with error.\n    ///\n    /// # Events\n    ///\n    /// * [`TransferSingle`] - If the arrays contain one element.\n    /// * [`TransferBatch`] - If the arrays contain multiple elements.\n    ///\n    /// # Panics\n    ///\n    /// * If updated balance exceeds [`U256::MAX`].\n    fn do_safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if to.is_zero() {\n            return Err(Error::InvalidReceiver(ERC1155InvalidReceiver {\n                receiver: to,\n            }));\n        }\n        if from.is_zero() {\n            return Err(Error::InvalidSender(ERC1155InvalidSender {\n                sender: from,\n            }));\n        }\n        self._update_with_acceptance_check(from, to, ids, values, data)\n    }\n\n    /// Transfers a `value` amount of `token_id` from `from` to\n    /// `to`. Will mint (or burn) if `from` (or `to`) is the [`Address::ZERO`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to transfer tokens from.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id.\n    /// * `value` - Amount of tokens to be transferred.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InsufficientBalance`] - If `value` is greater than the\n    ///   balance of the `from` account.\n    ///\n    /// # Panics\n    ///\n    /// * If updated balance exceeds [`U256::MAX`].\n    fn do_update(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        value: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !from.is_zero() {\n            let from_balance = self.balance_of(from, token_id);\n            if from_balance \u003c value {\n                return Err(Error::InsufficientBalance(\n                    ERC1155InsufficientBalance {\n                        sender: from,\n                        balance: from_balance,\n                        needed: value,\n                        token_id,\n                    },\n                ));\n            }\n            self.balances\n                .setter(token_id)\n                .setter(from)\n                .sub_assign_unchecked(value);\n        }\n\n        if !to.is_zero() {\n            self.balances.setter(token_id).setter(to).add_assign_checked(\n                value,\n                \"should not exceed `U256::MAX` for `balances`\",\n            );\n        }\n\n        Ok(())\n    }\n\n    /// Checks if `ids` array has same length as `values` array.\n    ///\n    /// # Arguments\n    ///\n    /// * `ids` - array of `ids`.\n    /// * `values` - array of `values`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidArrayLength`] - If length of `ids` is not equal to\n    ///   length of `values`.\n    fn require_equal_arrays_length\u003cT, U\u003e(\n        ids: \u0026[T],\n        values: \u0026[U],\n    ) -\u003e Result\u003c(), Error\u003e {\n        if ids.len() != values.len() {\n            return Err(Error::InvalidArrayLength(ERC1155InvalidArrayLength {\n                ids_length: U256::from(ids.len()),\n                values_length: U256::from(values.len()),\n            }));\n        }\n        Ok(())\n    }\n\n    /// Checks if `msg::sender()` is authorized to transfer tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `from` - Account to transfer tokens from.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::MissingApprovalForAll`] -  If the `from` is not the caller\n    ///   (`msg::sender()`), and the caller does not have the right to approve.\n    fn authorize_transfer(\u0026self, from: Address) -\u003e Result\u003c(), Error\u003e {\n        let sender = msg::sender();\n        if from != sender \u0026\u0026 !self.is_approved_for_all(from, sender) {\n            return Err(Error::MissingApprovalForAll(\n                ERC1155MissingApprovalForAll { operator: sender, owner: from },\n            ));\n        }\n\n        Ok(())\n    }\n}\n\n/// Data struct to be passed to a contract that\n/// implements [`IERC1155Receiver`] interface.\nstruct Erc1155ReceiverData {\n    /// ERC-1155 Receiver function selector.\n    receiver_fn_selector: [u8; 4],\n    /// Transfer details, either [`Transfer::Single`] or [`Transfer::Batch`].\n    transfer: Transfer,\n}\n\nimpl Erc1155ReceiverData {\n    /// Creates a new instance based on transfer details.\n    /// Assumes that `ids` is not empty.\n    ///\n    /// If `ids` array has only 1 element,\n    /// it means that it is a [`Transfer::Single`].\n    /// If `ids` array has many elements,\n    /// it means that it is a [`Transfer::Batch`].\n    ///\n    /// NOTE: Does not check if `ids` length is equal to `values`.\n    ///\n    /// # Arguments\n    ///\n    /// * `ids` - Array of tokens ids being transferred.\n    /// * `values` - Array of all amount of tokens being transferred.\n    fn new(ids: Vec\u003cU256\u003e, values: Vec\u003cU256\u003e) -\u003e Self {\n        if ids.len() == 1 {\n            Self::single(ids[0], values[0])\n        } else {\n            Self::batch(ids, values)\n        }\n    }\n\n    /// Creates a new instance for a [`Transfer::Single`].\n    /// Check [`IERC1155Receiver::on_erc_1155_received`].\n    ///\n    /// # Arguments\n    ///\n    /// * `id` - Token id being transferred.\n    /// * `value` - Amount of tokens being transferred.\n    fn single(id: U256, value: U256) -\u003e Self {\n        Self {\n            receiver_fn_selector: SINGLE_TRANSFER_FN_SELECTOR,\n            transfer: Transfer::Single { id, value },\n        }\n    }\n\n    /// Creates a new instance for a [`Transfer::Batch`].\n    /// Check [`IERC1155Receiver::on_erc_1155_batch_received`].\n    ///\n    /// # Arguments\n    ///\n    /// * `ids` - Array of tokens ids being transferred.\n    /// * `values` - Array of all amount of tokens being transferred.\n    fn batch(ids: Vec\u003cU256\u003e, values: Vec\u003cU256\u003e) -\u003e Self {\n        Self {\n            receiver_fn_selector: BATCH_TRANSFER_FN_SELECTOR,\n            transfer: Transfer::Batch { ids, values },\n        }\n    }\n}\n\n/// Struct representing token transfer details.\n#[derive(Debug, PartialEq)]\nenum Transfer {\n    /// Transfer of a single token.\n    ///\n    /// # Attributes\n    ///\n    /// * `id` - Token id being transferred.\n    /// * `value` - Amount of tokens being transferred.\n    Single { id: U256, value: U256 },\n    /// Batch tokens transfer.\n    ///\n    /// # Attributes\n    ///\n    /// * `ids` - Array of tokens ids being transferred.\n    /// * `values` - Array of all amount of tokens being transferred.\n    Batch { ids: Vec\u003cU256\u003e, values: Vec\u003cU256\u003e },\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{uint, Address, FixedBytes, U256};\n    use motsu::prelude::Contract;\n\n    use super::{\n        ERC1155InsufficientBalance, ERC1155InvalidArrayLength,\n        ERC1155InvalidOperator, ERC1155InvalidReceiver, ERC1155InvalidSender,\n        ERC1155MissingApprovalForAll, Erc1155, Erc1155ReceiverData, Error,\n        IErc1155, Transfer, BATCH_TRANSFER_FN_SELECTOR,\n        SINGLE_TRANSFER_FN_SELECTOR,\n    };\n    use crate::utils::introspection::erc165::IErc165;\n\n    pub(crate) fn random_token_ids(size: usize) -\u003e Vec\u003cU256\u003e {\n        (0..size).map(U256::from).collect()\n    }\n\n    pub(crate) fn random_values(size: usize) -\u003e Vec\u003cU256\u003e {\n        (1..=size).map(U256::from).collect()\n    }\n\n    fn init(\n        contract: \u0026mut Erc1155,\n        receiver: Address,\n        size: usize,\n    ) -\u003e (Vec\u003cU256\u003e, Vec\u003cU256\u003e) {\n        let token_ids = random_token_ids(size);\n        let values = random_values(size);\n\n        contract\n            ._mint_batch(\n                receiver,\n                token_ids.clone(),\n                values.clone(),\n                \u0026vec![0, 1, 2, 3].into(),\n            )\n            .expect(\"Mint failed\");\n        (token_ids, values)\n    }\n\n    fn append(values: Vec\u003cU256\u003e, value: u64) -\u003e Vec\u003cU256\u003e {\n        values.into_iter().chain(std::iter::once(U256::from(value))).collect()\n    }\n\n    #[test]\n    fn should_create_transfer_single() {\n        let id = uint!(1_U256);\n        let value = uint!(10_U256);\n        let details = Erc1155ReceiverData::new(vec![id], vec![value]);\n        assert_eq!(SINGLE_TRANSFER_FN_SELECTOR, details.receiver_fn_selector);\n        assert_eq!(Transfer::Single { id, value }, details.transfer);\n    }\n\n    #[test]\n    fn should_create_transfer_batch() {\n        let ids = random_token_ids(5);\n        let values = random_values(5);\n        let details = Erc1155ReceiverData::new(ids.clone(), values.clone());\n        assert_eq!(BATCH_TRANSFER_FN_SELECTOR, details.receiver_fn_selector);\n        assert_eq!(Transfer::Batch { ids, values }, details.transfer);\n    }\n\n    #[motsu::test]\n    fn balance_of_zero_balance(contract: Contract\u003cErc1155\u003e, alice: Address) {\n        let owner = alice;\n        let token_id = random_token_ids(1)[0];\n        let balance = contract.sender(alice).balance_of(owner, token_id);\n        assert_eq!(U256::ZERO, balance);\n    }\n\n    #[motsu::test]\n    fn error_when_array_length_mismatch(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n        charlie: Address,\n    ) {\n        let token_ids = random_token_ids(3);\n        let accounts = vec![alice, bob, dave, charlie];\n        let ids_length = U256::from(token_ids.len());\n        let accounts_length = U256::from(accounts.len());\n\n        let err = contract\n            .sender(alice)\n            .balance_of_batch(accounts, token_ids)\n            .expect_err(\"should return `Error::InvalidArrayLength`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidArrayLength(ERC1155InvalidArrayLength {\n                ids_length: ids_l,\n                values_length: accounts_l,\n            }) if ids_l == ids_length \u0026\u0026 accounts_l == accounts_length\n        ));\n    }\n\n    #[motsu::test]\n    fn balance_of_batch_zero_balance(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n        charlie: Address,\n    ) {\n        let token_ids = random_token_ids(4);\n        let accounts = vec![alice, bob, dave, charlie];\n        let balances = contract\n            .sender(alice)\n            .balance_of_batch(accounts, token_ids)\n            .expect(\"should return a vector of `U256::ZERO`\");\n\n        let expected = vec![U256::ZERO; 4];\n        assert_eq!(expected, balances);\n    }\n\n    #[motsu::test]\n    fn set_approval_for_all(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.operator_approvals.setter(alice).setter(bob).set(false);\n        });\n\n        contract\n            .sender(alice)\n            .set_approval_for_all(bob, true)\n            .expect(\"should approve Bob for operations on all Alice's tokens\");\n        assert!(contract.sender(alice).is_approved_for_all(alice, bob));\n\n        contract.sender(alice).set_approval_for_all(bob, false).expect(\n            \"should disapprove Bob for operations on all Alice's tokens\",\n        );\n        assert!(!contract.sender(alice).is_approved_for_all(alice, bob));\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_operator_set_approval_for_all(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let invalid_operator = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            .set_approval_for_all(invalid_operator, true)\n            .expect_err(\"should not approve for all for invalid operator\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidOperator(ERC1155InvalidOperator {\n                operator\n            }) if operator == invalid_operator\n        ));\n    }\n\n    #[motsu::test]\n    fn mints(contract: Contract\u003cErc1155\u003e, alice: Address) {\n        let token_id = random_token_ids(1)[0];\n        let value = random_values(1)[0];\n\n        contract\n            .sender(alice)\n            ._mint(alice, token_id, value, \u0026vec![0, 1, 2, 3].into())\n            .expect(\"should mint tokens for Alice\");\n\n        let balance = contract.sender(alice).balance_of(alice, token_id);\n\n        assert_eq!(balance, value);\n    }\n\n    #[motsu::test]\n    fn error_when_mints_to_invalid_receiver(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n        let token_id = random_token_ids(1)[0];\n        let value = random_values(1)[0];\n\n        let err = contract\n            .sender(alice)\n            ._mint(invalid_receiver, token_id, value, \u0026vec![0, 1, 2, 3].into())\n            .expect_err(\"should not mint tokens for invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC1155InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn mints_batch(contract: Contract\u003cErc1155\u003e, alice: Address) {\n        let token_ids = random_token_ids(4);\n        let values = random_values(4);\n\n        contract\n            .sender(alice)\n            ._mint_batch(\n                alice,\n                token_ids.clone(),\n                values.clone(),\n                \u0026vec![0, 1, 2, 3].into(),\n            )\n            .expect(\"should batch mint tokens\");\n\n        token_ids.iter().zip(values.iter()).for_each(|(\u0026token_id, \u0026value)| {\n            assert_eq!(\n                value,\n                contract.sender(alice).balance_of(alice, token_id)\n            );\n        });\n\n        let balances = contract\n            .sender(alice)\n            .balance_of_batch(vec![alice; 4], token_ids.clone())\n            .expect(\"should return balances\");\n\n        assert_eq!(values, balances);\n    }\n\n    #[motsu::test]\n    fn mints_batch_same_token(contract: Contract\u003cErc1155\u003e, alice: Address) {\n        let token_id = uint!(1_U256);\n        let values = random_values(4);\n        let expected_balance: U256 = values.iter().sum();\n\n        contract\n            .sender(alice)\n            ._mint_batch(\n                alice,\n                vec![token_id; 4],\n                values.clone(),\n                \u0026vec![0, 1, 2, 3].into(),\n            )\n            .expect(\"should batch mint tokens\");\n\n        assert_eq!(\n            expected_balance,\n            contract.sender(alice).balance_of(alice, token_id)\n        );\n\n        let balances = contract\n            .sender(alice)\n            .balance_of_batch(vec![alice; 4], vec![token_id; 4])\n            .expect(\"should return balances\");\n\n        assert_eq!(vec![expected_balance; 4], balances);\n    }\n\n    #[motsu::test]\n    fn error_when_batch_mints_to_invalid_receiver(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let token_ids = random_token_ids(1);\n        let values = random_values(1);\n        let invalid_receiver = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            ._mint_batch(\n                invalid_receiver,\n                token_ids,\n                values,\n                \u0026vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not batch mint tokens for invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC1155InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_batch_mints_not_equal_arrays(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let token_ids = random_token_ids(3);\n        let values = random_values(4);\n\n        let err = contract\n            .sender(alice)\n            ._mint_batch(alice, token_ids, values, \u0026vec![0, 1, 2, 3].into())\n            .expect_err(\n                \"should not batch mint tokens when not equal array lengths\",\n            );\n\n        assert!(matches!(\n            err,\n            Error::InvalidArrayLength(ERC1155InvalidArrayLength {\n                ids_length, values_length\n            }) if ids_length == uint!(3_U256) \u0026\u0026 values_length == uint!(4_U256)\n        ));\n    }\n\n    #[motsu::test]\n    fn burns(contract: Contract\u003cErc1155\u003e, alice: Address) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n\n        let token_id = token_ids[0];\n        let value = values[0];\n\n        contract\n            .sender(alice)\n            ._burn(alice, token_id, value)\n            .expect(\"should burn tokens\");\n\n        let balances = contract.sender(alice).balance_of(alice, token_id);\n\n        assert_eq!(U256::ZERO, balances);\n    }\n\n    #[motsu::test]\n    fn error_when_burns_from_invalid_sender(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n        let invalid_sender = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            ._burn(invalid_sender, token_ids[0], values[0])\n            .expect_err(\"should not burn token for invalid sender\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC1155InvalidSender {\n                sender\n            }) if sender == invalid_sender\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_burns_with_insufficient_balance(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n\n        let err = contract\n            .sender(alice)\n            ._burn(alice, token_ids[0], values[0] + uint!(1_U256))\n            .expect_err(\"should not burn token when insufficient balance\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientBalance(ERC1155InsufficientBalance {\n                sender,\n                balance,\n                needed,\n                token_id\n            }) if sender == alice \u0026\u0026 balance == values[0] \u0026\u0026 needed == values[0] + uint!(1_U256) \u0026\u0026 token_id == token_ids[0]\n        ));\n    }\n\n    #[motsu::test]\n    fn burns_batch(contract: Contract\u003cErc1155\u003e, alice: Address) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 4));\n\n        contract\n            .sender(alice)\n            ._burn_batch(alice, token_ids.clone(), values.clone())\n            .expect(\"should batch burn tokens\");\n\n        let balances = contract\n            .sender(alice)\n            .balance_of_batch(vec![alice; 4], token_ids.clone())\n            .expect(\"should return balances\");\n\n        assert_eq!(vec![U256::ZERO; 4], balances);\n    }\n\n    #[motsu::test]\n    fn burns_batch_same_token(contract: Contract\u003cErc1155\u003e, alice: Address) {\n        let token_id = uint!(1_U256);\n        let value = uint!(80_U256);\n\n        contract\n            .sender(alice)\n            ._mint(alice, token_id, value, \u0026vec![0, 1, 2, 3].into())\n            .expect(\"should mint token\");\n\n        contract\n            .sender(alice)\n            ._burn_batch(\n                alice,\n                vec![token_id; 4],\n                vec![\n                    uint!(20_U256),\n                    uint!(10_U256),\n                    uint!(30_U256),\n                    uint!(20_U256),\n                ],\n            )\n            .expect(\"should batch burn tokens\");\n\n        assert_eq!(\n            U256::ZERO,\n            contract.sender(alice).balance_of(alice, token_id)\n        );\n    }\n\n    #[motsu::test]\n    fn error_when_batch_burns_from_invalid_sender(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 4));\n        let invalid_sender = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            ._burn_batch(invalid_sender, token_ids, values)\n            .expect_err(\"should not batch burn tokens for invalid sender\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC1155InvalidSender {\n                sender\n            }) if sender == invalid_sender\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_batch_burns_with_insufficient_balance(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 4));\n\n        let err = contract\n            .sender(alice)\n            ._burn_batch(\n                alice,\n                token_ids.clone(),\n                values.clone().into_iter().map(|x| x + uint!(1_U256)).collect(),\n            )\n            .expect_err(\n                \"should not batch burn tokens when insufficient balance\",\n            );\n\n        assert!(matches!(\n            err,\n            Error::InsufficientBalance(ERC1155InsufficientBalance {\n                sender,\n                balance,\n                needed,\n                token_id\n            }) if sender == alice \u0026\u0026 balance == values[0] \u0026\u0026 needed == values[0] + uint!(1_U256) \u0026\u0026 token_id == token_ids[0]\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_batch_burns_not_equal_arrays(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 3));\n\n        let err = contract\n            .sender(alice)\n            ._burn_batch(alice, token_ids, append(values, 4))\n            .expect_err(\n                \"should not batch burn tokens when not equal array lengths\",\n            );\n\n        assert!(matches!(\n            err,\n            Error::InvalidArrayLength(ERC1155InvalidArrayLength {\n                ids_length, values_length\n            }) if ids_length == uint!(3_U256) \u0026\u0026 values_length == uint!(4_U256)\n        ));\n    }\n\n    #[motsu::test]\n    fn safe_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 2));\n        let amount_one = values[0] - uint!(1_U256);\n        let amount_two = values[1] - uint!(1_U256);\n\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Bob's tokens to Alice\");\n\n        contract\n            .sender(alice)\n            .safe_transfer_from(\n                bob,\n                dave,\n                token_ids[0],\n                amount_one,\n                vec![].into(),\n            )\n            .expect(\"should transfer tokens from Alice to Bob\");\n        contract\n            .sender(alice)\n            .safe_transfer_from(\n                bob,\n                dave,\n                token_ids[1],\n                amount_two,\n                vec![].into(),\n            )\n            .expect(\"should transfer tokens from Alice to Bob\");\n\n        let balance_id_one =\n            contract.sender(alice).balance_of(dave, token_ids[0]);\n        let balance_id_two =\n            contract.sender(alice).balance_of(dave, token_ids[1]);\n\n        assert_eq!(amount_one, balance_id_one);\n        assert_eq!(amount_two, balance_id_two);\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_receiver_safe_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n        let invalid_receiver = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(\n                alice,\n                invalid_receiver,\n                token_ids[0],\n                values[0],\n                vec![].into(),\n            )\n            .expect_err(\"should not transfer tokens to the `Address::ZERO`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC1155InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_sender_safe_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n        let invalid_sender = Address::ZERO;\n\n        contract\n            .sender(invalid_sender)\n            .set_approval_for_all(alice, true)\n            .unwrap();\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(\n                invalid_sender,\n                alice,\n                token_ids[0],\n                values[0],\n                vec![].into(),\n            )\n            .expect_err(\"should not transfer tokens from the `Address::ZERO`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC1155InvalidSender {\n                sender\n            }) if sender == invalid_sender\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_missing_approval_safe_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n\n        let err = contract\n            .sender(bob)\n            .safe_transfer_from(\n                alice,\n                bob,\n                token_ids[0],\n                values[0],\n                vec![].into(),\n            )\n            .expect_err(\"should not transfer tokens without approval\");\n\n        assert!(matches!(\n            err,\n            Error::MissingApprovalForAll(ERC1155MissingApprovalForAll {\n                operator,\n                owner\n            }) if operator == bob \u0026\u0026 owner == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_insufficient_balance_safe_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 1));\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Bob's tokens to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(\n                bob,\n                dave,\n                token_ids[0],\n                values[0] + uint!(1_U256),\n                vec![].into(),\n            )\n            .expect_err(\"should not transfer tokens with insufficient balance\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientBalance(ERC1155InsufficientBalance {\n                sender,\n                balance,\n                needed,\n                token_id\n            }) if sender == bob \u0026\u0026 balance == values[0] \u0026\u0026 needed == values[0] + uint!(1_U256) \u0026\u0026 token_id == token_ids[0]\n        ));\n    }\n\n    #[motsu::test]\n    fn safe_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        dave: Address,\n        charlie: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, dave, 1));\n\n        contract\n            .sender(dave)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Dave's tokens to Alice\");\n\n        contract\n            .sender(alice)\n            .safe_transfer_from(\n                dave,\n                charlie,\n                token_ids[0],\n                values[0],\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect(\"should transfer tokens from Alice to Bob\");\n\n        let balance = contract.sender(alice).balance_of(charlie, token_ids[0]);\n\n        assert_eq!(values[0], balance);\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_receiver_safe_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        dave: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, dave, 1));\n        let invalid_receiver = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            .do_safe_transfer_from(\n                dave,\n                invalid_receiver,\n                token_ids,\n                values,\n                \u0026vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer tokens to the `Address::ZERO`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC1155InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_sender_safe_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n        let invalid_sender = Address::ZERO;\n\n        contract\n            .sender(invalid_sender)\n            .set_approval_for_all(alice, true)\n            .unwrap();\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(\n                invalid_sender,\n                alice,\n                token_ids[0],\n                values[0],\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer tokens from the `Address::ZERO`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC1155InvalidSender {\n                sender\n            }) if sender == invalid_sender\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_missing_approval_safe_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 1));\n\n        let err = contract\n            .sender(bob)\n            .safe_transfer_from(\n                alice,\n                bob,\n                token_ids[0],\n                values[0],\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer tokens without approval\");\n\n        assert!(matches!(\n            err,\n            Error::MissingApprovalForAll(ERC1155MissingApprovalForAll {\n                operator,\n                owner\n            }) if operator == bob \u0026\u0026 owner == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_insufficient_balance_safe_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, bob, 1));\n\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Bob's tokens to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(\n                bob,\n                dave,\n                token_ids[0],\n                values[0] + uint!(1_U256),\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer tokens with insufficient balance\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientBalance(ERC1155InsufficientBalance {\n                sender,\n                balance,\n                needed,\n                token_id\n            }) if sender == bob \u0026\u0026 balance == values[0] \u0026\u0026 needed == values[0] + uint!(1_U256) \u0026\u0026 token_id == token_ids[0]\n        ));\n    }\n\n    #[motsu::test]\n    fn safe_batch_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, dave, 2));\n        let amount_one = values[0] - uint!(1_U256);\n        let amount_two = values[1] - uint!(1_U256);\n\n        contract\n            .sender(dave)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Dave's tokens to Alice\");\n\n        contract\n            .sender(alice)\n            .safe_batch_transfer_from(\n                dave,\n                bob,\n                token_ids.clone(),\n                vec![amount_one, amount_two],\n                vec![].into(),\n            )\n            .expect(\"should transfer tokens from Alice to Bob\");\n\n        let balance_id_one =\n            contract.sender(alice).balance_of(bob, token_ids[0]);\n        let balance_id_two =\n            contract.sender(alice).balance_of(bob, token_ids[1]);\n\n        assert_eq!(amount_one, balance_id_one);\n        assert_eq!(amount_two, balance_id_two);\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_receiver_safe_batch_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 4));\n        let invalid_receiver = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            .safe_batch_transfer_from(\n                alice,\n                invalid_receiver,\n                token_ids.clone(),\n                values.clone(),\n                vec![].into(),\n            )\n            .expect_err(\"should not transfer tokens to the `Address::ZERO`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC1155InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_sender_safe_batch_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 4));\n        let invalid_sender = Address::ZERO;\n\n        contract\n            .sender(invalid_sender)\n            .set_approval_for_all(alice, true)\n            .unwrap();\n\n        let err = contract\n            .sender(alice)\n            .safe_batch_transfer_from(\n                invalid_sender,\n                alice,\n                token_ids.clone(),\n                values.clone(),\n                vec![].into(),\n            )\n            .expect_err(\"should not transfer tokens from the `Address::ZERO`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC1155InvalidSender {\n                sender\n            }) if sender == invalid_sender\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_missing_approval_safe_batch_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 2));\n\n        let err = contract\n            .sender(bob)\n            .safe_batch_transfer_from(\n                alice,\n                bob,\n                token_ids.clone(),\n                values.clone(),\n                vec![].into(),\n            )\n            .expect_err(\"should not transfer tokens without approval\");\n\n        assert!(matches!(\n            err,\n            Error::MissingApprovalForAll(ERC1155MissingApprovalForAll {\n                operator,\n                owner\n            }) if operator == bob \u0026\u0026 owner == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_insufficient_balance_safe_batch_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n        charlie: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, charlie, 2));\n\n        contract\n            .sender(charlie)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Charlie's tokens to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_batch_transfer_from(\n                charlie,\n                bob,\n                token_ids.clone(),\n                vec![values[0] + uint!(1_U256), values[1]],\n                vec![].into(),\n            )\n            .expect_err(\"should not transfer tokens with insufficient balance\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientBalance(ERC1155InsufficientBalance {\n                sender,\n                balance,\n                needed,\n                token_id\n            }) if sender == charlie \u0026\u0026 balance == values[0] \u0026\u0026 needed == values[0] + uint!(1_U256) \u0026\u0026 token_id == token_ids[0]\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_not_equal_arrays_safe_batch_transfer_from(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        dave: Address,\n        charlie: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 4));\n\n        contract\n            .sender(dave)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Dave's tokens to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_batch_transfer_from(\n                dave,\n                charlie,\n                token_ids.clone(),\n                append(values, 4),\n                vec![].into(),\n            )\n            .expect_err(\n                \"should not transfer tokens when not equal array lengths\",\n            );\n\n        assert!(matches!(\n            err,\n            Error::InvalidArrayLength(ERC1155InvalidArrayLength {\n                ids_length, values_length\n            }) if ids_length == uint!(4_U256) \u0026\u0026 values_length == uint!(5_U256)\n        ));\n    }\n\n    #[motsu::test]\n    fn safe_batch_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, dave, 2));\n\n        contract\n            .sender(dave)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Dave's tokens to Alice\");\n\n        contract\n            .sender(alice)\n            .safe_batch_transfer_from(\n                dave,\n                bob,\n                token_ids.clone(),\n                values.clone(),\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect(\"should transfer tokens from Alice to Bob\");\n\n        let balance_id_one =\n            contract.sender(alice).balance_of(bob, token_ids[0]);\n        let balance_id_two =\n            contract.sender(alice).balance_of(bob, token_ids[1]);\n\n        assert_eq!(values[0], balance_id_one);\n        assert_eq!(values[1], balance_id_two);\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_receiver_safe_batch_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 4));\n        let invalid_receiver = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            .safe_batch_transfer_from(\n                alice,\n                invalid_receiver,\n                token_ids.clone(),\n                values.clone(),\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer tokens to the `Address::ZERO`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC1155InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_sender_safe_batch_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 4));\n        let invalid_sender = Address::ZERO;\n\n        contract\n            .sender(invalid_sender)\n            .set_approval_for_all(alice, true)\n            .unwrap();\n\n        let err = contract\n            .sender(alice)\n            .safe_batch_transfer_from(\n                invalid_sender,\n                alice,\n                token_ids.clone(),\n                values.clone(),\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer tokens from the `Address::ZERO`\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC1155InvalidSender {\n                sender\n            }) if sender == invalid_sender\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_missing_approval_safe_batch_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 2));\n\n        let err = contract\n            .sender(bob)\n            .safe_batch_transfer_from(\n                alice,\n                bob,\n                token_ids.clone(),\n                values.clone(),\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer tokens without approval\");\n\n        assert!(matches!(\n            err,\n            Error::MissingApprovalForAll(ERC1155MissingApprovalForAll {\n                operator,\n                owner\n            }) if operator == bob \u0026\u0026 owner == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_insufficient_balance_safe_batch_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        bob: Address,\n        charlie: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, charlie, 2));\n\n        contract\n            .sender(charlie)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Charlie's tokens to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_batch_transfer_from(\n                charlie,\n                bob,\n                token_ids.clone(),\n                vec![values[0] + uint!(1_U256), values[1]],\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer tokens with insufficient balance\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientBalance(ERC1155InsufficientBalance {\n                sender,\n                balance,\n                needed,\n                token_id\n            }) if sender == charlie \u0026\u0026 balance == values[0] \u0026\u0026 needed == values[0] + uint!(1_U256) \u0026\u0026 token_id == token_ids[0]\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_not_equal_arrays_safe_batch_transfer_from_with_data(\n        contract: Contract\u003cErc1155\u003e,\n        alice: Address,\n        dave: Address,\n        charlie: Address,\n    ) {\n        let (token_ids, values) =\n            contract.init(alice, |contract| init(contract, alice, 4));\n\n        contract\n            .sender(dave)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve Dave's tokens to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_batch_transfer_from(\n                dave,\n                charlie,\n                token_ids.clone(),\n                append(values, 4),\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\n                \"should not transfer tokens when not equal array lengths\",\n            );\n\n        assert!(matches!(\n            err,\n            Error::InvalidArrayLength(ERC1155InvalidArrayLength {\n                ids_length, values_length\n            }) if ids_length == uint!(4_U256) \u0026\u0026 values_length == uint!(5_U256)\n        ));\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc1155 as IErc1155\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0xd9b67a26_u32.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cErc1155\u003e, alice: Address) {\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc1155 as IErc1155\u003e::interface_id()));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc1155 as IErc165\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678_u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":100}},{"line":373,"address":[],"length":0,"stats":{"Line":300}},{"line":376,"address":[],"length":0,"stats":{"Line":5}},{"line":381,"address":[],"length":0,"stats":{"Line":16}},{"line":383,"address":[],"length":0,"stats":{"Line":4}},{"line":386,"address":[],"length":0,"stats":{"Line":64}},{"line":392,"address":[],"length":0,"stats":{"Line":21}},{"line":397,"address":[],"length":0,"stats":{"Line":105}},{"line":400,"address":[],"length":0,"stats":{"Line":27}},{"line":401,"address":[],"length":0,"stats":{"Line":81}},{"line":404,"address":[],"length":0,"stats":{"Line":10}},{"line":412,"address":[],"length":0,"stats":{"Line":32}},{"line":413,"address":[],"length":0,"stats":{"Line":8}},{"line":416,"address":[],"length":0,"stats":{"Line":12}},{"line":424,"address":[],"length":0,"stats":{"Line":38}},{"line":425,"address":[],"length":0,"stats":{"Line":10}},{"line":431,"address":[],"length":0,"stats":{"Line":6}},{"line":432,"address":[],"length":0,"stats":{"Line":6}},{"line":433,"address":[],"length":0,"stats":{"Line":4}},{"line":469,"address":[],"length":0,"stats":{"Line":80}},{"line":476,"address":[],"length":0,"stats":{"Line":244}},{"line":478,"address":[],"length":0,"stats":{"Line":76}},{"line":480,"address":[],"length":0,"stats":{"Line":312}},{"line":481,"address":[],"length":0,"stats":{"Line":944}},{"line":484,"address":[],"length":0,"stats":{"Line":103}},{"line":485,"address":[],"length":0,"stats":{"Line":105}},{"line":486,"address":[],"length":0,"stats":{"Line":105}},{"line":487,"address":[],"length":0,"stats":{"Line":175}},{"line":489,"address":[],"length":0,"stats":{"Line":33}},{"line":530,"address":[],"length":0,"stats":{"Line":67}},{"line":538,"address":[],"length":0,"stats":{"Line":548}},{"line":540,"address":[],"length":0,"stats":{"Line":55}},{"line":541,"address":[],"length":0,"stats":{"Line":48}},{"line":550,"address":[],"length":0,"stats":{"Line":55}},{"line":579,"address":[],"length":0,"stats":{"Line":3}},{"line":586,"address":[],"length":0,"stats":{"Line":24}},{"line":619,"address":[],"length":0,"stats":{"Line":43}},{"line":626,"address":[],"length":0,"stats":{"Line":258}},{"line":648,"address":[],"length":0,"stats":{"Line":7}},{"line":654,"address":[],"length":0,"stats":{"Line":49}},{"line":680,"address":[],"length":0,"stats":{"Line":9}},{"line":686,"address":[],"length":0,"stats":{"Line":45}},{"line":707,"address":[],"length":0,"stats":{"Line":21}},{"line":713,"address":[],"length":0,"stats":{"Line":21}},{"line":714,"address":[],"length":0,"stats":{"Line":1}},{"line":715,"address":[],"length":0,"stats":{"Line":1}},{"line":759,"address":[],"length":0,"stats":{"Line":56}},{"line":767,"address":[],"length":0,"stats":{"Line":56}},{"line":768,"address":[],"length":0,"stats":{"Line":56}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":46}},{"line":852,"address":[],"length":0,"stats":{"Line":46}},{"line":853,"address":[],"length":0,"stats":{"Line":2}},{"line":854,"address":[],"length":0,"stats":{"Line":2}},{"line":864,"address":[],"length":0,"stats":{"Line":43}},{"line":890,"address":[],"length":0,"stats":{"Line":16}},{"line":896,"address":[],"length":0,"stats":{"Line":16}},{"line":897,"address":[],"length":0,"stats":{"Line":4}},{"line":898,"address":[],"length":0,"stats":{"Line":4}},{"line":908,"address":[],"length":0,"stats":{"Line":7}},{"line":946,"address":[],"length":0,"stats":{"Line":19}},{"line":954,"address":[],"length":0,"stats":{"Line":19}},{"line":955,"address":[],"length":0,"stats":{"Line":4}},{"line":956,"address":[],"length":0,"stats":{"Line":4}},{"line":960,"address":[],"length":0,"stats":{"Line":4}},{"line":961,"address":[],"length":0,"stats":{"Line":4}},{"line":986,"address":[],"length":0,"stats":{"Line":156}},{"line":993,"address":[],"length":0,"stats":{"Line":156}},{"line":994,"address":[],"length":0,"stats":{"Line":39}},{"line":996,"address":[],"length":0,"stats":{"Line":8}},{"line":997,"address":[],"length":0,"stats":{"Line":8}},{"line":998,"address":[],"length":0,"stats":{"Line":16}},{"line":999,"address":[],"length":0,"stats":{"Line":16}},{"line":1000,"address":[],"length":0,"stats":{"Line":8}},{"line":1001,"address":[],"length":0,"stats":{"Line":8}},{"line":1011,"address":[],"length":0,"stats":{"Line":271}},{"line":1012,"address":[],"length":0,"stats":{"Line":123}},{"line":1013,"address":[],"length":0,"stats":{"Line":123}},{"line":1032,"address":[],"length":0,"stats":{"Line":85}},{"line":1036,"address":[],"length":0,"stats":{"Line":255}},{"line":1037,"address":[],"length":0,"stats":{"Line":5}},{"line":1038,"address":[],"length":0,"stats":{"Line":20}},{"line":1039,"address":[],"length":0,"stats":{"Line":10}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":22}},{"line":1057,"address":[],"length":0,"stats":{"Line":44}},{"line":1058,"address":[],"length":0,"stats":{"Line":79}},{"line":1059,"address":[],"length":0,"stats":{"Line":4}},{"line":1060,"address":[],"length":0,"stats":{"Line":4}},{"line":1092,"address":[],"length":0,"stats":{"Line":58}},{"line":1093,"address":[],"length":0,"stats":{"Line":58}},{"line":1094,"address":[],"length":0,"stats":{"Line":87}},{"line":1096,"address":[],"length":0,"stats":{"Line":29}},{"line":1107,"address":[],"length":0,"stats":{"Line":29}},{"line":1110,"address":[],"length":0,"stats":{"Line":29}},{"line":1121,"address":[],"length":0,"stats":{"Line":29}},{"line":1124,"address":[],"length":0,"stats":{"Line":29}}],"covered":95,"coverable":113},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc1155","receiver.rs"],"content":"//! Module with an interface required for smart contract in order to receive\n//! ERC-1155 token transfers.\n#![allow(missing_docs)]\n#![cfg_attr(coverage_nightly, coverage(off))]\nuse alloc::vec;\n\nuse stylus_sdk::prelude::sol_interface;\n\nsol_interface! {\n    /// [`super::Erc1155`] token receiver interface.\n    ///\n    /// Interface for any contract that wants to support safe transfers from\n    /// [`super::Erc1155`] asset contracts.\n    interface IERC1155Receiver {\n        /// Handles the receipt of a single ERC-1155 token type. This function\n        /// is called at the end of [`super::IErc1155::safe_transfer_from`]\n        /// after the balance has been updated.\n        ///\n        /// NOTE: To accept the transfer, this must return\n        /// [`super::SINGLE_TRANSFER_FN_SELECTOR`], or its own function\n        /// selector.\n        ///\n        /// # Arguments\n        ///\n        /// # Arguments\n        ///\n        /// * `operator` - The address which initiated the transfer.\n        /// * `from` - The address which previously owned the token.\n        /// * `id` - The ID of the token being transferred.\n        /// * `value` - The amount of tokens being transferred.\n        /// * `data` - Additional data with no specified format.\n        #[allow(missing_docs)]\n        function onERC1155Received(\n            address operator,\n            address from,\n            uint256 id,\n            uint256 value,\n            bytes calldata data\n        ) external returns (bytes4);\n\n        /// Handles the receipt of multiple ERC-1155 token types. This function\n        /// is called at the end of\n        /// [`super::IErc1155::safe_batch_transfer_from`] after the balances\n        /// have been updated.\n        ///\n        /// NOTE: To accept the transfer(s), this must return\n        /// [`super::BATCH_TRANSFER_FN_SELECTOR`], or its own function selector.\n        ///\n        /// # Arguments\n        ///\n        /// # Arguments\n        ///\n        /// * `operator` - The address which initiated the batch transfer.\n        /// * `from` - The address which previously owned the token.\n        /// * `ids` - An array containing ids of each token being transferred\n        ///   (order and length must match `values` array).\n        /// * `values` - An array containing amounts of each token being\n        ///   transferred (order and length must match `ids` array).\n        /// * `data` - Additional data with no specified format.\n        #[allow(missing_docs)]\n        function onERC1155BatchReceived(\n            address operator,\n            address from,\n            uint256[] calldata ids,\n            uint256[] calldata values,\n            bytes calldata data\n        ) external returns (bytes4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","extensions","burnable.rs"],"content":"//! Optional Burnable extension of the ERC-20 standard.\n\nuse alloy_primitives::{Address, U256};\nuse stylus_sdk::msg;\n\nuse crate::token::erc20::{self, Erc20};\n\n/// Extension of [`Erc20`] that allows token holders to destroy both\n/// their own tokens and those that they have an allowance for,\n/// in a way that can be recognized off-chain (via event analysis).\npub trait IErc20Burnable {\n    /// The error type associated to this ERC-20 Burnable trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Destroys a `value` amount of tokens from the caller, lowering the total\n    /// supply.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - Amount to be burnt.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc20::Error::InsufficientBalance`] - If the `from` address doesn't\n    ///   have enough tokens.\n    ///\n    /// # Events\n    ///\n    /// * [`erc20::Transfer`].\n    fn burn(\u0026mut self, value: U256) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Destroys a `value` amount of tokens from `account`, lowering the total\n    /// supply.\n    ///\n    /// # Arguments\n    ///\n    /// * `account` - Owner's address.\n    /// * `value` - Amount to be burnt.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc20::Error::InsufficientAllowance`] - If not enough allowance is\n    ///   available.\n    /// * [`erc20::Error::InvalidSender`] - If the `from` address is\n    ///   [`Address::ZERO`].\n    /// * [`erc20::Error::InsufficientBalance`] - If the `from` address doesn't\n    ///   have enough tokens.\n    ///\n    /// # Events\n    ///\n    /// * [`erc20::Transfer`].\n    fn burn_from(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\nimpl IErc20Burnable for Erc20 {\n    type Error = erc20::Error;\n\n    fn burn(\u0026mut self, value: U256) -\u003e Result\u003c(), Self::Error\u003e {\n        self._burn(msg::sender(), value)\n    }\n\n    fn burn_from(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self._spend_allowance(account, msg::sender(), value)?;\n        self._burn(account, value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{uint, Address, U256};\n    use motsu::prelude::*;\n\n    use super::IErc20Burnable;\n    use crate::token::erc20::{Erc20, Error, IErc20};\n\n    #[motsu::test]\n    fn burns(contract: Contract\u003cErc20\u003e, alice: Address) {\n        let zero = U256::ZERO;\n        let one = uint!(1_U256);\n\n        assert_eq!(zero, contract.sender(alice).total_supply());\n\n        // Mint some tokens for Alice.\n\n        let two = uint!(2_U256);\n        contract\n            .sender(alice)\n            ._update(Address::ZERO, alice, two)\n            .motsu_unwrap();\n        assert_eq!(two, contract.sender(alice).balance_of(alice));\n        assert_eq!(two, contract.sender(alice).total_supply());\n\n        contract.sender(alice).burn(one).motsu_unwrap();\n\n        assert_eq!(one, contract.sender(alice).balance_of(alice));\n        assert_eq!(one, contract.sender(alice).total_supply());\n    }\n\n    #[motsu::test]\n    fn burns_errors_when_insufficient_balance(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let zero = U256::ZERO;\n        let one = uint!(1_U256);\n\n        assert_eq!(zero, contract.sender(alice).balance_of(alice));\n\n        let result = contract.sender(alice).burn(one);\n        assert!(matches!(result, Err(Error::InsufficientBalance(_))));\n    }\n\n    #[motsu::test]\n    fn burn_from(contract: Contract\u003cErc20\u003e, alice: Address, bob: Address) {\n        // Alice approves `msg::sender`.\n        let one = uint!(1_U256);\n        contract.sender(alice).approve(bob, one).motsu_unwrap();\n\n        // Mint some tokens for Alice.\n        let two = uint!(2_U256);\n        contract\n            .sender(alice)\n            ._update(Address::ZERO, alice, two)\n            .motsu_unwrap();\n        assert_eq!(two, contract.sender(alice).balance_of(alice));\n        assert_eq!(two, contract.sender(alice).total_supply());\n\n        contract.sender(bob).burn_from(alice, one).motsu_unwrap();\n\n        assert_eq!(one, contract.sender(alice).balance_of(alice));\n        assert_eq!(one, contract.sender(alice).total_supply());\n        assert_eq!(U256::ZERO, contract.sender(alice).allowance(bob, alice));\n    }\n\n    #[motsu::test]\n    fn burns_from_errors_when_insufficient_balance(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        // Alice approves `msg::sender`.\n        let zero = U256::ZERO;\n        let one = uint!(1_U256);\n\n        contract.sender(alice).approve(bob, one).motsu_unwrap();\n        assert_eq!(zero, contract.sender(alice).balance_of(bob));\n\n        let one = uint!(1_U256);\n\n        let result = contract.sender(bob).burn_from(alice, one);\n        assert!(matches!(result, Err(Error::InsufficientBalance(_))));\n    }\n\n    #[motsu::test]\n    fn burns_from_errors_when_insufficient_allowance(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        // Mint some tokens for Alice.\n        let one = uint!(1_U256);\n        contract\n            .sender(alice)\n            ._update(Address::ZERO, alice, one)\n            .motsu_unwrap();\n        assert_eq!(one, contract.sender(alice).balance_of(alice));\n\n        let result = contract.sender(alice).burn_from(alice, one);\n        assert!(matches!(result, Err(Error::InsufficientAllowance(_))));\n    }\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":16}},{"line":72,"address":[],"length":0,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","extensions","capped.rs"],"content":"//! Capped Contract.\n//!\n//! Extension of ERC-20 standard that adds a cap to the supply of tokens.\n//!\n//! Note that they will not be capped by simply including this module,\n//! but only once the checks are put in place.\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::U256;\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{call::MethodError, prelude::*, storage::StorageU256};\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Indicates an error related to the operation that failed\n        /// because `total_supply` exceeded the `cap`.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC20ExceededCap(uint256 increased_supply, uint256 cap);\n\n        /// Indicates an error related to the operation that failed\n        /// because the supplied `cap` is not a valid cap value.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC20InvalidCap(uint256 cap);\n    }\n}\n\n/// A Capped error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates an error related to the operation that failed\n    /// because `total_supply` exceeded the `cap`.\n    ExceededCap(ERC20ExceededCap),\n    /// Indicates an error related to the operation that failed\n    /// because the supplied `cap` is not a valid cap value.\n    InvalidCap(ERC20InvalidCap),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of a [`Capped`] Contract.\n#[storage]\npub struct Capped {\n    /// A cap to the supply of tokens.\n    pub(crate) cap: StorageU256,\n}\n\n/// Interface for the token supply cap logic.\n#[interface_id]\npub trait ICapped {\n    /// Returns the cap on the token's total supply.\n    #[must_use]\n    fn cap(\u0026self) -\u003e U256;\n}\n\n#[public]\n#[implements(ICapped)]\nimpl Capped {\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `cap` - The token supply cap.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidCap`] - If cap is [`U256::ZERO`].\n    #[constructor]\n    pub fn constructor(\u0026mut self, cap: U256) -\u003e Result\u003c(), Error\u003e {\n        if cap.is_zero() {\n            return Err(Error::InvalidCap(ERC20InvalidCap { cap }));\n        }\n        self.cap.set(cap);\n        Ok(())\n    }\n}\n\n#[public]\nimpl ICapped for Capped {\n    fn cap(\u0026self) -\u003e U256 {\n        self.cap.get()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{uint, Address};\n    use motsu::prelude::Contract;\n    use stylus_sdk::prelude::*;\n\n    use super::*;\n\n    unsafe impl TopLevelStorage for Capped {}\n\n    #[motsu::test]\n    fn cap_works(contract: Contract\u003cCapped\u003e, alice: Address) {\n        let value = uint!(2024_U256);\n        contract.init(alice, |contract| contract.cap.set(value));\n        assert_eq!(contract.sender(alice).cap(), value);\n\n        let value = uint!(1_U256);\n        contract.init(alice, |contract| contract.cap.set(value));\n        assert_eq!(contract.sender(alice).cap(), value);\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":4}}],"covered":2,"coverable":7},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","extensions","erc4626.rs"],"content":"//! ERC-4626 Tokenized Vault Standard Implementation as defined in [ERC-4626].\n//!\n//! This extension allows the minting and burning of \"shares\" (represented using\n//! the ERC-20 inheritance) in exchange for underlying \"assets\" through\n//! standardized `deposit`, `mint`, `redeem` and `burn` workflows. This contract\n//! extends the ERC-20 standard. Any additional extensions included along it\n//! would affect the \"shares\" token represented by this contract and not the\n//! \"assets\" token which is an independent contract.\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{uint, Address, U256, U8};\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{\n    call::{Call, MethodError},\n    contract, evm, msg,\n    prelude::*,\n    storage::{StorageAddress, StorageU8},\n};\n\nuse super::IErc20Metadata;\nuse crate::{\n    token::erc20::{\n        self,\n        interface::{Erc20Interface, IErc20MetadataInterface},\n        utils::{safe_erc20, ISafeErc20, SafeErc20},\n        Erc20, IErc20,\n    },\n    utils::math::alloy::{Math, Rounding},\n};\n\nconst ONE: U256 = uint!(1_U256);\nconst TEN: U256 = uint!(10_U256);\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when assets are deposited into the contract.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n        /// Emitted when assets are withdrawn from the contract.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event Withdraw(\n            address indexed sender,\n            address indexed receiver,\n            address indexed owner,\n            uint256 assets,\n            uint256 shares\n        );\n    }\n\n    sol! {\n        /// Indicates an attempt to deposit more assets than the max amount for\n        /// `receiver`.\n        ///\n        /// * `receiver` - Address of the asset's recipient.\n        /// * `assets` - Amount of assets deposited.\n        /// * `max` - Maximum amount of assets that can be deposited.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n        /// Indicates an attempt to mint more shares than the max amount for\n        /// `receiver`.\n        ///\n        /// * `receiver` - Address of share's recipient.\n        /// * `shares` - Amount of shares to mint.\n        /// * `max` - Maximum amount of shares that can be minted.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n        /// Indicates an attempt to withdraw more assets than the max amount for\n        /// `owner`.\n        ///\n        /// * `owner` - Address of the asset's owner.\n        /// * `assets` - Amount of assets to withdraw.\n        /// * `max` - Maximum amount of assets that can be withdrawn.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n        /// Indicates an attempt to redeem more shares than the max amount for\n        /// `owner`.\n        ///\n        /// * `owner` - Address of the share's owner.\n        /// * `shares` - Amount of shares to redeem.\n        /// * `max` - Maximum amount of shares that can be redeemed.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n        /// The address is not a valid ERC-20 token.\n        ///\n        /// * `asset` - Address of the invalid ERC-20 token.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error InvalidAsset(address asset);\n    }\n}\n\n/// An [`Erc4626`] error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates an attempt to deposit more assets than the max amount for\n    /// `receiver`.\n    ExceededMaxDeposit(ERC4626ExceededMaxDeposit),\n    /// Indicates an attempt to mint more shares than the max amount for\n    /// `receiver`.\n    ExceededMaxMint(ERC4626ExceededMaxMint),\n    /// Indicates an attempt to withdraw more assets than the max amount for\n    /// `owner`.\n    ExceededMaxWithdraw(ERC4626ExceededMaxWithdraw),\n    /// Indicates an attempt to redeem more shares than the max amount for\n    /// `owner`.\n    ExceededMaxRedeem(ERC4626ExceededMaxRedeem),\n    /// The address is not a valid ERC-20 token.\n    InvalidAsset(InvalidAsset),\n    /// An operation with an ERC-20 token failed.\n    SafeErc20FailedOperation(safe_erc20::SafeErc20FailedOperation),\n    /// Indicates a failed [`ISafeErc20::safe_decrease_allowance`] request.\n    SafeErc20FailedDecreaseAllowance(\n        safe_erc20::SafeErc20FailedDecreaseAllowance,\n    ),\n    /// Indicates an error related to the current balance of `sender`. Used in\n    /// transfers.\n    InsufficientBalance(erc20::ERC20InsufficientBalance),\n    /// Indicates a failure with the token `sender`. Used in transfers.\n    InvalidSender(erc20::ERC20InvalidSender),\n    /// Indicates a failure with the token `receiver`. Used in transfers.\n    InvalidReceiver(erc20::ERC20InvalidReceiver),\n    /// Indicates a failure with the `spender`’s `allowance`. Used in\n    /// transfers.\n    InsufficientAllowance(erc20::ERC20InsufficientAllowance),\n    /// Indicates a failure with the `spender` to be approved. Used in\n    /// approvals.\n    InvalidSpender(erc20::ERC20InvalidSpender),\n    /// Indicates a failure with the `approver` of a token to be approved. Used\n    /// in approvals. approver Address initiating an approval operation.\n    InvalidApprover(erc20::ERC20InvalidApprover),\n}\n\nimpl From\u003csafe_erc20::Error\u003e for Error {\n    fn from(value: safe_erc20::Error) -\u003e Self {\n        match value {\n            safe_erc20::Error::SafeErc20FailedOperation(e) =\u003e {\n                Error::SafeErc20FailedOperation(e)\n            }\n            safe_erc20::Error::SafeErc20FailedDecreaseAllowance(e) =\u003e {\n                Error::SafeErc20FailedDecreaseAllowance(e)\n            }\n        }\n    }\n}\n\nimpl From\u003cerc20::Error\u003e for Error {\n    fn from(value: erc20::Error) -\u003e Self {\n        match value {\n            erc20::Error::InsufficientBalance(e) =\u003e {\n                Error::InsufficientBalance(e)\n            }\n            erc20::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc20::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc20::Error::InsufficientAllowance(e) =\u003e {\n                Error::InsufficientAllowance(e)\n            }\n            erc20::Error::InvalidSpender(e) =\u003e Error::InvalidSpender(e),\n            erc20::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n        }\n    }\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of an [`Erc4626`] token.\n#[storage]\npub struct Erc4626 {\n    /// Token Address of the vault.\n    pub(crate) asset: StorageAddress,\n    /// Token decimals.\n    pub(crate) underlying_decimals: StorageU8,\n    /// Decimals offset.\n    pub(crate) decimals_offset: StorageU8,\n    /// [`SafeErc20`] contract.\n    safe_erc20: SafeErc20,\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for Erc4626 {}\n\n/// ERC-4626 Tokenized Vault Standard Interface\n#[interface_id]\npub trait IErc4626: IErc20Metadata {\n    /// The error type associated to the trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns the address of the underlying token used for the Vault for\n    /// accounting, depositing, and withdrawing.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    #[must_use]\n    fn asset(\u0026self) -\u003e Address;\n\n    /// Returns the total amount of the underlying asset that is “managed” by\n    /// Vault.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not a ERC-20\n    ///   Token address.\n    fn total_assets(\u0026self) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Returns the amount of shares that the Vault would exchange for the\n    /// amount of assets provided, in an ideal scenario where all the conditions\n    /// are met.\n    ///\n    /// NOTE:\n    /// - This calculation MAY NOT reflect the “per-user” price-per-share, and\n    ///   instead should reflect the “average-user’s” price-per-share, meaning\n    ///   what the average user should expect to see when exchanging to and\n    ///   from.\n    /// - To expose this function in your contract's ABI, implement it as shown\n    ///   in the Examples section below, accepting only the `assets` parameter.\n    ///   The `erc20` reference should come from your contract's state. The\n    ///   implementation should forward the call to your internal storage\n    ///   instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `assets` - Amount of the underlying asset.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow.\n    fn convert_to_shares(\u0026self, assets: U256) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Returns the amount of assets that the Vault would exchange for the\n    /// amount of shares provided, in an ideal scenario where all the conditions\n    /// are met.\n    ///\n    /// NOTE:\n    /// - This calculation MAY NOT reflect the “per-user” price-per-share, and\n    ///   instead should reflect the “average-user’s” price-per-share, meaning\n    ///   what the average user should expect to see when exchanging to and\n    ///   from.\n    /// - To expose this function in your contract's ABI, implement it as shown\n    ///   in the Examples section below, accepting only the `shares` parameter.\n    ///   The `erc20` reference should come from your contract's state. The\n    ///   implementation should forward the call to your internal storage\n    ///   instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `shares` - Number of shares.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow.\n    fn convert_to_assets(\u0026self, shares: U256) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Returns the maximum amount of the underlying asset that can be deposited\n    /// into the Vault for the receiver, through a deposit call.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `receiver` - The address of the entity receiving the shares.\n    #[must_use]\n    fn max_deposit(\u0026self, receiver: Address) -\u003e U256;\n\n    /// Allows an on-chain or off-chain user to simulate the effects of their\n    /// deposit at the current block, given current on-chain conditions.\n    ///\n    /// NOTE:\n    /// - Any unfavorable discrepancy between [`IErc4626::convert_to_shares`]\n    ///   and [`IErc4626::preview_deposit`] SHOULD be considered slippage in\n    ///   share price or some other type of condition, meaning the depositor\n    ///   will lose assets by depositing.\n    /// - To expose this function in your contract's ABI, implement it as shown\n    ///   in the Examples section below, accepting only the `assets` parameter.\n    ///   The `erc20` reference should come from your contract's state. The\n    ///   implementation should forward the call to your internal storage\n    ///   instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `assets` - Amount of the underlying asset to deposit.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow during conversion.\n    fn preview_deposit(\u0026self, assets: U256) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Deposits exactly `assets` amount of underlying tokens into the Vault and\n    /// mints corresponding Vault shares to `receiver`.\n    ///\n    /// Returns the amount of shares minted.\n    ///\n    /// NOTE: To expose this function in your contract's ABI, implement it as\n    /// shown in the Examples section below, accepting only the `assets` and\n    /// `receiver` parameters. The `erc20` reference should come from your\n    /// contract's state. The implementation should forward the call to your\n    /// internal storage instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `assets` - Amount of the underlying asset to deposit.\n    /// * `receiver` - The address receiving the shares.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    /// * [`Error::ExceededMaxDeposit`] - If deposit amount exceeds maximum\n    ///   allowed.\n    /// * [`safe_erc20::Error::SafeErc20FailedOperation`] - If caller lacks\n    ///   sufficient balance or hasn't approved enough tokens to the Vault\n    ///   contract.\n    ///\n    /// # Events\n    ///\n    /// * [`Deposit`]\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow during conversion.\n    fn deposit(\n        \u0026mut self,\n        assets: U256,\n        receiver: Address,\n    ) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Returns the maximum amount of the Vault shares that can be minted for\n    /// the receiver, through a mint call.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `receiver` - The address of the entity receiving the shares.\n    #[must_use]\n    fn max_mint(\u0026self, receiver: Address) -\u003e U256;\n\n    /// Allows an on-chain or off-chain user to simulate the effects of their\n    /// mint at the current block, given current on-chain conditions.\n    ///\n    /// NOTE:\n    /// - Any unfavorable discrepancy between [`IErc4626::convert_to_assets`]\n    ///   and [`IErc4626::preview_mint`] SHOULD be considered slippage in share\n    ///   price or some other type of condition, meaning the depositor will lose\n    ///   assets by minting.\n    /// - To expose this function in your contract's ABI, implement it as shown\n    ///   in the Examples section below, accepting only the `shares` parameter.\n    ///   The `erc20` reference should come from your contract's state. The\n    ///   implementation should forward the call to your internal storage\n    ///   instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `shares` - Number of shares to mint.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow during conversion.\n    fn preview_mint(\u0026self, shares: U256) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Mints the specified number of shares to `receiver` by pulling the\n    /// required amount of underlying tokens from caller.\n    ///\n    /// Returns amount of tokens deposited.\n    ///\n    /// NOTE:\n    /// - Most implementations will require pre-approval of the Vault with the\n    ///   Vault’s underlying asset token.\n    /// - To expose this function in your contract's ABI, implement it as shown\n    ///   in the Examples section below, accepting only the `shares` and\n    ///   `receiver` parameters. The `erc20` reference should come from your\n    ///   contract's state. The implementation should forward the call to your\n    ///   internal storage instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `shares` - Number of shares to mint.\n    /// * `receiver` - The address receiving the shares.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    /// * [`Error::ExceededMaxMint`] - If requested shares amount exceeds\n    ///   maximum mintable amount for `receiver`.\n    /// * [`safe_erc20::Error::SafeErc20FailedOperation`] - If caller lacks\n    ///   sufficient balance or hasn't approved enough tokens to the Vault\n    ///   contract.\n    ///\n    /// # Events\n    ///\n    /// * [`Deposit`]\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow during conversion.\n    fn mint(\n        \u0026mut self,\n        shares: U256,\n        receiver: Address,\n    ) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Returns the maximum amount of the underlying asset that can be withdrawn\n    /// from the owner balance in the Vault, through a withdraw call.\n    ///\n    /// NOTE: To expose this function in your contract's ABI, implement it as\n    /// shown in the Examples section below, accepting only the `owner`\n    /// parameter. The `erc20` reference should come from your contract's state.\n    /// The implementation should forward the call to your internal storage\n    /// instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `owner` - The address of the entity owning the shares.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow during conversion.\n    fn max_withdraw(\u0026self, owner: Address) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Allows an on-chain or off-chain user to simulate the effects of their\n    /// withdrawal at the current block, given current on-chain conditions.\n    ///\n    /// NOTE: To expose this function in your contract's ABI, implement it as\n    /// shown in the Examples section below, accepting only the `assets`\n    /// parameter. The `erc20` reference should come from your contract's state.\n    /// The implementation should forward the call to your internal storage\n    /// instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `assets` - Amount of the underlying asset to withdraw.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow during conversion.\n    fn preview_withdraw(\u0026self, assets: U256) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Withdraws the specified amount of underlying tokens to `receiver` by\n    /// burning the required number of shares from `owner`.\n    ///\n    /// Returns number of shares burned.\n    ///\n    /// NOTE:\n    /// - Some implementations will require pre-requesting to the Vault before a\n    ///   withdrawal may be performed. Those methods should be performed\n    ///   separately.\n    /// - To expose this function in your contract's ABI, implement it as shown\n    ///   in the Examples section below, accepting only the `assets`, `receiver`\n    ///   and `owner` parameters. The `erc20` reference should come from your\n    ///   contract's state. The implementation should forward the call to your\n    ///   internal storage instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `assets` - Amount of the underlying asset to withdraw.\n    /// * `receiver` - The address receiving the withdrawn assets.\n    /// * `owner` - The address owning the shares to be deducted.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    /// * [`Error::ExceededMaxWithdraw`] - If requested assets amount exceeds\n    ///   maximum withdrawable amount for `owner`.\n    /// * [`erc20::Error::InsufficientAllowance`] - If caller is not `owner` and\n    ///   lacks sufficient allowance for shares.\n    /// * [`erc20::Error::InvalidApprover`] - If `owner` address is\n    ///   [`Address::ZERO`] when burning shares.\n    /// * [`safe_erc20::Error::SafeErc20FailedOperation`] - If underlying token\n    ///   transfer fails or returns false.\n    ///\n    /// # Events\n    ///\n    /// * [`Withdraw`]\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow during conversion.\n    fn withdraw(\n        \u0026mut self,\n        assets: U256,\n        receiver: Address,\n        owner: Address,\n    ) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Returns the maximum amount of Vault shares that can be redeemed from the\n    /// owner balance in the Vault, through a redeem call.\n    ///\n    /// NOTE: To expose this function in your contract's ABI, implement it as\n    /// shown in the Examples section below, accepting only the `owner`\n    /// parameter. The `erc20` reference should come from your contract's state.\n    /// The implementation should forward the call to your internal storage\n    /// instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `owner` - The address of the entity owning the shares.\n    #[must_use]\n    fn max_redeem(\u0026self, owner: Address) -\u003e U256;\n\n    /// Allows an on-chain or off-chain user to simulate the effects of their\n    /// redemption at the current block, given current on-chain conditions.\n    ///\n    /// NOTE: To expose this function in your contract's ABI, implement it as\n    /// shown in the Examples section below, accepting only the `shares`\n    /// parameter. The `erc20` reference should come from your contract's state.\n    /// The implementation should forward the call to your internal storage\n    /// instance along with the `erc20` reference.\n    ///\n    /// NOTE: Any unfavorable discrepancy between\n    /// [`IErc4626::convert_to_assets`] and [`IErc4626::preview_redeem`] SHOULD\n    /// be considered slippage in share price or some other type of condition,\n    /// meaning the depositor will lose assets by redeeming.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `shares` - Number of shares to redeem.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow during conversion.\n    fn preview_redeem(\u0026self, shares: U256) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Burns the specified number of shares from `owner` and sends the\n    /// corresponding amount of underlying tokens to `receiver`.\n    ///\n    /// Returns amount of tokens transferred.\n    ///\n    /// NOTE: To expose this function in your contract's ABI, implement it as\n    /// shown in the Examples section below, accepting only the `shares`,\n    /// `receiver` and `owner` parameters. The `erc20` reference should come\n    /// from your contract's state. The implementation should forward the call\n    /// to your internal storage instance along with the `erc20` reference.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `shares` - Number of shares to redeem.\n    /// * `receiver` - The address receiving the underlying assets.\n    /// * `owner` - The address owning the shares to be redeemed.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the [`IErc4626::asset()`] is not an\n    ///   ERC-20 Token address.\n    /// * [`Error::ExceededMaxRedeem`] - If requested shares amount exceeds\n    ///   maximum redeemable amount for owner.\n    /// * [`erc20::Error::InsufficientAllowance`] - If caller is not `owner` and\n    ///   lacks sufficient allowance for shares.\n    /// * [`safe_erc20::Error::SafeErc20FailedOperation`] - If underlying token\n    ///   transfer fails or returns false.\n    ///\n    /// # Events\n    ///\n    /// * [`Withdraw`]\n    ///\n    /// # Panics\n    ///\n    /// * If multiplication or division operations overflow during conversion.\n    fn redeem(\n        \u0026mut self,\n        shares: U256,\n        receiver: Address,\n        owner: Address,\n    ) -\u003e Result\u003cU256, Self::Error\u003e;\n}\n\nimpl Erc4626 {\n    /// See [`IErc4626::asset`].\n    #[must_use]\n    pub fn asset(\u0026self) -\u003e Address {\n        self.asset.get()\n    }\n\n    /// See [`IErc4626::total_assets`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn total_assets(\u0026self) -\u003e Result\u003cU256, Error\u003e {\n        let asset = self.asset();\n        let erc20 = Erc20Interface::new(asset);\n        erc20\n            .balance_of(self, contract::address())\n            .map_err(|_| InvalidAsset { asset }.into())\n    }\n\n    /// See [`IErc4626::convert_to_shares`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn convert_to_shares(\n        \u0026self,\n        assets: U256,\n        erc20: \u0026Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        self._convert_to_shares(assets, Rounding::Floor, erc20)\n    }\n\n    /// See [`IErc4626::convert_to_assets`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn convert_to_assets(\n        \u0026self,\n        shares: U256,\n        erc20: \u0026Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        self._convert_to_assets(shares, Rounding::Floor, erc20)\n    }\n\n    /// See [`IErc4626::max_deposit`].\n    #[must_use]\n    pub fn max_deposit(\u0026self, _receiver: Address) -\u003e U256 {\n        U256::MAX\n    }\n\n    /// See [`IErc4626::max_mint`].\n    #[must_use]\n    pub fn max_mint(\u0026self, _receiver: Address) -\u003e U256 {\n        U256::MAX\n    }\n\n    /// See [`IErc4626::max_withdraw`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn max_withdraw(\n        \u0026self,\n        owner: Address,\n        erc20: \u0026Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        let balance = erc20.balance_of(owner);\n        self._convert_to_assets(balance, Rounding::Floor, erc20)\n    }\n\n    /// See [`IErc4626::max_redeem`].\n    #[must_use]\n    pub fn max_redeem(\u0026self, owner: Address, erc20: \u0026Erc20) -\u003e U256 {\n        erc20.balance_of(owner)\n    }\n\n    /// See [`IErc4626::preview_deposit`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn preview_deposit(\n        \u0026self,\n        assets: U256,\n        erc20: \u0026Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        self._convert_to_shares(assets, Rounding::Floor, erc20)\n    }\n\n    /// See [`IErc4626::preview_mint`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn preview_mint(\n        \u0026self,\n        shares: U256,\n        erc20: \u0026Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        self._convert_to_assets(shares, Rounding::Ceil, erc20)\n    }\n\n    /// See [`IErc4626::preview_withdraw`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn preview_withdraw(\n        \u0026self,\n        assets: U256,\n        erc20: \u0026Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        self._convert_to_shares(assets, Rounding::Ceil, erc20)\n    }\n\n    /// See [`IErc4626::preview_redeem`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn preview_redeem(\n        \u0026self,\n        shares: U256,\n        erc20: \u0026Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        self._convert_to_assets(shares, Rounding::Floor, erc20)\n    }\n\n    /// See [`IErc4626::deposit`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn deposit(\n        \u0026mut self,\n        assets: U256,\n        receiver: Address,\n        erc20: \u0026mut Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        let max_assets = self.max_deposit(receiver);\n\n        if assets \u003e max_assets {\n            return Err(Error::ExceededMaxDeposit(ERC4626ExceededMaxDeposit {\n                receiver,\n                assets,\n                max: max_assets,\n            }));\n        }\n\n        let shares = self.preview_deposit(assets, erc20)?;\n\n        self._deposit(msg::sender(), receiver, assets, shares, erc20)?;\n\n        Ok(shares)\n    }\n\n    /// See [`IErc4626::mint`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn mint(\n        \u0026mut self,\n        shares: U256,\n        receiver: Address,\n        erc20: \u0026mut Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        let max_shares = self.max_mint(receiver);\n\n        if shares \u003e max_shares {\n            return Err(Error::ExceededMaxMint(ERC4626ExceededMaxMint {\n                receiver,\n                shares,\n                max: max_shares,\n            }));\n        }\n\n        let assets = self.preview_mint(shares, erc20)?;\n        self._deposit(msg::sender(), receiver, assets, shares, erc20)?;\n\n        Ok(assets)\n    }\n\n    /// See [`IErc4626::withdraw`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn withdraw(\n        \u0026mut self,\n        assets: U256,\n        receiver: Address,\n        owner: Address,\n        erc20: \u0026mut Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        let max_assets = self.max_withdraw(owner, erc20)?;\n\n        if assets \u003e max_assets {\n            return Err(Error::ExceededMaxWithdraw(\n                ERC4626ExceededMaxWithdraw { owner, assets, max: max_assets },\n            ));\n        }\n\n        let shares = self.preview_withdraw(assets, erc20)?;\n        self._withdraw(msg::sender(), receiver, owner, assets, shares, erc20)?;\n\n        Ok(shares)\n    }\n\n    /// See [`IErc4626::redeem`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn redeem(\n        \u0026mut self,\n        shares: U256,\n        receiver: Address,\n        owner: Address,\n        erc20: \u0026mut Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        let max_shares = self.max_redeem(owner, erc20);\n        if shares \u003e max_shares {\n            return Err(Error::ExceededMaxRedeem(ERC4626ExceededMaxRedeem {\n                owner,\n                shares,\n                max: max_shares,\n            }));\n        }\n\n        let assets = self.preview_redeem(shares, erc20)?;\n\n        self._withdraw(msg::sender(), receiver, owner, assets, shares, erc20)?;\n\n        Ok(assets)\n    }\n}\n\n#[public]\nimpl Erc4626 {\n    // TODO: remove `decimals_offset` once function overriding is possible.\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `asset` - The underlying vault asset.\n    /// * `decimals_offset` - The decimal offset of the vault shares.\n    #[constructor]\n    pub fn constructor(\u0026mut self, asset: Address, decimals_offset: U8) {\n        let underlying_decimals =\n            self.try_get_asset_decimals(asset).unwrap_or(18);\n\n        self.underlying_decimals.set(U8::from(underlying_decimals));\n        self.asset.set(asset);\n        self.decimals_offset.set(decimals_offset);\n    }\n}\n\nimpl Erc4626 {\n    /// Returns the number of decimals used in representing vault shares. Adds\n    /// the decimals offset to the underlying token's decimals.\n    ///\n    /// NOTE: To expose this function in your contract's ABI, implement it as\n    /// shown in the Examples section below. The implementation should forward\n    /// the call to your internal storage instance.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    ///\n    /// # Panics\n    ///\n    /// * When adding the offset decimals to the underlying token's decimals\n    ///   would exceed [`U8::MAX`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust,ignore\n    ///     fn decimals(\u0026self) -\u003e U8 {\n    ///         self.erc4626.decimals()\n    ///     }\n    /// ```\n    #[must_use]\n    pub fn decimals(\u0026self) -\u003e U8 {\n        self.underlying_decimals\n            .get()\n            .checked_add(self._decimals_offset())\n            .expect(\"Decimals should not be greater than `U8::MAX`\")\n    }\n\n    /// Converts a given amount of assets to shares using the specified\n    /// `rounding` mode.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `assets` - The amount of assets to convert.\n    /// * `rounding` - The [`Rounding`] mode to use for the conversion.\n    /// * `erc20` - Read access to an [`Erc20`] contract.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the token address is not a valid ERC-20\n    ///   token.\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows in the power operation.\n    /// * If multiplication or division operations overflow during conversion.\n    pub fn _convert_to_shares(\n        \u0026self,\n        assets: U256,\n        rounding: Rounding,\n        erc20: \u0026Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        let total_supply = erc20.total_supply();\n\n        let multiplier = total_supply\n            .checked_add(\n                TEN.checked_pow(U256::from(self._decimals_offset())).expect(\n                    \"decimal offset overflow in `Erc4626::_convert_to_shares`\",\n                ),\n            )\n            .expect(\"multiplier overflow in `Erc4626::_convert_to_shares`\");\n\n        let denominator = self\n            .total_assets()?\n            .checked_add(ONE)\n            .expect(\"denominator overflow in `Erc4626::_convert_to_shares`\");\n\n        let shares = assets.mul_div(multiplier, denominator, rounding);\n\n        Ok(shares)\n    }\n\n    /// Converts a given amount of shares to assets using the specified\n    /// `rounding` mode.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `shares` - The amount of shares to convert.\n    /// * `rounding` - The [`Rounding`] mode to use for the conversion.\n    /// * `erc20` - Read access to an [`Erc20`] contract.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAsset`] - If the token address is not a valid ERC-20\n    ///   token.\n    ///\n    /// # Panics\n    ///\n    /// * If decimal offset calculation overflows.\n    /// * If multiplication or division operations overflow.\n    pub fn _convert_to_assets(\n        \u0026self,\n        shares: U256,\n        rounding: Rounding,\n        erc20: \u0026Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        let multiplier = self\n            .total_assets()?\n            .checked_add(ONE)\n            .expect(\"multiplier overflow in `Erc4626::_convert_to_assets`\");\n\n        let total_supply = erc20.total_supply();\n\n        let denominator = total_supply\n            .checked_add(\n                TEN.checked_pow(U256::from(self._decimals_offset())).expect(\n                    \"decimal offset overflow in `Erc4626::_convert_to_assets`\",\n                ),\n            )\n            .expect(\"denominator overflow in `Erc4626::_convert_to_assets`\");\n\n        let assets = shares.mul_div(multiplier, denominator, rounding);\n\n        Ok(assets)\n    }\n\n    /// Deposit/mint common workflow.\n    ///\n    /// # Arguments\n    ///\n    /// * `caller` - Address initiating the deposit.\n    /// * `receiver` - Address receiving the minted shares.\n    /// * `assets` - Amount of underlying tokens to transfer.\n    /// * `shares` - Amount of shares to mint.\n    /// * `erc20` - Write access to an [`Erc20`] contract.\n    ///\n    /// # Errors\n    ///\n    /// * [`safe_erc20::Error::SafeErc20FailedOperation`] - If token transfer\n    ///   fails.\n    /// * [`erc20::Error::InvalidReceiver`] - If `receiver` is\n    ///   [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`Deposit`]\n    pub fn _deposit(\n        \u0026mut self,\n        caller: Address,\n        receiver: Address,\n        assets: U256,\n        shares: U256,\n        erc20: \u0026mut Erc20,\n    ) -\u003e Result\u003c(), Error\u003e {\n        // If asset() is ERC-777, `transfer_from` can trigger a reentrancy\n        // BEFORE the transfer happens through the `tokens_to_send` hook. On the\n        // other hand, the `token_received` hook, that is triggered after the\n        // transfer, calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any\n        // reentrancy would happen before the assets are transferred and before\n        // the shares are minted, which is a valid state.\n\n        self.safe_erc20.safe_transfer_from(\n            self.asset(),\n            caller,\n            contract::address(),\n            assets,\n        )?;\n\n        erc20._mint(receiver, shares)?;\n\n        evm::log(Deposit { sender: caller, owner: receiver, assets, shares });\n\n        Ok(())\n    }\n\n    /// Withdraw/redeem common workflow.\n    ///\n    /// # Arguments\n    ///\n    /// * `caller` - Address initiating the withdrawal.\n    /// * `receiver` - Address receiving the assets.\n    /// * `owner` - Address owning the shares.\n    /// * `assets` - Amount of underlying tokens to transfer.\n    /// * `shares` - Amount of shares to burn.\n    /// * `erc20` - Write access to an [`Erc20`] contract.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc20::Error::InsufficientAllowance`] - If `caller` needs allowance.\n    /// * [`erc20::Error::InvalidApprover`] - If `owner` is [`Address::ZERO`].\n    /// * [`erc20::Error::InsufficientBalance`] - If `owner` lacks shares.\n    /// * [`safe_erc20::Error::SafeErc20FailedOperation`] - If transfer fails.\n    ///\n    /// # Events\n    ///\n    /// * [`Withdraw`]\n    pub fn _withdraw(\n        \u0026mut self,\n        caller: Address,\n        receiver: Address,\n        owner: Address,\n        assets: U256,\n        shares: U256,\n        erc20: \u0026mut Erc20,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if caller != owner {\n            erc20._spend_allowance(owner, caller, shares)?;\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the\n        // transfer happens through the `tokens_received` hook. On the other\n        // hand, the `tokens_to_send` hook, that is triggered before the\n        // transfer, calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any\n        // reentrancy would happen after the shares are burned and after the\n        // assets are transferred, which is a valid state.\n\n        erc20._burn(owner, shares)?;\n\n        self.safe_erc20.safe_transfer(self.asset(), receiver, assets)?;\n\n        evm::log(Withdraw { sender: caller, receiver, owner, assets, shares });\n\n        Ok(())\n    }\n\n    /// Returns the decimals offset between the underlying asset and vault\n    /// shares.\n    /// Currently, always returns [`U8::ZERO`].\n    #[must_use]\n    pub fn _decimals_offset(\u0026self) -\u003e U8 {\n        self.decimals_offset.get()\n    }\n}\n\nimpl Erc4626 {\n    /// Attempts to fetch the asset decimals. Returns None if the attempt failed\n    /// in any way. This follows Rust's idiomatic Option pattern rather than\n    /// Solidity's boolean tuple return.\n    fn try_get_asset_decimals(\u0026mut self, asset: Address) -\u003e Option\u003cu8\u003e {\n        let erc20 = IErc20MetadataInterface::new(asset);\n        let call = Call::new_in(self);\n        erc20.decimals(call).ok()\n    }\n}\n\n// TODO: implement `IErc165` once `IErc4626` is implemented for `Erc4626`.\n// #[public]\n// impl IErc165 for Erc4626 {\n//     fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n//         \u003cSelf as IErc4626\u003e::interface_id() == interface_id\n//             || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n//     }\n// }\n\n// TODO: Add missing tests once `motsu` supports calling external contracts.\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{address, Address, FixedBytes, U256, U8};\n    use motsu::prelude::*;\n    use stylus_sdk::prelude::*;\n\n    use super::*;\n    use crate::{\n        token::erc20::{\n            extensions::{Erc20Metadata, IErc20Metadata},\n            Erc20,\n        },\n        utils::introspection::erc165::IErc165,\n    };\n\n    #[storage]\n    struct Erc4626TestExample {\n        erc4626: Erc4626,\n        erc20: Erc20,\n        metadata: Erc20Metadata,\n    }\n\n    #[public]\n    #[implements(IErc4626\u003cError = Error\u003e, IErc20Metadata, IErc165)]\n    impl Erc4626TestExample {}\n\n    #[public]\n    impl IErc4626 for Erc4626TestExample {\n        type Error = Error;\n\n        fn asset(\u0026self) -\u003e Address {\n            self.erc4626.asset()\n        }\n\n        fn total_assets(\u0026self) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.total_assets()\n        }\n\n        fn convert_to_shares(\u0026self, assets: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.convert_to_shares(assets, \u0026self.erc20)\n        }\n\n        fn convert_to_assets(\u0026self, shares: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.convert_to_assets(shares, \u0026self.erc20)\n        }\n\n        fn max_deposit(\u0026self, receiver: Address) -\u003e U256 {\n            self.erc4626.max_deposit(receiver)\n        }\n\n        fn preview_deposit(\u0026self, assets: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.preview_deposit(assets, \u0026self.erc20)\n        }\n\n        fn deposit(\n            \u0026mut self,\n            assets: U256,\n            receiver: Address,\n        ) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.deposit(assets, receiver, \u0026mut self.erc20)\n        }\n\n        fn max_mint(\u0026self, receiver: Address) -\u003e U256 {\n            self.erc4626.max_mint(receiver)\n        }\n\n        fn preview_mint(\u0026self, shares: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.preview_mint(shares, \u0026self.erc20)\n        }\n\n        fn mint(\n            \u0026mut self,\n            shares: U256,\n            receiver: Address,\n        ) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.mint(shares, receiver, \u0026mut self.erc20)\n        }\n\n        fn max_withdraw(\u0026self, owner: Address) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.max_withdraw(owner, \u0026self.erc20)\n        }\n\n        fn preview_withdraw(\u0026self, assets: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.preview_withdraw(assets, \u0026self.erc20)\n        }\n\n        fn withdraw(\n            \u0026mut self,\n            assets: U256,\n            receiver: Address,\n            owner: Address,\n        ) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.withdraw(assets, receiver, owner, \u0026mut self.erc20)\n        }\n\n        fn max_redeem(\u0026self, owner: Address) -\u003e U256 {\n            self.erc4626.max_redeem(owner, \u0026self.erc20)\n        }\n\n        fn preview_redeem(\u0026self, shares: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.preview_redeem(shares, \u0026self.erc20)\n        }\n\n        fn redeem(\n            \u0026mut self,\n            shares: U256,\n            receiver: Address,\n            owner: Address,\n        ) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc4626.redeem(shares, receiver, owner, \u0026mut self.erc20)\n        }\n    }\n\n    #[public]\n    impl IErc20Metadata for Erc4626TestExample {\n        fn name(\u0026self) -\u003e String {\n            self.metadata.name()\n        }\n\n        fn symbol(\u0026self) -\u003e String {\n            self.metadata.symbol()\n        }\n\n        fn decimals(\u0026self) -\u003e U8 {\n            self.metadata.decimals()\n        }\n    }\n\n    #[public]\n    impl IErc165 for Erc4626TestExample {\n        fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n            \u003cSelf as IErc4626\u003e::interface_id() == interface_id\n                || self.erc20.supports_interface(interface_id)\n                || self.metadata.supports_interface(interface_id)\n        }\n    }\n\n    unsafe impl TopLevelStorage for Erc4626TestExample {}\n\n    #[motsu::test]\n    fn asset_works(contract: Contract\u003cErc4626TestExample\u003e, alice: Address) {\n        let asset = address!(\"DeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF\");\n        contract.init(alice, |contract| contract.erc4626.asset.set(asset));\n        assert_eq!(contract.sender(alice).erc4626.asset(), asset);\n    }\n\n    #[motsu::test]\n    fn max_deposit(contract: Contract\u003cErc4626TestExample\u003e, alice: Address) {\n        let max_deposit = contract.sender(alice).max_deposit(alice);\n        assert_eq!(max_deposit, U256::MAX);\n    }\n\n    #[motsu::test]\n    fn max_mint(contract: Contract\u003cErc4626TestExample\u003e, alice: Address) {\n        let max_mint = contract.sender(alice).max_mint(alice);\n        assert_eq!(max_mint, U256::MAX);\n    }\n\n    #[motsu::test]\n    fn max_redeem_works(\n        contract: Contract\u003cErc4626TestExample\u003e,\n        alice: Address,\n    ) {\n        let assets = U256::from(1000);\n        contract.init(alice, |contract| {\n            contract\n                .erc20\n                ._mint(alice, assets)\n                .motsu_expect(\"should mint assets\");\n        });\n        let max_redeem = contract.sender(alice).max_redeem(alice);\n        assert_eq!(assets, max_redeem);\n    }\n\n    #[motsu::test]\n    fn decimals_offset(contract: Contract\u003cErc4626TestExample\u003e, alice: Address) {\n        let decimals_offset = contract.sender(alice).erc4626._decimals_offset();\n        assert_eq!(decimals_offset, U8::ZERO);\n\n        let new_decimal_offset = U8::from(10);\n        contract.sender(alice).erc4626.decimals_offset.set(new_decimal_offset);\n\n        let decimals_offset = contract.sender(alice).erc4626._decimals_offset();\n        assert_eq!(decimals_offset, new_decimal_offset);\n    }\n\n    #[motsu::test]\n    fn decimals(contract: Contract\u003cErc4626TestExample\u003e, alice: Address) {\n        let underlying_decimals = U8::from(17);\n        contract.init(alice, |contract| {\n            contract.erc4626.underlying_decimals.set(underlying_decimals);\n        });\n        let decimals = contract.sender(alice).erc4626.decimals();\n        assert_eq!(decimals, underlying_decimals);\n\n        let new_decimal_offset = U8::from(10);\n        contract.sender(alice).erc4626.decimals_offset.set(new_decimal_offset);\n\n        let decimals = contract.sender(alice).erc4626.decimals();\n        assert_eq!(decimals, underlying_decimals + new_decimal_offset);\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc4626TestExample as IErc4626\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0x87dfe5a0_u32.into();\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":1}},{"line":652,"address":[],"length":0,"stats":{"Line":2}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":1}},{"line":688,"address":[],"length":0,"stats":{"Line":1}},{"line":693,"address":[],"length":0,"stats":{"Line":1}},{"line":694,"address":[],"length":0,"stats":{"Line":1}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":1}},{"line":711,"address":[],"length":0,"stats":{"Line":3}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":2}},{"line":899,"address":[],"length":0,"stats":{"Line":2}},{"line":901,"address":[],"length":0,"stats":{"Line":6}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":4}},{"line":1103,"address":[],"length":0,"stats":{"Line":8}},{"line":1111,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}}],"covered":13,"coverable":119},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","extensions","flash_mint.rs"],"content":"//! Implementation of the ERC-3156 Flash loans extension, as defined in\n//! [ERC-3156].\n//!\n//! Adds the [`IErc3156FlashLender::flash_loan`] method, which provides flash\n//! loan support at the token level. By default there is no fee, but this can be\n//! changed by overriding [`IErc3156FlashLender::flash_loan`].\n//!\n//! NOTE: When this extension is used along with the\n//! [`crate::token::erc20::extensions::Capped`] extension,\n//! [`IErc3156FlashLender::max_flash_loan`] will not correctly reflect the\n//! maximum that can be flash minted. We recommend overriding\n//! [`IErc3156FlashLender::max_flash_loan`] so that it correctly reflects the\n//! supply cap.\n//!\n//! [ERC-3156]: https://eips.ethereum.org/EIPS/eip-3156\n\n// TODO: once ERC20Votes is implemented, include it in the comment above next to\n// ERC20Capped.\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{Address, U256};\nuse openzeppelin_stylus_proc::interface_id;\nuse stylus_sdk::{\n    abi::Bytes,\n    call::{Call, MethodError},\n    contract, msg,\n    prelude::*,\n    storage::{StorageAddress, StorageU256},\n};\n\nuse crate::token::erc20::{self, Erc20, IErc20};\n\n/// The expected value returned from [`IERC3156FlashBorrower::on_flash_loan`].\npub const BORROWER_CALLBACK_VALUE: [u8; 32] = keccak_const::Keccak256::new()\n    .update(\"ERC3156FlashBorrower.onFlashLoan\".as_bytes())\n    .finalize();\n\npub use sol::*;\nmod sol {\n    #![cfg_attr(coverage_nightly, coverage(off))]\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Indicate that the loan token is not supported or valid.\n        ///\n        /// * `token` - Address of the unsupported token.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC3156UnsupportedToken(address token);\n\n        /// Indicate an error related to the loan value exceeding the maximum.\n        ///\n        /// * `max_loan` - Maximum loan value.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC3156ExceededMaxLoan(uint256 max_loan);\n\n        /// Indicate that the receiver of a flashloan is not a valid [`IERC3156FlashBorrower::on_flash_loan`] implementer.\n        ///\n        /// * `receiver` - Address to which tokens are being transferred.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC3156InvalidReceiver(address receiver);\n    }\n}\n\n/// An [`Erc20FlashMint`] extension error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicate that the loan token is not supported or valid.\n    UnsupportedToken(ERC3156UnsupportedToken),\n    /// Indicate an error related to the loan value exceeding the maximum.\n    ExceededMaxLoan(ERC3156ExceededMaxLoan),\n    /// Indicate that the receiver of a flashloan is not a valid\n    /// [`IERC3156FlashBorrower::on_flash_loan`] implementer.\n    ERC3156InvalidReceiver(ERC3156InvalidReceiver),\n    /// Indicates an error related to the current balance of `sender`. Used in\n    /// transfers.\n    InsufficientBalance(erc20::ERC20InsufficientBalance),\n    /// Indicates a failure with the token `sender`. Used in transfers.\n    InvalidSender(erc20::ERC20InvalidSender),\n    /// Indicates a failure with the token `receiver`. Used in transfers.\n    InvalidReceiver(erc20::ERC20InvalidReceiver),\n    /// Indicates a failure with the `spender`’s `allowance`. Used in\n    /// transfers.\n    InsufficientAllowance(erc20::ERC20InsufficientAllowance),\n    /// Indicates a failure with the `spender` to be approved. Used in\n    /// approvals.\n    InvalidSpender(erc20::ERC20InvalidSpender),\n    /// Indicates a failure with the `approver` of a token to be approved. Used\n    /// in approvals. approver Address initiating an approval operation.\n    InvalidApprover(erc20::ERC20InvalidApprover),\n}\n\nimpl From\u003cerc20::Error\u003e for Error {\n    fn from(value: erc20::Error) -\u003e Self {\n        match value {\n            erc20::Error::InsufficientBalance(e) =\u003e {\n                Error::InsufficientBalance(e)\n            }\n            erc20::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc20::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc20::Error::InsufficientAllowance(e) =\u003e {\n                Error::InsufficientAllowance(e)\n            }\n            erc20::Error::InvalidSpender(e) =\u003e Error::InvalidSpender(e),\n            erc20::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n        }\n    }\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\npub use borrower::IERC3156FlashBorrower;\nmod borrower {\n    #![allow(missing_docs)]\n    #![cfg_attr(coverage_nightly, coverage(off))]\n    use alloc::vec;\n\n    use stylus_sdk::prelude::sol_interface;\n\n    sol_interface! {\n        /// Interface of the ERC-3156 FlashBorrower, as defined in [ERC-3156].\n        ///\n        /// [ERC-3156]: https://eips.ethereum.org/EIPS/eip-3156\n        interface IERC3156FlashBorrower {\n            /// Receives a flash loan.\n            ///\n            /// To indicate successful handling of the flash loan, this function should return\n            /// the `keccak256` hash of \"ERC3156FlashBorrower.onFlashLoan\".\n            ///\n            /// # Arguments\n            ///\n            /// * `initiator` - The initiator of the flash loan.\n            /// * `token` - The token to be flash loaned.\n            /// * `amount` - The amount of tokens lent.\n            /// * `fee` - The additional amount of tokens to repay.\n            /// * `data` - Arbitrary data structure, intended to contain user-defined parameters.\n            #[allow(missing_docs)]\n            function onFlashLoan(\n                address initiator,\n                address token,\n                uint256 amount,\n                uint256 fee,\n                bytes calldata data\n            ) external returns (bytes32);\n        }\n    }\n}\n\n/// State of an [`Erc20FlashMint`] Contract.\n#[storage]\npub struct Erc20FlashMint {\n    // TODO: Remove this field once function overriding is possible. For now we\n    // keep this field `pub`, since this is used to simulate overriding.\n    /// Fee applied when doing flash loans.\n    pub flash_fee_value: StorageU256,\n    // TODO: Remove this field once function overriding is possible. For now we\n    // keep this field `pub`, since this is used to simulate overriding.\n    /// Receiver address of the flash fee.\n    pub flash_fee_receiver_address: StorageAddress,\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for Erc20FlashMint {}\n\n/// Interface of the ERC-3156 Flash Lender, as defined in [ERC-3156].\n///\n/// [ERC-3156]: https://eips.ethereum.org/EIPS/eip-3156\n#[interface_id]\npub trait IErc3156FlashLender {\n    /// The error type associated to this trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns the maximum amount of tokens available for loan.\n    ///\n    /// NOTE: This function does not consider any form of supply cap, so in case\n    /// it's used in a token with a cap like\n    /// [`crate::token::erc20::extensions::Capped`], make sure to override this\n    /// function to integrate the cap instead of [`U256::MAX`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token` - The address of the token that is requested.\n    #[must_use]\n    fn max_flash_loan(\u0026self, token: Address) -\u003e U256;\n\n    /// Returns the fee applied when doing flash loans.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token` - The token to be flash loaned.\n    /// * `value` - The amount of tokens to be loaned.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::UnsupportedToken`] - If the token is not supported.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,ignore\n    /// fn flash_fee(\u0026self, token: Address, value: U256) -\u003e Result\u003cU256, flash_mint::Error\u003e {\n    ///     self.erc20_flash_mint.flash_fee(token, value)\n    /// }\n    /// ```\n    fn flash_fee(\n        \u0026self,\n        token: Address,\n        value: U256,\n    ) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Performs a flash loan.\n    ///\n    /// New tokens are minted and sent to the `receiver`, who is required to\n    /// implement the [`IERC3156FlashBorrower`] interface. By the end of the\n    /// flash loan, the receiver is expected to own value + fee tokens and have\n    /// them approved back to the token contract itself so they can be burned.\n    ///\n    /// Returns a boolean value indicating whether the operation succeeded.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `receiver` - The receiver of the flash loan. Should implement the\n    ///   [`IERC3156FlashBorrower::on_flash_loan`] interface.\n    /// * `token` - The token to be flash loaned. Only [`contract::address()`]\n    ///   is supported.\n    /// * `value` - The amount of tokens to be loaned.\n    /// * `data` - Arbitrary data that is passed to the receiver.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::ExceededMaxLoan`] - If the `value` is greater than the value\n    ///   returned by [`IErc3156FlashLender::max_flash_loan`].\n    /// * [`Error::UnsupportedToken`] - If `token` is not supported.\n    /// * [`Error::InvalidReceiver`] - If the `token` address is not a contract\n    ///   , the contract fails to execute the call, or the receiver does not\n    ///   return [`BORROWER_CALLBACK_VALUE`].\n    ///\n    /// # Events\n    ///\n    /// * [`erc20::Transfer`].\n    /// * [`erc20::Approval`].\n    ///\n    /// # Panics\n    ///\n    /// * If the new (temporary) total supply exceeds [`U256::MAX`].\n    /// * If the sum of the loan value and fee exceeds the maximum value of\n    ///   [`U256::MAX`].\n    fn flash_loan(\n        \u0026mut self,\n        receiver: Address,\n        token: Address,\n        value: U256,\n        data: Bytes,\n    ) -\u003e Result\u003cbool, Self::Error\u003e;\n}\n\nimpl Erc20FlashMint {\n    /// See [`IErc3156FlashLender::max_flash_loan`].\n    #[must_use]\n    pub fn max_flash_loan(\u0026self, token: Address, erc20: \u0026erc20::Erc20) -\u003e U256 {\n        if token == contract::address() {\n            U256::MAX - erc20.total_supply()\n        } else {\n            U256::MIN\n        }\n    }\n\n    /// See [`IErc3156FlashLender::flash_fee`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn flash_fee(\n        \u0026self,\n        token: Address,\n        _value: U256,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        if token == contract::address() {\n            Ok(self.flash_fee_value.get())\n        } else {\n            Err(Error::UnsupportedToken(ERC3156UnsupportedToken { token }))\n        }\n    }\n\n    // This function can reenter, but it doesn't pose a risk because it always\n    // preserves the property that the amount minted at the beginning is always\n    // recovered and burned at the end, or else the entire function will revert.\n    /// See [`IErc3156FlashLender::flash_loan`].\n    #[allow(clippy::missing_panics_doc, clippy::missing_errors_doc)]\n    pub fn flash_loan(\n        \u0026mut self,\n        receiver: Address,\n        token: Address,\n        value: U256,\n        data: \u0026Bytes,\n        erc20: \u0026mut Erc20,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let max_loan = self.max_flash_loan(token, erc20);\n        if value \u003e max_loan {\n            return Err(Error::ExceededMaxLoan(ERC3156ExceededMaxLoan {\n                max_loan,\n            }));\n        }\n\n        let fee = self.flash_fee(token, value)?;\n        if !Address::has_code(\u0026receiver) {\n            return Err(Error::ERC3156InvalidReceiver(\n                ERC3156InvalidReceiver { receiver },\n            ));\n        }\n        erc20._mint(receiver, value)?;\n        let loan_receiver = IERC3156FlashBorrower::new(receiver);\n        let loan_return = loan_receiver\n            .on_flash_loan(\n                Call::new_in(self),\n                msg::sender(),\n                token,\n                value,\n                fee,\n                data.to_vec().into(),\n            )\n            .map_err(|_| {\n                Error::ERC3156InvalidReceiver(ERC3156InvalidReceiver {\n                    receiver,\n                })\n            })?;\n        if loan_return != BORROWER_CALLBACK_VALUE {\n            return Err(Error::ERC3156InvalidReceiver(\n                ERC3156InvalidReceiver { receiver },\n            ));\n        }\n\n        let allowance = value\n            .checked_add(fee)\n            .expect(\"allowance should not exceed `U256::MAX`\");\n        erc20._spend_allowance(receiver, contract::address(), allowance)?;\n\n        let flash_fee_receiver = self.flash_fee_receiver_address.get();\n\n        if fee.is_zero() || flash_fee_receiver.is_zero() {\n            erc20._burn(receiver, allowance)?;\n        } else {\n            erc20._burn(receiver, value)?;\n            erc20._transfer(receiver, flash_fee_receiver, fee)?;\n        }\n\n        Ok(true)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use motsu::prelude::*;\n    use stylus_sdk::{\n        abi::Bytes,\n        alloy_primitives::{uint, Address, FixedBytes, U256},\n        prelude::*,\n    };\n\n    use super::*;\n\n    #[storage]\n    struct Erc20FlashMintTestExample {\n        erc20_flash_mint: Erc20FlashMint,\n        erc20: Erc20,\n    }\n\n    #[public]\n    #[implements(IErc3156FlashLender\u003cError = Error\u003e)]\n    impl Erc20FlashMintTestExample {}\n\n    #[public]\n    impl IErc3156FlashLender for Erc20FlashMintTestExample {\n        type Error = Error;\n\n        fn max_flash_loan(\u0026self, token: Address) -\u003e U256 {\n            self.erc20_flash_mint.max_flash_loan(token, \u0026self.erc20)\n        }\n\n        fn flash_fee(\n            \u0026self,\n            token: Address,\n            value: U256,\n        ) -\u003e Result\u003cU256, Self::Error\u003e {\n            self.erc20_flash_mint.flash_fee(token, value)\n        }\n\n        fn flash_loan(\n            \u0026mut self,\n            receiver: Address,\n            token: Address,\n            value: U256,\n            data: Bytes,\n        ) -\u003e Result\u003cbool, Self::Error\u003e {\n            self.erc20_flash_mint.flash_loan(\n                receiver,\n                token,\n                value,\n                \u0026data,\n                \u0026mut self.erc20,\n            )\n        }\n    }\n\n    unsafe impl TopLevelStorage for Erc20FlashMintTestExample {}\n\n    #[motsu::test]\n    fn max_flash_loan_token_match(\n        contract: Contract\u003cErc20FlashMintTestExample\u003e,\n        alice: Address,\n    ) {\n        let max_flash_loan =\n            contract.sender(alice).max_flash_loan(contract.address());\n        assert_eq!(max_flash_loan, U256::MAX);\n    }\n\n    #[motsu::test]\n    fn max_flash_loan_token_mismatch(\n        contract: Contract\u003cErc20FlashMintTestExample\u003e,\n        alice: Address,\n    ) {\n        let max_flash_loan = contract.sender(alice).max_flash_loan(alice);\n        assert_eq!(max_flash_loan, U256::MIN);\n    }\n\n    #[motsu::test]\n    fn max_flash_loan_when_token_minted(\n        contract: Contract\u003cErc20FlashMintTestExample\u003e,\n        alice: Address,\n    ) {\n        let initial_supply = uint!(10000_U256);\n\n        contract.init(alice, |contract| {\n            contract\n                .erc20\n                ._mint(alice, initial_supply)\n                .motsu_expect(\"should mint initial supply tokens\");\n        });\n\n        let max_flash_loan =\n            contract.sender(alice).max_flash_loan(contract.address());\n\n        assert_eq!(max_flash_loan, U256::MAX - initial_supply);\n    }\n\n    #[motsu::test]\n    fn flash_fee(\n        contract: Contract\u003cErc20FlashMintTestExample\u003e,\n        alice: Address,\n    ) {\n        let flash_fee_value = uint!(69_U256);\n        contract.init(alice, |contract| {\n            contract.erc20_flash_mint.flash_fee_value.set(flash_fee_value);\n        });\n\n        let flash_fee = contract\n            .sender(alice)\n            .flash_fee(contract.address(), uint!(1000_U256))\n            .motsu_expect(\"should return flash fee value\");\n\n        assert_eq!(flash_fee, flash_fee_value);\n    }\n\n    #[motsu::test]\n    fn flash_fee_reverts_when_invalid_token(\n        contract: Contract\u003cErc20FlashMintTestExample\u003e,\n        alice: Address,\n    ) {\n        let invalid_token = alice;\n\n        let err = contract\n            .sender(alice)\n            .flash_fee(invalid_token, uint!(1000_U256))\n            .motsu_expect_err(\"should return Error::UnsupportedToken\");\n\n        assert!(matches!(\n            err,\n            Error::UnsupportedToken(ERC3156UnsupportedToken { token })\n                if token == invalid_token\n        ));\n    }\n\n    #[motsu::test]\n    fn flash_loan_reverts_when_exceeded_max_loan(\n        contract: Contract\u003cErc20FlashMintTestExample\u003e,\n        alice: Address,\n    ) {\n        let initial_supply = uint!(10000_U256);\n\n        contract.init(alice, |contract| {\n            contract\n                .erc20\n                ._mint(alice, initial_supply)\n                .motsu_expect(\"should mint initial supply tokens\");\n        });\n\n        let err = contract\n            .sender(alice)\n            .flash_loan(alice, contract.address(), U256::MAX, vec![0, 1].into())\n            .motsu_expect_err(\"should return Error::ExceededMaxLoan\");\n\n        assert!(matches!(\n            err,\n            Error::ExceededMaxLoan(ERC3156ExceededMaxLoan { max_loan })\n                if max_loan == U256::MAX - initial_supply\n        ));\n    }\n\n    #[motsu::test]\n    fn flash_loan_reverts_when_receiver_is_zero_address(\n        contract: Contract\u003cErc20FlashMintTestExample\u003e,\n        alice: Address,\n    ) {\n        let invalid_reciver = Address::ZERO;\n        let err = contract\n            .sender(alice)\n            .flash_loan(\n                invalid_reciver,\n                contract.address(),\n                uint!(1000_U256),\n                vec![0, 1].into(),\n            )\n            .motsu_expect_err(\"should return Error::InvalidReceiver\");\n\n        assert!(matches!(\n            err,\n            Error::ERC3156InvalidReceiver(ERC3156InvalidReceiver { receiver }) if receiver == invalid_reciver\n        ));\n    }\n\n    #[motsu::test]\n    fn flash_loan_reverts_when_invalid_receiver(\n        contract: Contract\u003cErc20FlashMintTestExample\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = alice;\n\n        let err = contract\n            .sender(alice)\n            .flash_loan(\n                invalid_receiver,\n                contract.address(),\n                uint!(1000_U256),\n                vec![0, 1].into(),\n            )\n            .motsu_expect_err(\"should return Error::InvalidReceiver\");\n\n        assert!(matches!(\n            err,\n            Error::ERC3156InvalidReceiver(ERC3156InvalidReceiver { receiver })\n                if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual =\n            \u003cErc20FlashMintTestExample as IErc3156FlashLender\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0xe4143091_u32.into();\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":6}},{"line":272,"address":[],"length":0,"stats":{"Line":6}},{"line":273,"address":[],"length":0,"stats":{"Line":5}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":4}},{"line":287,"address":[],"length":0,"stats":{"Line":3}},{"line":289,"address":[],"length":0,"stats":{"Line":1}},{"line":298,"address":[],"length":0,"stats":{"Line":3}},{"line":306,"address":[],"length":0,"stats":{"Line":15}},{"line":307,"address":[],"length":0,"stats":{"Line":3}},{"line":308,"address":[],"length":0,"stats":{"Line":1}},{"line":309,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":2}},{"line":316,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":42},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","extensions","metadata.rs"],"content":"//! Optional Metadata of the ERC-20 standard.\n\nuse alloc::{string::String, vec, vec::Vec};\n\nuse openzeppelin_stylus_proc::interface_id;\nuse stylus_sdk::{\n    alloy_primitives::{uint, FixedBytes, U8},\n    prelude::*,\n};\n\nuse crate::utils::{introspection::erc165::IErc165, Metadata};\n\n/// Number of decimals used by default on implementors of [`Metadata`].\npub const DEFAULT_DECIMALS: U8 = uint!(18_U8);\n\n/// State of an [`Erc20Metadata`] contract.\n#[storage]\npub struct Erc20Metadata {\n    /// [`Metadata`] contract.\n    pub(crate) metadata: Metadata,\n}\n\n/// Interface for the optional metadata functions from the ERC-20 standard.\n#[interface_id]\npub trait IErc20Metadata: IErc165 {\n    /// Returns the name of the token.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    #[must_use]\n    fn name(\u0026self) -\u003e String;\n\n    /// Returns the symbol of the token, usually a shorter version of the name.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    #[must_use]\n    fn symbol(\u0026self) -\u003e String;\n\n    /// Returns the number of decimals used to get a user-friendly\n    /// representation of values of this token.\n    ///\n    /// For example, if `decimals` equals `2`, a balance of `505` tokens should\n    /// be displayed to a user as `5.05` (`505 / 10 ** 2`).\n    ///\n    /// Tokens usually opt for a value of `18`, imitating the relationship\n    /// between Ether and Wei. This is the default value returned by this\n    /// function ([`DEFAULT_DECIMALS`]), unless it's overridden.\n    ///\n    /// NOTE: This information is only used for *display* purposes: in\n    /// no way it affects any of the arithmetic of the contract, including\n    /// [`super::super::IErc20::balance_of`] and\n    /// [`super::super::IErc20::transfer`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    #[must_use]\n    fn decimals(\u0026self) -\u003e U8;\n}\n\n#[public]\n#[implements(IErc20Metadata, IErc165)]\nimpl Erc20Metadata {\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `name` - Token name.\n    /// * `symbol` - Token symbol.\n    #[constructor]\n    pub fn constructor(\u0026mut self, name: String, symbol: String) {\n        self.metadata.constructor(name, symbol);\n    }\n}\n\n#[public]\nimpl IErc20Metadata for Erc20Metadata {\n    fn name(\u0026self) -\u003e String {\n        self.metadata.name()\n    }\n\n    fn symbol(\u0026self) -\u003e String {\n        self.metadata.symbol()\n    }\n\n    fn decimals(\u0026self) -\u003e U8 {\n        DEFAULT_DECIMALS\n    }\n}\n\n#[public]\nimpl IErc165 for Erc20Metadata {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IErc20Metadata\u003e::interface_id() == interface_id\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use motsu::prelude::Contract;\n    use stylus_sdk::{\n        alloy_primitives::{Address, FixedBytes},\n        prelude::*,\n    };\n\n    use super::{Erc20Metadata, IErc165, IErc20Metadata};\n\n    unsafe impl TopLevelStorage for Erc20Metadata {}\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc20Metadata as IErc20Metadata\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0xa219a025_u32.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cErc20Metadata\u003e, alice: Address) {\n        assert!(contract.sender(alice).supports_interface(\n            \u003cErc20Metadata as IErc20Metadata\u003e::interface_id()\n        ));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc20Metadata as IErc165\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":2}}],"covered":3,"coverable":11},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","extensions","mod.rs"],"content":"//! Common extensions to the ERC-20 standard.\npub mod burnable;\npub mod capped;\npub mod erc4626;\npub mod flash_mint;\npub mod metadata;\npub mod permit;\npub mod wrapper;\n\npub use burnable::IErc20Burnable;\npub use capped::{Capped, ICapped};\npub use erc4626::{Erc4626, IErc4626};\npub use flash_mint::{Erc20FlashMint, IErc3156FlashLender};\npub use metadata::{Erc20Metadata, IErc20Metadata};\npub use permit::{Erc20Permit, IErc20Permit};\npub use wrapper::{Erc20Wrapper, IErc20Wrapper};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","extensions","permit.rs"],"content":"//! Permit Contract.\n//!\n//! Extension of the ERC-20 standard allowing approvals to be made\n//! via signatures, as defined in the [ERC].\n//!\n//! Adds the `permit` method, which can be used to change an account’s\n//! ERC20 allowance (see [`crate::token::erc20::IErc20::allowance`])\n//! by presenting a message signed by the account.\n//! By not relying on [`erc20::IErc20::approve`],\n//! the token holder account doesn’t need to send a transaction,\n//! and thus is not required to hold Ether at all.\n//!\n//! [ERC]: https://eips.ethereum.org/EIPS/eip-2612\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{keccak256, Address, FixedBytes, B256, U256, U8};\nuse alloy_sol_types::SolType;\nuse stylus_sdk::{block, call::MethodError, function_selector, prelude::*};\n\nuse crate::{\n    token::erc20::{self, Erc20},\n    utils::{\n        cryptography::{\n            ecdsa::{self, ECDSAInvalidSignature, ECDSAInvalidSignatureS},\n            eip712::IEip712,\n        },\n        nonces::{INonces, Nonces},\n    },\n};\n\nconst PERMIT_TYPEHASH: [u8; 32] =\n    keccak_const::Keccak256::new()\n        .update(b\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n        .finalize();\n\npub use sol::*;\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    pub(crate) type StructHashTuple = sol! {\n        tuple(bytes32, address, address, uint256, uint256, uint256)\n    };\n\n    sol! {\n        /// Indicates an error related to the fact that\n        /// permit deadline has expired.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC2612ExpiredSignature(uint256 deadline);\n\n        /// Indicates an error related to the issue about mismatched signature.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC2612InvalidSigner(address signer, address owner);\n    }\n}\n\n/// A Permit error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates an error related to the fact that\n    /// permit deadline has expired.\n    ExpiredSignature(ERC2612ExpiredSignature),\n    /// Indicates an error related to the issue about mismatched signature.\n    InvalidSigner(ERC2612InvalidSigner),\n    /// Indicates an error related to the current balance of `sender`. Used in\n    /// transfers.\n    InsufficientBalance(erc20::ERC20InsufficientBalance),\n    /// Indicates a failure with the token `sender`. Used in transfers.\n    InvalidSender(erc20::ERC20InvalidSender),\n    /// Indicates a failure with the token `receiver`. Used in transfers.\n    InvalidReceiver(erc20::ERC20InvalidReceiver),\n    /// Indicates a failure with the `spender`’s `allowance`. Used in\n    /// transfers.\n    InsufficientAllowance(erc20::ERC20InsufficientAllowance),\n    /// Indicates a failure with the `spender` to be approved. Used in\n    /// approvals.\n    InvalidSpender(erc20::ERC20InvalidSpender),\n    /// Indicates a failure with the `approver` of a token to be approved. Used\n    /// in approvals. approver Address initiating an approval operation.\n    InvalidApprover(erc20::ERC20InvalidApprover),\n    /// The signature derives the [`Address::ZERO`].\n    InvalidSignature(ECDSAInvalidSignature),\n    /// The signature has an `S` value that is in the upper half order.\n    InvalidSignatureS(ECDSAInvalidSignatureS),\n}\n\nimpl From\u003cerc20::Error\u003e for Error {\n    fn from(value: erc20::Error) -\u003e Self {\n        match value {\n            erc20::Error::InsufficientBalance(e) =\u003e {\n                Error::InsufficientBalance(e)\n            }\n            erc20::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc20::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc20::Error::InsufficientAllowance(e) =\u003e {\n                Error::InsufficientAllowance(e)\n            }\n            erc20::Error::InvalidSpender(e) =\u003e Error::InvalidSpender(e),\n            erc20::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n        }\n    }\n}\n\nimpl From\u003cecdsa::Error\u003e for Error {\n    fn from(value: ecdsa::Error) -\u003e Self {\n        match value {\n            ecdsa::Error::InvalidSignature(e) =\u003e Error::InvalidSignature(e),\n            ecdsa::Error::InvalidSignatureS(e) =\u003e Error::InvalidSignatureS(e),\n        }\n    }\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of an [`Erc20Permit`] Contract.\n#[storage]\npub struct Erc20Permit\u003cT: IEip712 + StorageType\u003e {\n    /// Contract implementing [`IEip712`] trait.\n    pub(crate) eip712: T,\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl\u003cT: IEip712 + StorageType\u003e TopLevelStorage for Erc20Permit\u003cT\u003e {}\n\n/// Interface for [`Erc20Permit`]\npub trait IErc20Permit: INonces {\n    /// The error type associated to this interface.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    // Calculated manually to include [`INonces::nonces`].\n    /// Solidity interface id associated with [`IErc20Permit`] trait.\n    /// Computed as a XOR of selectors for each function in the trait.\n    #[must_use]\n    fn interface_id() -\u003e FixedBytes\u003c4\u003e\n    where\n        Self: Sized,\n    {\n        FixedBytes::\u003c4\u003e::new(function_selector!(\"DOMAIN_SEPARATOR\",))\n            ^ FixedBytes::\u003c4\u003e::new(function_selector!(\"nonces\", Address,))\n            ^ FixedBytes::\u003c4\u003e::new(function_selector!(\n                \"permit\", Address, Address, U256, U256, U8, B256, B256\n            ))\n    }\n\n    /// Returns the domain separator used in the encoding of the signature for\n    /// [`Self::permit`], as defined by EIP712.\n    ///\n    /// NOTE: The implementation should use `#[selector(name =\n    /// \"DOMAIN_SEPARATOR\")]` to match Solidity's camelCase naming\n    /// convention.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    #[must_use]\n    fn domain_separator(\u0026self) -\u003e B256;\n\n    /// Sets `value` as the allowance of `spender` over `owner`'s tokens,\n    /// given `owner`'s signed approval.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state. given address.\n    /// * `owner` - Account that owns the tokens.\n    /// * `spender` - Account that will spend the tokens.\n    /// * `value` - The number of tokens being permitted to transfer by\n    ///   `spender`.\n    /// * `deadline` - Deadline for the permit action.\n    /// * `v` - v value from the `owner`'s signature.\n    /// * `r` - r value from the `owner`'s signature.\n    /// * `s` - s value from the `owner`'s signature.\n    ///\n    /// # Errors\n    ///\n    /// * [`ERC2612ExpiredSignature`] - If the `deadline` param is from the\n    ///   past.\n    /// * [`ERC2612InvalidSigner`] - If signer is not an `owner`.\n    /// * [`ecdsa::Error::InvalidSignatureS`] - If the `s` value is grater than\n    ///   [`ecdsa::SIGNATURE_S_UPPER_BOUND`].\n    /// * [`ecdsa::Error::InvalidSignature`] - If the recovered address is\n    ///   [`Address::ZERO`].\n    /// * [`erc20::Error::InvalidSpender`] - If the `spender` address is\n    ///   [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`erc20::Approval`]\n    #[allow(clippy::too_many_arguments)]\n    fn permit(\n        \u0026mut self,\n        owner: Address,\n        spender: Address,\n        value: U256,\n        deadline: U256,\n        v: u8,\n        r: B256,\n        s: B256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\nimpl\u003cT: IEip712 + StorageType\u003e Erc20Permit\u003cT\u003e {\n    /// See [`IErc20Permit::domain_separator`].\n    #[must_use]\n    pub fn domain_separator(\u0026self) -\u003e B256 {\n        self.eip712.domain_separator_v4()\n    }\n\n    /// See [`IErc20Permit::permit`].\n    #[allow(clippy::too_many_arguments, clippy::missing_errors_doc)]\n    pub fn permit(\n        \u0026mut self,\n        owner: Address,\n        spender: Address,\n        value: U256,\n        deadline: U256,\n        v: u8,\n        r: B256,\n        s: B256,\n        erc20: \u0026mut Erc20,\n        nonces: \u0026mut Nonces,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if U256::from(block::timestamp()) \u003e deadline {\n            return Err(ERC2612ExpiredSignature { deadline }.into());\n        }\n\n        let struct_hash = keccak256(StructHashTuple::abi_encode(\u0026(\n            PERMIT_TYPEHASH,\n            owner,\n            spender,\n            value,\n            nonces.use_nonce(owner),\n            deadline,\n        )));\n\n        let hash: B256 = self.eip712.hash_typed_data_v4(struct_hash);\n\n        let signer: Address = ecdsa::recover(self, hash, v, r, s)?;\n\n        if signer != owner {\n            return Err(ERC2612InvalidSigner { signer, owner }.into());\n        }\n\n        erc20._approve(owner, spender, value, true)?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","extensions","wrapper.rs"],"content":"//! Extension of the ERC-20 token contract to support token wrapping.\n//!\n//! Users can deposit and withdraw \"underlying tokens\" and receive a matching\n//! number of \"wrapped tokens\". This is useful in conjunction with other\n//! modules.\n//!\n//! WARNING: Any mechanism in which the underlying token changes the\n//! [`IErc20::balance_of`] of an account without an explicit transfer may\n//! desynchronize this contract's supply and its underlying balance. Please\n//! exercise caution when wrapping tokens that may undercollateralize the\n//! wrapper (i.e. wrapper's total supply is higher than its underlying balance).\n//! See [`Erc20Wrapper::_recover`] for recovering value accrued to the wrapper.\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{Address, U256, U8};\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{\n    call::{Call, MethodError},\n    contract, msg,\n    prelude::*,\n    storage::StorageAddress,\n};\n\nuse crate::token::erc20::{\n    self,\n    interface::{Erc20Interface, IErc20MetadataInterface},\n    utils::{safe_erc20, ISafeErc20, SafeErc20},\n    Erc20, IErc20,\n};\n\n/// Default number of decimals for an [ERC-20] token.\n///\n/// [ERC-20]: \u003chttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.3.0/contracts/token/ERC20/ERC20.sol\u003e\nconst DEFAULT_DECIMALS: u8 = 18;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Indicates that the address is not a valid ERC-20 token.\n        ///\n        /// * `token` - Address of the invalid ERC-20 token.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC20InvalidUnderlying(address token);\n    }\n}\n\n/// An [`Erc20Wrapper`] error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates an error related to the current balance of `sender`. Used in\n    /// transfers.\n    InsufficientBalance(erc20::ERC20InsufficientBalance),\n    /// Indicates a failure with the token `sender`. Used in transfers.\n    InvalidSender(erc20::ERC20InvalidSender),\n    /// Indicates a failure with the token `receiver`. Used in transfers.\n    InvalidReceiver(erc20::ERC20InvalidReceiver),\n    /// Indicates a failure with the `spender`’s `allowance`. Used in\n    /// transfers.\n    InsufficientAllowance(erc20::ERC20InsufficientAllowance),\n    /// Indicates a failure with the `spender` to be approved. Used in\n    /// approvals.\n    InvalidSpender(erc20::ERC20InvalidSpender),\n    /// Indicates a failure with the `approver` of a token to be approved. Used\n    /// in approvals. approver Address initiating an approval operation.\n    InvalidApprover(erc20::ERC20InvalidApprover),\n    /// An operation with an ERC-20 token failed.\n    SafeErc20FailedOperation(safe_erc20::SafeErc20FailedOperation),\n    /// Indicates a failed [`ISafeErc20::safe_decrease_allowance`] request.\n    SafeErc20FailedDecreaseAllowance(\n        safe_erc20::SafeErc20FailedDecreaseAllowance,\n    ),\n    /// The underlying token couldn't be wrapped.\n    InvalidUnderlying(ERC20InvalidUnderlying),\n}\n\nimpl From\u003cerc20::Error\u003e for Error {\n    fn from(value: erc20::Error) -\u003e Self {\n        match value {\n            erc20::Error::InsufficientBalance(e) =\u003e {\n                Error::InsufficientBalance(e)\n            }\n            erc20::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc20::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc20::Error::InsufficientAllowance(e) =\u003e {\n                Error::InsufficientAllowance(e)\n            }\n            erc20::Error::InvalidSpender(e) =\u003e Error::InvalidSpender(e),\n            erc20::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n        }\n    }\n}\n\nimpl From\u003csafe_erc20::Error\u003e for Error {\n    fn from(value: safe_erc20::Error) -\u003e Self {\n        match value {\n            safe_erc20::Error::SafeErc20FailedOperation(e) =\u003e {\n                Error::SafeErc20FailedOperation(e)\n            }\n            safe_erc20::Error::SafeErc20FailedDecreaseAllowance(e) =\u003e {\n                Error::SafeErc20FailedDecreaseAllowance(e)\n            }\n        }\n    }\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of an [`Erc20Wrapper`] token.\n#[storage]\npub struct Erc20Wrapper {\n    /// Address of the underlying token.\n    pub(crate) underlying: StorageAddress,\n    /// [`SafeErc20`] contract.\n    safe_erc20: SafeErc20,\n}\n\n/// ERC-20 Wrapper Standard Interface\n#[interface_id]\npub trait IErc20Wrapper {\n    /// The error type associated to the trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns the number of decimals used to get its user representation.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,ignore\n    /// fn decimals(\u0026self) -\u003e U8 {\n    ///     self.erc20_wrapper.decimals()\n    /// }\n    /// ```\n    #[must_use]\n    fn decimals(\u0026self) -\u003e U8;\n\n    /// Returns the address of the underlying ERC-20 token that is being\n    /// wrapped.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,ignore\n    /// fn underlying(\u0026self) -\u003e Address {\n    ///     self.erc20_wrapper.underlying()\n    /// }\n    /// ```\n    #[must_use]\n    fn underlying(\u0026self) -\u003e Address;\n\n    /// Allow a user to deposit underlying tokens and mint the corresponding\n    /// number of wrapped tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `account` - The account to deposit tokens to.\n    /// * `value` - The amount of tokens to deposit.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSender`] - If the `msg::sender()`'s address is the\n    ///   `contract:address()`.\n    /// * [`Error::InvalidReceiver`] - If the `account` address is a\n    ///   `contract:address()`.\n    /// * [`Error::SafeErc20FailedOperation`] - If caller lacks sufficient\n    ///   balance or hasn't approved enough tokens to the [`Erc20Wrapper`]\n    ///   contract.\n    /// * [`Error::InvalidReceiver`] - If the `account` address is\n    ///   [`Address::ZERO`].\n    ///\n    /// # Panics\n    ///\n    /// * If [`Erc20::_mint`] operation panics.\n    fn deposit_for(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e;\n\n    /// Allow a user to burn a number of wrapped tokens and withdraw the\n    /// corresponding number of underlying tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `account` - The account to withdraw tokens from.\n    /// * `value` - The amount of tokens to withdraw.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If the `account`'s address is a\n    ///   `contract:address()`.\n    /// * [`Error::InvalidSender`] - If the `from` address is [`Address::ZERO`].\n    /// * [`Error::InsufficientBalance`] - If the `from` address doesn't have\n    ///   enough tokens.\n    /// * [`Error::SafeErc20FailedOperation`] - If the [`Erc20Wrapper`] contract\n    ///   lacks sufficient balance.\n    fn withdraw_to(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e;\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for Erc20Wrapper {}\n\nimpl Erc20Wrapper {\n    /// See [`IErc20Wrapper::decimals`].\n    #[must_use]\n    pub fn decimals(\u0026self) -\u003e U8 {\n        U8::from(\n            IErc20MetadataInterface::new(self.underlying())\n                .decimals(self)\n                .unwrap_or(DEFAULT_DECIMALS),\n        )\n    }\n\n    /// See [`IErc20Wrapper::underlying`].\n    #[must_use]\n    pub fn underlying(\u0026self) -\u003e Address {\n        self.underlying.get()\n    }\n\n    /// See [`IErc20Wrapper::deposit_for`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn deposit_for(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n        erc20: \u0026mut Erc20,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let contract_address = contract::address();\n        let sender = msg::sender();\n\n        if sender == contract_address {\n            return Err(erc20::ERC20InvalidSender { sender }.into());\n        }\n\n        if account == contract_address {\n            return Err(\n                erc20::ERC20InvalidReceiver { receiver: account }.into()\n            );\n        }\n\n        self.safe_erc20.safe_transfer_from(\n            self.underlying(),\n            sender,\n            contract_address,\n            value,\n        )?;\n\n        erc20._mint(account, value)?;\n\n        Ok(true)\n    }\n\n    /// See [`IErc20Wrapper::withdraw_to`].\n    #[allow(clippy::missing_errors_doc)]\n    pub fn withdraw_to(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n        erc20: \u0026mut Erc20,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        if account == contract::address() {\n            return Err(\n                erc20::ERC20InvalidReceiver { receiver: account }.into()\n            );\n        }\n\n        erc20._burn(msg::sender(), value)?;\n\n        self.safe_erc20.safe_transfer(self.underlying(), account, value)?;\n\n        Ok(true)\n    }\n}\n\n#[public]\nimpl Erc20Wrapper {\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `underlying_token` - The wrapped token.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidUnderlying`] - If underlying token is this contract.\n    #[constructor]\n    pub fn constructor(\n        \u0026mut self,\n        underlying_token: Address,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if underlying_token == contract::address() {\n            return Err(Error::InvalidUnderlying(ERC20InvalidUnderlying {\n                token: underlying_token,\n            }));\n        }\n        self.underlying.set(underlying_token);\n        Ok(())\n    }\n}\n\nimpl Erc20Wrapper {\n    /// Mint wrapped token to cover any underlying tokens that would have been\n    /// transferred by mistake or acquired from rebasing mechanisms.\n    ///\n    /// Internal function that can be exposed with access control if desired.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `account` - The account to mint tokens to.\n    /// * `erc20` - Write access to an [`Erc20`] contract.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidUnderlying`]  - If the external call for\n    ///   [`IErc20::balance_of`] fails.\n    /// * [`Error::InvalidReceiver`] - If the `account` address is\n    ///   [`Address::ZERO`].\n    ///\n    /// # Panics\n    ///\n    /// * If the underlying balance is less than the [`IErc20::total_supply`].\n    pub fn _recover(\n        \u0026mut self,\n        account: Address,\n        erc20: \u0026mut Erc20,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        let contract_address = contract::address();\n\n        let underlying_token = Erc20Interface::new(self.underlying());\n\n        let underlying_balance = underlying_token\n            .balance_of(Call::new_in(self), contract_address)\n            .map_err(|_| ERC20InvalidUnderlying { token: contract_address })?;\n\n        let value = underlying_balance\n            .checked_sub(erc20.total_supply())\n            .expect(\"underlying balance should be greater than the `IErc20::total_supply`\");\n\n        if value \u003e U256::ZERO {\n            erc20._mint(account, value)?;\n        }\n\n        Ok(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{uint, FixedBytes};\n    use motsu::prelude::*;\n\n    use super::*;\n    use crate::{\n        token::erc20::extensions::IErc20Metadata,\n        utils::introspection::erc165::IErc165,\n    };\n\n    const DUMMY_TEST_DECIMALS: u8 = 12;\n    #[storage]\n    struct DummyErc20Metadata {}\n\n    #[public]\n    #[implements(IErc20Metadata, IErc165)]\n    impl DummyErc20Metadata {}\n\n    #[public]\n    impl IErc20Metadata for DummyErc20Metadata {\n        fn name(\u0026self) -\u003e String {\n            \"DummyErc20Metadata\".into()\n        }\n\n        fn symbol(\u0026self) -\u003e String {\n            \"TTK\".into()\n        }\n\n        fn decimals(\u0026self) -\u003e U8 {\n            U8::from(DUMMY_TEST_DECIMALS)\n        }\n    }\n\n    #[public]\n    impl IErc165 for DummyErc20Metadata {\n        fn supports_interface(\u0026self, _interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n            // dummy implementation, required by [`IErc20Metadata`] trait.\n            true\n        }\n    }\n\n    unsafe impl TopLevelStorage for DummyErc20Metadata {}\n\n    #[storage]\n    struct Erc20WrapperTestExample {\n        wrapper: Erc20Wrapper,\n        erc20: Erc20,\n    }\n\n    #[public]\n    #[implements(IErc20Wrapper\u003cError = Error\u003e)]\n    impl Erc20WrapperTestExample {\n        fn recover(\u0026mut self, account: Address) -\u003e Result\u003cU256, Error\u003e {\n            self.wrapper._recover(account, \u0026mut self.erc20)\n        }\n    }\n\n    #[public]\n    impl IErc20Wrapper for Erc20WrapperTestExample {\n        type Error = Error;\n\n        fn decimals(\u0026self) -\u003e U8 {\n            self.wrapper.decimals()\n        }\n\n        fn underlying(\u0026self) -\u003e Address {\n            self.wrapper.underlying()\n        }\n\n        fn deposit_for(\n            \u0026mut self,\n            account: Address,\n            value: U256,\n        ) -\u003e Result\u003cbool, Error\u003e {\n            self.wrapper.deposit_for(account, value, \u0026mut self.erc20)\n        }\n\n        fn withdraw_to(\n            \u0026mut self,\n            account: Address,\n            value: U256,\n        ) -\u003e Result\u003cbool, Error\u003e {\n            self.wrapper.withdraw_to(account, value, \u0026mut self.erc20)\n        }\n    }\n\n    unsafe impl TopLevelStorage for Erc20WrapperTestExample {}\n\n    #[motsu::test]\n    fn decimals_works(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        metadata: Contract\u003cDummyErc20Metadata\u003e,\n        alice: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(metadata.address());\n        });\n        assert_eq!(\n            contract.sender(alice).decimals(),\n            U8::from(DUMMY_TEST_DECIMALS)\n        );\n    }\n\n    #[motsu::test]\n    fn underlying_works(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let erc20_address = erc20_contract.address();\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_address);\n        });\n\n        assert_eq!(contract.sender(alice).underlying(), erc20_address);\n    }\n\n    #[motsu::test]\n    fn deposit_for_reverts_when_invalid_asset(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        alice: Address,\n    ) {\n        let invalid_asset = alice;\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(invalid_asset);\n        });\n\n        let err = contract\n            .sender(alice)\n            .deposit_for(invalid_asset, uint!(10_U256))\n            .motsu_expect_err(\"should return Error::SafeErc20\");\n\n        assert!(matches!(\n            err,\n            Error::SafeErc20FailedOperation(\n                safe_erc20::SafeErc20FailedOperation { token }\n            ) if token == invalid_asset\n        ));\n    }\n\n    #[motsu::test]\n    fn deposit_for_reverts_when_invalid_sender(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let invalid_sender = contract.address();\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        let err = contract\n            .sender(invalid_sender)\n            .deposit_for(alice, uint!(10_U256))\n            .motsu_expect_err(\"should return Error::InvalidSender\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(erc20::ERC20InvalidSender { sender }) if sender == invalid_sender\n        ));\n    }\n\n    #[motsu::test]\n    fn deposit_for_reverts_when_invalid_receiver(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = contract.address();\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        let err = contract\n            .sender(alice)\n            .deposit_for(invalid_receiver, uint!(10_U256))\n            .motsu_expect_err(\"should return Error::InvalidReceiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(erc20::ERC20InvalidReceiver { receiver }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn deposit_for_reverts_when_insufficient_allowance(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let amount = uint!(10_U256);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        erc20_contract\n            .sender(alice)\n            ._mint(alice, amount)\n            .motsu_expect(\"should mint\");\n\n        let err = contract\n            .sender(alice)\n            .deposit_for(alice, amount)\n            .motsu_expect_err(\"should return Error::SafeErc20\");\n\n        assert!(matches!(\n            err,\n            Error::SafeErc20FailedOperation(\n                safe_erc20::SafeErc20FailedOperation { token }\n            ) if token == erc20_contract.address()\n        ));\n    }\n\n    #[motsu::test]\n    fn deposit_for_reverts_when_insufficient_balance(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let amount = uint!(10_U256);\n\n        let exceeding_value = amount + uint!(1_U256);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        erc20_contract\n            .sender(alice)\n            ._mint(alice, amount)\n            .motsu_expect(\"should mint\");\n\n        erc20_contract\n            .sender(alice)\n            .approve(contract.address(), exceeding_value)\n            .motsu_expect(\"should approve\");\n\n        let err = contract\n            .sender(alice)\n            .deposit_for(alice, exceeding_value)\n            .motsu_expect_err(\"should return Error::SafeErc20\");\n\n        assert!(matches!(\n            err,\n            Error::SafeErc20FailedOperation(\n                safe_erc20::SafeErc20FailedOperation { token }\n            ) if token == erc20_contract.address()\n        ));\n    }\n\n    #[motsu::test]\n    fn deposit_for_works(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let amount = uint!(10_U256);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        erc20_contract\n            .sender(alice)\n            ._mint(alice, amount)\n            .motsu_expect(\"should mint\");\n\n        let initial_balance = erc20_contract.sender(alice).balance_of(alice);\n        let initial_wrapped_balance =\n            contract.sender(alice).erc20.balance_of(alice);\n\n        let initial_contract_balance =\n            erc20_contract.sender(alice).balance_of(contract.address());\n\n        let initial_wrapped_supply =\n            contract.sender(alice).erc20.total_supply();\n\n        erc20_contract\n            .sender(alice)\n            .approve(contract.address(), amount)\n            .motsu_expect(\"should approve\");\n\n        assert!(contract\n            .sender(alice)\n            .deposit_for(alice, amount)\n            .motsu_expect(\"should deposit\"));\n\n        erc20_contract.assert_emitted(\u0026erc20::Transfer {\n            from: alice,\n            to: contract.address(),\n            value: amount,\n        });\n\n        contract.assert_emitted(\u0026erc20::Transfer {\n            from: Address::ZERO,\n            to: alice,\n            value: amount,\n        });\n\n        assert_eq!(\n            erc20_contract.sender(alice).balance_of(alice),\n            initial_balance - amount\n        );\n\n        assert_eq!(\n            contract.sender(alice).erc20.balance_of(alice),\n            initial_wrapped_balance + amount\n        );\n\n        assert_eq!(\n            erc20_contract\n                .sender(contract.address())\n                .balance_of(contract.address()),\n            initial_contract_balance + amount\n        );\n\n        assert_eq!(\n            contract.sender(alice).erc20.total_supply(),\n            initial_wrapped_supply + amount\n        );\n    }\n\n    #[motsu::test]\n    fn withdraw_to_reverts_when_invalid_receiver(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = contract.address();\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        let err = contract\n            .sender(alice)\n            .withdraw_to(invalid_receiver, uint!(10_U256))\n            .motsu_expect_err(\"should return Error::InvalidReceiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(erc20::ERC20InvalidReceiver { receiver }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn withdraw_to_reverts_when_insufficient_balance(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let amount = uint!(10_U256);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        erc20_contract\n            .sender(alice)\n            ._mint(alice, amount)\n            .motsu_expect(\"should mint\");\n\n        erc20_contract\n            .sender(alice)\n            .approve(contract.address(), amount)\n            .motsu_expect(\"should approve\");\n\n        contract\n            .sender(alice)\n            .deposit_for(alice, amount)\n            .motsu_expect(\"should deposit\");\n\n        let exceeding_value = amount + uint!(1_U256);\n\n        let err = contract\n            .sender(alice)\n            .withdraw_to(alice, exceeding_value)\n            .motsu_expect_err(\"should return Error::SafeErc20\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientBalance(\n                erc20::ERC20InsufficientBalance {\n                    sender,\n                    balance,\n                    needed\n                }\n            ) if sender == alice \u0026\u0026 balance == amount \u0026\u0026 needed == exceeding_value\n        ));\n    }\n\n    #[motsu::test]\n    fn withdraw_to_works(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let amount = uint!(10_U256);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        erc20_contract\n            .sender(alice)\n            ._mint(alice, amount)\n            .motsu_expect(\"should mint\");\n\n        erc20_contract\n            .sender(alice)\n            .approve(contract.address(), amount)\n            .motsu_expect(\"should approve\");\n\n        contract\n            .sender(alice)\n            .deposit_for(alice, amount)\n            .motsu_expect(\"should deposit\");\n\n        let initial_balance = erc20_contract.sender(alice).balance_of(alice);\n        let initial_wrapped_balance =\n            contract.sender(alice).erc20.balance_of(alice);\n\n        let initial_contract_balance =\n            erc20_contract.sender(alice).balance_of(contract.address());\n\n        let initial_wrapped_supply =\n            contract.sender(alice).erc20.total_supply();\n\n        assert!(contract\n            .sender(alice)\n            .withdraw_to(alice, amount)\n            .motsu_expect(\"should withdraw\"));\n\n        contract.assert_emitted(\u0026erc20::Transfer {\n            from: alice,\n            to: Address::ZERO,\n            value: amount,\n        });\n\n        erc20_contract.assert_emitted(\u0026erc20::Transfer {\n            from: contract.address(),\n            to: alice,\n            value: amount,\n        });\n\n        assert_eq!(\n            erc20_contract.sender(alice).balance_of(alice),\n            initial_balance + amount\n        );\n\n        assert_eq!(\n            contract.sender(alice).erc20.balance_of(alice),\n            initial_wrapped_balance - amount\n        );\n\n        assert_eq!(\n            erc20_contract\n                .sender(contract.address())\n                .balance_of(contract.address()),\n            initial_contract_balance - amount\n        );\n\n        assert_eq!(\n            contract.sender(alice).erc20.total_supply(),\n            initial_wrapped_supply - amount\n        );\n    }\n\n    #[storage]\n    struct NonErc20;\n\n    #[public]\n    impl NonErc20 {}\n\n    unsafe impl TopLevelStorage for NonErc20 {}\n\n    // TODO: Should be a test for the `Error::InvalidUnderlying` error,\n    // but impossible with current motsu limitations.\n    #[motsu::test]\n    #[ignore]\n    fn recover_reverts_when_invalid_underlying(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        invalid_underlying: Contract\u003cNonErc20\u003e,\n        alice: Address,\n    ) {\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(invalid_underlying.address());\n        });\n\n        let err = contract\n            .sender(alice)\n            .recover(alice)\n            .motsu_expect_err(\"should return Error::InvalidUnderlying\");\n\n        assert!(matches!(\n            err, Error::InvalidUnderlying(ERC20InvalidUnderlying { token }) if token == invalid_underlying.address()\n        ));\n    }\n\n    #[motsu::test]\n    #[should_panic = \"underlying balance should be greater than the `IErc20::total_supply`\"]\n    fn recover_panics_when_underlying_balance_is_less_than_total_supply(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let amount = uint!(10_U256);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        erc20_contract\n            .sender(alice)\n            ._mint(alice, amount)\n            .motsu_expect(\"should mint\");\n\n        erc20_contract\n            .sender(alice)\n            .approve(contract.address(), amount)\n            .motsu_expect(\"should approve\");\n\n        contract\n            .sender(alice)\n            .deposit_for(alice, amount)\n            .motsu_expect(\"should deposit\");\n\n        // Unexpected mint.\n        contract\n            .sender(alice)\n            .erc20\n            ._mint(alice, amount)\n            .motsu_expect(\"should mint\");\n\n        // This should panic.\n        _ = contract.sender(alice).recover(alice);\n    }\n\n    #[motsu::test]\n    fn recover_works_when_underlying_balance_is_equal_to_total_supply(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let amount = uint!(10_U256);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        erc20_contract\n            .sender(alice)\n            ._mint(alice, amount)\n            .motsu_expect(\"should mint\");\n\n        erc20_contract\n            .sender(alice)\n            .approve(contract.address(), amount)\n            .motsu_expect(\"should approve\");\n\n        contract\n            .sender(alice)\n            .deposit_for(alice, amount)\n            .motsu_expect(\"should deposit\");\n\n        assert_eq!(\n            contract\n                .sender(alice)\n                .recover(alice)\n                .motsu_expect(\"should recover\"),\n            U256::ZERO\n        );\n    }\n\n    #[motsu::test]\n    fn recover_works_when_underlying_balance_is_greater_than_total_supply(\n        contract: Contract\u003cErc20WrapperTestExample\u003e,\n        erc20_contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let amount = uint!(10_U256);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc20_contract.address());\n        });\n\n        erc20_contract\n            .sender(alice)\n            ._mint(alice, amount)\n            .motsu_expect(\"should mint\");\n\n        erc20_contract\n            .sender(alice)\n            .approve(contract.address(), amount)\n            .motsu_expect(\"should approve\");\n\n        contract\n            .sender(alice)\n            .deposit_for(alice, amount)\n            .motsu_expect(\"should deposit\");\n\n        // Unexpected mint.\n        let unexpected_delta = uint!(1_U256);\n        erc20_contract\n            .sender(alice)\n            ._mint(contract.address(), unexpected_delta)\n            .motsu_expect(\"should mint\");\n\n        assert_eq!(\n            contract\n                .sender(alice)\n                .recover(alice)\n                .motsu_expect(\"should recover\"),\n            unexpected_delta\n        );\n\n        contract.assert_emitted(\u0026erc20::Transfer {\n            from: Address::ZERO,\n            to: alice,\n            value: unexpected_delta,\n        });\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc20WrapperTestExample as IErc20Wrapper\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0x511f913e_u32.into();\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":15}},{"line":239,"address":[],"length":0,"stats":{"Line":30}},{"line":244,"address":[],"length":0,"stats":{"Line":11}},{"line":250,"address":[],"length":0,"stats":{"Line":22}},{"line":251,"address":[],"length":0,"stats":{"Line":22}},{"line":253,"address":[],"length":0,"stats":{"Line":11}},{"line":254,"address":[],"length":0,"stats":{"Line":1}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":270,"address":[],"length":0,"stats":{"Line":6}},{"line":272,"address":[],"length":0,"stats":{"Line":6}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":283,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":285,"address":[],"length":0,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":1}},{"line":291,"address":[],"length":0,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":3}},{"line":351,"address":[],"length":0,"stats":{"Line":6}},{"line":353,"address":[],"length":0,"stats":{"Line":12}},{"line":355,"address":[],"length":0,"stats":{"Line":6}},{"line":356,"address":[],"length":0,"stats":{"Line":12}},{"line":357,"address":[],"length":0,"stats":{"Line":3}},{"line":364,"address":[],"length":0,"stats":{"Line":4}},{"line":367,"address":[],"length":0,"stats":{"Line":3}}],"covered":36,"coverable":52},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","interface.rs"],"content":"//! Solidity Interface of the ERC-20 token.\npub use token::*;\n\nmod token {\n    #![allow(missing_docs)]\n    #![cfg_attr(coverage_nightly, coverage(off))]\n\n    use alloc::vec;\n\n    use stylus_sdk::prelude::sol_interface;\n    sol_interface! {\n        interface Erc20Interface {\n            function totalSupply() external view returns (uint256);\n            function balanceOf(address account) external view returns (uint256);\n            function transfer(address to, uint256 value) external returns (bool);\n            function allowance(address owner, address spender) external view returns (uint256);\n            function approve(address spender, uint256 value) external returns (bool);\n            function transferFrom(address from, address to, uint256 value) external returns (bool);\n        }\n    }\n\n    sol_interface! {\n        /// Solidity Interface of the ERC-20 Metadata token.\n        interface IErc20MetadataInterface {\n            function name() external view returns (string);\n            function symbol() external view returns (string);\n            function decimals() external view returns (uint8);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","mod.rs"],"content":"//! Implementation of the ERC-20 token standard.\n//!\n//! We have followed general `OpenZeppelin` Contracts guidelines: functions\n//! revert instead of returning `false` on failure. This behavior is\n//! nonetheless conventional and does not conflict with the expectations of\n//! [`Erc20`] applications.\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{Address, FixedBytes, U256};\nuse openzeppelin_stylus_proc::interface_id;\nuse stylus_sdk::{\n    call::MethodError,\n    evm, msg,\n    prelude::*,\n    storage::{StorageMap, StorageU256},\n};\n\nuse crate::utils::{\n    introspection::erc165::IErc165,\n    math::storage::{AddAssignChecked, AddAssignUnchecked, SubAssignUnchecked},\n};\n\npub mod extensions;\npub mod interface;\npub mod utils;\n\npub use sol::*;\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when `value` tokens are moved from one account (`from`) to\n        /// another (`to`).\n        ///\n        /// Note that `value` may be zero.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        /// Emitted when the allowance of a `spender` for an `owner` is set by a\n        /// call to `approve`. `value` is the new allowance.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n    }\n\n    sol! {\n        /// Indicates an error related to the current `balance` of `sender`. Used\n        /// in transfers.\n        ///\n        /// * `sender` - Address whose tokens are being transferred.\n        /// * `balance` - Current balance for the interacting account.\n        /// * `needed` - Minimum amount required to perform a transfer.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n        /// Indicates a failure with the token `sender`. Used in transfers.\n        ///\n        /// * `sender` - Address whose tokens are being transferred.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC20InvalidSender(address sender);\n        /// Indicates a failure with the token `receiver`. Used in transfers.\n        ///\n        /// * `receiver` - Address to which the tokens are being transferred.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC20InvalidReceiver(address receiver);\n        /// Indicates a failure with the `spender`’s `allowance`. Used in\n        /// transfers.\n        ///\n        /// * `spender` - Address that may be allowed to operate on tokens without\n        /// being their owner.\n        /// * `allowance` - Amount of tokens a `spender` is allowed to operate\n        /// with.\n        /// * `needed` - Minimum amount required to perform a transfer.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n        /// Indicates a failure with the `spender` to be approved. Used in\n        /// approvals.\n        ///\n        /// * `spender` - Address that may be allowed to operate on tokens without\n        /// being their owner.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC20InvalidSpender(address spender);\n\n        /// Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n        /// approver Address initiating an approval operation.\n        ///\n        /// * `approver` - Address initiating an approval operation.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC20InvalidApprover(address approver);\n\n    }\n}\n\n/// An [`Erc20`] error defined as described in [ERC-6093].\n///\n/// [ERC-6093]: https://eips.ethereum.org/EIPS/eip-6093\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates an error related to the current balance of `sender`. Used in\n    /// transfers.\n    InsufficientBalance(ERC20InsufficientBalance),\n    /// Indicates a failure with the token `sender`. Used in transfers.\n    InvalidSender(ERC20InvalidSender),\n    /// Indicates a failure with the token `receiver`. Used in transfers.\n    InvalidReceiver(ERC20InvalidReceiver),\n    /// Indicates a failure with the `spender`’s `allowance`. Used in\n    /// transfers.\n    InsufficientAllowance(ERC20InsufficientAllowance),\n    /// Indicates a failure with the `spender` to be approved. Used in\n    /// approvals.\n    InvalidSpender(ERC20InvalidSpender),\n    /// Indicates a failure with the `approver` of a token to be approved. Used\n    /// in approvals. approver Address initiating an approval operation.\n    InvalidApprover(ERC20InvalidApprover),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of an [`Erc20`] token.\n#[storage]\npub struct Erc20 {\n    /// Maps users to balances.\n    pub(crate) balances: StorageMap\u003cAddress, StorageU256\u003e,\n    /// Maps users to a mapping of each spender's allowance.\n    pub(crate) allowances:\n        StorageMap\u003cAddress, StorageMap\u003cAddress, StorageU256\u003e\u003e,\n    /// The total supply of the token.\n    pub(crate) total_supply: StorageU256,\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for Erc20 {}\n\n/// Required interface of an [`Erc20`] compliant contract.\n#[interface_id]\npub trait IErc20 {\n    /// The error type associated to this ERC-20 trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns the number of tokens in existence.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn total_supply(\u0026self) -\u003e U256;\n\n    /// Returns the number of tokens owned by `account`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `account` - Account to get balance from.\n    fn balance_of(\u0026self, account: Address) -\u003e U256;\n\n    /// Moves a `value` amount of tokens from the caller's account to `to`.\n    ///\n    /// Returns a boolean value indicating whether the operation succeeded.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account to transfer tokens to.\n    /// * `value` - Number of tokens to transfer.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If the `to` address is [`Address::ZERO`].\n    /// * [`Error::InsufficientBalance`] - If the caller doesn't have a balance\n    ///   of at least `value`.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e;\n\n    /// Returns the remaining number of tokens that `spender` will be allowed\n    /// to spend on behalf of `owner` through `transfer_from`. This is zero by\n    /// default.\n    ///\n    /// This value changes when `approve` or `transfer_from` are called.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `owner` - Account that owns the tokens.\n    /// * `spender` - Account that will spend the tokens.\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256;\n\n    /// Sets a `value` number of tokens as the allowance of `spender` over the\n    /// caller's tokens.\n    ///\n    /// Returns a boolean value indicating whether the operation succeeded.\n    ///\n    /// WARNING: Beware that changing an allowance with this method brings the\n    /// risk that someone may use both the old and the new allowance by\n    /// unfortunate transaction ordering. One possible solution to mitigate\n    /// this race condition is to first reduce the `spender`'s allowance to 0\n    /// and set the desired value afterwards:\n    /// \u003chttps://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\u003e\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `owner` - Account that owns the tokens.\n    /// * `spender` - Account that will spend the tokens.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSpender`] - If the `spender` address is\n    ///   [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`Approval`].\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e;\n\n    /// Moves a `value` number of tokens from `from` to `to` using the\n    /// allowance mechanism. `value` is then deducted from the caller's\n    /// allowance.\n    ///\n    /// Returns a boolean value indicating whether the operation succeeded.\n    ///\n    /// NOTE: If `value` is the maximum [`U256::MAX`], the allowance is not\n    /// updated on `transfer_from`. This is semantically equivalent to\n    /// an infinite approval.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to transfer tokens from.\n    /// * `to` - Account to transfer tokens to.\n    /// * `value` - Number of tokens to transfer.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSender`] - If the `from` address is [`Address::ZERO`].\n    /// * [`Error::InvalidReceiver`] - If the `to` address is [`Address::ZERO`].\n    /// * [`Error::InsufficientAllowance`] - If not enough allowance is\n    ///   available.\n    /// * [`Error::InsufficientBalance`] - If the `from` address doesn't have\n    ///   enough tokens, then the error\n    ///  is returned.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e;\n}\n\n#[public]\n#[implements(IErc20\u003cError = Error\u003e)]\nimpl Erc20 {}\n\n#[public]\nimpl IErc20 for Erc20 {\n    type Error = Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.total_supply.get()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.balances.get(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        let from = msg::sender();\n        self._transfer(from, to, value)?;\n        Ok(true)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.allowances.get(owner).get(spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        let owner = msg::sender();\n        self._approve(owner, spender, value, true)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        let spender = msg::sender();\n        self._spend_allowance(from, spender, value)?;\n        self._transfer(from, to, value)?;\n        Ok(true)\n    }\n}\n\nimpl Erc20 {\n    /// Sets a `value` number of tokens as the allowance of `spender` over the\n    /// caller's tokens.\n    ///\n    /// Returns a boolean value indicating whether the operation succeeded.\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `owner` - Account that owns the tokens.\n    /// * `spender` - Account that will spend the tokens.\n    /// * `emit_event` - Emit an [`Approval`] event flag.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSpender`] - If the `spender` address is\n    ///   [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`Approval`].\n    fn _approve(\n        \u0026mut self,\n        owner: Address,\n        spender: Address,\n        value: U256,\n        emit_event: bool,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        if owner.is_zero() {\n            return Err(Error::InvalidApprover(ERC20InvalidApprover {\n                approver: Address::ZERO,\n            }));\n        }\n\n        if spender.is_zero() {\n            return Err(Error::InvalidSpender(ERC20InvalidSpender {\n                spender: Address::ZERO,\n            }));\n        }\n\n        self.allowances.setter(owner).insert(spender, value);\n        if emit_event {\n            evm::log(Approval { owner, spender, value });\n        }\n        Ok(true)\n    }\n\n    /// Internal implementation of transferring tokens between two accounts.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account to transfer tokens from.\n    /// * `to` - Account to transfer tokens to.\n    /// * `value` - The number of tokens to transfer.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSender`] - If the `from` address is [`Address::ZERO`].\n    /// * [`Error::InvalidReceiver`] - If the `to` address is [`Address::ZERO`].\n    /// * [`Error::InsufficientBalance`] - If the `from` address doesn't have\n    ///   enough tokens.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    fn _transfer(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if from.is_zero() {\n            return Err(Error::InvalidSender(ERC20InvalidSender {\n                sender: Address::ZERO,\n            }));\n        }\n        if to.is_zero() {\n            return Err(Error::InvalidReceiver(ERC20InvalidReceiver {\n                receiver: Address::ZERO,\n            }));\n        }\n\n        self._update(from, to, value)?;\n\n        Ok(())\n    }\n\n    /// Creates a `value` amount of tokens and assigns them to `account`,\n    /// by transferring it from [`Address::ZERO`].\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If the `account` address is\n    ///   [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    ///\n    /// # Panics\n    ///\n    /// * If `total_supply` exceeds [`U256::MAX`].\n    pub fn _mint(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if account.is_zero() {\n            return Err(Error::InvalidReceiver(ERC20InvalidReceiver {\n                receiver: Address::ZERO,\n            }));\n        }\n        self._update(Address::ZERO, account, value)\n    }\n\n    /// Transfers a `value` amount of tokens from `from` to `to`, or\n    /// alternatively mints (or burns) if `from` (or `to`) is the zero address.\n    ///\n    /// All customizations to transfers, mints, and burns should be done by\n    /// using this function.\n    ///\n    /// # Arguments\n    ///\n    /// * `from` - Owner's address.\n    /// * `to` - Recipient's address.\n    /// * `value` - Amount to be transferred.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InsufficientBalance`] - If the `from` address doesn't have\n    ///   enough tokens.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    ///\n    /// # Panics\n    ///\n    /// * If `total_supply` exceeds [`U256::MAX`]. It may happen during `mint`\n    ///   operation.\n    pub fn _update(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if from.is_zero() {\n            // Mint operation. Overflow check required: the rest of the code\n            // assumes that `total_supply` never overflows.\n            self.total_supply.add_assign_checked(\n                value,\n                \"should not exceed `U256::MAX` for `total_supply`\",\n            );\n        } else {\n            let from_balance = self.balances.get(from);\n            if from_balance \u003c value {\n                return Err(Error::InsufficientBalance(\n                    ERC20InsufficientBalance {\n                        sender: from,\n                        balance: from_balance,\n                        needed: value,\n                    },\n                ));\n            }\n            // Overflow not possible:\n            // `value` \u003c= `from_balance` \u003c= `total_supply`.\n            self.balances.setter(from).set(from_balance - value);\n        }\n\n        if to.is_zero() {\n            // Overflow not possible:\n            // `value` \u003c= `total_supply` or\n            // `value` \u003c= `from_balance` \u003c= `total_supply`.\n            self.total_supply.sub_assign_unchecked(value);\n        } else {\n            // Overflow not possible:\n            // `balance_to` + `value` is at most `total_supply`,\n            // which fits into a `U256`.\n            self.balances.setter(to).add_assign_unchecked(value);\n        }\n\n        evm::log(Transfer { from, to, value });\n\n        Ok(())\n    }\n\n    /// Destroys a `value` amount of tokens from `account`,\n    /// lowering the total supply.\n    ///\n    /// # Arguments\n    ///\n    /// * `account` - Owner's address.\n    /// * `value` - Amount to be burnt.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSender`] - If the `from` address is [`Address::ZERO`].\n    /// * [`Error::InsufficientBalance`] - If the `from` address doesn't have\n    ///   enough tokens.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _burn(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if account == Address::ZERO {\n            return Err(Error::InvalidSender(ERC20InvalidSender {\n                sender: Address::ZERO,\n            }));\n        }\n        self._update(account, Address::ZERO, value)\n    }\n\n    /// Updates `owner`'s allowance for `spender` based on spent `value`.\n    ///\n    /// Does not update the allowance value in the case of infinite allowance.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `owner` - Account to transfer tokens from.\n    /// * `to` - Account to transfer tokens to.\n    /// * `value` - The number of tokens to transfer.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InsufficientAllowance`] - If not enough allowance is\n    ///   available.\n    ///\n    /// # Events\n    ///\n    /// * [`Approval`].\n    pub fn _spend_allowance(\n        \u0026mut self,\n        owner: Address,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        let current_allowance = self.allowance(owner, spender);\n        if current_allowance != U256::MAX {\n            if current_allowance \u003c value {\n                return Err(Error::InsufficientAllowance(\n                    ERC20InsufficientAllowance {\n                        spender,\n                        allowance: current_allowance,\n                        needed: value,\n                    },\n                ));\n            }\n\n            self._approve(owner, spender, current_allowance - value, false)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl IErc165 for Erc20 {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IErc20\u003e::interface_id() == interface_id\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{uint, Address, FixedBytes, U256};\n    use motsu::prelude::*;\n\n    use super::{Approval, Erc20, Error, IErc165, IErc20, Transfer};\n\n    #[motsu::test]\n    fn mint(contract: Contract\u003cErc20\u003e, alice: Address) {\n        let one = uint!(1_U256);\n\n        // Store initial balance \u0026 supply.\n        let initial_balance = contract.sender(alice).balance_of(alice);\n        let initial_supply = contract.sender(alice).total_supply();\n\n        // Mint action should work.\n        let result = contract.sender(alice)._mint(alice, one);\n        assert!(result.is_ok());\n\n        // Check updated balance \u0026 supply.\n        assert_eq!(\n            initial_balance + one,\n            contract.sender(alice).balance_of(alice)\n        );\n        assert_eq!(initial_supply + one, contract.sender(alice).total_supply());\n\n        contract.assert_emitted(\u0026Transfer {\n            from: Address::ZERO,\n            to: alice,\n            value: one,\n        });\n    }\n\n    #[motsu::test]\n    #[should_panic = \"should not exceed `U256::MAX` for `total_supply`\"]\n    fn update_mint_errors_arithmetic_overflow(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let one = uint!(1_U256);\n        assert_eq!(U256::ZERO, contract.sender(alice).balance_of(alice));\n        assert_eq!(U256::ZERO, contract.sender(alice).total_supply());\n\n        // Initialize state for the test case:\n        // Alice's balance as `U256::MAX`.\n        contract\n            .sender(alice)\n            ._mint(alice, U256::MAX)\n            .motsu_expect(\"should mint tokens\");\n        // Mint action should NOT work:\n        // overflow on `total_supply`.\n        let _result = contract.sender(alice)._mint(alice, one);\n    }\n\n    #[motsu::test]\n    fn mint_errors_invalid_receiver(contract: Contract\u003cErc20\u003e, alice: Address) {\n        let receiver = Address::ZERO;\n        let one = uint!(1_U256);\n\n        // Store initial balance \u0026 supply.\n        let initial_balance = contract.sender(alice).balance_of(receiver);\n        let initial_supply = contract.sender(alice).total_supply();\n\n        // Mint action should work.\n        let err =\n            contract.sender(alice)._mint(receiver, one).motsu_unwrap_err();\n        assert!(matches!(err, Error::InvalidReceiver(_)));\n\n        // Check updated balance \u0026 supply.\n        assert_eq!(\n            initial_balance,\n            contract.sender(alice).balance_of(receiver)\n        );\n        assert_eq!(initial_supply, contract.sender(alice).total_supply());\n    }\n\n    #[motsu::test]\n    #[should_panic = \"should not exceed `U256::MAX` for `total_supply`\"]\n    fn mint_errors_arithmetic_overflow(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let one = uint!(1_U256);\n        assert_eq!(U256::ZERO, contract.sender(alice).balance_of(alice));\n        assert_eq!(U256::ZERO, contract.sender(alice).total_supply());\n\n        // Initialize state for the test case:\n        // Alice's balance as [`U256::MAX`].\n        contract\n            .sender(alice)\n            ._mint(alice, U256::MAX)\n            .motsu_expect(\"should mint tokens\");\n        // Mint action should NOT work -- overflow on `_total_supply`.\n        let _result = contract.sender(alice)._mint(alice, one);\n    }\n\n    #[motsu::test]\n    fn burn(contract: Contract\u003cErc20\u003e, alice: Address) {\n        let one = uint!(1_U256);\n        let two = uint!(2_U256);\n\n        // Initialize state for the test case:\n        // Alice's balance as `two`.\n        contract\n            .sender(alice)\n            ._mint(alice, two)\n            .motsu_expect(\"should mint tokens\");\n\n        // Store initial balance \u0026 supply.\n        let initial_balance = contract.sender(alice).balance_of(alice);\n        let initial_supply = contract.sender(alice).total_supply();\n\n        // Burn action should work.\n        contract.sender(alice)._burn(alice, one).motsu_unwrap();\n\n        // Check updated balance \u0026 supply.\n        assert_eq!(\n            initial_balance - one,\n            contract.sender(alice).balance_of(alice)\n        );\n        assert_eq!(initial_supply - one, contract.sender(alice).total_supply());\n\n        contract.assert_emitted(\u0026Transfer {\n            from: alice,\n            to: Address::ZERO,\n            value: one,\n        });\n    }\n\n    #[motsu::test]\n    fn burn_errors_insufficient_balance(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        let one = uint!(1_U256);\n        let two = uint!(2_U256);\n\n        // Initialize state for the test case:\n        // Alice's balance as `one`.\n        contract\n            .sender(alice)\n            ._mint(alice, one)\n            .motsu_expect(\"should mint tokens\");\n\n        // Store initial balance \u0026 supply.\n        let initial_balance = contract.sender(alice).balance_of(alice);\n        let initial_supply = contract.sender(alice).total_supply();\n\n        // Burn action should NOT work - `InsufficientBalance`.\n        let err = contract.sender(alice)._burn(alice, two).motsu_unwrap_err();\n        assert!(matches!(err, Error::InsufficientBalance(_)));\n\n        // Check proper state (before revert).\n        assert_eq!(initial_balance, contract.sender(alice).balance_of(alice));\n        assert_eq!(initial_supply, contract.sender(alice).total_supply());\n    }\n\n    #[motsu::test]\n    fn transfer(contract: Contract\u003cErc20\u003e, alice: Address, bob: Address) {\n        let one = uint!(1_U256);\n\n        // Initialize state for the test case:\n        //  Alice's \u0026 Bob's balance as `one`.\n        contract\n            .sender(alice)\n            ._mint(alice, one)\n            .motsu_expect(\"should mint tokens\");\n        contract\n            .sender(alice)\n            ._mint(bob, one)\n            .motsu_expect(\"should mint tokens\");\n\n        // Store initial balance \u0026 supply.\n        let initial_alice_balance = contract.sender(alice).balance_of(alice);\n        let initial_bob_balance = contract.sender(alice).balance_of(bob);\n        let initial_supply = contract.sender(alice).total_supply();\n\n        // Transfer action should work.\n        let result = contract.sender(alice).transfer(bob, one);\n        assert!(result.is_ok());\n\n        // Check updated balance \u0026 supply.\n        assert_eq!(\n            initial_alice_balance - one,\n            contract.sender(alice).balance_of(alice)\n        );\n        assert_eq!(\n            initial_bob_balance + one,\n            contract.sender(alice).balance_of(bob)\n        );\n        assert_eq!(initial_supply, contract.sender(alice).total_supply());\n\n        contract.assert_emitted(\u0026Transfer { from: alice, to: bob, value: one });\n    }\n\n    #[motsu::test]\n    fn transfer_errors_insufficient_balance(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let one = uint!(1_U256);\n\n        // Initialize state for the test case:\n        // Alice's \u0026 Bob's balance as `one`.\n        contract\n            .sender(alice)\n            ._mint(alice, one)\n            .motsu_expect(\"should mint tokens\");\n        contract\n            .sender(alice)\n            ._mint(bob, one)\n            .motsu_expect(\"should mint tokens\");\n\n        // Store initial balance \u0026 supply.\n        let initial_alice_balance = contract.sender(alice).balance_of(alice);\n        let initial_bob_balance = contract.sender(alice).balance_of(bob);\n        let initial_supply = contract.sender(alice).total_supply();\n\n        // Transfer action should NOT work - `InsufficientBalance`.\n        let err =\n            contract.sender(alice).transfer(bob, one + one).motsu_unwrap_err();\n        assert!(matches!(err, Error::InsufficientBalance(_)));\n\n        // Check proper state (before revert).\n        assert_eq!(\n            initial_alice_balance,\n            contract.sender(alice).balance_of(alice)\n        );\n        assert_eq!(initial_bob_balance, contract.sender(alice).balance_of(bob));\n        assert_eq!(initial_supply, contract.sender(alice).total_supply());\n    }\n\n    #[motsu::test]\n    fn transfer_from(contract: Contract\u003cErc20\u003e, alice: Address, bob: Address) {\n        // Alice approves Bob.\n        let one = uint!(1_U256);\n        contract.sender(alice).approve(bob, one).motsu_unwrap();\n\n        // Mint some tokens for Alice.\n        let two = uint!(2_U256);\n        contract.sender(alice)._mint(alice, two).motsu_unwrap();\n        assert_eq!(two, contract.sender(alice).balance_of(alice));\n\n        contract.sender(bob).transfer_from(alice, bob, one).motsu_unwrap();\n\n        assert_eq!(one, contract.sender(alice).balance_of(alice));\n        assert_eq!(one, contract.sender(alice).balance_of(bob));\n        assert_eq!(U256::ZERO, contract.sender(alice).allowance(alice, bob));\n\n        contract.assert_emitted(\u0026Transfer { from: alice, to: bob, value: one });\n    }\n\n    #[motsu::test]\n    fn error_when_transfer_with_insufficient_balance(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        // Alice approves Bob.\n        let one = uint!(1_U256);\n        contract.sender(alice).approve(bob, one).motsu_unwrap();\n\n        let err = contract\n            .sender(bob)\n            .transfer_from(alice, bob, one)\n            .motsu_unwrap_err();\n        assert!(matches!(err, Error::InsufficientBalance(_)));\n    }\n\n    #[motsu::test]\n    fn error_when_transfer_to_invalid_receiver(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        // Alice approves Bob.\n        let one = uint!(1_U256);\n        contract.sender(alice).approve(bob, one).motsu_unwrap();\n\n        let err = contract\n            .sender(bob)\n            .transfer_from(alice, Address::ZERO, one)\n            .motsu_unwrap_err();\n        assert!(matches!(err, Error::InvalidReceiver(_)));\n    }\n\n    #[motsu::test]\n    fn errors_when_transfer_with_insufficient_allowance(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        // Mint some tokens for Alice.\n        let one = uint!(1_U256);\n        contract.sender(alice)._mint(alice, one).motsu_unwrap();\n        assert_eq!(one, contract.sender(alice).balance_of(alice));\n\n        let err = contract\n            .sender(alice)\n            .transfer_from(alice, bob, one)\n            .motsu_unwrap_err();\n        assert!(matches!(err, Error::InsufficientAllowance(_)));\n    }\n\n    #[motsu::test]\n    fn approves_and_reads_allowance(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let allowance = contract.sender(alice).allowance(alice, bob);\n        assert_eq!(U256::ZERO, allowance);\n\n        let one = uint!(1_U256);\n        contract.sender(alice).approve(bob, one).motsu_unwrap();\n        let allowance = contract.sender(alice).allowance(alice, bob);\n        assert_eq!(one, allowance);\n\n        contract.assert_emitted(\u0026Approval {\n            owner: alice,\n            spender: bob,\n            value: one,\n        });\n    }\n\n    #[motsu::test]\n    fn error_when_approve_for_invalid_spender(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n    ) {\n        // alice approves [`Address::ZERO`].\n        let one = uint!(1_U256);\n        let err = contract\n            .sender(alice)\n            .approve(Address::ZERO, one)\n            .motsu_unwrap_err();\n        assert!(matches!(err, Error::InvalidSpender(_)));\n    }\n\n    #[motsu::test]\n    fn error_when_invalid_approver(\n        contract: Contract\u003cErc20\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let one = uint!(1_U256);\n        let err = contract\n            .sender(alice)\n            ._approve(Address::ZERO, bob, one, false)\n            .motsu_unwrap_err();\n        assert!(matches!(err, Error::InvalidApprover(_)));\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc20 as IErc20\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0x36372b07_u32.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cErc20\u003e, alice: Address) {\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc20 as IErc20\u003e::interface_id()));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc20 as IErc165\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":31}},{"line":284,"address":[],"length":0,"stats":{"Line":62}},{"line":287,"address":[],"length":0,"stats":{"Line":109}},{"line":288,"address":[],"length":0,"stats":{"Line":327}},{"line":291,"address":[],"length":0,"stats":{"Line":3}},{"line":296,"address":[],"length":0,"stats":{"Line":6}},{"line":297,"address":[],"length":0,"stats":{"Line":16}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":301,"address":[],"length":0,"stats":{"Line":19}},{"line":302,"address":[],"length":0,"stats":{"Line":57}},{"line":305,"address":[],"length":0,"stats":{"Line":14}},{"line":310,"address":[],"length":0,"stats":{"Line":28}},{"line":311,"address":[],"length":0,"stats":{"Line":70}},{"line":314,"address":[],"length":0,"stats":{"Line":12}},{"line":320,"address":[],"length":0,"stats":{"Line":24}},{"line":321,"address":[],"length":0,"stats":{"Line":62}},{"line":322,"address":[],"length":0,"stats":{"Line":13}},{"line":323,"address":[],"length":0,"stats":{"Line":7}},{"line":347,"address":[],"length":0,"stats":{"Line":27}},{"line":354,"address":[],"length":0,"stats":{"Line":27}},{"line":355,"address":[],"length":0,"stats":{"Line":1}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":1}},{"line":362,"address":[],"length":0,"stats":{"Line":1}},{"line":367,"address":[],"length":0,"stats":{"Line":13}},{"line":368,"address":[],"length":0,"stats":{"Line":39}},{"line":392,"address":[],"length":0,"stats":{"Line":13}},{"line":398,"address":[],"length":0,"stats":{"Line":13}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":1}},{"line":405,"address":[],"length":0,"stats":{"Line":1}},{"line":409,"address":[],"length":0,"stats":{"Line":3}},{"line":411,"address":[],"length":0,"stats":{"Line":9}},{"line":429,"address":[],"length":0,"stats":{"Line":35}},{"line":434,"address":[],"length":0,"stats":{"Line":35}},{"line":435,"address":[],"length":0,"stats":{"Line":1}},{"line":436,"address":[],"length":0,"stats":{"Line":1}},{"line":467,"address":[],"length":0,"stats":{"Line":57}},{"line":473,"address":[],"length":0,"stats":{"Line":94}},{"line":476,"address":[],"length":0,"stats":{"Line":111}},{"line":477,"address":[],"length":0,"stats":{"Line":37}},{"line":481,"address":[],"length":0,"stats":{"Line":20}},{"line":483,"address":[],"length":0,"stats":{"Line":7}},{"line":484,"address":[],"length":0,"stats":{"Line":7}},{"line":485,"address":[],"length":0,"stats":{"Line":14}},{"line":486,"address":[],"length":0,"stats":{"Line":7}},{"line":487,"address":[],"length":0,"stats":{"Line":7}},{"line":496,"address":[],"length":0,"stats":{"Line":54}},{"line":500,"address":[],"length":0,"stats":{"Line":8}},{"line":505,"address":[],"length":0,"stats":{"Line":46}},{"line":530,"address":[],"length":0,"stats":{"Line":8}},{"line":535,"address":[],"length":0,"stats":{"Line":8}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":15}},{"line":568,"address":[],"length":0,"stats":{"Line":75}},{"line":569,"address":[],"length":0,"stats":{"Line":15}},{"line":570,"address":[],"length":0,"stats":{"Line":15}},{"line":571,"address":[],"length":0,"stats":{"Line":3}},{"line":572,"address":[],"length":0,"stats":{"Line":3}},{"line":573,"address":[],"length":0,"stats":{"Line":6}},{"line":574,"address":[],"length":0,"stats":{"Line":3}},{"line":575,"address":[],"length":0,"stats":{"Line":3}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":12}},{"line":588,"address":[],"length":0,"stats":{"Line":3}},{"line":589,"address":[],"length":0,"stats":{"Line":3}},{"line":590,"address":[],"length":0,"stats":{"Line":2}}],"covered":64,"coverable":71},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","utils","mod.rs"],"content":"//! Utilities for the ERC-20 standard.\npub mod safe_erc20;\n\npub use safe_erc20::{ISafeErc20, SafeErc20};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc20","utils","safe_erc20.rs"],"content":"//! Wrappers around ERC-20 operations that throw on failure (when the token\n//! contract returns false).\n//!\n//! Tokens that return no value (and instead revert or\n//! throw on failure) are also supported, non-reverting calls are assumed to be\n//! successful.\n//!\n//! To use this library, you can add a `#[implements(ISafeErc20\u003cError =\n//! Error\u003e)]` attribute to your contract, which allows you to call the safe\n//! operations as `contract.safe_transfer(token_addr, ...)`, etc.\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{Address, FixedBytes, U256};\nuse alloy_sol_types::SolCall;\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{\n    call::{MethodError, RawCall},\n    contract::address,\n    function_selector,\n    prelude::*,\n    types::AddressVM,\n};\n\nuse crate::utils::introspection::erc165::IErc165;\n\nconst BOOL_TYPE_SIZE: usize = 32;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// An operation with an ERC-20 token failed.\n        ///\n        /// * `token` - Address of the ERC-20 token.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error SafeErc20FailedOperation(address token);\n\n        /// Indicates a failed [`ISafeErc20::safe_decrease_allowance`] request.\n        ///\n        /// * `spender` - Address of future tokens' spender.\n        /// * `current_allowance` - Current allowance of the `spender`.\n        /// * `requested_decrease` - Requested decrease in allowance for `spender`.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error SafeErc20FailedDecreaseAllowance(\n            address spender,\n            uint256 current_allowance,\n            uint256 requested_decrease\n        );\n    }\n}\n\n/// A [`SafeErc20`] error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// An operation with an ERC-20 token failed.\n    SafeErc20FailedOperation(SafeErc20FailedOperation),\n    /// Indicates a failed [`ISafeErc20::safe_decrease_allowance`] request.\n    SafeErc20FailedDecreaseAllowance(SafeErc20FailedDecreaseAllowance),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\npub use token::*;\nmod token {\n    #![allow(missing_docs)]\n    #![cfg_attr(coverage_nightly, coverage(off))]\n    alloy_sol_types::sol! {\n        /// Interface of the ERC-20 token.\n        interface IErc20 {\n            function allowance(address owner, address spender) external view returns (uint256);\n            function approve(address spender, uint256 value) external returns (bool);\n            function transfer(address to, uint256 value) external returns (bool);\n            function transferFrom(address from, address to, uint256 value) external returns (bool);\n        }\n    }\n}\n\n/// State of a [`SafeErc20`] Contract.\n#[storage]\npub struct SafeErc20;\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for SafeErc20 {}\n\n/// Required interface of a [`SafeErc20`] utility contract.\n#[interface_id]\npub trait ISafeErc20 {\n    /// The error type associated to this trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Transfer `value` amount of `token` from the calling contract to `to`. If\n    /// `token` returns no value, non-reverting calls are assumed to be\n    /// successful.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token` - Address of the ERC-20 token contract.\n    /// * `to` - Account to transfer tokens to.\n    /// * `value` - Number of tokens to transfer.\n    ///\n    /// # Errors\n    ///\n    ///  * [`Error::SafeErc20FailedOperation`] - If the `token` address is not a\n    ///    contract , the contract fails to execute the call or the call returns\n    ///    value that is not `true`.\n    fn safe_transfer(\n        \u0026mut self,\n        token: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Transfer `value` amount of `token` from `from` to `to`, spending the\n    /// approval given by `from` to the calling contract. If `token` returns\n    /// no value, non-reverting calls are assumed to be successful.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token` - Address of the ERC-20 token contract.\n    /// * `from` - Account to transfer tokens from.\n    /// * `to` - Account to transfer tokens to.\n    /// * `value` - Number of tokens to transfer.\n    ///\n    /// # Errors\n    ///\n    ///  * [`Error::SafeErc20FailedOperation`] - If the `token` address is not a\n    ///    contract , the contract fails to execute the call or the call returns\n    ///    value that is not `true`.\n    fn safe_transfer_from(\n        \u0026mut self,\n        token: Address,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Increase the calling contract's allowance toward `spender` by `value`.\n    /// If `token` returns no value, non-reverting calls are assumed to be\n    /// successful.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token` - Address of the ERC-20 token contract.\n    /// * `spender` - Account that will spend the tokens.\n    /// * `value` - Value to increase current allowance for `spender`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::SafeErc20FailedOperation`] - If the `token` address is not a\n    ///   contract, the contract fails to execute the call or the call returns\n    ///   value that is not `true`.\n    ///\n    /// # Panics\n    ///\n    /// * If increased allowance exceeds [`U256::MAX`].\n    fn safe_increase_allowance(\n        \u0026mut self,\n        token: Address,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Decrease the calling contract's allowance toward `spender` by\n    /// `requested_decrease`. If `token` returns no value, non-reverting\n    /// calls are assumed to be successful.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token` - Address of the ERC-20 token contract.\n    /// * `spender` - Account that will spend the tokens.\n    /// * `requested_decrease` - Value allowed to be spent by `spender`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::SafeErc20FailedOperation`] - If the `token` address is not a\n    ///   contract, the contract fails to execute the call or the call returns\n    ///   value that is not `true`.\n    /// * [`Error::SafeErc20FailedDecreaseAllowance`] - If the current allowance\n    ///   is less than `requested_decrease`.\n    fn safe_decrease_allowance(\n        \u0026mut self,\n        token: Address,\n        spender: Address,\n        requested_decrease: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Set the calling contract's allowance toward `spender` to `value`. If\n    /// `token` returns no value, non-reverting calls are assumed to be\n    /// successful. Meant to be used with tokens that require the approval\n    /// to be set to zero before setting it to a non-zero value, such as USDT.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token` - Address of the ERC-20 token contract.\n    /// * `spender` - Account that will spend the tokens.\n    /// * `value` - Value allowed to be spent by `spender`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::SafeErc20FailedOperation`] - If the `token` address is not a\n    ///   contract, the contract fails to execute the call or the call returns\n    ///   value that is not `true`.\n    fn force_approve(\n        \u0026mut self,\n        token: Address,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\n#[public]\n#[implements(ISafeErc20\u003cError = Error\u003e)]\nimpl SafeErc20 {}\n\n#[public]\nimpl ISafeErc20 for SafeErc20 {\n    type Error = Error;\n\n    fn safe_transfer(\n        \u0026mut self,\n        token: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let call = IErc20::transferCall { to, value };\n\n        Self::call_optional_return(token, \u0026call)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        token: Address,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let call = IErc20::transferFromCall { from, to, value };\n\n        Self::call_optional_return(token, \u0026call)\n    }\n\n    fn safe_increase_allowance(\n        \u0026mut self,\n        token: Address,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let current_allowance = Self::allowance(token, spender)?;\n        let new_allowance = current_allowance\n            .checked_add(value)\n            .expect(\"should not exceed `U256::MAX` for allowance\");\n        self.force_approve(token, spender, new_allowance)\n    }\n\n    fn safe_decrease_allowance(\n        \u0026mut self,\n        token: Address,\n        spender: Address,\n        requested_decrease: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let current_allowance = Self::allowance(token, spender)?;\n\n        if current_allowance \u003c requested_decrease {\n            return Err(SafeErc20FailedDecreaseAllowance {\n                spender,\n                current_allowance,\n                requested_decrease,\n            }\n            .into());\n        }\n\n        self.force_approve(\n            token,\n            spender,\n            current_allowance - requested_decrease,\n        )\n    }\n\n    fn force_approve(\n        \u0026mut self,\n        token: Address,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let approve_call = IErc20::approveCall { spender, value };\n\n        // Try performing the approval with the desired value.\n        if Self::call_optional_return(token, \u0026approve_call).is_ok() {\n            return Ok(());\n        }\n\n        // If that fails, reset the allowance to zero, then retry the desired\n        // approval.\n        let reset_approval_call =\n            IErc20::approveCall { spender, value: U256::ZERO };\n        Self::call_optional_return(token, \u0026reset_approval_call)?;\n        Self::call_optional_return(token, \u0026approve_call)\n    }\n}\n\nimpl SafeErc20 {\n    /// Imitates a Stylus high-level call, relaxing the requirement on the\n    /// return value: if data is returned, it must not be `false`, otherwise\n    /// calls are assumed to be successful.\n    ///\n    /// # Arguments\n    ///\n    /// * `token` - Address of the ERC-20 token contract.\n    /// * `call` - [`IErc20`] call that implements [`SolCall`] trait.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::SafeErc20FailedOperation`] - If the `token` address is not a\n    ///   contract, the contract fails to execute the call or the call returns\n    ///   value that is not `true`.\n    fn call_optional_return(\n        token: Address,\n        call: \u0026impl SolCall,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !Address::has_code(\u0026token) {\n            return Err(SafeErc20FailedOperation { token }.into());\n        }\n\n        unsafe {\n            match RawCall::new()\n                .limit_return_data(0, BOOL_TYPE_SIZE)\n                .flush_storage_cache()\n                .call(token, \u0026call.abi_encode())\n            {\n                Ok(data) if data.is_empty() || Self::encodes_true(\u0026data) =\u003e {\n                    Ok(())\n                }\n                _ =\u003e Err(SafeErc20FailedOperation { token }.into()),\n            }\n        }\n    }\n\n    /// Returns the remaining number of ERC-20 tokens that `spender`\n    /// will be allowed to spend on behalf of an owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `token` - Address of the ERC-20 token contract.\n    /// * `spender` - Account that will spend the tokens.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::SafeErc20FailedOperation`] - If the `token` address is not a\n    ///   contract.\n    /// * [`Error::SafeErc20FailedOperation`] - If the contract fails to read\n    ///   `spender`'s allowance.\n    fn allowance(token: Address, spender: Address) -\u003e Result\u003cU256, Error\u003e {\n        if !Address::has_code(\u0026token) {\n            return Err(SafeErc20FailedOperation { token }.into());\n        }\n\n        let call = IErc20::allowanceCall { owner: address(), spender };\n        let result = unsafe {\n            RawCall::new()\n                .limit_return_data(0, BOOL_TYPE_SIZE)\n                .flush_storage_cache()\n                .call(token, \u0026call.abi_encode())\n                .map_err(|_| {\n                    Error::SafeErc20FailedOperation(SafeErc20FailedOperation {\n                        token,\n                    })\n                })?\n        };\n\n        Ok(U256::from_be_slice(\u0026result))\n    }\n\n    /// Returns true if a slice of bytes is an ABI encoded `true` value.\n    ///\n    /// # Arguments\n    ///\n    /// * `data` - Slice of bytes.\n    fn encodes_true(data: \u0026[u8]) -\u003e bool {\n        data.split_last().is_some_and(|(last, rest)| {\n            *last == 1 \u0026\u0026 rest.iter().all(|\u0026byte| byte == 0)\n        })\n    }\n}\n\nimpl IErc165 for SafeErc20 {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as ISafeErc20\u003e::interface_id() == interface_id\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use motsu::prelude::Contract;\n    use stylus_sdk::alloy_primitives::{Address, FixedBytes};\n\n    use super::{ISafeErc20, SafeErc20};\n    use crate::utils::introspection::erc165::IErc165;\n\n    #[test]\n    fn encodes_true_empty_slice() {\n        assert!(!SafeErc20::encodes_true(\u0026[]));\n    }\n\n    #[test]\n    fn encodes_false_single_byte() {\n        assert!(!SafeErc20::encodes_true(\u0026[0]));\n    }\n\n    #[test]\n    fn encodes_true_single_byte() {\n        assert!(SafeErc20::encodes_true(\u0026[1]));\n    }\n\n    #[test]\n    fn encodes_false_many_bytes() {\n        assert!(!SafeErc20::encodes_true(\u0026[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));\n    }\n\n    #[test]\n    fn encodes_true_many_bytes() {\n        assert!(SafeErc20::encodes_true(\u0026[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]));\n    }\n\n    #[test]\n    fn encodes_true_wrong_bytes() {\n        assert!(!SafeErc20::encodes_true(\u0026[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]));\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cSafeErc20 as ISafeErc20\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0xf71993e3_u32.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cSafeErc20\u003e, alice: Address) {\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cSafeErc20 as IErc165\u003e::interface_id()));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cSafeErc20 as ISafeErc20\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":3}},{"line":246,"address":[],"length":0,"stats":{"Line":9}},{"line":253,"address":[],"length":0,"stats":{"Line":27}},{"line":255,"address":[],"length":0,"stats":{"Line":27}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":10}},{"line":336,"address":[],"length":0,"stats":{"Line":10}},{"line":337,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":9}},{"line":342,"address":[],"length":0,"stats":{"Line":9}},{"line":343,"address":[],"length":0,"stats":{"Line":9}},{"line":344,"address":[],"length":0,"stats":{"Line":27}},{"line":346,"address":[],"length":0,"stats":{"Line":28}},{"line":349,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":13}},{"line":395,"address":[],"length":0,"stats":{"Line":51}},{"line":396,"address":[],"length":0,"stats":{"Line":261}},{"line":402,"address":[],"length":0,"stats":{"Line":3}},{"line":403,"address":[],"length":0,"stats":{"Line":3}},{"line":404,"address":[],"length":0,"stats":{"Line":2}}],"covered":21,"coverable":48},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc6909","erc6909.rs"],"content":"// #![no_std]\n// extern crate alloc;\n\n// // bring vec![] macro and Vec\u003cT\u003e into scope\n// use alloc::{vec, vec::Vec};\n\n// use alloy_primitives::{Address, U256};\n// use stylus_sdk::{\n//     prelude::{storage, HostAccess, StorageType},\n//     storage::{StorageBool, StorageMap, StorageUint},\n// };\n\n// use super::{\n//     error::Error,\n//     traits::{IErc6909, IErc6909Burnable, IErc6909Mintable},\n// };\n\n// /// Core ERC-6909 (no supply tracking), single-ID multi-token standard.\n// ///\n// /// All storage fields get a `::new(...)` constructor generated by the\n// /// `#[storage]` macro (requires `StorageType` in scope).\n// #[storage]\n// pub struct Erc6909 {\n//     /// owner ⇒ (id ⇒ balance)\n//     balances: StorageMap\u003cAddress, StorageMap\u003cU256, StorageUint\u003c256, 4\u003e\u003e\u003e,\n\n//     /// owner ⇒ (spender ⇒ (id ⇒ allowance))\n//     allowances: StorageMap\u003c\n//         Address,\n//         StorageMap\u003cAddress, StorageMap\u003cU256, StorageUint\u003c256, 4\u003e\u003e\u003e,\n//     \u003e,\n\n//     /// owner ⇒ (operator ⇒ approved?)\n//     operator_approvals: StorageMap\u003cAddress, StorageMap\u003cAddress, StorageBool\u003e\u003e,\n// }\n\n// impl Erc6909 {\n//     /// Single‐point hook for mint/burn/transfer.\n//     #[inline(always)]\n//     fn _update(\n//         \u0026mut self,\n//         from: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e {\n//         // ── debit `from` ─────────────────────────\n//         if !from.is_zero() {\n//             // bind each setter to its own local so the parent map guard\n//             // outlives `slot`\n//             let mut by_owner = self.balances.setter(from);\n//             let mut slot = by_owner.setter(id);\n\n//             let prev = slot.get();\n//             if prev \u003c amount {\n//                 return Err(Error::InsufficientBalance);\n//             }\n\n//             // subtraction is safe, because we just checked\n//             slot.set(prev - amount);\n//         }\n\n//         // ── credit `to` ──────────────────────────\n//         if !to.is_zero() {\n//             let mut by_owner = self.balances.setter(to);\n//             let mut slot = by_owner.setter(id);\n\n//             let prev = slot.get();\n//             // one checked_add + early error\n//             let next =\n//                 prev.checked_add(amount).ok_or(Error::ArithmeticOverflow)?;\n//             slot.set(next);\n//         }\n\n//         Ok(())\n//     }\n\n//     /// Low-level mint hook (from = zero).\n//     #[inline(always)]\n//     pub fn _mint(\n//         \u0026mut self,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e {\n//         if to.is_zero() {\n//             return Err(Error::InvalidReceiver);\n//         }\n//         self._update(Address::ZERO, to, id, amount)\n//     }\n\n//     /// Low-level burn hook (to = zero).\n//     #[inline(always)]\n//     pub fn _burn(\n//         \u0026mut self,\n//         from: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e {\n//         if from.is_zero() {\n//             return Err(Error::InvalidSender);\n//         }\n//         self._update(from, Address::ZERO, id, amount)\n//     }\n// }\n\n// impl IErc6909 for Erc6909 {\n//     /// Returns the balance of `owner` for token `id`.\n//     fn balance_of(\u0026self, owner: Address, id: U256) -\u003e U256 {\n//         self.balances.get(owner).get(id)\n//     }\n\n//     /// Returns current allowance `owner` has granted `spender` for `id`.\n//     fn allowance(\u0026self, owner: Address, spender: Address, id: U256) -\u003e U256 {\n//         self.allowances.get(owner).get(spender).get(id)\n//     }\n\n//     /// Returns true if `operator` is approved to manage all of `owner`’s\n//     /// tokens.\n//     fn is_operator(\u0026self, owner: Address, operator: Address) -\u003e bool {\n//         self.operator_approvals.get(owner).get(operator)\n//     }\n\n//     /// Set allowance `amount` for `spender` to use token `id` from `caller`.\n//     fn approve(\n//         \u0026mut self,\n//         caller: Address,\n//         spender: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003cbool, Error\u003e {\n//         if caller.is_zero() {\n//             return Err(Error::InvalidApprover);\n//         }\n//         if spender.is_zero() {\n//             return Err(Error::InvalidSpender);\n//         }\n//         let mut by_owner = self.allowances.setter(caller);\n//         let mut by_spender = by_owner.setter(spender);\n//         let mut slot = by_spender.setter(id);\n//         slot.set(amount);\n//         Ok(true)\n//     }\n\n//     /// Set or unset `operator` to manage *all* tokens of `caller`.\n//     fn set_operator(\n//         \u0026mut self,\n//         caller: Address,\n//         operator: Address,\n//         approved: bool,\n//     ) -\u003e Result\u003cbool, Error\u003e {\n//         if caller.is_zero() {\n//             return Err(Error::InvalidApprover);\n//         }\n//         if operator.is_zero() {\n//             return Err(Error::InvalidSpender);\n//         }\n//         let mut by_owner = self.operator_approvals.setter(caller);\n//         let mut slot = by_owner.setter(operator);\n//         slot.set(approved);\n//         Ok(true)\n//     }\n\n//     /// Transfer `amount` of `id` from `caller` to `to`.\n//     fn transfer(\n//         \u0026mut self,\n//         caller: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003cbool, Error\u003e {\n//         // forward to transfer_from with self-allowance\n//         self.transfer_from(caller, caller, to, id, amount)\n//     }\n\n//     /// Transfer `amount` of `id` from `from` to `to`, using allowances or\n//     /// operator rights.\n//     fn transfer_from(\n//         \u0026mut self,\n//         caller: Address,\n//         from: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003cbool, Error\u003e {\n//         if from.is_zero() {\n//             return Err(Error::InvalidSender);\n//         }\n//         if to.is_zero() {\n//             return Err(Error::InvalidReceiver);\n//         }\n\n//         // if caller is neither owner nor operator, spend allowance\n//         if caller != from \u0026\u0026 !self.is_operator(from, caller) {\n//             let mut by_owner = self.allowances.setter(from);\n//             let mut by_caller = by_owner.setter(caller);\n//             let mut slot = by_caller.setter(id);\n\n//             let allowance = slot.get();\n//             if allowance \u003c amount {\n//                 return Err(Error::InsufficientAllowance);\n//             }\n//             slot.set(allowance - amount);\n//         }\n\n//         self._update(from, to, id, amount)?;\n//         Ok(true)\n//     }\n// }\n\n// // ─── Mintable \u0026 Burnable thin wrappers ──────────────────────────────────────\n\n// impl IErc6909Mintable for Erc6909 {\n//     #[inline]\n//     fn mint(\n//         \u0026mut self,\n//         _caller: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e {\n//         self._mint(to, id, amount)\n//     }\n// }\n\n// impl IErc6909Burnable for Erc6909 {\n//     #[inline]\n//     fn burn(\n//         \u0026mut self,\n//         _caller: Address,\n//         from: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e {\n//         self._burn(from, id, amount)\n//     }\n// }\n\n// #[cfg(test)]\n// mod tests {\n//     use super::*;\n//     use stylus_sdk::testing::TestVM;\n//     use alloy_primitives::{Address, U256};\n//     use crate::token::erc6909::Error;\n\n//     use crate::token::erc6909::extensions::metadata_uri::Erc6909MetadataUri;\n\n\n//     /// Helper to get a fresh token and two accounts.\n//     fn fresh() -\u003e (Erc6909, Address, Address, U256) {\n//         let vm = TestVM::default();\n//         let mut t = Erc6909::from(\u0026vm);\n//         let alice = Address::new([1u8; 20]);\n//         let bob   = Address::new([2u8; 20]);\n//         let id    = U256::from(42u64);\n//         (t, alice, bob, id)\n//     }\n\n//     #[test]\n//     fn zero_address_mint_reverts() {\n//         let (mut t, _alice, _bob, id) = fresh();\n//         let zero = Address::zero();\n//         let res = t.mint(zero, zero, id, U256::from(1u64));\n//         assert_eq!(res, Err(Error::InvalidApprover));\n//     }\n\n//     #[test]\n//     fn burn_underflow_reverts() {\n//         let (mut t, alice, _, id) = fresh();\n//         // Alice has zero balance initially\n//         let res = t.burn(alice, alice, id, U256::from(1u64));\n//         assert_eq!(res, Err(Error::InsufficientBalance));\n//     }\n\n//     #[test]\n//     fn approve_zero_address_reverts() {\n//         let (mut t, alice, _bob, id) = fresh();\n//         let zero = Address::zero();\n//         let res = t.approve(alice, zero, id, U256::from(1u64));\n//         assert_eq!(res, Err(Error::InvalidApprover));\n//     }\n\n//     #[test]\n//     fn transfer_zero_amount_ok() {\n//         let (mut t, alice, bob, id) = fresh();\n//         // mint some first\n//         t.mint(alice, alice, id, U256::from(10u64)).unwrap();\n//         // transferring zero should succeed (no-op)\n//         assert!(t.transfer(alice, bob, id, U256::ZERO).unwrap());\n//     }\n\n//     #[test]\n//     fn metadata_only_nonzero_caller() {\n//         let (mut t, alice, _, id) = fresh();\n//         // hook up metadata extension\n//         let mut meta = Erc6909MetadataUri::from(\u0026t.vm());\n//         let zero = Address::zero();\n//         let res = meta.set_token_uri(zero, id, b\"foo\".to_vec());\n//         assert_eq!(res, Err(Error::InvalidApprover));\n//     }\n// }\n\n\n// contracts/src/erc6909/erc6909.rs FINAL VERSION WORKED FINE\n// #![no_std]\n// extern crate alloc;\n\n// // bring vec![] macro and Vec\u003cT\u003e into scope\n// use alloc::{vec, vec::Vec};\n\n// use alloy_primitives::{Address, U256};\n// use stylus_sdk::{\n//     prelude::{storage, HostAccess, StorageType},\n//     storage::{StorageBool, StorageMap, StorageUint},\n// };\n\n// use super::{\n//     error::Error,\n//     traits::{IErc6909, IErc6909Burnable, IErc6909Mintable},\n// };\n\n// /// Core ERC-6909 (no supply tracking), single-ID multi-token standard.\n// ///\n// /// All storage fields get a `::new(...)` constructor generated by the\n// /// `#[storage]` macro (requires `StorageType` in scope).\n// #[storage]\n// pub struct Erc6909 {\n//     /// owner ⇒ (id ⇒ balance)\n//     balances: StorageMap\u003cAddress, StorageMap\u003cU256, StorageUint\u003c256, 4\u003e\u003e\u003e,\n\n//     /// owner ⇒ (spender ⇒ (id ⇒ allowance))\n//     allowances: StorageMap\u003c\n//         Address,\n//         StorageMap\u003cAddress, StorageMap\u003cU256, StorageUint\u003c256, 4\u003e\u003e\u003e,\n//     \u003e,\n\n//     /// owner ⇒ (operator ⇒ approved?)\n//     operator_approvals: StorageMap\u003cAddress, StorageMap\u003cAddress, StorageBool\u003e\u003e,\n// }\n\n// impl Erc6909 {\n//     /// Single‐point hook for mint/burn/transfer.\n//     #[inline(always)]\n//     fn _update(\n//         \u0026mut self,\n//         from: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e {\n//         // ── debit `from` ─────────────────────────\n//         if from != Address::new([0u8; 20]) {\n//             let mut by_owner = self.balances.setter(from);\n//             let mut slot = by_owner.setter(id);\n\n//             let prev = slot.get();\n//             if prev \u003c amount {\n//                 return Err(Error::InsufficientBalance);\n//             }\n//             slot.set(prev - amount);\n//         }\n\n//         // ── credit `to` ──────────────────────────\n//         if to != Address::new([0u8; 20]) {\n//             let mut by_owner = self.balances.setter(to);\n//             let mut slot = by_owner.setter(id);\n\n//             let prev = slot.get();\n//             let next = prev.checked_add(amount).ok_or(Error::ArithmeticOverflow)?;\n//             slot.set(next);\n//         }\n\n//         Ok(())\n//     }\n\n//     /// Low-level mint hook (from = zero).\n//     #[inline(always)]\n//     pub fn _mint(\n//         \u0026mut self,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e {\n//         if to == Address::new([0u8; 20]) {\n//             return Err(Error::InvalidReceiver);\n//         }\n//         self._update(Address::new([0u8; 20]), to, id, amount)\n//     }\n\n//     /// Low-level burn hook (to = zero).\n//     #[inline(always)]\n//     pub fn _burn(\n//         \u0026mut self,\n//         from: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e {\n//         if from == Address::new([0u8; 20]) {\n//             return Err(Error::InvalidSender);\n//         }\n//         self._update(from, Address::new([0u8; 20]), id, amount)\n//     }\n// }\n\n// impl IErc6909 for Erc6909 {\n//     fn balance_of(\u0026self, owner: Address, id: U256) -\u003e U256 {\n//         self.balances.get(owner).get(id)\n//     }\n\n//     fn allowance(\u0026self, owner: Address, spender: Address, id: U256) -\u003e U256 {\n//         self.allowances.get(owner).get(spender).get(id)\n//     }\n\n//     fn is_operator(\u0026self, owner: Address, operator: Address) -\u003e bool {\n//         self.operator_approvals.get(owner).get(operator)\n//     }\n\n//     fn approve(\n//         \u0026mut self,\n//         caller: Address,\n//         spender: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003cbool, Error\u003e {\n//         if caller == Address::new([0u8; 20]) {\n//             return Err(Error::InvalidApprover);\n//         }\n//         if spender == Address::new([0u8; 20]) {\n//             return Err(Error::InvalidSpender);\n//         }\n//         let mut by_owner = self.allowances.setter(caller);\n//         let mut by_spender = by_owner.setter(spender);\n//         let mut slot = by_spender.setter(id);\n//         slot.set(amount);\n//         Ok(true)\n//     }\n\n//     fn set_operator(\n//         \u0026mut self,\n//         caller: Address,\n//         operator: Address,\n//         approved: bool,\n//     ) -\u003e Result\u003cbool, Error\u003e {\n//         if caller == Address::new([0u8; 20]) {\n//             return Err(Error::InvalidApprover);\n//         }\n//         if operator == Address::new([0u8; 20]) {\n//             return Err(Error::InvalidSpender);\n//         }\n//         let mut by_owner = self.operator_approvals.setter(caller);\n//         let mut slot = by_owner.setter(operator);\n//         slot.set(approved);\n//         Ok(true)\n//     }\n\n//     fn transfer(\n//         \u0026mut self,\n//         caller: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003cbool, Error\u003e {\n//         self.transfer_from(caller, caller, to, id, amount)\n//     }\n\n//     fn transfer_from(\n//         \u0026mut self,\n//         caller: Address,\n//         from: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003cbool, Error\u003e {\n//         if from == Address::new([0u8; 20]) {\n//             return Err(Error::InvalidSender);\n//         }\n//         if to == Address::new([0u8; 20]) {\n//             return Err(Error::InvalidReceiver);\n//         }\n\n//         if caller != from \u0026\u0026 !self.is_operator(from, caller) {\n//             let mut by_owner = self.allowances.setter(from);\n//             let mut by_caller = by_owner.setter(caller);\n//             let mut slot = by_caller.setter(id);\n\n//             let allowance = slot.get();\n//             if allowance \u003c amount {\n//                 return Err(Error::InsufficientAllowance);\n//             }\n//             slot.set(allowance - amount);\n//         }\n\n//         self._update(from, to, id, amount)?;\n//         Ok(true)\n//     }\n// }\n\n// impl IErc6909Mintable for Erc6909 {\n//     #[inline]\n//     fn mint(\n//         \u0026mut self,\n//         _caller: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e {\n//         self._mint(to, id, amount)\n//     }\n// }\n\n// impl IErc6909Burnable for Erc6909 {\n//     #[inline]\n//     fn burn(\n//         \u0026mut self,\n//         _caller: Address,\n//         from: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e {\n//         self._burn(from, id, amount)\n//     }\n// }\n\n// #[cfg(test)]\n// mod tests {\n//     use super::*;\n//     use stylus_sdk::testing::TestVM;\n//     use alloy_primitives::{Address, U256};\n//     use crate::token::erc6909::Error;\n//     use crate::token::erc6909::extensions::metadata_uri::Erc6909MetadataUri;\n//     use crate::token::erc6909::traits::IErc6909MetadataUri;\n\n//     /// Helper to get a fresh token, VM, and two accounts.\n//     fn fresh() -\u003e (Erc6909, TestVM, Address, Address, U256) {\n//         let vm = TestVM::default();\n//         let mut t = Erc6909::from(\u0026vm);\n//         let alice = Address::new([1u8; 20]);\n//         let bob   = Address::new([2u8; 20]);\n//         let id    = U256::from(42u64);\n//         (t, vm, alice, bob, id)\n//     }\n\n//     #[test]\n//     fn zero_address_mint_reverts() {\n//         let (mut t, _, _, _, id) = fresh();\n//         let zero = Address::new([0u8; 20]);\n//         let res = t.mint(zero, zero, id, U256::from(1u64));\n//         assert_eq!(res, Err(Error::InvalidApprover));\n//     }\n\n//     #[test]\n//     fn burn_underflow_reverts() {\n//         let (mut t, _, alice, _, id) = fresh();\n//         let res = t.burn(alice, alice, id, U256::from(1u64));\n//         assert_eq!(res, Err(Error::InsufficientBalance));\n//     }\n\n//     #[test]\n//     fn approve_zero_address_reverts() {\n//         let (mut t, _, alice, _, id) = fresh();\n//         let zero = Address::new([0u8; 20]);\n//         let res = t.approve(alice, zero, id, U256::from(1u64));\n//         assert_eq!(res, Err(Error::InvalidApprover));\n//     }\n\n//     #[test]\n//     fn transfer_zero_amount_ok() {\n//         let (mut t, _, alice, bob, id) = fresh();\n//         t.mint(alice, alice, id, U256::from(10u64)).unwrap();\n//         assert!(t.transfer(alice, bob, id, U256::ZERO).unwrap());\n//     }\n\n//     #[test]\n//     fn metadata_only_nonzero_caller() {\n//         let (mut t, vm, alice, _, id) = fresh();\n//         let mut meta = Erc6909MetadataUri::from(\u0026vm);\n//         let zero = Address::new([0u8; 20]);\n//         let res = meta.set_token_uri(zero, id, b\"foo\".to_vec());\n//         assert_eq!(res, Err(Error::InvalidApprover));\n//     }\n// }\n\n// contracts/src/erc6909/erc6909.rs \n// FINAL VERSION WORKED FINE\n// All test passed\n\n#![no_std]\nextern crate alloc;\n\n// bring vec![] macro and Vec\u003cT\u003e into scope\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{Address, U256};\nuse stylus_sdk::{\n    prelude::{storage, HostAccess, StorageType},\n    storage::{StorageBool, StorageMap, StorageUint},\n};\n\nuse super::{\n    error::Error,\n    traits::{IErc6909, IErc6909Burnable, IErc6909Mintable},\n};\n\n// use stylus_sdk::testing::TestVM;\n\n\n/// Core ERC-6909 (no supply tracking), single-ID multi-token standard.\n///\n/// All storage fields get a `::new(...)` constructor generated by the\n/// `#[storage]` macro (requires `StorageType` in scope).\n#[storage]\npub struct Erc6909 {\n    /// owner ⇒ (id ⇒ balance)\n    balances: StorageMap\u003cAddress, StorageMap\u003cU256, StorageUint\u003c256, 4\u003e\u003e\u003e,\n\n    /// owner ⇒ (spender ⇒ (id ⇒ allowance))\n    allowances: StorageMap\u003c\n        Address,\n        StorageMap\u003cAddress, StorageMap\u003cU256, StorageUint\u003c256, 4\u003e\u003e\u003e,\n    \u003e,\n\n    /// owner ⇒ (operator ⇒ approved?)\n    operator_approvals: StorageMap\u003cAddress, StorageMap\u003cAddress, StorageBool\u003e\u003e,\n}\n\nimpl Erc6909 {\n    #[inline(always)]\n    fn _update(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        // debit from\n        if from != Address::new([0u8; 20]) {\n            let mut by_owner = self.balances.setter(from);\n            let mut slot = by_owner.setter(id);\n            let prev = slot.get();\n            if prev \u003c amount {\n                return Err(Error::InsufficientBalance);\n            }\n            slot.set(prev - amount);\n        }\n        // credit to\n        if to != Address::new([0u8; 20]) {\n            let mut by_owner = self.balances.setter(to);\n            let mut slot = by_owner.setter(id);\n            let prev = slot.get();\n            let next = prev.checked_add(amount).ok_or(Error::ArithmeticOverflow)?;\n            slot.set(next);\n        }\n        Ok(())\n    }\n\n    #[inline(always)]\n    pub fn _mint(\n        \u0026mut self,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if to == Address::new([0u8; 20]) {\n            return Err(Error::InvalidReceiver);\n        }\n        self._update(Address::new([0u8; 20]), to, id, amount)\n    }\n\n    #[inline(always)]\n    pub fn _burn(\n        \u0026mut self,\n        from: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if from == Address::new([0u8; 20]) {\n            return Err(Error::InvalidSender);\n        }\n        self._update(from, Address::new([0u8; 20]), id, amount)\n    }\n}\n\nimpl IErc6909 for Erc6909 {\n    fn balance_of(\u0026self, owner: Address, id: U256) -\u003e U256 {\n        self.balances.get(owner).get(id)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address, id: U256) -\u003e U256 {\n        self.allowances.get(owner).get(spender).get(id)\n    }\n\n    fn is_operator(\u0026self, owner: Address, operator: Address) -\u003e bool {\n        self.operator_approvals.get(owner).get(operator)\n    }\n\n    fn approve(\n        \u0026mut self,\n        caller: Address,\n        spender: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        // reject any zero-address as approver or spender\n        if caller == Address::new([0u8; 20]) {\n            return Err(Error::InvalidApprover);\n        }\n        if spender == Address::new([0u8; 20]) {\n            return Err(Error::InvalidApprover);\n        }\n        let mut by_owner = self.allowances.setter(caller);\n        let mut by_spender = by_owner.setter(spender);\n        let mut slot = by_spender.setter(id);\n        slot.set(amount);\n        Ok(true)\n    }\n\n    fn set_operator(\n        \u0026mut self,\n        caller: Address,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        if caller == Address::new([0u8; 20]) {\n            return Err(Error::InvalidApprover);\n        }\n        if operator == Address::new([0u8; 20]) {\n            return Err(Error::InvalidSpender);\n        }\n        let mut by_owner = self.operator_approvals.setter(caller);\n        let mut slot = by_owner.setter(operator);\n        slot.set(approved);\n        Ok(true)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        caller: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.transfer_from(caller, caller, to, id, amount)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        caller: Address,\n        from: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        if from == Address::new([0u8; 20]) {\n            return Err(Error::InvalidSender);\n        }\n        if to == Address::new([0u8; 20]) {\n            return Err(Error::InvalidReceiver);\n        }\n        if caller != from \u0026\u0026 !self.is_operator(from, caller) {\n            let mut by_owner = self.allowances.setter(from);\n            let mut by_caller = by_owner.setter(caller);\n            let mut slot = by_caller.setter(id);\n            let allowance = slot.get();\n            if allowance \u003c amount {\n                return Err(Error::InsufficientAllowance);\n            }\n            slot.set(allowance - amount);\n        }\n        self._update(from, to, id, amount)?;\n        Ok(true)\n    }\n}\n\nimpl IErc6909Mintable for Erc6909 {\n    #[inline]\n    fn mint(\n        \u0026mut self,\n        caller: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        // guard against zero caller or recipient\n        if caller == Address::new([0u8; 20]) {\n            return Err(Error::InvalidApprover);\n        }\n        if to == Address::new([0u8; 20]) {\n            return Err(Error::InvalidApprover);\n        }\n        // proceed with internal mint\n        self._mint(to, id, amount)\n    }\n}\n\nimpl IErc6909Burnable for Erc6909 {\n    #[inline]\n    fn burn(\n        \u0026mut self,\n        _caller: Address,\n        from: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self._burn(from, id, amount)\n    }\n}\n\n\n// Unit TESTS\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use stylus_sdk::testing::TestVM;\n    use alloy_primitives::{Address, U256};\n    use crate::token::erc6909::Error;\n    use motsu::prelude::*;\n\n    // use crate::token::erc6909::extensions::composite_token::MyToken;\n\n\n    // Core traits:\n    use crate::token::erc6909::traits::{\n        IErc6909,\n        IErc6909Mintable,\n        IErc6909Burnable,\n    };\n\n    // Extension traits \u0026 types:\n    use crate::token::erc6909::traits::{\n        IErc6909Supply,\n        IErc6909MetadataUri,\n        IErc6909Enumerable,\n    };\n    use crate::token::erc6909::extensions::{\n        metadata_uri::Erc6909MetadataUri,\n        token_supply::Erc6909Supply,\n        enumerable::Erc6909Enumerable,\n    };\n\n    /// Helper: fresh core + VM + two addresses + an ID\n    fn fresh_core() -\u003e (Erc6909, TestVM, Address, Address, U256) {\n        let vm    = TestVM::default();\n        let t     = Erc6909::from(\u0026vm);\n        let alice = Address::new([0xAA;20]);\n        let bob   = Address::new([0xBB;20]);\n        let id    = U256::from(1u64);\n        (t, vm, alice, bob, id)\n    }\n\n    #[motsu::test]\n    fn zero_address_mint_reverts() {\n        let (mut t, _, _, _, id) = fresh_core();\n        let zero = Address::new([0u8;20]);\n        let res = t.mint(zero, zero, id, U256::from(1u64));\n        assert_eq!(res, Err(Error::InvalidApprover));\n    }\n\n    #[motsu::test]\n    fn burn_underflow_reverts() {\n        let (mut t, _, alice, _, id) = fresh_core();\n        let res = t.burn(alice, alice, id, U256::from(1u64));\n        assert_eq!(res, Err(Error::InsufficientBalance));\n    }\n\n    #[motsu::test]\n    fn approve_zero_address_reverts() {\n        let (mut t, _, alice, _, id) = fresh_core();\n        let zero = Address::new([0u8;20]);\n        let res = t.approve(alice, zero, id, U256::from(1u64));\n        assert_eq!(res, Err(Error::InvalidApprover));\n    }\n\n    #[motsu::test]\n    fn transfer_zero_amount_ok() {\n        let (mut t, _, alice, bob, id) = fresh_core();\n        t.mint(alice, alice, id, U256::from(10u64)).unwrap();\n        assert!(t.transfer(alice, bob, id, U256::ZERO).unwrap());\n    }\n\n    #[motsu::test]\n    fn supply_tracks_total() {\n        let (_, vm, alice, _, id) = fresh_core();\n        let mut sup = Erc6909Supply::from(\u0026vm);\n        // mint 7 for Alice\n        sup.mint(alice, alice, id, U256::from(7u64)).unwrap();\n        assert_eq!(sup.total_supply(id), U256::from(7u64));\n        // burn 3\n        sup.burn(alice, alice, id, U256::from(3u64)).unwrap();\n        assert_eq!(sup.total_supply(id), U256::from(4u64));\n    }\n\n    #[motsu::test]\n    fn metadata_round_trip() {\n        let (_, vm, _, _, id) = fresh_core();\n        let mut meta = Erc6909MetadataUri::from(\u0026vm);\n        let alice = Address::new([0xAA;20]);\n        // only nonzero caller can set\n        assert_eq!( meta.set_token_uri(alice, id, b\"hello\".to_vec()),\n                    Ok(true) );\n        assert_eq!( meta.token_uri(id), b\"hello\".to_vec() );\n    }\n\n    #[motsu::test]\n    fn enumerable_behaviour() {\n        let (_, vm, _, _, _) = fresh_core();\n        let mut en = Erc6909Enumerable::from(\u0026vm);\n\n        en._record_id(U256::from(10u64));\n        en._record_id(U256::from(20u64));\n        en._record_id(U256::from(30u64));\n\n        assert_eq!(en.total_ids(), U256::from(3u64));\n        assert_eq!(en.id_by_index(U256::from(0u64)), U256::from(10u64));\n        assert_eq!(en.id_by_index(U256::from(1u64)), U256::from(20u64));\n        assert_eq!(en.id_by_index(U256::from(2u64)), U256::from(30u64));    \n    }\n}\n","traces":[{"line":628,"address":[],"length":0,"stats":{"Line":6}},{"line":636,"address":[],"length":0,"stats":{"Line":12}},{"line":637,"address":[],"length":0,"stats":{"Line":16}},{"line":638,"address":[],"length":0,"stats":{"Line":12}},{"line":639,"address":[],"length":0,"stats":{"Line":8}},{"line":640,"address":[],"length":0,"stats":{"Line":4}},{"line":641,"address":[],"length":0,"stats":{"Line":1}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":5}},{"line":647,"address":[],"length":0,"stats":{"Line":16}},{"line":648,"address":[],"length":0,"stats":{"Line":12}},{"line":649,"address":[],"length":0,"stats":{"Line":8}},{"line":650,"address":[],"length":0,"stats":{"Line":24}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":5}},{"line":657,"address":[],"length":0,"stats":{"Line":2}},{"line":663,"address":[],"length":0,"stats":{"Line":4}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":2}},{"line":676,"address":[],"length":0,"stats":{"Line":4}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":3}},{"line":685,"address":[],"length":0,"stats":{"Line":9}},{"line":688,"address":[],"length":0,"stats":{"Line":1}},{"line":689,"address":[],"length":0,"stats":{"Line":4}},{"line":692,"address":[],"length":0,"stats":{"Line":1}},{"line":693,"address":[],"length":0,"stats":{"Line":3}},{"line":696,"address":[],"length":0,"stats":{"Line":2}},{"line":704,"address":[],"length":0,"stats":{"Line":4}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":1}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":1}},{"line":742,"address":[],"length":0,"stats":{"Line":7}},{"line":745,"address":[],"length":0,"stats":{"Line":2}},{"line":753,"address":[],"length":0,"stats":{"Line":4}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":3}},{"line":760,"address":[],"length":0,"stats":{"Line":1}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":2}},{"line":770,"address":[],"length":0,"stats":{"Line":2}},{"line":776,"address":[],"length":0,"stats":{"Line":4}},{"line":784,"address":[],"length":0,"stats":{"Line":8}},{"line":785,"address":[],"length":0,"stats":{"Line":1}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":3}},{"line":804,"address":[],"length":0,"stats":{"Line":15}}],"covered":39,"coverable":61},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc6909","error.rs"],"content":"#![no_std]\n\n/// Typed error codes for ERC-6909 operations.\n///\n/// These correspond to revert reasons in the Solidity reference contract,\n/// plus an explicit overflow error for checked arithmetic.\n#[derive(Debug, Copy, Clone, Eq, PartialEq)]\npub enum Error {\n    /// Caller tried to approve from the zero address.\n    InvalidApprover,\n    /// Caller tried to transfer/mint to the zero address.\n    InvalidReceiver,\n    /// Caller tried to burn/transfer from the zero address.\n    InvalidSender,\n    /// Caller tried to set operator to the zero address.\n    InvalidSpender,\n    /// Balance was insufficient for the requested operation.\n    InsufficientBalance,\n    /// Allowance was insufficient for the requested spend.\n    InsufficientAllowance,\n    /// An addition or subtraction overflow/underflow was detected.\n    ArithmeticOverflow,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc6909","extensions","enumerable.rs"],"content":"#![no_std]\n\nuse alloc::{vec, vec::Vec};\nuse alloy_primitives::U256;\nuse stylus_sdk::{\n    prelude::{storage, HostAccess, StorageType},\n    host::VM,\n};\nuse stylus_sdk::storage::{StorageVec, StorageMap, StorageUint};\n\nuse crate::token::erc6909::traits::IErc6909Enumerable;\nuse core::convert::TryInto;\n\n/// Enumerable extension: tracks all unique IDs and their indices.\n#[storage]\npub struct Erc6909Enumerable {\n    /// List of token IDs in insertion order.\n    all_ids: StorageVec\u003cStorageUint\u003c256, 4\u003e\u003e,\n    /// Mapping from token ID → its index in `all_ids`.\n    index_of: StorageMap\u003cU256, StorageUint\u003c256, 4\u003e\u003e,\n}\n\nimpl Erc6909Enumerable {\n    /// Internal hook: record a new ID if not seen before.\n    pub fn _record_id(\u0026mut self, id: U256) {\n        // Skip if already recorded\n        let exists_u256: U256 = self.index_of.get(id).into();\n        // If already recorded (non-zero), skip\n        if exists_u256 != U256::ZERO {\n            return;\n        }\n        \n        // Determine next index\n        let next_index: U256 = U256::from(self.all_ids.len());\n        \n        // Append to list and update map\n        self.all_ids.push(id);\n        self.index_of.insert(id, next_index);\n    }\n}\n\nimpl IErc6909Enumerable for Erc6909Enumerable {\n    /// Returns the total number of unique IDs recorded.\n    fn total_ids(\u0026self) -\u003e U256 {\n        U256::from(self.all_ids.len())\n    }\n\n    /// Returns the token ID at the given index, or zero if out of bounds.\n    fn id_by_index(\u0026self, index: U256) -\u003e U256 {\n        // Convert U256 index to usize by taking the low 8 bytes\n        let raw: [u8; 32] = index.to_le_bytes();\n        let idx_u64 = u64::from_le_bytes(raw[0..8].try_into().unwrap());\n        let idx_usize = idx_u64 as usize;\n\n        self.all_ids\n            .get(idx_usize)\n            .unwrap_or(U256::ZERO)\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":18}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":3}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":52,"address":[],"length":0,"stats":{"Line":15}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":3}}],"covered":12,"coverable":13},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc6909","extensions","metadata_uri.rs"],"content":"#![no_std]\nextern crate alloc;\n\nuse alloc::{vec, vec::Vec};\nuse core::convert::TryFrom;\n\nuse alloy_primitives::{Address, Uint, U256};\nuse stylus_sdk::{\n    prelude::{storage, HostAccess, StorageType},\n    storage::{StorageBool, StorageMap, StorageUint},\n};\n\nuse crate::token::erc6909::{traits::IErc6909MetadataUri, Error};\n\n/// ERC-6909 metadata-URI extension: stores for each `id`\n///   • `uri_len[id]` → length (Uint\u003c256\u003e),  \n///   • `uri_byte[id][idx]` → the byte at `idx` (Uint\u003c8\u003e).\n#[storage]\npub struct Erc6909MetadataUri {\n    /// id → length\n    uri_len: StorageMap\u003cU256, StorageUint\u003c256, 4\u003e\u003e,\n    /// id → (index → byte)\n    uri_byte: StorageMap\u003cU256, StorageMap\u003cU256, StorageUint\u003c8, 1\u003e\u003e\u003e,\n}\n\nimpl IErc6909MetadataUri for Erc6909MetadataUri {\n    fn token_uri(\u0026self, id: U256) -\u003e Vec\u003cu8\u003e {\n        // 1) read the length\n        let len_u256 = self.uri_len.get(id);\n\n        // 2) iterate in U256 space\n        let mut idx = U256::ZERO;\n        let mut out = Vec::new();\n        while idx \u003c len_u256 {\n            // read the stored Uint\u003c8\u003e\n            let byte_u8 = {\n                let b_u256 = self\n                    .uri_byte\n                    .get(id) // get the second‐level map\n                    .get(idx); // get the byte at `idx`\n                               // convert Uint\u003c8,1\u003e → u8 via TryFrom\n                u8::try_from(b_u256).unwrap_or(0)\n            };\n            out.push(byte_u8);\n            idx = idx.checked_add(U256::ONE).unwrap();\n        }\n        out\n    }\n\n    fn set_token_uri(\n        \u0026mut self,\n        caller: Address,\n        id: U256,\n        uri: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        if caller.is_zero() {\n            return Err(Error::InvalidApprover);\n        }\n\n        // 1) store the length\n        let len = U256::from(uri.len() as u64);\n        self.uri_len.insert(id, len);\n\n        // 2) store each byte\n        let mut idx = U256::ZERO;\n        for \u0026b in uri.iter() {\n            // convert raw u8 → Uint\u003c8,1\u003e\n            let byte8: Uint\u003c8, 1\u003e = Uint::from_be_bytes([b]);\n            // let b_u256 = U256::from(b as u64);\n\n            // nested setter: uri_byte[id][idx] = b_u256\n            let mut by_id = self.uri_byte.setter(id);\n            let mut by_idx = by_id.setter(idx);\n            by_idx.set(byte8);\n            idx = idx.checked_add(U256::ONE).unwrap();\n        }\n        Ok(true)\n    }\n}\n\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":11}},{"line":36,"address":[],"length":0,"stats":{"Line":5}},{"line":37,"address":[],"length":0,"stats":{"Line":5}},{"line":38,"address":[],"length":0,"stats":{"Line":5}},{"line":39,"address":[],"length":0,"stats":{"Line":5}},{"line":40,"address":[],"length":0,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":5}},{"line":44,"address":[],"length":0,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":5}}],"covered":17,"coverable":18},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc6909","extensions","mod.rs"],"content":"#![no_std]\n\npub mod metadata_uri;\npub mod token_supply;\npub mod enumerable;\n\n\n// only re-export the _types_ here; the traits stay in the top-level\n// `traits.rs`\npub use metadata_uri::Erc6909MetadataUri;\npub use token_supply::Erc6909Supply;\npub use enumerable::Erc6909Enumerable;\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc6909","extensions","token_supply.rs"],"content":"#![no_std]\nextern crate alloc;\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{Address, U256};\nuse stylus_sdk::{\n    prelude::{storage, HostAccess, StorageType},\n    storage::{StorageMap, StorageUint},\n};\n\n\n// === change these imports to point at the core ERC-6909 and its traits ===\nuse super::super::{\n    erc6909::Erc6909,\n    error::Error,\n    traits::{IErc6909, IErc6909Mintable, IErc6909Burnable, IErc6909Supply},\n};\n\n/// ERC-6909 + per-ID total-supply extension.\n#[storage]\npub struct Erc6909Supply {\n    /// The core ERC-6909 logic\n    pub base: Erc6909,\n    /// Tracks minted minus burned for each token ID\n    total_supplies: StorageMap\u003cU256, StorageUint\u003c256, 4\u003e\u003e,\n}\n\n// --------------------------------------------------------------------------\n// IErc6909Supply: just read out our `total_supplies` map\n// --------------------------------------------------------------------------\nimpl IErc6909Supply for Erc6909Supply {\n    fn total_supply(\u0026self, id: U256) -\u003e U256 {\n        self.total_supplies.get(id)\n    }\n}\n\n// --------------------------------------------------------------------------\n// IErc6909: forward every core method to `base`\n// --------------------------------------------------------------------------\nimpl IErc6909 for Erc6909Supply {\n    fn balance_of(\u0026self, owner: Address, id: U256) -\u003e U256 {\n        self.base.balance_of(owner, id)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address, id: U256) -\u003e U256 {\n        self.base.allowance(owner, spender, id)\n    }\n\n    fn is_operator(\u0026self, owner: Address, operator: Address) -\u003e bool {\n        self.base.is_operator(owner, operator)\n    }\n\n    fn approve(\n        \u0026mut self,\n        caller: Address,\n        spender: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.base.approve(caller, spender, id, amount)\n    }\n\n    fn set_operator(\n        \u0026mut self,\n        caller: Address,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.base.set_operator(caller, operator, approved)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        caller: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.base.transfer(caller, to, id, amount)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        caller: Address,\n        from: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.base.transfer_from(caller, from, to, id, amount)\n    }\n}\n\n// --------------------------------------------------------------------------\n// IErc6909Mintable: bump our total_supplies then mint balances\n// --------------------------------------------------------------------------\nimpl IErc6909Mintable for Erc6909Supply {\n    fn mint(\n        \u0026mut self,\n        caller: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        // 1) update total_supplies[id] += amount\n        let old = self.total_supplies.get(id);\n        let new = old.checked_add(amount).ok_or(Error::ArithmeticOverflow)?;\n        self.total_supplies.insert(id, new);\n        // 2) mint the balance\n        self.base.mint(caller, to, id, amount)\n    }\n}\n\n// --------------------------------------------------------------------------\n// IErc6909Burnable: burn balances then decrement total_supplies\n// --------------------------------------------------------------------------\nimpl IErc6909Burnable for Erc6909Supply {\n    fn burn(\n        \u0026mut self,\n        caller: Address,\n        from: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        // 1) burn the balance\n        self.base.burn(caller, from, id, amount)?;\n        // 2) decrement total_supplies[id]\n        let old = self.total_supplies.get(id);\n        // you may want to guard underflow here; core already checks balances\n        let new = old.checked_sub(amount).unwrap_or_default();\n        self.total_supplies.insert(id, new);\n        Ok(())\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":6}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":129,"address":[],"length":0,"stats":{"Line":1}}],"covered":8,"coverable":22},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc6909","mod.rs"],"content":"// #![no_std]\n\n// pub mod erc6909;\n// pub mod error;\n// pub mod extensions;\n// pub mod traits;\n\n// // ─── Core exports\n// // ───────────────────────────────────────────────────────────────\n// pub use erc6909::Erc6909;\n// pub use error::Error;\n// pub use extensions::metadata_uri::Erc6909MetadataUri;\n// // ─── Extensions (types)\n// // ─────────────────────────────────────────────────────────\n// pub use extensions::token_supply::Erc6909Supply;\n// // ─── Traits export\n// // ──────────────────────────────────────────────────────────────\n// pub use traits::{\n//     IErc6909, IErc6909Burnable, IErc6909MetadataUri, IErc6909Mintable,\n//     IErc6909Supply,\n// };\n\n#![no_std]\n\npub mod erc6909;\npub mod error;\npub mod extensions;\npub mod traits;\n\n// ─── Core exports ───────────────────────────────────────────────────────────\npub use erc6909::Erc6909;\npub use error::Error;\n\n// ─── Extension *types* ──────────────────────────────────────────────────────\npub use extensions::metadata_uri::Erc6909MetadataUri;\npub use extensions::token_supply::Erc6909Supply;\n\n// ─── All of the ERC-6909 traits ──────────────────────────────────────────────\npub use traits::{\n    IErc6909,\n    IErc6909Mintable,\n    IErc6909Burnable,\n    IErc6909Supply,\n    IErc6909MetadataUri,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc6909","traits.rs"],"content":"#![no_std]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse alloy_primitives::{Address, U256};\n\nuse super::error::Error;\n\n/// Core ERC-6909 interface: single-ID multi-token.\npub trait IErc6909 {\n    fn balance_of(\u0026self, owner: Address, id: U256) -\u003e U256;\n    fn allowance(\u0026self, owner: Address, spender: Address, id: U256) -\u003e U256;\n    fn is_operator(\u0026self, owner: Address, operator: Address) -\u003e bool;\n\n    fn approve(\n        \u0026mut self,\n        caller: Address,\n        spender: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e;\n\n    fn set_operator(\n        \u0026mut self,\n        caller: Address,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003cbool, Error\u003e;\n\n    fn transfer(\n        \u0026mut self,\n        caller: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e;\n\n    fn transfer_from(\n        \u0026mut self,\n        caller: Address,\n        from: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e;\n}\n\n/// Mintable extension\npub trait IErc6909Mintable {\n    fn mint(\n        \u0026mut self,\n        caller: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003c(), Error\u003e;\n}\n\n/// Burnable extension\npub trait IErc6909Burnable {\n    fn burn(\n        \u0026mut self,\n        caller: Address,\n        from: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003c(), Error\u003e;\n}\n\n/// Supply-tracking extension\npub trait IErc6909Supply {\n    fn total_supply(\u0026self, id: U256) -\u003e U256;\n}\n\n/// Metadata-URI extension\npub trait IErc6909MetadataUri {\n    fn token_uri(\u0026self, id: U256) -\u003e Vec\u003cu8\u003e;\n    fn set_token_uri(\n        \u0026mut self,\n        caller: Address,\n        id: U256,\n        uri: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e;\n}\n\n/// Enumerable extension trait for ERC-6909.\npub trait IErc6909Enumerable {\n    /// Returns total unique IDs recorded.\n    fn total_ids(\u0026self) -\u003e U256;\n    /// Returns the ID at `index`, or zero if out of bounds.\n    fn id_by_index(\u0026self, index: U256) -\u003e U256;\n}\n\n// #![no_std]\n// extern crate alloc;\n\n// use alloc::vec::Vec;\n// use alloy_primitives::{Address, U256};\n\n// use super::error::Error;\n\n// /// ERC-6909 core interface: single-ID multi-token standard.\n// pub trait IErc6909 {\n//     /// Returns the `owner`’s balance of token `id`.\n//     fn balance_of(\u0026self, owner: Address, id: U256) -\u003e U256;\n\n//     /// Returns how much `spender` is still allowed to transfer of `owner`’s\n// `id`.     fn allowance(\u0026self, owner: Address, spender: Address, id: U256) -\u003e\n// U256;\n\n//     /// Returns true if `operator` is approved to manage *all* of `owner`’s\n// tokens.     fn is_operator(\u0026self, owner: Address, operator: Address) -\u003e bool;\n\n//     /// Grant `spender` permission to transfer up to `amount` of token `id`\n// from `caller`.     ///\n//     /// # Errors\n//     /// - [`Error::InvalidApprover`] if `caller` is the zero address.\n//     /// - [`Error::InvalidSpender`]  if `spender` is the zero address.\n//     fn approve(\n//         \u0026mut self,\n//         caller: Address,\n//         spender: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003cbool, Error\u003e;\n\n//     /// Set or unset `operator` as a global operator for `caller`.\n//     ///\n//     /// # Errors\n//     /// - [`Error::InvalidApprover`] if `caller` is the zero address.\n//     /// - [`Error::InvalidSpender`]  if `operator` is the zero address.\n//     fn set_operator(\n//         \u0026mut self,\n//         caller: Address,\n//         operator: Address,\n//         approved: bool,\n//     ) -\u003e Result\u003cbool, Error\u003e;\n\n//     /// Transfer `amount` of `id` from `caller` to `to`.\n//     ///\n//     /// # Errors\n//     /// - [`Error::InvalidSender`]   if `caller` is the zero address.\n//     /// - [`Error::InvalidReceiver`] if `to` is the zero address.\n//     /// - [`Error::InsufficientBalance`]\n//     /// - [`Error::ArithmeticOverflow`]\n//     fn transfer(\n//         \u0026mut self,\n//         caller: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003cbool, Error\u003e;\n\n//     /// Transfer `amount` of `id` from `from` to `to`, spending allowance or\n// operator rights.     ///\n//     /// # Errors\n//     /// - [`Error::InvalidSender`]         if `from` is the zero address.\n//     /// - [`Error::InvalidReceiver`]       if `to` is the zero address.\n//     /// - [`Error::InsufficientAllowance`]\n//     /// - [`Error::InsufficientBalance`]\n//     /// - [`Error::ArithmeticOverflow`]\n//     fn transfer_from(\n//         \u0026mut self,\n//         caller: Address,\n//         from: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003cbool, Error\u003e;\n// }\n\n// /// Thin wrapper over the core `_mint` hook.\n// pub trait IErc6909Mintable {\n//     /// Mint `amount` of `id` into `to`.\n//     ///\n//     /// # Errors\n//     /// - [`Error::InvalidReceiver`]\n//     /// - [`Error::ArithmeticOverflow`]\n//     fn mint(\n//         \u0026mut self,\n//         caller: Address,\n//         to: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e;\n// }\n\n// /// Thin wrapper over the core `_burn` hook.\n// pub trait IErc6909Burnable {\n//     /// Burn `amount` of `id` from `from`.\n//     ///\n//     /// # Errors\n//     /// - [`Error::InvalidSender`]\n//     /// - [`Error::InsufficientBalance`]\n//     fn burn(\n//         \u0026mut self,\n//         caller: Address,\n//         from: Address,\n//         id: U256,\n//         amount: U256,\n//     ) -\u003e Result\u003c(), Error\u003e;\n// }\n\n// /// Supply‐tracking extension: total minted minus burned per ID.\n// pub trait IErc6909Supply {\n//     /// Returns total supply of token `id`.\n//     fn total_supply(\u0026self, id: U256) -\u003e U256;\n// }\n\n// /// Simple metadata‐URI extension: store arbitrary bytes per ID.\n// pub trait IErc6909MetadataUri {\n//     /// Returns the URI bytes for `id`.\n//     fn token_uri(\u0026self, id: U256) -\u003e Vec\u003cu8\u003e;\n\n//     /// Sets the URI bytes for `id`.\n//     ///\n//     /// # Errors\n//     /// - [`Error::InvalidApprover`] if `caller` is the zero address.\n//     fn set_token_uri(\n//         \u0026mut self,\n//         caller: Address,\n//         id: U256,\n//         uri: Vec\u003cu8\u003e,\n//     ) -\u003e Result\u003cbool, Error\u003e;\n// }\n\n// /// Enumerable extension: list and index all known IDs.\n// pub trait IErc6909Enumerable {\n//     /// Returns a `Vec` of *all* token IDs that have ever existed.\n//     fn total_ids(\u0026self) -\u003e Vec\u003cU256\u003e;\n\n//     /// Returns the token ID at position `index`.\n//     ///\n//     /// # Panics\n//     /// If `index \u003e= total_ids().len()`.\n//     fn id_by_index(\u0026self, index: U256) -\u003e U256;\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc721","extensions","burnable.rs"],"content":"//! Optional Burnable extension of the ERC-721 standard.\nuse alloc::vec::Vec;\n\nuse alloy_primitives::{Address, U256};\nuse openzeppelin_stylus_proc::interface_id;\nuse stylus_sdk::{msg, prelude::*};\n\nuse crate::token::erc721::{self, Erc721};\n\n/// An [`Erc721`] token that can be burned (destroyed).\n#[interface_id]\npub trait IErc721Burnable {\n    /// The error type associated to this trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Burns `token_id`.\n    /// The approval is cleared when the token is burned.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - Amount to be burnt.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::NonexistentToken`] - If token does not exist.\n    /// * [`erc721::Error::InsufficientApproval`] - If the caller does not have\n    ///   the right to approve.\n    ///\n    /// # Events\n    ///\n    /// * [`erc721::Transfer`].\n    fn burn(\u0026mut self, token_id: U256) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\n#[public]\nimpl IErc721Burnable for Erc721 {\n    type Error = erc721::Error;\n\n    fn burn(\u0026mut self, token_id: U256) -\u003e Result\u003c(), Self::Error\u003e {\n        // Setting an \"auth\" arguments enables the\n        // [`super::super::Erc721::_is_authorized`] check which verifies that\n        // the token exists (from != [`Address::ZERO`]).\n        //\n        // Therefore, it is not needed to verify that the return value is not 0\n        // here.\n        self._update(Address::ZERO, token_id, msg::sender())?;\n        Ok(())\n    }\n}\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{uint, Address};\n    use motsu::prelude::*;\n\n    use super::*;\n    use crate::token::erc721::{\n        ERC721InsufficientApproval, ERC721NonexistentToken, Erc721, Error,\n        IErc721,\n    };\n\n    const TOKEN_ID: U256 = uint!(1_U256);\n\n    #[motsu::test]\n    fn burns(contract: Contract\u003cErc721\u003e, alice: Address) {\n        let one = uint!(1_U256);\n\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token for Alice\");\n\n        let initial_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        let result = contract.sender(alice).burn(TOKEN_ID);\n        assert!(result.is_ok());\n\n        let balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        assert_eq!(initial_balance - one, balance);\n\n        let err = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken (ERC721NonexistentToken{\n                token_id: t_id\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn burns_with_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint a token for Bob\");\n\n        let initial_balance = contract\n            .sender(alice)\n            .balance_of(bob)\n            .expect(\"should return the balance of Bob\");\n\n        contract\n            .sender(bob)\n            .approve(alice, TOKEN_ID)\n            .expect(\"should approve a token for Alice\");\n\n        let result = contract.sender(alice).burn(TOKEN_ID);\n        assert!(result.is_ok());\n\n        let err = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken (ERC721NonexistentToken{\n                token_id: t_id\n            }) if t_id == TOKEN_ID\n        ));\n\n        let balance = contract\n            .sender(alice)\n            .balance_of(bob)\n            .expect(\"should return the balance of Bob\");\n\n        assert_eq!(initial_balance - uint!(1_U256), balance);\n    }\n\n    #[motsu::test]\n    fn burns_with_approval_for_all(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint a token for Bob\");\n\n        let initial_balance = contract\n            .sender(alice)\n            .balance_of(bob)\n            .expect(\"should return the balance of Bob\");\n\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve all Bob's tokens for Alice\");\n\n        let result = contract.sender(alice).burn(TOKEN_ID);\n\n        assert!(result.is_ok());\n\n        let err = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken (ERC721NonexistentToken{\n                token_id: t_id\n            }) if t_id == TOKEN_ID\n        ));\n\n        let balance = contract\n            .sender(alice)\n            .balance_of(bob)\n            .expect(\"should return the balance of Bob\");\n\n        assert_eq!(initial_balance - uint!(1_U256), balance);\n    }\n\n    #[motsu::test]\n    fn error_when_get_approved_of_previous_approval_burned(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token for Alice\");\n        contract\n            .sender(alice)\n            .approve(bob, TOKEN_ID)\n            .expect(\"should approve a token for Bob\");\n\n        contract\n            .sender(alice)\n            .burn(TOKEN_ID)\n            .expect(\"should burn previously minted token\");\n\n        let err = contract\n            .sender(alice)\n            .get_approved(TOKEN_ID)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken (ERC721NonexistentToken{\n                token_id: t_id\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_burn_without_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint a token for Bob\");\n\n        let err = contract\n            .sender(alice)\n            .burn(TOKEN_ID)\n            .expect_err(\"should not burn unapproved token\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientApproval(ERC721InsufficientApproval {\n                    operator,\n                    token_id: t_id,\n            }) if operator == alice \u0026\u0026 t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_burn_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            .burn(TOKEN_ID)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken (ERC721NonexistentToken{\n                token_id: t_id\n            }) if t_id == TOKEN_ID\n        ));\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":46,"address":[],"length":0,"stats":{"Line":26}},{"line":47,"address":[],"length":0,"stats":{"Line":4}}],"covered":3,"coverable":3},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc721","extensions","consecutive.rs"],"content":"//! Implementation of the ERC-2309 \"Consecutive Transfer Extension\" as defined\n//! in the [ERC].\n//!\n//! This extension allows the minting large batches of tokens, during\n//! contract construction only. For upgradeable contracts, this implies that\n//! batch minting is only available during proxy deployment, and not in\n//! subsequent upgrades. These batches are limited to 5000 tokens at a time by\n//! default to accommodate off-chain indexers.\n//!\n//! Using this extension removes the ability to mint single tokens during\n//! contract construction. This ability is regained after construction. During\n//! construction, only batch minting is allowed.\n//!\n//! Fields `first_consecutive_id` (used to offset first token id) and\n//! `max_batch_size` (used to restrict maximum batch size) can be assigned\n//! during construction.\n//!\n//! IMPORTANT: Consecutive mint of [`Erc721Consecutive`] tokens is only allowed\n//! inside the contract's Solidity constructor.\n//! As opposed to the Solidity implementation of Consecutive, there is no\n//! restriction on the [`Erc721Consecutive::_update`] function call since it is\n//! not possible to call a Rust function from the Solidity constructor.\n//!\n//! [ERC]: https://eips.ethereum.org/EIPS/eip-2309\n\nuse alloc::{vec, vec::Vec};\nuse core::ops::{Deref, DerefMut};\n\nuse alloy_primitives::{aliases::U96, uint, Address, FixedBytes, U256};\nuse stylus_sdk::{abi::Bytes, call::MethodError, evm, msg, prelude::*};\n\nuse crate::{\n    token::erc721::{\n        self, Approval, ERC721IncorrectOwner, ERC721InsufficientApproval,\n        ERC721InvalidApprover, ERC721InvalidOperator, ERC721InvalidOwner,\n        ERC721InvalidReceiver, ERC721InvalidSender, ERC721NonexistentToken,\n        Erc721, IErc721, InvalidReceiverWithReason, Transfer,\n    },\n    utils::{\n        introspection::erc165::IErc165,\n        math::storage::{AddAssignUnchecked, SubAssignUnchecked},\n        structs::{\n            bitmap::BitMap,\n            checkpoints::{\n                self, CheckpointUnorderedInsertion, Size, Trace, S160,\n            },\n        },\n    },\n};\n\ntype StorageU96 = \u003cS160 as Size\u003e::KeyStorage;\n\npub use sol::*;\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when the tokens from `from_token_id` to `to_token_id` are transferred from `from_address` to `to_address`.\n        ///\n        /// * `from_token_id` - First token being transferred.\n        /// * `to_token_id` - Last token being transferred.\n        /// * `from_address` - Address from which tokens will be transferred.\n        /// * `to_address` - Address where the tokens will be transferred to.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event ConsecutiveTransfer(\n            uint256 indexed from_token_id,\n            uint256 to_token_id,\n            address indexed from_address,\n            address indexed to_address\n        );\n    }\n\n    sol! {\n        /// Batch mint is restricted to the constructor.\n        /// Any batch mint not emitting the [`Transfer`] event outside of the constructor\n        /// is non ERC-721 compliant.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721ForbiddenBatchMint();\n\n        /// Exceeds the max number of mints per batch.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721ExceededMaxBatchMint(uint256 batch_size, uint256 max_batch);\n\n        /// Individual minting is not allowed.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721ForbiddenMint();\n\n        /// Batch burn is not supported.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721ForbiddenBatchBurn();\n    }\n}\n\n/// An [`Erc721Consecutive`] error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates that an address can't be an owner.\n    /// For example, [`Address::ZERO`] is a forbidden owner in [`Erc721`].\n    /// Used in balance queries.\n    InvalidOwner(ERC721InvalidOwner),\n    /// Indicates a `token_id` whose `owner` is the zero address.\n    NonexistentToken(ERC721NonexistentToken),\n    /// Indicates an error related to the ownership over a particular token.\n    /// Used in transfers.\n    IncorrectOwner(ERC721IncorrectOwner),\n    /// Indicates a failure with the token `sender`. Used in transfers.\n    InvalidSender(ERC721InvalidSender),\n    /// Indicates a failure with the token `receiver`. Used in transfers.\n    InvalidReceiver(ERC721InvalidReceiver),\n    /// Indicates a failure with the token `receiver`, with the reason\n    /// specified by it.\n    InvalidReceiverWithReason(InvalidReceiverWithReason),\n    /// Indicates a failure with the `operator`’s approval. Used in transfers.\n    InsufficientApproval(ERC721InsufficientApproval),\n    /// Indicates a failure with the `approver` of a token to be approved. Used\n    /// in approvals.\n    InvalidApprover(ERC721InvalidApprover),\n    /// Indicates a failure with the `operator` to be approved. Used in\n    /// approvals.\n    InvalidOperator(ERC721InvalidOperator),\n    /// A value was attempted to be inserted into a past checkpoint.\n    CheckpointUnorderedInsertion(CheckpointUnorderedInsertion),\n    /// Batch mint is restricted to the constructor.\n    /// Any batch mint not emitting the [`Transfer`] event outside of\n    /// the constructor is non ERC-721 compliant.\n    ForbiddenBatchMint(ERC721ForbiddenBatchMint),\n    /// Exceeds the max amount of mints per batch.\n    ExceededMaxBatchMint(ERC721ExceededMaxBatchMint),\n    /// Individual minting is not allowed.\n    ForbiddenMint(ERC721ForbiddenMint),\n    /// Batch burn is not supported.\n    ForbiddenBatchBurn(ERC721ForbiddenBatchBurn),\n}\n\nimpl From\u003cerc721::Error\u003e for Error {\n    fn from(value: erc721::Error) -\u003e Self {\n        match value {\n            erc721::Error::InvalidOwner(e) =\u003e Error::InvalidOwner(e),\n            erc721::Error::NonexistentToken(e) =\u003e Error::NonexistentToken(e),\n            erc721::Error::IncorrectOwner(e) =\u003e Error::IncorrectOwner(e),\n            erc721::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc721::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc721::Error::InvalidReceiverWithReason(e) =\u003e {\n                Error::InvalidReceiverWithReason(e)\n            }\n            erc721::Error::InsufficientApproval(e) =\u003e {\n                Error::InsufficientApproval(e)\n            }\n            erc721::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n            erc721::Error::InvalidOperator(e) =\u003e Error::InvalidOperator(e),\n        }\n    }\n}\n\nimpl From\u003ccheckpoints::Error\u003e for Error {\n    fn from(value: checkpoints::Error) -\u003e Self {\n        match value {\n            checkpoints::Error::CheckpointUnorderedInsertion(e) =\u003e {\n                Error::CheckpointUnorderedInsertion(e)\n            }\n        }\n    }\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of an [`Erc721Consecutive`] token.\n#[storage]\npub struct Erc721Consecutive {\n    // Must be public so that internal fields can be accessed in inheriting\n    // contracts' constructors.\n    /// [`Erc721`] contract.\n    pub erc721: Erc721,\n    /// [`Trace`] contract for sequential ownership.\n    pub(crate) sequential_ownership: Trace\u003cS160\u003e,\n    /// [`BitMap`] contract for sequential burn of tokens.\n    pub(crate) sequential_burn: BitMap,\n    // TODO: Remove this field once function overriding is possible. For now we\n    // keep this field `pub`, since this is used to simulate overriding.\n    /// Used to offset the first token id in `next_consecutive_id` calculation.\n    pub first_consecutive_id: StorageU96,\n    // TODO: Remove this field once function overriding is possible. For now we\n    // keep this field `pub`, since this is used to simulate overriding.\n    /// Maximum size of a batch of consecutive tokens. This is designed to\n    /// limit stress on off-chain indexing services that have to record one\n    /// entry per token, and have protections against \"unreasonably large\"\n    /// batches of tokens.\n    pub max_batch_size: StorageU96,\n}\n\nimpl Deref for Erc721Consecutive {\n    type Target = Erc721;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.erc721\n    }\n}\n\nimpl DerefMut for Erc721Consecutive {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.erc721\n    }\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for Erc721Consecutive {}\n\n// ************** ERC-721 External **************\n\n#[public]\nimpl IErc721 for Erc721Consecutive {\n    type Error = Error;\n\n    fn balance_of(\u0026self, owner: Address) -\u003e Result\u003cU256, Self::Error\u003e {\n        Ok(self.erc721.balance_of(owner)?)\n    }\n\n    fn owner_of(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        self._require_owned(token_id)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        // TODO: Once the SDK supports the conversion,\n        // use alloy_primitives::bytes!(\"\") here.\n        self.safe_transfer_from_with_data(from, to, token_id, vec![].into())\n    }\n\n    fn safe_transfer_from_with_data(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.transfer_from(from, to, token_id)?;\n        Ok(self.erc721._check_on_erc721_received(\n            msg::sender(),\n            from,\n            to,\n            token_id,\n            \u0026data,\n        )?)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        if to.is_zero() {\n            return Err(erc721::Error::InvalidReceiver(\n                ERC721InvalidReceiver { receiver: Address::ZERO },\n            )\n            .into());\n        }\n\n        // Setting an \"auth\" argument enables the `_is_authorized` check which\n        // verifies that the token exists (`!from.is_zero()`). Therefore, it is\n        // not needed to verify that the return value is not 0 here.\n        let previous_owner = self._update(to, token_id, msg::sender())?;\n        if previous_owner != from {\n            return Err(erc721::Error::IncorrectOwner(ERC721IncorrectOwner {\n                sender: from,\n                token_id,\n                owner: previous_owner,\n            })\n            .into());\n        }\n        Ok(())\n    }\n\n    fn approve(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self._approve(to, token_id, msg::sender(), true)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.erc721.set_approval_for_all(operator, approved)?)\n    }\n\n    fn get_approved(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        self._require_owned(token_id)?;\n        Ok(self.erc721._get_approved(token_id))\n    }\n\n    fn is_approved_for_all(\u0026self, owner: Address, operator: Address) -\u003e bool {\n        self.erc721.is_approved_for_all(owner, operator)\n    }\n}\n\n#[public]\n#[implements(IErc721\u003cError = Error\u003e, IErc165)]\nimpl Erc721Consecutive {\n    // TODO: remove once function overriding is possible, so `max_batch_size`\n    // can be set that way.\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    #[constructor]\n    pub fn constructor(\u0026mut self) {\n        self.max_batch_size.set(U96::from(5000));\n    }\n}\n\n// ************** Consecutive **************\n\nimpl Erc721Consecutive {\n    /// Override of [`Erc721::_owner_of`] that checks the sequential\n    /// ownership structure for tokens that have been minted as part of a\n    /// batch, and not yet transferred.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token_id` - Token id as a number.\n    pub fn _owner_of(\u0026self, token_id: U256) -\u003e Address {\n        let owner = self.erc721._owner_of(token_id);\n        // If token is owned by the core, or beyond consecutive range, return\n        // base value.\n        if !owner.is_zero()\n            || token_id \u003c U256::from(self._first_consecutive_id())\n            || token_id \u003e U256::from(U96::MAX)\n        {\n            return owner;\n        }\n\n        // Otherwise, check the token was not burned, and fetch ownership from\n        // the anchors.\n        if self.sequential_burn.get(token_id) {\n            Address::ZERO\n        } else {\n            // NOTE: Bounds already checked. No need for safe cast of token_id\n            self.sequential_ownership.lower_lookup(U96::from(token_id)).into()\n        }\n    }\n\n    /// Mint a batch of tokens with length `batch_size` for `to`.\n    /// Returns the token id of the first token minted in the batch; if\n    /// `batch_size` is 0, returns the number of consecutive ids minted so\n    /// far.\n    ///\n    /// CAUTION: Does not emit a [`Transfer`] event. This is ERC-721 compliant\n    /// as long as it is done inside of the constructor, which is enforced by\n    /// this function.\n    ///\n    /// CAUTION: Does not invoke\n    /// [`erc721::IERC721Receiver::on_erc_721_received`] on the receiver.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Write access to the contract's state.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`Error::ExceededMaxBatchMint`] - If `batch_size` exceeds\n    ///   `max_batch_size` of the contract.\n    ///\n    /// # Events\n    ///\n    /// * [`ConsecutiveTransfer`].\n    pub fn _mint_consecutive(\n        \u0026mut self,\n        to: Address,\n        batch_size: U96,\n    ) -\u003e Result\u003cU96, Error\u003e {\n        let next = self._next_consecutive_id();\n\n        // Minting a batch of size 0 is a no-op.\n        if batch_size \u003e U96::ZERO {\n            if to.is_zero() {\n                return Err(erc721::Error::InvalidReceiver(\n                    ERC721InvalidReceiver { receiver: Address::ZERO },\n                )\n                .into());\n            }\n\n            if batch_size \u003e self._max_batch_size() {\n                return Err(ERC721ExceededMaxBatchMint {\n                    batch_size: U256::from(batch_size),\n                    max_batch: U256::from(self._max_batch_size()),\n                }\n                .into());\n            }\n\n            // Push an ownership checkpoint \u0026 emit event.\n            let last = next + batch_size - uint!(1_U96);\n            self.sequential_ownership.push(last, to.into())?;\n\n            // The invariant required by this function is preserved because the\n            // new sequential_ownership checkpoint is attributing\n            // ownership of `batch_size` new tokens to account `to`.\n            self.erc721._increase_balance(\n                to,\n                alloy_primitives::U128::from(batch_size),\n            );\n\n            evm::log(ConsecutiveTransfer {\n                from_token_id: next.to::\u003cU256\u003e(),\n                to_token_id: last.to::\u003cU256\u003e(),\n                from_address: Address::ZERO,\n                to_address: to,\n            });\n        }\n        Ok(next)\n    }\n\n    /// Override of [`Erc721::_update`] that restricts normal minting to after\n    /// construction.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    /// * `auth` - Account used for authorization of the update.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::NonexistentToken`] - If token does not exist and\n    ///   `auth` is not [`Address::ZERO`].\n    /// * [`erc721::Error::InsufficientApproval`] - If `auth` is not\n    ///   [`Address::ZERO`] and `auth` does not have a right to approve this\n    ///   token.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _update(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n        auth: Address,\n    ) -\u003e Result\u003cAddress, Error\u003e {\n        let previous_owner = self._update_base(to, token_id, auth)?;\n\n        // if we burn\n        if to.is_zero()\n            // and the token_id was minted in a batch\n            \u0026\u0026 token_id \u003c U256::from(self._next_consecutive_id())\n            // and the token was never marked as burnt\n            \u0026\u0026 !self.sequential_burn.get(token_id)\n        {\n            // record burn\n            self.sequential_burn.set(token_id);\n        }\n\n        Ok(previous_owner)\n    }\n\n    /// Returns the next token id to mint using [`Self::_mint_consecutive`]. It\n    /// will return [`Erc721Consecutive::_first_consecutive_id`] if no\n    /// consecutive token id has been minted before.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn _next_consecutive_id(\u0026self) -\u003e U96 {\n        match self.sequential_ownership.latest_checkpoint() {\n            None =\u003e self._first_consecutive_id(),\n            Some((latest_id, _)) =\u003e latest_id + uint!(1_U96),\n        }\n    }\n\n    /// Used to offset the first token id in\n    /// [`Erc721Consecutive::_next_consecutive_id`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn _first_consecutive_id(\u0026self) -\u003e U96 {\n        self.first_consecutive_id.get()\n    }\n\n    /// Maximum size of consecutive token's batch.\n    /// This is designed to limit stress on off-chain indexing services that\n    /// have to record one entry per token, and have protections against\n    /// \"unreasonably large\" batches of tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn _max_batch_size(\u0026self) -\u003e U96 {\n        self.max_batch_size.get()\n    }\n}\n\n// ************** ERC-721 Internal **************\n\nimpl Erc721Consecutive {\n    /// Transfers `token_id` from its current owner to `to`, or alternatively\n    /// mints (or burns) if the current owner (or `to`) is the\n    /// [`Address::ZERO`]. Returns the owner of the `token_id` before the\n    /// update.\n    ///\n    /// The `auth` argument is optional. If the value passed is non-zero, then\n    /// this function will check that `auth` is either the owner of the\n    /// token, or approved to operate on the token (by the owner).\n    ///\n    /// NOTE: If overriding this function in a way that tracks balances, see\n    /// also [`Erc721::_increase_balance`].\n    fn _update_base(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n        auth: Address,\n    ) -\u003e Result\u003cAddress, Error\u003e {\n        let from = self._owner_of(token_id);\n\n        // Perform (optional) operator check.\n        if !auth.is_zero() {\n            self.erc721._check_authorized(from, auth, token_id)?;\n        }\n\n        // Execute the update.\n        if !from.is_zero() {\n            // Clear approval. No need to re-authorize or emit the `Approval`\n            // event.\n            self._approve(Address::ZERO, token_id, Address::ZERO, false)?;\n            self.erc721\n                .balances\n                .setter(from)\n                .sub_assign_unchecked(uint!(1_U256));\n        }\n\n        if !to.is_zero() {\n            self.erc721.balances.setter(to).add_assign_unchecked(uint!(1_U256));\n        }\n\n        self.erc721.owners.setter(token_id).set(to);\n        evm::log(Transfer { from, to, token_id });\n        Ok(from)\n    }\n\n    /// Mints `token_id` and transfers it to `to`.\n    ///\n    /// WARNING: Usage of this method is discouraged, use [`Self::_safe_mint`]\n    /// whenever possible.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::InvalidSender`] - If `token_id` already exists.\n    /// * [`erc721::Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _mint(\u0026mut self, to: Address, token_id: U256) -\u003e Result\u003c(), Error\u003e {\n        if to.is_zero() {\n            return Err(erc721::Error::InvalidReceiver(\n                ERC721InvalidReceiver { receiver: Address::ZERO },\n            )\n            .into());\n        }\n\n        let previous_owner = self._update(to, token_id, Address::ZERO)?;\n        if !previous_owner.is_zero() {\n            return Err(erc721::Error::InvalidSender(ERC721InvalidSender {\n                sender: Address::ZERO,\n            })\n            .into());\n        }\n        Ok(())\n    }\n\n    /// Mints `token_id`, transfers it to `to`, and checks for `to`'s\n    /// acceptance.\n    ///\n    /// An additional `data` parameter is forwarded to\n    /// [`erc721::IERC721Receiver::on_erc_721_received`] to contract recipients.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    /// * `data` - Additional data with no specified format, sent in the call to\n    ///   [`Erc721::_check_on_erc721_received`].\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::InvalidSender`] - If `token_id` already exists.\n    /// * [`erc721::Error::InvalidReceiver`] - If `to` is [`Address::ZERO`], or\n    ///   [`erc721::IERC721Receiver::on_erc_721_received`] hasn't returned its\n    ///   interface id or returned with error.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _safe_mint(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self._mint(to, token_id)?;\n        Ok(self.erc721._check_on_erc721_received(\n            msg::sender(),\n            Address::ZERO,\n            to,\n            token_id,\n            data,\n        )?)\n    }\n\n    /// Destroys `token_id`.\n    ///\n    /// The approval is cleared when the token is burned. This is an\n    /// internal function that does not check if the sender is authorized\n    /// to operate on the token.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::NonexistentToken`] - If token does not exist.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _burn(\u0026mut self, token_id: U256) -\u003e Result\u003c(), Error\u003e {\n        let previous_owner =\n            self._update(Address::ZERO, token_id, Address::ZERO)?;\n        if previous_owner.is_zero() {\n            return Err(erc721::Error::NonexistentToken(\n                ERC721NonexistentToken { token_id },\n            )\n            .into());\n        }\n        Ok(())\n    }\n\n    /// Transfers `token_id` from `from` to `to`.\n    ///\n    /// As opposed to [`Self::transfer_from`], this imposes no restrictions on\n    /// `msg::sender`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account of the sender.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`erc721::Error::NonexistentToken`] - If `token_id` does not exist.\n    /// * [`erc721::Error::IncorrectOwner`] - If the previous owner is not\n    ///   `from`.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _transfer(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if to.is_zero() {\n            return Err(erc721::Error::InvalidReceiver(\n                ERC721InvalidReceiver { receiver: Address::ZERO },\n            )\n            .into());\n        }\n\n        let previous_owner = self._update(to, token_id, Address::ZERO)?;\n        if previous_owner.is_zero() {\n            return Err(erc721::Error::NonexistentToken(\n                ERC721NonexistentToken { token_id },\n            )\n            .into());\n        } else if previous_owner != from {\n            return Err(erc721::Error::IncorrectOwner(ERC721IncorrectOwner {\n                sender: from,\n                token_id,\n                owner: previous_owner,\n            })\n            .into());\n        }\n\n        Ok(())\n    }\n\n    /// Safely transfers `token_id` token from `from` to `to`, checking that\n    /// contract recipients are aware of the [`Erc721`] standard to prevent\n    /// tokens from being forever locked.\n    ///\n    /// `data` is additional data, it has\n    /// no specified format and it is sent in call to `to`. This internal\n    /// function is like [`Self::safe_transfer_from`] in the sense that it\n    /// invokes [`erc721::IERC721Receiver::on_erc_721_received`] on the\n    /// receiver, and can be used to e.g. implement alternative mechanisms\n    /// to perform token transfer, such as signature-based.\n    ///\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account of the sender.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    /// * `data` - Additional data with no specified format, sent in the call to\n    ///   [`Erc721::_check_on_erc721_received`].\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`erc721::Error::NonexistentToken`] - If `token_id` does not exist.\n    /// * [`erc721::Error::IncorrectOwner`] - If the previous owner is not\n    ///   `from`.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _safe_transfer(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self._transfer(from, to, token_id)?;\n        Ok(self.erc721._check_on_erc721_received(\n            msg::sender(),\n            from,\n            to,\n            token_id,\n            data,\n        )?)\n    }\n\n    /// Approve `to` to operate on `token_id`.\n    ///\n    /// The `auth` argument is optional. If the value passed is non\n    /// [`Address::ZERO`], then this function will check that `auth` is either\n    /// the owner of the token, or approved to operate on all tokens held by\n    /// this owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    /// * `auth` - Account used for authorization of the update.\n    /// * `emit_event` - Emit an [`Approval`] event flag.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::NonexistentToken`] - If the token does not exist.\n    /// * [`erc721::Error::InvalidApprover`] - If `auth` does not have a right\n    ///   to approve this token.\n    ///\n    /// # Events\n    ///\n    /// * [`Approval`].\n    pub fn _approve(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n        auth: Address,\n        emit_event: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        // Avoid reading the owner unless necessary.\n        if emit_event || !auth.is_zero() {\n            let owner = self._require_owned(token_id)?;\n            if !auth.is_zero()\n                \u0026\u0026 owner != auth\n                \u0026\u0026 !self.is_approved_for_all(owner, auth)\n            {\n                return Err(erc721::Error::InvalidApprover(\n                    ERC721InvalidApprover { approver: auth },\n                )\n                .into());\n            }\n\n            if emit_event {\n                evm::log(Approval { owner, approved: to, token_id });\n            }\n        }\n\n        self.erc721.token_approvals.setter(token_id).set(to);\n        Ok(())\n    }\n\n    /// Reverts if the `token_id` doesn't have a current owner (it hasn't been\n    /// minted, or it has been burned). Returns the owner.\n    ///\n    /// Overrides to ownership logic should be done to\n    /// [`Self::_owner_of`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::NonexistentToken`] - If token does not exist.\n    pub fn _require_owned(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Error\u003e {\n        let owner = self._owner_of(token_id);\n        if owner.is_zero() {\n            return Err(erc721::Error::NonexistentToken(\n                ERC721NonexistentToken { token_id },\n            )\n            .into());\n        }\n        Ok(owner)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc721Consecutive {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        self.erc721.supports_interface(interface_id)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{uint, Address, FixedBytes, U256};\n    use motsu::prelude::Contract;\n\n    use super::*;\n\n    const FIRST_CONSECUTIVE_TOKEN_ID: U96 = uint!(0_U96);\n    const MAX_BATCH_SIZE: U96 = uint!(5000_U96);\n    const TOKEN_ID: U256 = uint!(1_U256);\n    const NON_CONSECUTIVE_TOKEN_ID: U256 = uint!(10001_U256);\n\n    fn mint_consecutive(\n        contract: \u0026mut Erc721Consecutive,\n        receivers: Vec\u003cAddress\u003e,\n        batches: Vec\u003cU96\u003e,\n    ) {\n        contract.first_consecutive_id.set(FIRST_CONSECUTIVE_TOKEN_ID);\n        contract.max_batch_size.set(MAX_BATCH_SIZE);\n        for (to, batch_size) in receivers.into_iter().zip(batches) {\n            contract\n                ._mint_consecutive(to, batch_size)\n                .expect(\"should mint consecutively\");\n        }\n    }\n\n    #[motsu::test]\n    fn mints(contract: Contract\u003cErc721Consecutive\u003e, alice: Address) {\n        let initial_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        let init_tokens_count = uint!(10_U96);\n        contract.init(alice, |contract| {\n            mint_consecutive(contract, vec![alice], vec![init_tokens_count]);\n        });\n\n        let balance1 = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n        assert_eq!(balance1, initial_balance + U256::from(init_tokens_count));\n\n        // Check non-consecutive mint.\n        let non_consecutive_token_id = uint!(10_U256);\n        contract\n            .sender(alice)\n            ._mint(alice, non_consecutive_token_id)\n            .expect(\"should mint a token for Alice\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(non_consecutive_token_id)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n\n        let balance2 = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        assert_eq!(balance2, balance1 + uint!(1_U256));\n    }\n\n    #[motsu::test]\n    fn error_when_minting_token_id_twice(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint the token a first time\");\n        let err = contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect_err(\"should not mint a token with `TOKEN_ID` twice\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC721InvalidSender { sender: Address::ZERO })\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_minting_token_invalid_receiver(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            ._mint(invalid_receiver, TOKEN_ID)\n            .expect_err(\"should not mint a token for invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_to_is_zero(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            ._mint_consecutive(Address::ZERO, uint!(11_U96))\n            .expect_err(\"should not mint consecutive\");\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver: Address::ZERO\n            })\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_exceed_batch_size(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n    ) {\n        let batch_size =\n            contract.sender(alice)._max_batch_size() + uint!(1_U96);\n        let err = contract\n            .sender(alice)\n            ._mint_consecutive(alice, batch_size)\n            .expect_err(\"should not mint consecutive\");\n        assert!(matches!(\n            err,\n            Error::ExceededMaxBatchMint(ERC721ExceededMaxBatchMint {\n                batch_size,\n                max_batch\n            })\n            if batch_size == U256::from(batch_size) \u0026\u0026 max_batch == U256::from(contract.sender(alice)._max_batch_size())\n        ));\n    }\n\n    #[motsu::test]\n    fn transfers_from(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        // Mint batches of 1000 tokens to Alice and Bob.\n        contract.init(alice, |contract| {\n            mint_consecutive(\n                contract,\n                vec![alice, bob],\n                vec![uint!(1000_U96), uint!(1000_U96)],\n            );\n        });\n\n        // Transfer first consecutive token from Alice to Bob.\n        contract\n            .sender(alice)\n            .transfer_from(alice, bob, U256::from(FIRST_CONSECUTIVE_TOKEN_ID))\n            .expect(\"should transfer a token from Alice to Bob\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(U256::from(FIRST_CONSECUTIVE_TOKEN_ID))\n            .expect(\"token should be owned\");\n        assert_eq!(owner, bob);\n\n        // Check that balances changed.\n        let alice_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n        assert_eq!(alice_balance, uint!(1000_U256) - uint!(1_U256));\n        let bob_balance = contract\n            .sender(alice)\n            .balance_of(bob)\n            .expect(\"should return the balance of Bob\");\n        assert_eq!(bob_balance, uint!(1000_U256) + uint!(1_U256));\n\n        // Check non-consecutive mint.\n        contract\n            .sender(alice)\n            ._mint(alice, NON_CONSECUTIVE_TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n        let alice_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n        assert_eq!(alice_balance, uint!(1000_U256));\n\n        // Check transfer of the token that wasn't minted consecutive.\n        contract\n            .sender(alice)\n            .transfer_from(alice, bob, NON_CONSECUTIVE_TOKEN_ID)\n            .expect(\"should transfer a token from Alice to Bob\");\n        let alice_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n        assert_eq!(alice_balance, uint!(1000_U256) - uint!(1_U256));\n    }\n\n    #[motsu::test]\n    fn burns(contract: Contract\u003cErc721Consecutive\u003e, alice: Address) {\n        // Mint batch of 1000 tokens to Alice.\n        contract.init(alice, |contract| {\n            mint_consecutive(contract, vec![alice], vec![uint!(1000_U96)]);\n        });\n\n        // Check consecutive token burn.\n        contract\n            .sender(alice)\n            ._burn(U256::from(FIRST_CONSECUTIVE_TOKEN_ID))\n            .expect(\"should burn token\");\n\n        let alice_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n        assert_eq!(alice_balance, uint!(1000_U256) - uint!(1_U256));\n\n        let err = contract\n            .sender(alice)\n            .owner_of(U256::from(FIRST_CONSECUTIVE_TOKEN_ID))\n            .expect_err(\"token should not exist\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken { token_id })\n            if token_id == U256::from(FIRST_CONSECUTIVE_TOKEN_ID)\n        ));\n\n        // Check non-consecutive token burn.\n        let non_consecutive_token_id = uint!(2000_U256);\n        contract\n            .sender(alice)\n            ._mint(alice, non_consecutive_token_id)\n            .expect(\"should mint a token to Alice\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(non_consecutive_token_id)\n            .expect(\"should return owner of the token\");\n        assert_eq!(owner, alice);\n        let alice_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n        assert_eq!(alice_balance, uint!(1000_U256));\n\n        contract\n            .sender(alice)\n            ._burn(non_consecutive_token_id)\n            .expect(\"should burn token\");\n\n        let err = contract\n            .sender(alice)\n            .owner_of(U256::from(non_consecutive_token_id))\n            .expect_err(\"token should not exist\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken { token_id })\n            if token_id == U256::from(non_consecutive_token_id)\n        ));\n\n        // After being burnt the token should not be burnt again.\n        let non_existent_token = non_consecutive_token_id;\n        let err = contract\n            .sender(alice)\n            ._burn(non_existent_token)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken (ERC721NonexistentToken{\n                token_id: t_id\n            }) if t_id == non_existent_token\n        ));\n    }\n\n    #[motsu::test]\n    fn safe_transfer_from(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        contract\n            .sender(alice)\n            .safe_transfer_from(alice, bob, TOKEN_ID)\n            .expect(\"should transfer a token from Alice to Bob\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n\n        assert_eq!(owner, bob);\n    }\n\n    #[motsu::test]\n    fn safe_transfers_from_approved_token(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n        contract\n            .sender(bob)\n            .approve(alice, TOKEN_ID)\n            .expect(\"should approve Bob's token to Alice\");\n        contract\n            .sender(alice)\n            .safe_transfer_from(bob, alice, TOKEN_ID)\n            .expect(\"should transfer Bob's token to Alice\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn error_when_safe_transfer_from_incorrect_owner(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(dave, bob, TOKEN_ID)\n            .expect_err(\"should not transfer from incorrect owner\");\n\n        assert!(matches!(\n            err,\n            Error::IncorrectOwner(ERC721IncorrectOwner {\n                sender,\n                token_id: t_id,\n                owner\n            }) if sender == dave \u0026\u0026 t_id == TOKEN_ID \u0026\u0026 owner == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_internal_safe_transfer_nonexistent_token(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            ._safe_transfer(alice, bob, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect_err(\"should not transfer a non-existent token\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id,\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_safe_transfer_to_invalid_receiver(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(alice, invalid_receiver, TOKEN_ID)\n            .expect_err(\"should not transfer the token to invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn safe_transfers_from_with_data(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        contract\n            .sender(alice)\n            .safe_transfer_from_with_data(\n                alice,\n                bob,\n                TOKEN_ID,\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect(\"should transfer a token from Alice to Bob\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n\n        assert_eq!(owner, bob);\n    }\n\n    #[motsu::test]\n    fn error_when_internal_safe_transfer_to_invalid_receiver(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            ._safe_transfer(\n                alice,\n                invalid_receiver,\n                TOKEN_ID,\n                \u0026vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer the token to invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_internal_safe_transfer_from_incorrect_owner(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            ._safe_transfer(dave, bob, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect_err(\"should not transfer the token from incorrect owner\");\n        assert!(matches!(\n            err,\n            Error::IncorrectOwner(ERC721IncorrectOwner {\n                sender,\n                token_id: t_id,\n                owner\n            }) if sender == dave \u0026\u0026 t_id == TOKEN_ID \u0026\u0026 owner == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn safe_mints(contract: Contract\u003cErc721Consecutive\u003e, alice: Address) {\n        let initial_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        contract\n            .sender(alice)\n            ._safe_mint(alice, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect(\"should mint a token for Alice\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n\n        let balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        assert_eq!(initial_balance + uint!(1_U256), balance);\n    }\n\n    #[motsu::test]\n    fn error_when_approve_for_nonexistent_token(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            .approve(bob, TOKEN_ID)\n            .expect_err(\"should not approve for a non-existent token\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id\n            }) if TOKEN_ID == t_id\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_approve_by_invalid_approver(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint a token\");\n\n        let err = contract\n            .sender(alice)\n            .approve(dave, TOKEN_ID)\n            .expect_err(\"should not approve when invalid approver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidApprover(ERC721InvalidApprover {\n                approver\n            }) if approver == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn approval_for_all(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            .set_approval_for_all(bob, true)\n            .expect(\"should approve Bob for operations on all Alice's tokens\");\n        assert!(contract.sender(alice).is_approved_for_all(alice, bob));\n\n        contract.sender(alice).set_approval_for_all(bob, false).expect(\n            \"should disapprove Bob for operations on all Alice's tokens\",\n        );\n        assert!(!contract.sender(alice).is_approved_for_all(alice, bob));\n    }\n\n    #[motsu::test]\n    fn error_when_get_approved_of_nonexistent_token(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            .get_approved(TOKEN_ID)\n            .expect_err(\"should not return approved for a non-existent token\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id\n            }) if TOKEN_ID == t_id\n        ));\n    }\n\n    #[motsu::test]\n    fn supports_interface(\n        contract: Contract\u003cErc721Consecutive\u003e,\n        alice: Address,\n    ) {\n        assert!(\n            contract.sender(alice).supports_interface(\n                \u003cErc721Consecutive as IErc721\u003e::interface_id()\n            )\n        );\n        assert!(\n            contract.sender(alice).supports_interface(\n                \u003cErc721Consecutive as IErc165\u003e::interface_id()\n            )\n        );\n\n        let fake_interface_id: FixedBytes\u003c4\u003e = 0x12345678_u32.into();\n        assert!(!contract.sender(alice).supports_interface(fake_interface_id));\n    }\n}\n","traces":[{"line":142,"address":[],"length":0,"stats":{"Line":14}},{"line":143,"address":[],"length":0,"stats":{"Line":14}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":12}},{"line":146,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":8}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":11}},{"line":227,"address":[],"length":0,"stats":{"Line":33}},{"line":230,"address":[],"length":0,"stats":{"Line":11}},{"line":231,"address":[],"length":0,"stats":{"Line":33}},{"line":234,"address":[],"length":0,"stats":{"Line":4}},{"line":242,"address":[],"length":0,"stats":{"Line":28}},{"line":245,"address":[],"length":0,"stats":{"Line":5}},{"line":252,"address":[],"length":0,"stats":{"Line":27}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":7}},{"line":268,"address":[],"length":0,"stats":{"Line":7}},{"line":269,"address":[],"length":0,"stats":{"Line":1}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":6}},{"line":280,"address":[],"length":0,"stats":{"Line":1}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":285,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":3}},{"line":295,"address":[],"length":0,"stats":{"Line":15}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":8}},{"line":306,"address":[],"length":0,"stats":{"Line":1}},{"line":307,"address":[],"length":0,"stats":{"Line":4}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":3}},{"line":312,"address":[],"length":0,"stats":{"Line":12}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":40}},{"line":344,"address":[],"length":0,"stats":{"Line":160}},{"line":347,"address":[],"length":0,"stats":{"Line":40}},{"line":348,"address":[],"length":0,"stats":{"Line":63}},{"line":349,"address":[],"length":0,"stats":{"Line":21}},{"line":351,"address":[],"length":0,"stats":{"Line":19}},{"line":357,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":20}},{"line":390,"address":[],"length":0,"stats":{"Line":6}},{"line":395,"address":[],"length":0,"stats":{"Line":18}},{"line":398,"address":[],"length":0,"stats":{"Line":6}},{"line":399,"address":[],"length":0,"stats":{"Line":6}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":1}},{"line":407,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":3}},{"line":409,"address":[],"length":0,"stats":{"Line":2}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":4}},{"line":433,"address":[],"length":0,"stats":{"Line":4}},{"line":457,"address":[],"length":0,"stats":{"Line":25}},{"line":463,"address":[],"length":0,"stats":{"Line":150}},{"line":468,"address":[],"length":0,"stats":{"Line":9}},{"line":470,"address":[],"length":0,"stats":{"Line":2}},{"line":473,"address":[],"length":0,"stats":{"Line":1}},{"line":486,"address":[],"length":0,"stats":{"Line":9}},{"line":487,"address":[],"length":0,"stats":{"Line":9}},{"line":488,"address":[],"length":0,"stats":{"Line":5}},{"line":489,"address":[],"length":0,"stats":{"Line":8}},{"line":499,"address":[],"length":0,"stats":{"Line":26}},{"line":500,"address":[],"length":0,"stats":{"Line":52}},{"line":511,"address":[],"length":0,"stats":{"Line":8}},{"line":512,"address":[],"length":0,"stats":{"Line":16}},{"line":530,"address":[],"length":0,"stats":{"Line":25}},{"line":536,"address":[],"length":0,"stats":{"Line":100}},{"line":539,"address":[],"length":0,"stats":{"Line":25}},{"line":540,"address":[],"length":0,"stats":{"Line":6}},{"line":544,"address":[],"length":0,"stats":{"Line":25}},{"line":547,"address":[],"length":0,"stats":{"Line":10}},{"line":548,"address":[],"length":0,"stats":{"Line":10}},{"line":549,"address":[],"length":0,"stats":{"Line":10}},{"line":554,"address":[],"length":0,"stats":{"Line":47}},{"line":555,"address":[],"length":0,"stats":{"Line":22}},{"line":582,"address":[],"length":0,"stats":{"Line":15}},{"line":583,"address":[],"length":0,"stats":{"Line":15}},{"line":584,"address":[],"length":0,"stats":{"Line":1}},{"line":585,"address":[],"length":0,"stats":{"Line":1}},{"line":587,"address":[],"length":0,"stats":{"Line":1}},{"line":590,"address":[],"length":0,"stats":{"Line":14}},{"line":592,"address":[],"length":0,"stats":{"Line":1}},{"line":593,"address":[],"length":0,"stats":{"Line":1}},{"line":595,"address":[],"length":0,"stats":{"Line":1}},{"line":597,"address":[],"length":0,"stats":{"Line":13}},{"line":624,"address":[],"length":0,"stats":{"Line":1}},{"line":630,"address":[],"length":0,"stats":{"Line":4}},{"line":631,"address":[],"length":0,"stats":{"Line":1}},{"line":658,"address":[],"length":0,"stats":{"Line":3}},{"line":659,"address":[],"length":0,"stats":{"Line":3}},{"line":660,"address":[],"length":0,"stats":{"Line":9}},{"line":662,"address":[],"length":0,"stats":{"Line":1}},{"line":663,"address":[],"length":0,"stats":{"Line":1}},{"line":665,"address":[],"length":0,"stats":{"Line":1}},{"line":692,"address":[],"length":0,"stats":{"Line":3}},{"line":698,"address":[],"length":0,"stats":{"Line":3}},{"line":699,"address":[],"length":0,"stats":{"Line":1}},{"line":700,"address":[],"length":0,"stats":{"Line":1}},{"line":702,"address":[],"length":0,"stats":{"Line":1}},{"line":705,"address":[],"length":0,"stats":{"Line":2}},{"line":707,"address":[],"length":0,"stats":{"Line":1}},{"line":708,"address":[],"length":0,"stats":{"Line":1}},{"line":710,"address":[],"length":0,"stats":{"Line":1}},{"line":711,"address":[],"length":0,"stats":{"Line":1}},{"line":712,"address":[],"length":0,"stats":{"Line":1}},{"line":713,"address":[],"length":0,"stats":{"Line":2}},{"line":714,"address":[],"length":0,"stats":{"Line":1}},{"line":715,"address":[],"length":0,"stats":{"Line":1}},{"line":717,"address":[],"length":0,"stats":{"Line":1}},{"line":754,"address":[],"length":0,"stats":{"Line":3}},{"line":761,"address":[],"length":0,"stats":{"Line":18}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":13}},{"line":803,"address":[],"length":0,"stats":{"Line":23}},{"line":804,"address":[],"length":0,"stats":{"Line":6}},{"line":806,"address":[],"length":0,"stats":{"Line":2}},{"line":807,"address":[],"length":0,"stats":{"Line":3}},{"line":809,"address":[],"length":0,"stats":{"Line":1}},{"line":810,"address":[],"length":0,"stats":{"Line":1}},{"line":812,"address":[],"length":0,"stats":{"Line":1}},{"line":815,"address":[],"length":0,"stats":{"Line":1}},{"line":816,"address":[],"length":0,"stats":{"Line":3}},{"line":820,"address":[],"length":0,"stats":{"Line":11}},{"line":838,"address":[],"length":0,"stats":{"Line":15}},{"line":839,"address":[],"length":0,"stats":{"Line":60}},{"line":840,"address":[],"length":0,"stats":{"Line":15}},{"line":841,"address":[],"length":0,"stats":{"Line":4}},{"line":842,"address":[],"length":0,"stats":{"Line":4}},{"line":844,"address":[],"length":0,"stats":{"Line":4}},{"line":852,"address":[],"length":0,"stats":{"Line":3}},{"line":853,"address":[],"length":0,"stats":{"Line":9}}],"covered":134,"coverable":155},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc721","extensions","enumerable.rs"],"content":"//! Optional `Enumerable` extension of the ERC-721 standard.\n//!\n//! This implements an optional extension of [`super::super::Erc721`] defined in\n//! the EIP that adds enumerability of all the token ids in the contract as well\n//! as all token ids owned by each account.\n//!\n//! CAUTION: [`super::super::Erc721`] extensions that implement custom\n//! [`super::super::Erc721::balance_of`] logic, such as `Erc721Consecutive`,\n//! interfere with enumerability and should not be used together with\n//! [`Erc721Enumerable`].\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{uint, Address, FixedBytes, U256};\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{\n    call::MethodError,\n    prelude::*,\n    storage::{StorageMap, StorageU256, StorageVec},\n};\n\nuse crate::{\n    token::erc721::{self, IErc721},\n    utils::introspection::erc165::IErc165,\n};\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Indicates an error when an `owner`'s token query\n        /// was out of bounds for `index`.\n        ///\n        /// NOTE: The owner being [`Address::ZERO`]\n        /// indicates a global out of bounds index.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721OutOfBoundsIndex(address owner, uint256 index);\n\n        /// Indicates an error related to batch minting not allowed.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721EnumerableForbiddenBatchMint();\n    }\n}\n\n/// An [`Erc721Enumerable`] extension error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates an error when an `owner`'s token query\n    /// was out of bounds for `index`.\n    ///\n    /// NOTE: The owner being [`Address::ZERO`]\n    /// indicates a global out of bounds index.\n    OutOfBoundsIndex(ERC721OutOfBoundsIndex),\n\n    /// Indicates an error related to batch minting not allowed.\n    EnumerableForbiddenBatchMint(ERC721EnumerableForbiddenBatchMint),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of an [`Erc721Enumerable`] contract.\n#[storage]\npub struct Erc721Enumerable {\n    /// Maps owners to a mapping of indices to tokens ids.\n    pub(crate) owned_tokens: StorageMap\u003cAddress, StorageMap\u003cU256, StorageU256\u003e\u003e,\n    /// Maps tokens ids to indices in `owned_tokens`.\n    pub(crate) owned_tokens_index: StorageMap\u003cU256, StorageU256\u003e,\n    /// Stores all tokens ids.\n    pub(crate) all_tokens: StorageVec\u003cStorageU256\u003e,\n    /// Maps indices at `all_tokens` to tokens ids.\n    pub(crate) all_tokens_index: StorageMap\u003cU256, StorageU256\u003e,\n}\n\n/// This is the interface of the optional `Enumerable` extension\n/// of the ERC-721 standard.\n#[interface_id]\npub trait IErc721Enumerable {\n    /// The error type associated to this ERC-721 enumerable trait\n    /// implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns a token ID owned by `owner` at a given `index` of its token\n    /// list.\n    ///\n    /// Use along with [`super::super::Erc721::balance_of`] to enumerate all of\n    /// `owner`'s tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `owner` - Address of token's owner.\n    /// * `index` - Index of the token at `owner`'s tokens list.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::OutOfBoundsIndex`] - If an `owner`'s token query is out of\n    ///   bounds for `index`.\n    fn token_of_owner_by_index(\n        \u0026self,\n        owner: Address,\n        index: U256,\n    ) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Returns the total amount of tokens stored by the contract.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn total_supply(\u0026self) -\u003e U256;\n\n    /// Returns a token ID at a given `index` of all the tokens\n    /// stored by the contract.\n    ///\n    /// Use along with [`Self::total_supply`] to\n    /// enumerate all tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `index` - Index of the token in all tokens list.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::OutOfBoundsIndex`] - If an `owner`'s token query is out of\n    ///   bounds for `index`.\n    fn token_by_index(\u0026self, index: U256) -\u003e Result\u003cU256, Self::Error\u003e;\n}\n\n#[public]\n#[implements(IErc721Enumerable\u003cError = Error\u003e, IErc165)]\nimpl Erc721Enumerable {}\n\n#[public]\nimpl IErc721Enumerable for Erc721Enumerable {\n    type Error = Error;\n\n    fn token_of_owner_by_index(\n        \u0026self,\n        owner: Address,\n        index: U256,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        let token = self.owned_tokens.getter(owner).get(index);\n\n        if token.is_zero() {\n            Err(ERC721OutOfBoundsIndex { owner, index }.into())\n        } else {\n            Ok(token)\n        }\n    }\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        let tokens_length = self.all_tokens.len();\n        U256::from(tokens_length)\n    }\n\n    fn token_by_index(\u0026self, index: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.all_tokens.get(index).ok_or(\n            ERC721OutOfBoundsIndex { owner: Address::ZERO, index }.into(),\n        )\n    }\n}\n\n#[public]\nimpl IErc165 for Erc721Enumerable {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IErc721Enumerable\u003e::interface_id() == interface_id\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\nimpl Erc721Enumerable {\n    /// Function to add a token to this extension's\n    /// ownership-tracking data structures.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Address representing the new owner of the given `token_id`.\n    /// * `token_id` - ID of the token to be added to the tokens list of the\n    ///   given address.\n    /// * `erc721` - Read access to a contract providing [`IErc721`] interface.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::InvalidOwner`] - If owner address is\n    ///   [`Address::ZERO`].\n    pub fn _add_token_to_owner_enumeration(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n        erc721: \u0026impl IErc721\u003cError = erc721::Error\u003e,\n    ) -\u003e Result\u003c(), erc721::Error\u003e {\n        let length = erc721.balance_of(to)? - uint!(1_U256);\n        self.owned_tokens.setter(to).setter(length).set(token_id);\n        self.owned_tokens_index.setter(token_id).set(length);\n\n        Ok(())\n    }\n\n    /// Function to add a token to this extension's token\n    /// tracking data structures.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token_id` - ID of the token to be added to the tokens list.\n    pub fn _add_token_to_all_tokens_enumeration(\u0026mut self, token_id: U256) {\n        let index = self.total_supply();\n\n        self.all_tokens_index.setter(token_id).set(index);\n        self.all_tokens.push(token_id);\n    }\n\n    /// Function to remove a token from this extension's\n    /// ownership-tracking data structures.\n    ///\n    /// Note that while the token is not assigned a new owner,\n    /// the `self.owned_tokens_index` mapping is NOT updated:\n    /// this allows for  gas optimizations e.g.\n    /// when performing a transfer operation (avoiding double writes).\n    ///\n    /// This has O(1) time complexity, but alters the order\n    /// of the `self.owned_tokens` array.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Address representing the previous owner of the given\n    ///   `token_id`.\n    /// * `token_id` - ID of the token to be removed from the tokens list of the\n    ///   given address.\n    /// * `erc721` - Read access to a contract providing [`IErc721`] interface.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::InvalidOwner`] - If owner address is\n    ///   [`Address::ZERO`].\n    pub fn _remove_token_from_owner_enumeration(\n        \u0026mut self,\n        from: Address,\n        token_id: U256,\n        erc721: \u0026impl IErc721\u003cError = erc721::Error\u003e,\n    ) -\u003e Result\u003c(), erc721::Error\u003e {\n        // To prevent a gap in from's tokens array,\n        // we store the last token in the index of the token to delete,\n        // and then delete the last slot (swap and pop).\n        let last_token_index = erc721.balance_of(from)?;\n        let token_index = self.owned_tokens_index.get(token_id);\n\n        let mut owned_tokens_by_owner = self.owned_tokens.setter(from);\n\n        // When the token to delete is the last token,\n        // the swap operation is unnecessary.\n        if token_index != last_token_index {\n            let last_token_id = owned_tokens_by_owner.get(last_token_index);\n\n            // Move the last token to the slot of the to-delete token.\n            owned_tokens_by_owner.setter(token_index).set(last_token_id);\n            // Update the moved token's index.\n            self.owned_tokens_index.setter(last_token_id).set(token_index);\n        }\n\n        // This also deletes the contents at the last position of the array.\n        self.owned_tokens_index.delete(token_id);\n        owned_tokens_by_owner.delete(last_token_index);\n\n        Ok(())\n    }\n\n    /// Function to remove a token from this extension's\n    /// token tracking data structures.\n    ///\n    /// This has O(1) time complexity,\n    /// but alters the order of the `self.all_tokens` array.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token_id` -  ID of the token to be removed from the tokens list.\n    ///\n    /// # Panics\n    ///\n    /// * The function should not panic in a regular way.\n    pub fn _remove_token_from_all_tokens_enumeration(\n        \u0026mut self,\n        token_id: U256,\n    ) {\n        // To prevent a gap in the tokens array,\n        // we store the last token in the index of the token to delete,\n        // and then delete the last slot (swap and pop).\n        let last_token_index = U256::from(self.all_tokens.len() - 1);\n        let token_index = self.all_tokens_index.get(token_id);\n\n        // When the token to delete is the last token,\n        // the swap operation is unnecessary.\n        // However, since this occurs so\n        // rarely (when the last minted token is burnt)\n        // that we still do the swap here\n        // to avoid the gas cost of adding an 'if' statement\n        // (like in `self._remove_token_from_owner_enumeration`).\n        let last_token_id = self\n            .all_tokens\n            .get(last_token_index)\n            .expect(\"token at given index must exist\");\n\n        // Move the last token to the slot of the to-delete token.\n        self.all_tokens\n            .setter(token_index)\n            .expect(\"slot at given `token_index` must exist\")\n            .set(last_token_id);\n\n        // Update the moved token's index.\n        self.all_tokens_index.setter(last_token_id).set(token_index);\n\n        // This also deletes the contents at the last position of the array.\n        self.all_tokens_index.delete(token_id);\n        self.all_tokens.pop();\n    }\n\n    /// See [`erc721::Erc721::_increase_balance`].\n    /// Check if tokens can be minted in batch.\n    ///\n    /// Mechanism to be consistent with [Solidity version](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.0.0/contracts/token/ERC721/extensions/ERC721Enumerable.sol#L163-L171)\n    ///\n    /// # Arguments\n    ///\n    /// * `amount` - The number of tokens to increase balance.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::EnumerableForbiddenBatchMint`] - If an `amount` is greater\n    ///   than `0`.\n    pub fn _check_increase_balance(amount: u128) -\u003e Result\u003c(), Error\u003e {\n        if amount \u003e 0 {\n            Err(ERC721EnumerableForbiddenBatchMint {}.into())\n        } else {\n            Ok(())\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use motsu::prelude::*;\n    use stylus_sdk::prelude::*;\n\n    use super::*;\n    use crate::token::erc721::Erc721;\n\n    #[storage]\n    struct Erc721EnumerableTestExample {\n        pub erc721: Erc721,\n        pub enumerable: Erc721Enumerable,\n    }\n\n    #[public]\n    #[implements(IErc721Enumerable\u003cError = Error\u003e, IErc165)]\n    impl Erc721EnumerableTestExample {}\n\n    #[public]\n    impl IErc721Enumerable for Erc721EnumerableTestExample {\n        type Error = Error;\n\n        fn total_supply(\u0026self) -\u003e U256 {\n            self.enumerable.total_supply()\n        }\n\n        fn token_by_index(\u0026self, index: U256) -\u003e Result\u003cU256, Error\u003e {\n            Ok(self.enumerable.token_by_index(index)?)\n        }\n\n        fn token_of_owner_by_index(\n            \u0026self,\n            owner: Address,\n            index: U256,\n        ) -\u003e Result\u003cU256, Error\u003e {\n            Ok(self.enumerable.token_of_owner_by_index(owner, index)?)\n        }\n    }\n\n    #[public]\n    impl IErc165 for Erc721EnumerableTestExample {\n        fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n            \u003cErc721EnumerableTestExample as IErc721Enumerable\u003e::interface_id()\n                == interface_id\n                || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n        }\n    }\n\n    unsafe impl TopLevelStorage for Erc721EnumerableTestExample {}\n\n    #[motsu::test]\n    fn total_supply_no_tokens(\n        contract: Contract\u003cErc721EnumerableTestExample\u003e,\n        alice: Address,\n    ) {\n        assert_eq!(U256::ZERO, contract.sender(alice).total_supply());\n    }\n\n    #[motsu::test]\n    fn reverts_when_token_by_index_is_out_of_bound(\n        contract: Contract\u003cErc721EnumerableTestExample\u003e,\n        alice: Address,\n    ) {\n        let token_idx = uint!(2024_U256);\n\n        let err = contract\n            .sender(alice)\n            .token_by_index(token_idx)\n            .expect_err(\"should return Error::OutOfBoundsIndex\");\n\n        assert!(matches!(\n            err,\n            Error::OutOfBoundsIndex(ERC721OutOfBoundsIndex {\n                owner,\n                index\n            }) if owner.is_zero() \u0026\u0026 index == token_idx\n        ));\n    }\n\n    #[motsu::test]\n    fn add_token_to_all_tokens_enumeration_works(\n        contract: Contract\u003cErc721EnumerableTestExample\u003e,\n        alice: Address,\n    ) {\n        let tokens_len = 10;\n\n        let mut tokens_ids = Vec::new();\n        for token_id in 0..tokens_len {\n            let token_id = U256::from(token_id);\n            // Store ids for test.\n            tokens_ids.push(token_id);\n            contract\n                .sender(alice)\n                .enumerable\n                ._add_token_to_all_tokens_enumeration(token_id);\n        }\n\n        assert_eq!(\n            U256::from(tokens_len),\n            contract.sender(alice).total_supply()\n        );\n\n        tokens_ids.iter().enumerate().for_each(|(idx, expected_token_id)| {\n            let token_id = contract\n                .sender(alice)\n                .token_by_index(U256::from(idx))\n                .expect(\"should return token id for\");\n            assert_eq!(*expected_token_id, token_id);\n        });\n\n        let err = contract\n            .sender(alice)\n            .token_by_index(U256::from(tokens_len))\n            .expect_err(\"should return Error::OutOfBoundsIndex\");\n\n        assert!(matches!(\n            err,\n            Error::OutOfBoundsIndex(ERC721OutOfBoundsIndex {\n                owner,\n                index\n            }) if owner.is_zero() \u0026\u0026 index == U256::from(tokens_len)\n        ));\n    }\n\n    #[motsu::test]\n    fn remove_token_from_all_tokens_enumeration_works(\n        contract: Contract\u003cErc721EnumerableTestExample\u003e,\n        alice: Address,\n    ) {\n        let initial_tokens_len = 10;\n\n        let mut tokens_ids = Vec::new();\n        for token_id in 0..initial_tokens_len {\n            let token_id = U256::from(token_id);\n            // Store ids for test.\n            tokens_ids.push(token_id);\n\n            contract\n                .sender(alice)\n                .enumerable\n                ._add_token_to_all_tokens_enumeration(token_id);\n        }\n        assert_eq!(\n            U256::from(initial_tokens_len),\n            contract.sender(alice).total_supply()\n        );\n\n        // Remove the last token.\n        let last_token_id = tokens_ids.swap_remove(initial_tokens_len - 1);\n        contract\n            .sender(alice)\n            .enumerable\n            ._remove_token_from_all_tokens_enumeration(last_token_id);\n        assert_eq!(\n            U256::from(initial_tokens_len - 1),\n            contract.sender(alice).total_supply()\n        );\n\n        // Remove the second (`idx = 1`) element\n        // to check that swap_remove operation works as expected.\n        let token_to_remove = tokens_ids.swap_remove(1);\n        contract\n            .sender(alice)\n            .enumerable\n            ._remove_token_from_all_tokens_enumeration(token_to_remove);\n        assert_eq!(\n            U256::from(initial_tokens_len - 2),\n            contract.sender(alice).total_supply()\n        );\n\n        // Add a new token.\n        let token_id = U256::from(initial_tokens_len);\n        tokens_ids.push(token_id);\n        contract\n            .sender(alice)\n            .enumerable\n            ._add_token_to_all_tokens_enumeration(token_id);\n        assert_eq!(\n            U256::from(initial_tokens_len - 1),\n            contract.sender(alice).total_supply()\n        );\n\n        // Check proper indices of tokens.\n        tokens_ids.iter().enumerate().for_each(|(idx, expected_token_id)| {\n            let token_id = contract\n                .sender(alice)\n                .token_by_index(U256::from(idx))\n                .expect(\"should return token id\");\n            assert_eq!(*expected_token_id, token_id);\n        });\n\n        let err = contract\n            .sender(alice)\n            .token_by_index(U256::from(initial_tokens_len - 1))\n            .expect_err(\"should return Error::OutOfBoundsIndex\");\n\n        assert!(matches!(err, Error::OutOfBoundsIndex(ERC721OutOfBoundsIndex {\n                owner,\n                index\n            }) if owner.is_zero() \u0026\u0026 index == U256::from(initial_tokens_len - 1)\n        ));\n    }\n\n    #[motsu::test]\n    fn check_increase_balance() {\n        assert!(Erc721Enumerable::_check_increase_balance(0).is_ok());\n\n        let err = Erc721Enumerable::_check_increase_balance(1)\n            .expect_err(\"should return Error::EnumerableForbiddenBatchMint\");\n\n        assert!(matches!(\n            err,\n            Error::EnumerableForbiddenBatchMint(\n                ERC721EnumerableForbiddenBatchMint {}\n            )\n        ));\n    }\n\n    #[motsu::test]\n    fn token_of_owner_by_index_works(\n        contract: Contract\u003cErc721EnumerableTestExample\u003e,\n        alice: Address,\n    ) {\n        let token_id = uint!(1_U256);\n        contract\n            .sender(alice)\n            .erc721\n            ._mint(alice, token_id)\n            .expect(\"should mint a token for {{alice}}\");\n\n        let owner = contract\n            .sender(alice)\n            .erc721\n            .owner_of(token_id)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n\n        contract\n            .sender(alice)\n            .enumerable\n            ._add_token_to_owner_enumeration(\n                alice,\n                token_id,\n                \u0026contract.sender(alice).erc721,\n            )\n            .expect(\"should add token to owner enumeration\");\n\n        let test_token_id = contract\n            .sender(alice)\n            .token_of_owner_by_index(alice, U256::ZERO)\n            .expect(\"should return `token_id`\");\n\n        assert_eq!(token_id, test_token_id);\n    }\n\n    #[motsu::test]\n    fn reverts_when_token_of_owner_for_index_out_of_bound(\n        contract: Contract\u003cErc721EnumerableTestExample\u003e,\n        alice: Address,\n    ) {\n        let token_id = uint!(1_U256);\n        contract\n            .sender(alice)\n            .erc721\n            ._mint(alice, token_id)\n            .expect(\"should mint a token for {{alice}}\");\n\n        let owner = contract\n            .sender(alice)\n            .erc721\n            .owner_of(token_id)\n            .expect(\"should return the owner of the token\");\n\n        assert_eq!(owner, alice);\n\n        contract\n            .sender(alice)\n            .enumerable\n            ._add_token_to_owner_enumeration(\n                alice,\n                token_id,\n                \u0026contract.sender(alice).erc721,\n            )\n            .expect(\"should add token to owner enumeration\");\n\n        let token_idx = uint!(1_U256);\n\n        let err = contract\n            .sender(alice)\n            .token_of_owner_by_index(alice, token_idx)\n            .expect_err(\"should return Error::OutOfBoundsIndex\");\n\n        assert!(matches!(err, Error::OutOfBoundsIndex(ERC721OutOfBoundsIndex {\n                owner,\n                index\n            }) if owner == alice \u0026\u0026 index == token_idx\n        ));\n    }\n\n    #[motsu::test]\n    fn reverts_when_token_of_owner_does_not_own_any_token(\n        contract: Contract\u003cErc721EnumerableTestExample\u003e,\n        alice: Address,\n    ) {\n        let token_idx = U256::ZERO;\n\n        let err = contract\n            .sender(alice)\n            .token_of_owner_by_index(alice, token_idx)\n            .expect_err(\"should return Error::OutOfBoundsIndex\");\n\n        assert!(matches!(err, Error::OutOfBoundsIndex(ERC721OutOfBoundsIndex {\n                owner,\n                index\n            }) if owner == alice \u0026\u0026 index == token_idx\n        ));\n    }\n\n    #[motsu::test]\n    fn token_of_owner_by_index_after_transfer_works(\n        contract: Contract\u003cErc721EnumerableTestExample\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let token_id = uint!(1_U256);\n        contract\n            .sender(alice)\n            .erc721\n            ._mint(alice, token_id)\n            .expect(\"should mint a token for {{alice}}\");\n\n        contract\n            .sender(alice)\n            .enumerable\n            ._add_token_to_owner_enumeration(\n                alice,\n                token_id,\n                \u0026contract.sender(alice).erc721,\n            )\n            .expect(\"should add token to owner enumeration\");\n\n        // Transfer the token from alice to bob.\n        contract\n            .sender(alice)\n            .erc721\n            .transfer_from(alice, bob, token_id)\n            .expect(\"should transfer the token from {{alice}} to {{bob}}\");\n\n        // Remove the token from alice's enumeration.\n        contract\n            .sender(alice)\n            .enumerable\n            ._remove_token_from_owner_enumeration(\n                alice,\n                token_id,\n                \u0026contract.sender(alice).erc721,\n            )\n            .expect(\"should remove token from {{alice}} enumeration\");\n\n        contract\n            .sender(bob)\n            .enumerable\n            ._add_token_to_owner_enumeration(\n                bob,\n                token_id,\n                \u0026contract.sender(bob).erc721,\n            )\n            .expect(\"should add token to {{bob}} enumeration\");\n\n        let token_idx = U256::ZERO;\n\n        let test_token_id = contract\n            .sender(bob)\n            .token_of_owner_by_index(bob, token_idx)\n            .expect(\"should return `token_id`\");\n\n        assert_eq!(token_id, test_token_id);\n\n        let err = contract\n            .sender(alice)\n            .token_of_owner_by_index(alice, token_idx)\n            .expect_err(\"should return Error::OutOfBoundsIndex\");\n\n        assert!(matches!(err, Error::OutOfBoundsIndex(ERC721OutOfBoundsIndex {\n                owner,\n                index\n            }) if owner == alice \u0026\u0026 index == token_idx\n        ));\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc721Enumerable as IErc721Enumerable\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0x780e9d63.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(\n        contract: Contract\u003cErc721EnumerableTestExample\u003e,\n        alice: Address,\n    ) {\n        assert!(contract.sender(alice).enumerable.supports_interface(\n            \u003cErc721Enumerable as IErc721Enumerable\u003e::interface_id()\n        ));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc721Enumerable as IErc165\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":150,"address":[],"length":0,"stats":{"Line":20}},{"line":152,"address":[],"length":0,"stats":{"Line":10}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":27}},{"line":160,"address":[],"length":0,"stats":{"Line":81}},{"line":161,"address":[],"length":0,"stats":{"Line":54}},{"line":164,"address":[],"length":0,"stats":{"Line":22}},{"line":165,"address":[],"length":0,"stats":{"Line":88}},{"line":166,"address":[],"length":0,"stats":{"Line":44}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":16}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":21}},{"line":216,"address":[],"length":0,"stats":{"Line":63}},{"line":218,"address":[],"length":0,"stats":{"Line":63}},{"line":219,"address":[],"length":0,"stats":{"Line":63}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":6}},{"line":300,"address":[],"length":0,"stats":{"Line":8}},{"line":309,"address":[],"length":0,"stats":{"Line":4}},{"line":310,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":6}},{"line":316,"address":[],"length":0,"stats":{"Line":8}},{"line":318,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":6}},{"line":324,"address":[],"length":0,"stats":{"Line":6}},{"line":325,"address":[],"length":0,"stats":{"Line":4}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":343,"address":[],"length":0,"stats":{"Line":1}},{"line":345,"address":[],"length":0,"stats":{"Line":1}}],"covered":37,"coverable":52},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc721","extensions","metadata.rs"],"content":"//! Optional Metadata of the ERC-721 standard.\n\nuse alloc::{\n    string::{String, ToString},\n    vec,\n    vec::Vec,\n};\n\nuse alloy_primitives::U256;\nuse openzeppelin_stylus_proc::interface_id;\nuse stylus_sdk::{prelude::*, storage::StorageString};\n\nuse crate::{\n    token::erc721::{self, IErc721},\n    utils::{introspection::erc165::IErc165, Metadata},\n};\n\n/// State of an [`Erc721Metadata`] contract.\n#[storage]\npub struct Erc721Metadata {\n    /// [`Metadata`] contract.\n    pub(crate) metadata: Metadata,\n    // TODO: Remove this field once function overriding is possible. For now we\n    // keep this field `pub`, since this is used to simulate overriding.\n    /// Base URI for tokens.\n    pub base_uri: StorageString,\n}\n\n/// Interface for the optional metadata functions from the ERC-721 standard.\n#[interface_id]\npub trait IErc721Metadata: IErc165 {\n    /// The error type associated to this trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns the token collection name.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn name(\u0026self) -\u003e String;\n\n    /// Returns token collection symbol.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn symbol(\u0026self) -\u003e String;\n\n    /// Returns the Uniform Resource Identifier (URI) for `token_id` token.\n    ///\n    /// NOTE: The implementation should use `#[selector(name = \"tokenURI\")]` to\n    /// match Solidity's camelCase naming convention.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token_id` - ID of a token.\n    ///\n    /// # Errors\n    ///\n    /// * [`erc721::Error::NonexistentToken`] - If the token does not exist.\n    #[selector(name = \"tokenURI\")]\n    fn token_uri(\u0026self, token_id: U256) -\u003e Result\u003cString, Self::Error\u003e;\n}\n\nimpl Erc721Metadata {\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `name` - Token name.\n    /// * `symbol` - Token symbol.\n    pub fn constructor(\u0026mut self, name: String, symbol: String) {\n        self.metadata.constructor(name, symbol);\n    }\n\n    /// Check [`IErc721Metadata::name()`] for more details.\n    pub fn name(\u0026self) -\u003e String {\n        self.metadata.name()\n    }\n\n    /// Check [`IErc721Metadata::symbol()`] for more details.\n    pub fn symbol(\u0026self) -\u003e String {\n        self.metadata.symbol()\n    }\n\n    /// Returns the base of Uniform Resource Identifier (URI) for tokens'\n    /// collection.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    pub fn base_uri(\u0026self) -\u003e String {\n        self.base_uri.get_string()\n    }\n\n    /// Check [`IErc721Metadata::token_uri()`] for more details.\n    #[allow(clippy::missing_errors_doc)]\n    pub fn token_uri(\n        \u0026self,\n        token_id: U256,\n        erc721: \u0026impl IErc721\u003cError = erc721::Error\u003e,\n    ) -\u003e Result\u003cString, erc721::Error\u003e {\n        erc721.owner_of(token_id)?;\n\n        let base_uri = self.base_uri();\n\n        let token_uri = if base_uri.is_empty() {\n            String::new()\n        } else {\n            base_uri + \u0026token_id.to_string()\n        };\n\n        Ok(token_uri)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{Address, FixedBytes};\n    use motsu::prelude::Contract;\n\n    use super::*;\n    use crate::{\n        token::erc721::{self, Erc721},\n        utils::introspection::erc165::IErc165,\n    };\n\n    #[storage]\n    struct Erc721MetadataExample {\n        erc721: Erc721,\n        metadata: Erc721Metadata,\n    }\n\n    #[public]\n    #[implements(IErc721Metadata\u003cError = erc721::Error\u003e, IErc165)]\n    impl Erc721MetadataExample {\n        #[constructor]\n        fn constructor(\u0026mut self, name: String, symbol: String) {\n            self.metadata.constructor(name, symbol);\n        }\n    }\n\n    #[public]\n    impl IErc721Metadata for Erc721MetadataExample {\n        type Error = erc721::Error;\n\n        fn name(\u0026self) -\u003e String {\n            self.metadata.name()\n        }\n\n        fn symbol(\u0026self) -\u003e String {\n            self.metadata.symbol()\n        }\n\n        #[selector(name = \"tokenURI\")]\n        fn token_uri(\u0026self, token_id: U256) -\u003e Result\u003cString, erc721::Error\u003e {\n            self.metadata.token_uri(token_id, \u0026self.erc721)\n        }\n    }\n\n    #[public]\n    impl IErc165 for Erc721MetadataExample {\n        fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n            \u003cSelf as IErc721Metadata\u003e::interface_id() == interface_id\n                || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n        }\n    }\n\n    unsafe impl TopLevelStorage for Erc721MetadataExample {}\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc721MetadataExample as IErc721Metadata\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0x5b5e139f.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(\n        contract: Contract\u003cErc721MetadataExample\u003e,\n        alice: Address,\n    ) {\n        assert!(contract.sender(alice).supports_interface(\n            \u003cErc721MetadataExample as IErc721Metadata\u003e::interface_id()\n        ));\n        assert!(contract.sender(alice).supports_interface(\n            \u003cErc721MetadataExample as IErc165\u003e::interface_id()\n        ));\n\n        let fake_interface_id: FixedBytes\u003c4\u003e = 0x12345678_u32.into();\n        assert!(!contract.sender(alice).supports_interface(fake_interface_id));\n    }\n\n    #[motsu::test]\n    fn metadata(contract: Contract\u003cErc721MetadataExample\u003e, alice: Address) {\n        let name: String = \"Erc721MetadataExample\".to_string();\n        let symbol: String = \"OZ\".to_string();\n\n        contract.init(alice, |contract| {\n            contract.metadata.constructor(name.clone(), symbol.clone());\n        });\n        assert_eq!(contract.sender(alice).name(), name);\n        assert_eq!(contract.sender(alice).symbol(), symbol);\n    }\n\n    #[motsu::test]\n    fn constructor(contract: Contract\u003cErc721MetadataExample\u003e, alice: Address) {\n        let name: String = \"Erc721MetadataExample\".to_string();\n        let symbol: String = \"OZ\".to_string();\n        contract.init(alice, |contract| {\n            contract.constructor(name.clone(), symbol.clone());\n        });\n\n        assert_eq!(contract.sender(alice).name(), name);\n        assert_eq!(contract.sender(alice).symbol(), symbol);\n    }\n}\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":8}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":15},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc721","extensions","mod.rs"],"content":"//! Common extensions to the ERC-721 standard.\npub mod burnable;\npub mod consecutive;\npub mod enumerable;\npub mod metadata;\npub mod uri_storage;\npub mod wrapper;\n\npub use burnable::IErc721Burnable;\npub use consecutive::Erc721Consecutive;\npub use enumerable::{Erc721Enumerable, IErc721Enumerable};\npub use metadata::{Erc721Metadata, IErc721Metadata};\npub use uri_storage::{Erc721UriStorage, IErc721UriStorage};\npub use wrapper::{Erc721Wrapper, IErc721Wrapper};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc721","extensions","uri_storage.rs"],"content":"//! ERC-721 token with storage-based token URI management.\n//!\n//! It also implements IERC4096, which is an ERC-721 Metadata Update Extension.\nuse alloc::{string::String, vec, vec::Vec};\n\nuse alloy_primitives::U256;\npub use sol::*;\nuse stylus_sdk::{\n    evm,\n    prelude::*,\n    storage::{StorageMap, StorageString},\n};\n\nuse crate::token::erc721::{\n    self,\n    extensions::{Erc721Metadata, IErc721Metadata},\n    IErc721,\n};\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// This event gets emitted when the metadata of a token is changed.\n        ///\n        /// The event comes from IERC4096.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event MetadataUpdate(uint256 token_id);\n\n        /// This event gets emitted when the metadata of a range of tokens\n        /// is changed.\n        ///\n        /// The event comes from IERC4096.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event BatchMetadataUpdate(uint256 from_token_id, uint256 to_token_id);\n    }\n}\n\n/// State of an [`Erc721UriStorage`] contract.\n#[storage]\npub struct Erc721UriStorage {\n    /// Optional mapping for token URIs.\n    pub token_uris: StorageMap\u003cU256, StorageString\u003e,\n}\n\n/// Interface of an optional extension ERC-721 token providing storage based\n/// token URI management.\npub trait IErc721UriStorage: IErc721Metadata {}\n\nimpl Erc721UriStorage {\n    /// Sets `token_uri` as the token URI of `token_id`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token_id` - Id of a token.\n    /// * `token_uri` - URI for the token.\n    ///\n    /// # Events\n    ///\n    /// * [`MetadataUpdate`].\n    pub fn _set_token_uri(\u0026mut self, token_id: U256, token_uri: String) {\n        self.token_uris.setter(token_id).set_str(token_uri);\n        evm::log(MetadataUpdate { token_id });\n    }\n\n    /// Check [`IErc721Metadata::token_uri()`] for more details.\n    #[allow(clippy::missing_errors_doc)]\n    pub fn token_uri(\n        \u0026self,\n        token_id: U256,\n        erc721: \u0026impl IErc721\u003cError = erc721::Error\u003e,\n        metadata: \u0026Erc721Metadata,\n    ) -\u003e Result\u003cString, erc721::Error\u003e {\n        erc721.owner_of(token_id)?;\n\n        let token_uri = self.token_uris.getter(token_id).get_string();\n        let base = metadata.base_uri();\n\n        // If there is no base URI, return the token URI.\n        if base.is_empty() {\n            return Ok(token_uri);\n        }\n\n        // If both are set, concatenate the `base_uri` and `token_uri`.\n        let uri = if token_uri.is_empty() {\n            metadata.token_uri(token_id, erc721)?\n        } else {\n            base + \u0026token_uri\n        };\n\n        Ok(uri)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{uint, Address};\n    use motsu::prelude::*;\n    use stylus_sdk::prelude::*;\n\n    use super::*;\n    use crate::{\n        token::erc721::{self, extensions::Erc721Metadata, Erc721},\n        utils::introspection::erc165::IErc165,\n    };\n    const TOKEN_ID: U256 = uint!(1_U256);\n    use alloy_primitives::FixedBytes;\n\n    #[storage]\n    struct Erc721MetadataExample {\n        pub erc721: Erc721,\n        pub metadata: Erc721Metadata,\n        pub uri_storage: Erc721UriStorage,\n    }\n\n    #[public]\n    #[implements(IErc721Metadata\u003cError = erc721::Error\u003e, IErc165)]\n    impl Erc721MetadataExample {\n        #[constructor]\n        fn constructor(\u0026mut self, name: String, symbol: String) {\n            self.metadata.constructor(name, symbol);\n        }\n\n        #[selector(name = \"setTokenURI\")]\n        fn set_token_uri(\u0026mut self, token_id: U256, token_uri: String) {\n            self.uri_storage._set_token_uri(token_id, token_uri);\n        }\n    }\n\n    #[public]\n    impl IErc721Metadata for Erc721MetadataExample {\n        type Error = erc721::Error;\n\n        fn name(\u0026self) -\u003e String {\n            self.metadata.name()\n        }\n\n        fn symbol(\u0026self) -\u003e String {\n            self.metadata.symbol()\n        }\n\n        #[selector(name = \"tokenURI\")]\n        fn token_uri(\u0026self, token_id: U256) -\u003e Result\u003cString, erc721::Error\u003e {\n            self.uri_storage.token_uri(token_id, \u0026self.erc721, \u0026self.metadata)\n        }\n    }\n\n    #[public]\n    impl IErc165 for Erc721MetadataExample {\n        fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n            \u003cSelf as IErc721Metadata\u003e::interface_id() == interface_id\n                || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n        }\n    }\n\n    unsafe impl TopLevelStorage for Erc721MetadataExample {}\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc721MetadataExample as IErc721Metadata\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = 0x5b5e139f.into();\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(\n        contract: Contract\u003cErc721MetadataExample\u003e,\n        alice: Address,\n    ) {\n        assert!(contract.sender(alice).supports_interface(\n            \u003cErc721MetadataExample as IErc721Metadata\u003e::interface_id()\n        ));\n        assert!(contract.sender(alice).supports_interface(\n            \u003cErc721MetadataExample as IErc165\u003e::interface_id()\n        ));\n\n        let fake_interface_id: FixedBytes\u003c4\u003e = 0x12345678_u32.into();\n        assert!(!contract.sender(alice).supports_interface(fake_interface_id));\n    }\n    #[motsu::test]\n    fn token_uri_works(\n        contract: Contract\u003cErc721MetadataExample\u003e,\n        alice: Address,\n    ) {\n        contract\n            .sender(alice)\n            .erc721\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token for Alice\");\n\n        let token_uri = String::from(\"https://docs.openzeppelin.com/contracts/5.x/api/token/erc721#Erc721URIStorage\");\n        contract.sender(alice).set_token_uri(TOKEN_ID, token_uri.clone());\n\n        assert_eq!(\n            token_uri,\n            contract\n                .sender(alice)\n                .token_uri(TOKEN_ID)\n                .expect(\"should return token URI\")\n        );\n    }\n}\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":13},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc721","extensions","wrapper.rs"],"content":"//! Extension of the ERC-721 token contract to support token wrapping.\n//!\n//! Users can deposit and withdraw an \"underlying token\" and receive a \"wrapped\n//! token\" with a matching token ID. This is useful in conjunction with other\n//! modules.\nuse alloc::{\n    string::{String, ToString},\n    vec,\n    vec::Vec,\n};\n\nuse alloy_primitives::{Address, FixedBytes, U256};\nuse openzeppelin_stylus_proc::interface_id;\npub use sol::*;\nuse stylus_sdk::{\n    abi::Bytes,\n    call::{self, Call, MethodError},\n    contract, msg,\n    prelude::*,\n    storage::StorageAddress,\n};\n\nuse crate::token::erc721::{\n    self, interface::Erc721Interface, Erc721, RECEIVER_FN_SELECTOR,\n};\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// The received ERC-721 token couldn't be wrapped.\n        ///\n        /// * `token` - The token address.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721UnsupportedToken(address token);\n\n        /// An operation with an ERC-721 token failed.\n        ///\n        /// * `token` - Address of the ERC-721 token.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error Erc721FailedOperation(address token);\n\n    }\n}\n\n/// An [`Erc721Wrapper`] error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates that an address can't be an owner.\n    /// For example, [`Address::ZERO`] is a forbidden owner in [`Erc721`].\n    /// Used in balance queries.\n    InvalidOwner(erc721::ERC721InvalidOwner),\n    /// Indicates a `token_id` whose `owner` is the zero address.\n    NonexistentToken(erc721::ERC721NonexistentToken),\n    /// Indicates an error related to the ownership over a particular token.\n    /// Used in transfers.\n    IncorrectOwner(erc721::ERC721IncorrectOwner),\n    /// Indicates a failure with the token `sender`. Used in transfers.\n    InvalidSender(erc721::ERC721InvalidSender),\n    /// Indicates a failure with the token `receiver`. Used in transfers.\n    InvalidReceiver(erc721::ERC721InvalidReceiver),\n    /// Indicates a failure with the token `receiver`, with the reason\n    /// specified by it.\n    InvalidReceiverWithReason(erc721::InvalidReceiverWithReason),\n    /// Indicates a failure with the `operator`’s approval. Used in transfers.\n    InsufficientApproval(erc721::ERC721InsufficientApproval),\n    /// Indicates a failure with the `approver` of a token to be approved. Used\n    /// in approvals.\n    InvalidApprover(erc721::ERC721InvalidApprover),\n    /// Indicates a failure with the `operator` to be approved. Used in\n    /// approvals.\n    InvalidOperator(erc721::ERC721InvalidOperator),\n    /// The received ERC-721 token couldn't be wrapped.\n    UnsupportedToken(ERC721UnsupportedToken),\n    /// An operation with an ERC-721 token failed.\n    Erc721FailedOperation(Erc721FailedOperation),\n}\n\nimpl From\u003cerc721::Error\u003e for Error {\n    fn from(value: erc721::Error) -\u003e Self {\n        match value {\n            erc721::Error::InvalidOwner(e) =\u003e Error::InvalidOwner(e),\n            erc721::Error::NonexistentToken(e) =\u003e Error::NonexistentToken(e),\n            erc721::Error::IncorrectOwner(e) =\u003e Error::IncorrectOwner(e),\n            erc721::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc721::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc721::Error::InvalidReceiverWithReason(e) =\u003e {\n                Error::InvalidReceiverWithReason(e)\n            }\n            erc721::Error::InsufficientApproval(e) =\u003e {\n                Error::InsufficientApproval(e)\n            }\n            erc721::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n            erc721::Error::InvalidOperator(e) =\u003e Error::InvalidOperator(e),\n        }\n    }\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of an [`Erc721Wrapper`] token.\n#[storage]\npub struct Erc721Wrapper {\n    /// Address of the underlying token.\n    underlying: StorageAddress,\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for Erc721Wrapper {}\n\n/// Interface of an extension of the ERC-721 token contract that supports token\n/// wrapping.\n#[interface_id]\npub trait IErc721Wrapper {\n    /// The error type associated to this trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Allow a user to deposit underlying tokens and mint the corresponding\n    /// `token_ids`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `account` - The account to deposit tokens to.\n    /// * `token_ids` - List of underlying token ids to deposit.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::Erc721FailedOperation`] - If the underlying token is not an\n    ///   ERC-721 contract.\n    /// * [`Error::InvalidReceiverWithReason`] - If an error occurs during\n    ///   [`erc721::IErc721::transfer_from`] operation on the underlying token.\n    /// * [`Error::InvalidSender`] - If `token_id` already exists.\n    /// * [`Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`erc721::IERC721Receiver::on_erc_721_received`] hasn't returned its\n    ///   interface id or returned with an error.\n    fn deposit_for(\n        \u0026mut self,\n        account: Address,\n        token_ids: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003cbool, Self::Error\u003e;\n\n    /// Allow a user to burn wrapped tokens and withdraw the corresponding\n    /// `token_ids` of the underlying tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `account` - The account to withdraw tokens to.\n    /// * `token_ids` - List of underlying token ids to withdraw.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::Erc721FailedOperation`] - If the underlying token is not an\n    ///   ERC-721 contract.\n    /// * [`Error::InvalidReceiverWithReason`] - If an error occurs during\n    ///   [`erc721::IErc721::safe_transfer_from`] operation on the underlying\n    ///   token.\n    /// * [`Error::NonexistentToken`] - If the token does not exist and `auth`\n    ///   is not [`Address::ZERO`].\n    /// * [`Error::InsufficientApproval`] - If `auth` is not [`Address::ZERO`]\n    ///   and `auth` does not have a right to approve this token.\n    fn withdraw_to(\n        \u0026mut self,\n        account: Address,\n        token_ids: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003cbool, Self::Error\u003e;\n\n    /// Overrides [`erc721::IERC721Receiver::on_erc_721_received`] to allow\n    /// minting on direct ERC-721 transfers to this contract.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `operator` - The operator of the transfer.\n    /// * `from` - The sender of the transfer.\n    /// * `token_id` - The token id of the transfer.\n    /// * `data` - The data of the transfer.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::UnsupportedToken`] - If `msg::sender()` is not the underlying\n    ///   token.\n    /// * [`Error::InvalidSender`] - If `token_id` already exists.\n    /// * [`Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`erc721::IERC721Receiver::on_erc_721_received`] hasn't returned its\n    ///   interface id or returned with an error.\n    fn on_erc721_received(\n        \u0026mut self,\n        operator: Address,\n        from: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -\u003e Result\u003cFixedBytes\u003c4\u003e, Self::Error\u003e;\n\n    /// Returns the underlying token.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    #[must_use]\n    fn underlying(\u0026self) -\u003e Address;\n}\n\nimpl Erc721Wrapper {\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `underlying_token` - The wrapped token.\n    pub fn constructor(\u0026mut self, underlying_token: Address) {\n        self.underlying.set(underlying_token);\n    }\n\n    /// Check [`IErc721Wrapper::deposit_for()`] for more information.\n    #[allow(clippy::missing_errors_doc)]\n    pub fn deposit_for(\n        \u0026mut self,\n        account: Address,\n        token_ids: Vec\u003cU256\u003e,\n        erc721: \u0026mut Erc721,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let sender = msg::sender();\n        let contract_address = contract::address();\n        let underlying = Erc721Interface::new(self.underlying());\n\n        for token_id in token_ids {\n            // This is an \"unsafe\" transfer that doesn't call any hook on\n            // the receiver. With [`IErc721Wrapper::underlying()`] being trusted\n            // (by design of this contract) and no other contracts expected to\n            // be called from there, we are safe.\n            match underlying.transfer_from(\n                Call::new_in(self),\n                sender,\n                contract_address,\n                token_id,\n            ) {\n                Ok(()) =\u003e (),\n                Err(e) =\u003e {\n                    if let call::Error::Revert(ref reason) = e {\n                        if !reason.is_empty() {\n                            return Err(Error::InvalidReceiverWithReason(\n                                erc721::InvalidReceiverWithReason {\n                                    reason: String::from_utf8_lossy(reason)\n                                        .to_string(),\n                                },\n                            ));\n                        }\n                    }\n                    return Err(Error::Erc721FailedOperation(\n                        Erc721FailedOperation { token: self.underlying() },\n                    ));\n                }\n            }\n\n            erc721._safe_mint(account, token_id, \u0026vec![].into())?;\n        }\n\n        Ok(true)\n    }\n\n    /// Check [`IErc721Wrapper::withdraw_to()`] for more information.\n    #[allow(clippy::missing_errors_doc)]\n    pub fn withdraw_to(\n        \u0026mut self,\n        account: Address,\n        token_ids: Vec\u003cU256\u003e,\n        erc721: \u0026mut Erc721,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let sender = msg::sender();\n        let underlying = Erc721Interface::new(self.underlying());\n\n        for token_id in token_ids {\n            // Setting the `auth` argument enables the `_is_authorized` check\n            // which verifies that the token exists (from != 0).\n            // Therefore, it is not needed to verify that the return value is\n            // not 0 here.\n            erc721._update(Address::ZERO, token_id, sender)?;\n            match underlying.safe_transfer_from(\n                Call::new_in(self),\n                contract::address(),\n                account,\n                token_id,\n                vec![].into(),\n            ) {\n                Ok(()) =\u003e (),\n                Err(e) =\u003e {\n                    if let call::Error::Revert(ref reason) = e {\n                        if !reason.is_empty() {\n                            return Err(Error::InvalidReceiverWithReason(\n                                erc721::InvalidReceiverWithReason {\n                                    reason: String::from_utf8_lossy(reason)\n                                        .to_string(),\n                                },\n                            ));\n                        }\n                    }\n                    return Err(Error::Erc721FailedOperation(\n                        Erc721FailedOperation { token: self.underlying() },\n                    ));\n                }\n            }\n        }\n\n        Ok(true)\n    }\n\n    /// Check [`IErc721Wrapper::on_erc721_received()`] for more information.\n    #[allow(clippy::missing_errors_doc)]\n    pub fn on_erc721_received(\n        \u0026mut self,\n        _operator: Address,\n        from: Address,\n        token_id: U256,\n        _data: \u0026Bytes,\n        erc721: \u0026mut Erc721,\n    ) -\u003e Result\u003cFixedBytes\u003c4\u003e, Error\u003e {\n        let sender = msg::sender();\n        if self.underlying() != sender {\n            return Err(Error::UnsupportedToken(ERC721UnsupportedToken {\n                token: sender,\n            }));\n        }\n\n        erc721._safe_mint(from, token_id, \u0026vec![].into())?;\n\n        Ok(RECEIVER_FN_SELECTOR.into())\n    }\n\n    /// Check [`IErc721Wrapper::underlying()`] for more information.\n    #[must_use]\n    pub fn underlying(\u0026self) -\u003e Address {\n        self.underlying.get()\n    }\n\n    /// Mints wrapped tokens to cover any underlying tokens that would have been\n    /// function that can be exposed with access control if desired.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `account` - The account to mint tokens to.\n    /// * `token_id` - A mutable reference to the Erc20 contract.\n    /// * `erc721` - Write access to an [`Erc721`] contract.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::Erc721FailedOperation`] - If the underlying token is not a\n    ///   [`Erc721`] contract, or the contract fails to execute the call.\n    /// * [`Error::IncorrectOwner`] - If the underlying token is not owned by\n    ///   the contract.\n    /// * [`Error::InvalidSender`] - If `token_id` already exists.\n    /// * [`Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`erc721::IERC721Receiver::on_erc_721_received`] hasn't returned its\n    ///   interface id or returned with an error.\n    fn _recover(\n        \u0026mut self,\n        account: Address,\n        token_id: U256,\n        erc721: \u0026mut Erc721,\n    ) -\u003e Result\u003cU256, Error\u003e {\n        let underlying = Erc721Interface::new(self.underlying());\n\n        let owner = underlying.owner_of(Call::new_in(self), token_id).map_err(\n            |_| {\n                Error::Erc721FailedOperation(Erc721FailedOperation {\n                    token: self.underlying(),\n                })\n            },\n        )?;\n\n        let contract_address = contract::address();\n        if owner != contract_address {\n            return Err(erc721::Error::IncorrectOwner(\n                erc721::ERC721IncorrectOwner {\n                    sender: contract_address,\n                    token_id,\n                    owner,\n                },\n            )\n            .into());\n        }\n\n        erc721._safe_mint(account, token_id, \u0026vec![].into())?;\n\n        Ok(token_id)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::uint;\n    use motsu::prelude::*;\n    use stylus_sdk::abi::Bytes;\n\n    use super::*;\n    use crate::{\n        token::erc721::{self, IErc721},\n        utils::introspection::erc165::IErc165,\n    };\n\n    pub(crate) fn random_token_ids(size: usize) -\u003e Vec\u003cU256\u003e {\n        (0..size).map(U256::from).collect()\n    }\n\n    #[storage]\n    struct Erc721WrapperTestExample {\n        wrapper: Erc721Wrapper,\n        erc721: Erc721,\n    }\n\n    #[public]\n    #[implements(IErc721\u003cError = erc721::Error\u003e, IErc721Wrapper\u003cError = Error\u003e, IErc165)]\n    impl Erc721WrapperTestExample {\n        #[constructor]\n        fn constructor(\u0026mut self, underlying_token: Address) {\n            self.wrapper.constructor(underlying_token);\n        }\n\n        fn recover(\n            \u0026mut self,\n            account: Address,\n            token_id: U256,\n        ) -\u003e Result\u003cU256, Error\u003e {\n            self.wrapper._recover(account, token_id, \u0026mut self.erc721)\n        }\n    }\n\n    #[public]\n    impl IErc721 for Erc721WrapperTestExample {\n        type Error = erc721::Error;\n\n        fn balance_of(\u0026self, owner: Address) -\u003e Result\u003cU256, erc721::Error\u003e {\n            self.erc721.balance_of(owner)\n        }\n\n        fn owner_of(\u0026self, token_id: U256) -\u003e Result\u003cAddress, erc721::Error\u003e {\n            self.erc721.owner_of(token_id)\n        }\n\n        fn safe_transfer_from(\n            \u0026mut self,\n            from: Address,\n            to: Address,\n            token_id: U256,\n        ) -\u003e Result\u003c(), erc721::Error\u003e {\n            self.erc721.safe_transfer_from(from, to, token_id)\n        }\n\n        fn safe_transfer_from_with_data(\n            \u0026mut self,\n            from: Address,\n            to: Address,\n            token_id: U256,\n            data: Bytes,\n        ) -\u003e Result\u003c(), erc721::Error\u003e {\n            self.erc721.safe_transfer_from_with_data(from, to, token_id, data)\n        }\n\n        fn transfer_from(\n            \u0026mut self,\n            from: Address,\n            to: Address,\n            token_id: U256,\n        ) -\u003e Result\u003c(), erc721::Error\u003e {\n            self.erc721.transfer_from(from, to, token_id)\n        }\n\n        fn approve(\n            \u0026mut self,\n            to: Address,\n            token_id: U256,\n        ) -\u003e Result\u003c(), erc721::Error\u003e {\n            self.erc721.approve(to, token_id)\n        }\n\n        fn set_approval_for_all(\n            \u0026mut self,\n            operator: Address,\n            approved: bool,\n        ) -\u003e Result\u003c(), erc721::Error\u003e {\n            self.erc721.set_approval_for_all(operator, approved)\n        }\n\n        fn get_approved(\n            \u0026self,\n            token_id: U256,\n        ) -\u003e Result\u003cAddress, erc721::Error\u003e {\n            self.erc721.get_approved(token_id)\n        }\n\n        fn is_approved_for_all(\n            \u0026self,\n            owner: Address,\n            operator: Address,\n        ) -\u003e bool {\n            self.erc721.is_approved_for_all(owner, operator)\n        }\n    }\n\n    #[public]\n    impl IErc721Wrapper for Erc721WrapperTestExample {\n        type Error = Error;\n\n        fn underlying(\u0026self) -\u003e Address {\n            self.wrapper.underlying()\n        }\n\n        fn deposit_for(\n            \u0026mut self,\n            account: Address,\n            token_ids: Vec\u003cU256\u003e,\n        ) -\u003e Result\u003cbool, Error\u003e {\n            self.wrapper.deposit_for(account, token_ids, \u0026mut self.erc721)\n        }\n\n        fn withdraw_to(\n            \u0026mut self,\n            account: Address,\n            token_ids: Vec\u003cU256\u003e,\n        ) -\u003e Result\u003cbool, Error\u003e {\n            self.wrapper.withdraw_to(account, token_ids, \u0026mut self.erc721)\n        }\n\n        fn on_erc721_received(\n            \u0026mut self,\n            operator: Address,\n            from: Address,\n            token_id: U256,\n            data: Bytes,\n        ) -\u003e Result\u003cFixedBytes\u003c4\u003e, Error\u003e {\n            self.wrapper.on_erc721_received(\n                operator,\n                from,\n                token_id,\n                \u0026data,\n                \u0026mut self.erc721,\n            )\n        }\n    }\n\n    #[public]\n    impl IErc165 for Erc721WrapperTestExample {\n        fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n            self.erc721.supports_interface(interface_id)\n        }\n    }\n\n    unsafe impl TopLevelStorage for Erc721WrapperTestExample {}\n\n    #[motsu::test]\n    fn underlying_works(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let erc721_address = erc721_contract.address();\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_address);\n        });\n\n        assert_eq!(contract.sender(alice).underlying(), erc721_address);\n    }\n\n    // TODO: motsu should revert on calling a function that doesn't exist at\n    // specified address.\n    #[motsu::test]\n    #[ignore]\n    fn deposit_for_reverts_when_unsupported_token(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        alice: Address,\n    ) {\n        let token_ids = random_token_ids(1);\n\n        let invalid_token = alice;\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(invalid_token);\n        });\n\n        let err = contract\n            .sender(alice)\n            .deposit_for(alice, token_ids.clone())\n            .motsu_expect_err(\"should return Error::UnsupportedToken\");\n\n        assert!(matches!(\n            err,\n            Error::UnsupportedToken(ERC721UnsupportedToken { token }\n            ) if token == invalid_token\n        ));\n    }\n\n    #[motsu::test]\n    fn deposit_for_reverts_when_nonexistent_token(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let token_ids = random_token_ids(1);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        let err = contract\n            .sender(alice)\n            .deposit_for(alice, token_ids.clone())\n            .motsu_expect_err(\"should return Error::InvalidReceiverWithReason\");\n\n        let expected_error: Vec\u003cu8\u003e =\n            erc721::Error::NonexistentToken(erc721::ERC721NonexistentToken {\n                token_id: token_ids[0],\n            })\n            .into();\n        let expected_error = String::from_utf8_lossy(\u0026expected_error);\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiverWithReason(erc721::InvalidReceiverWithReason { reason })\n                if reason == expected_error\n        ));\n    }\n\n    #[motsu::test]\n    fn deposit_for_reverts_when_missing_approval(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let token_ids = random_token_ids(1);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        erc721_contract\n            .sender(alice)\n            ._mint(alice, token_ids[0])\n            .motsu_expect(\"should mint {token_id} for {alice}\");\n\n        let err = contract\n            .sender(alice)\n            .deposit_for(alice, token_ids.clone())\n            .motsu_expect_err(\"should return Error::InvalidReceiverWithReason\");\n\n        let expected_error: Vec\u003cu8\u003e = erc721::Error::InsufficientApproval(\n            erc721::ERC721InsufficientApproval {\n                operator: contract.address(),\n                token_id: token_ids[0],\n            },\n        )\n        .into();\n        let expected_error = String::from_utf8_lossy(\u0026expected_error);\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiverWithReason(erc721::InvalidReceiverWithReason { reason })\n                if reason == expected_error\n        ));\n    }\n\n    #[motsu::test]\n    fn deposit_for_reverts_when_wrapped_token_already_exists(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let token_ids = random_token_ids(1);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        erc721_contract\n            .sender(alice)\n            ._mint(alice, token_ids[0])\n            .motsu_expect(\"should mint {token_id} for {alice}\");\n\n        erc721_contract\n            .sender(alice)\n            .approve(contract.address(), token_ids[0])\n            .motsu_expect(\"should approve {token_id} for {contract.address()}\");\n\n        // Mint an \"unexpected\" wrapped token.\n        contract\n            .sender(alice)\n            .erc721\n            ._mint(alice, token_ids[0])\n            .motsu_expect(\"should mint {token_id} for {alice}\");\n\n        let err = contract\n            .sender(alice)\n            .deposit_for(alice, token_ids.clone())\n            .motsu_expect_err(\"should return Error::Erc721\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(\n                erc721::ERC721InvalidSender { sender }\n            ) if sender.is_zero()\n        ));\n    }\n\n    #[motsu::test]\n    fn deposit_for_works(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let tokens = 4;\n        let token_ids = random_token_ids(tokens);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        for \u0026token_id in \u0026token_ids {\n            erc721_contract\n                .sender(alice)\n                ._mint(alice, token_id)\n                .motsu_expect(\"should mint {token_id} for {alice}\");\n\n            erc721_contract\n                .sender(alice)\n                .approve(contract.address(), token_id)\n                .motsu_expect(\n                    \"should approve {token_id} for {contract.address()}\",\n                );\n        }\n\n        let initial_balance =\n            erc721_contract.sender(alice).balance_of(alice).motsu_unwrap();\n        let initial_wrapped_balance =\n            contract.sender(alice).erc721.balance_of(alice).motsu_unwrap();\n\n        let initial_contract_balance = erc721_contract\n            .sender(alice)\n            .balance_of(contract.address())\n            .motsu_unwrap();\n\n        assert!(contract\n            .sender(alice)\n            .deposit_for(alice, token_ids.clone())\n            .motsu_expect(\"should deposit\"));\n\n        for token_id in token_ids {\n            erc721_contract.assert_emitted(\u0026erc721::Transfer {\n                from: alice,\n                to: contract.address(),\n                token_id,\n            });\n\n            contract.assert_emitted(\u0026erc721::Transfer {\n                from: Address::ZERO,\n                to: alice,\n                token_id,\n            });\n        }\n\n        assert_eq!(\n            erc721_contract.sender(alice).balance_of(alice).motsu_unwrap(),\n            initial_balance - U256::from(tokens)\n        );\n\n        assert_eq!(\n            contract.sender(alice).erc721.balance_of(alice).motsu_unwrap(),\n            initial_wrapped_balance + U256::from(tokens)\n        );\n\n        assert_eq!(\n            erc721_contract\n                .sender(contract.address())\n                .balance_of(contract.address())\n                .motsu_unwrap(),\n            initial_contract_balance + U256::from(tokens)\n        );\n    }\n\n    #[motsu::test]\n    fn withdraw_to_reverts_when_invalid_receiver(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let tokens = 4;\n        let token_ids = random_token_ids(tokens);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        for token_id in \u0026token_ids {\n            erc721_contract\n                .sender(alice)\n                ._mint(alice, *token_id)\n                .motsu_expect(\"should mint {token_id} for {alice}\");\n\n            erc721_contract\n                .sender(alice)\n                .approve(contract.address(), *token_id)\n                .motsu_expect(\n                    \"should approve {token_id} for {contract.address()}\",\n                );\n        }\n\n        assert!(contract\n            .sender(alice)\n            .deposit_for(alice, token_ids.clone())\n            .motsu_expect(\"should deposit\"));\n\n        let err = contract\n            .sender(alice)\n            .withdraw_to(Address::ZERO, token_ids.clone())\n            .motsu_expect_err(\"should return Error::InvalidReceiverWithReason\");\n\n        let expected_error: Vec\u003cu8\u003e =\n            erc721::Error::InvalidReceiver(erc721::ERC721InvalidReceiver {\n                receiver: Address::ZERO,\n            })\n            .into();\n        let expected_error = String::from_utf8_lossy(\u0026expected_error);\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiverWithReason(\n                erc721::InvalidReceiverWithReason { reason }\n            ) if reason == expected_error\n        ));\n    }\n\n    #[motsu::test]\n    fn withdraw_to_reverts_when_nonexistent_token(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let tokens = 1;\n        let token_ids = random_token_ids(tokens);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        let err = contract\n            .sender(alice)\n            .withdraw_to(alice, token_ids.clone())\n            .motsu_expect_err(\"should return Error::Erc721\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(\n                erc721::ERC721NonexistentToken { token_id },\n            ) if token_id == token_ids[0]\n        ));\n    }\n\n    #[motsu::test]\n    fn withdraw_to_reverts_when_insufficient_approval(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let tokens = 1;\n        let token_ids = random_token_ids(tokens);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        erc721_contract\n            .sender(alice)\n            ._mint(alice, token_ids[0])\n            .motsu_expect(\"should mint {token_id} for {alice}\");\n\n        erc721_contract\n            .sender(alice)\n            .approve(contract.address(), token_ids[0])\n            .motsu_expect(\"should approve {token_id} for {contract.address()}\");\n\n        assert!(contract\n            .sender(alice)\n            .deposit_for(alice, token_ids.clone())\n            .motsu_expect(\"should deposit\"));\n\n        let err = contract\n            .sender(bob)\n            .withdraw_to(alice, token_ids.clone())\n            .motsu_expect_err(\"should return Error::Erc721\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientApproval(\n                erc721::ERC721InsufficientApproval { token_id, operator},\n            ) if token_id == token_ids[0] \u0026\u0026 operator == bob\n        ));\n    }\n\n    #[motsu::test]\n    fn withdraw_to_works(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let tokens = 4;\n        let token_ids = random_token_ids(tokens);\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        for token_id in \u0026token_ids {\n            erc721_contract\n                .sender(alice)\n                ._mint(alice, *token_id)\n                .motsu_expect(\"should mint {token_id} for {alice}\");\n\n            erc721_contract\n                .sender(alice)\n                .approve(contract.address(), *token_id)\n                .motsu_expect(\n                    \"should approve {token_id} for {contract.address()}\",\n                );\n        }\n\n        assert!(contract\n            .sender(alice)\n            .deposit_for(alice, token_ids.clone())\n            .motsu_expect(\"should deposit\"));\n\n        let initial_balance =\n            erc721_contract.sender(alice).balance_of(alice).motsu_unwrap();\n        let initial_wrapped_balance =\n            contract.sender(alice).erc721.balance_of(alice).motsu_unwrap();\n\n        let initial_contract_balance = erc721_contract\n            .sender(alice)\n            .balance_of(contract.address())\n            .motsu_unwrap();\n\n        assert!(contract\n            .sender(alice)\n            .withdraw_to(alice, token_ids.clone())\n            .motsu_expect(\"should withdraw\"));\n\n        for token_id in token_ids {\n            erc721_contract.assert_emitted(\u0026erc721::Transfer {\n                from: contract.address(),\n                to: alice,\n                token_id,\n            });\n\n            contract.assert_emitted(\u0026erc721::Transfer {\n                from: alice,\n                to: Address::ZERO,\n                token_id,\n            });\n        }\n\n        assert_eq!(\n            erc721_contract.sender(alice).balance_of(alice).unwrap(),\n            initial_balance + U256::from(tokens)\n        );\n\n        assert_eq!(\n            contract.sender(alice).erc721.balance_of(alice).unwrap(),\n            initial_wrapped_balance - U256::from(tokens)\n        );\n\n        assert_eq!(\n            erc721_contract\n                .sender(contract.address())\n                .balance_of(contract.address())\n                .motsu_unwrap(),\n            initial_contract_balance - U256::from(tokens)\n        );\n    }\n\n    #[motsu::test]\n    fn on_erc721_received_reverts_when_sender_is_unsupported_token(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let token_id = random_token_ids(1)[0];\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        let invalid_operator = alice;\n\n        let err = contract\n            .sender(invalid_operator)\n            .on_erc721_received(\n                invalid_operator,\n                alice,\n                token_id,\n                vec![].into(),\n            )\n            .motsu_expect_err(\"should return Error::UnsupportedToken\");\n\n        assert!(matches!(\n            err,\n            Error::UnsupportedToken(ERC721UnsupportedToken { token })\n                if token == invalid_operator\n        ));\n    }\n\n    #[motsu::test]\n    fn on_erc721_received_reverts_when_wrapped_token_already_exists(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let token_id = random_token_ids(1)[0];\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        // Mint an \"unexpected\" wrapped token.\n        contract\n            .sender(alice)\n            .erc721\n            ._mint(alice, token_id)\n            .motsu_expect(\"should mint {token_id} for {alice}\");\n\n        let operator = alice;\n\n        let err = contract\n            .sender(erc721_contract.address())\n            .on_erc721_received(operator, alice, token_id, vec![].into())\n            .motsu_expect_err(\"should return Error::Erc721\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(\n                erc721::ERC721InvalidSender { sender }\n            ) if sender.is_zero()\n        ));\n    }\n\n    #[motsu::test]\n    fn on_erc721_received_works(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let token_id = random_token_ids(1)[0];\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        let initial_wrapped_balance =\n            contract.sender(alice).erc721.balance_of(alice).motsu_unwrap();\n\n        let operator = alice;\n        let interface_id = contract\n            .sender(erc721_contract.address())\n            .on_erc721_received(operator, alice, token_id, vec![].into())\n            .motsu_expect(\"should handle ERC721Received\");\n\n        assert_eq!(interface_id, RECEIVER_FN_SELECTOR);\n\n        contract.assert_emitted(\u0026erc721::Transfer {\n            from: Address::ZERO,\n            to: alice,\n            token_id,\n        });\n\n        assert_eq!(\n            contract.sender(alice).erc721.balance_of(alice).motsu_unwrap(),\n            initial_wrapped_balance + uint!(1_U256)\n        );\n    }\n\n    // TODO: motsu should revert on calling a function that doesn't exist at\n    // specified address.\n    #[motsu::test]\n    #[ignore]\n    fn recover_reverts_when_invalid_token(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        alice: Address,\n    ) {\n        let token_id = random_token_ids(1)[0];\n        let invalid_token_address = alice;\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(invalid_token_address);\n        });\n\n        let err = contract\n            .sender(alice)\n            .recover(alice, token_id)\n            .motsu_expect_err(\"should return Error::Erc721FailedOperation\");\n\n        assert!(matches!(\n            err,\n            Error::Erc721FailedOperation(Erc721FailedOperation { token })\n                if token == invalid_token_address\n        ));\n    }\n\n    #[motsu::test]\n    fn recover_reverts_when_incorrect_owner(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let token_id = random_token_ids(1)[0];\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        erc721_contract\n            .sender(alice)\n            ._mint(alice, token_id)\n            .motsu_expect(\"should mint {token_id} for {alice}\");\n\n        let err = contract\n            .sender(alice)\n            .recover(alice, token_id)\n            .motsu_expect_err(\"should return Error::Erc721\");\n\n        assert!(matches!(\n            err,\n            Error::IncorrectOwner(\n                erc721::ERC721IncorrectOwner { sender, token_id: t_id, owner },\n            ) if sender == contract.address() \u0026\u0026 t_id == token_id \u0026\u0026 owner == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn recover_reverts_when_wrapped_token_already_exists(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let token_id = random_token_ids(1)[0];\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        erc721_contract\n            .sender(alice)\n            ._mint(alice, token_id)\n            .motsu_expect(\"should mint {token_id} for {alice}\");\n\n        erc721_contract\n            .sender(alice)\n            .transfer_from(\n                alice,\n                contract.address(),\n                token_id,\n            )\n            .motsu_expect(\"should transfer {token_id} from {alice} to {contract.address()}\");\n\n        // Mint an \"unexpected\" wrapped token.\n        contract\n            .sender(alice)\n            .erc721\n            ._mint(alice, token_id)\n            .motsu_expect(\"should mint {token_id} for {alice}\");\n\n        let err = contract\n            .sender(alice)\n            .recover(alice, token_id)\n            .motsu_expect_err(\"should return Error::Erc721\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(\n                erc721::ERC721InvalidSender { sender }\n            ) if sender.is_zero()\n        ));\n    }\n\n    #[motsu::test]\n    fn recover_works(\n        contract: Contract\u003cErc721WrapperTestExample\u003e,\n        erc721_contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let token_id = random_token_ids(1)[0];\n\n        contract.init(alice, |contract| {\n            contract.wrapper.underlying.set(erc721_contract.address());\n        });\n\n        erc721_contract\n            .sender(alice)\n            ._mint(alice, token_id)\n            .motsu_expect(\"should mint {token_id} for {alice}\");\n\n        erc721_contract\n            .sender(alice)\n            .transfer_from(\n                alice,\n                contract.address(),\n                token_id,\n            )\n            .motsu_expect(\"should transfer {token_id} from {alice} to {contract.address()}\");\n\n        let initial_wrapped_balance =\n            contract.sender(alice).erc721.balance_of(alice).motsu_unwrap();\n\n        contract\n            .sender(alice)\n            .recover(alice, token_id)\n            .motsu_expect(\"should recover {token_id} for {alice}\");\n\n        let wrapped_balance =\n            contract.sender(alice).erc721.balance_of(alice).motsu_unwrap();\n\n        assert_eq!(wrapped_balance, initial_wrapped_balance + uint!(1_U256));\n\n        contract.assert_emitted(\u0026erc721::Transfer {\n            from: Address::ZERO,\n            to: alice,\n            token_id,\n        });\n\n        assert_eq!(\n            contract.sender(alice).erc721.balance_of(alice).motsu_unwrap(),\n            initial_wrapped_balance + uint!(1_U256)\n        );\n    }\n}\n","traces":[{"line":83,"address":[],"length":0,"stats":{"Line":6}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":7}},{"line":235,"address":[],"length":0,"stats":{"Line":14}},{"line":236,"address":[],"length":0,"stats":{"Line":14}},{"line":237,"address":[],"length":0,"stats":{"Line":28}},{"line":239,"address":[],"length":0,"stats":{"Line":36}},{"line":244,"address":[],"length":0,"stats":{"Line":48}},{"line":245,"address":[],"length":0,"stats":{"Line":48}},{"line":246,"address":[],"length":0,"stats":{"Line":32}},{"line":247,"address":[],"length":0,"stats":{"Line":16}},{"line":248,"address":[],"length":0,"stats":{"Line":16}},{"line":250,"address":[],"length":0,"stats":{"Line":14}},{"line":251,"address":[],"length":0,"stats":{"Line":2}},{"line":252,"address":[],"length":0,"stats":{"Line":4}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":4}},{"line":282,"address":[],"length":0,"stats":{"Line":8}},{"line":283,"address":[],"length":0,"stats":{"Line":16}},{"line":285,"address":[],"length":0,"stats":{"Line":15}},{"line":290,"address":[],"length":0,"stats":{"Line":30}},{"line":291,"address":[],"length":0,"stats":{"Line":5}},{"line":298,"address":[],"length":0,"stats":{"Line":4}},{"line":299,"address":[],"length":0,"stats":{"Line":1}},{"line":300,"address":[],"length":0,"stats":{"Line":1}},{"line":302,"address":[],"length":0,"stats":{"Line":1}},{"line":303,"address":[],"length":0,"stats":{"Line":1}},{"line":304,"address":[],"length":0,"stats":{"Line":1}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":1}},{"line":322,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":6}},{"line":331,"address":[],"length":0,"stats":{"Line":3}},{"line":332,"address":[],"length":0,"stats":{"Line":1}},{"line":333,"address":[],"length":0,"stats":{"Line":1}},{"line":337,"address":[],"length":0,"stats":{"Line":1}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":344,"address":[],"length":0,"stats":{"Line":18}},{"line":345,"address":[],"length":0,"stats":{"Line":36}},{"line":369,"address":[],"length":0,"stats":{"Line":3}},{"line":375,"address":[],"length":0,"stats":{"Line":12}},{"line":377,"address":[],"length":0,"stats":{"Line":21}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":1}},{"line":388,"address":[],"length":0,"stats":{"Line":1}},{"line":389,"address":[],"length":0,"stats":{"Line":2}},{"line":390,"address":[],"length":0,"stats":{"Line":1}},{"line":391,"address":[],"length":0,"stats":{"Line":1}},{"line":394,"address":[],"length":0,"stats":{"Line":1}},{"line":397,"address":[],"length":0,"stats":{"Line":1}},{"line":399,"address":[],"length":0,"stats":{"Line":1}}],"covered":60,"coverable":79},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc721","interface.rs"],"content":"//! Solidity Interface of the ERC-721 token.\npub use token::*;\n\nmod token {\n    #![allow(missing_docs)]\n    #![cfg_attr(coverage_nightly, coverage(off))]\n    use alloc::vec;\n\n    stylus_sdk::prelude::sol_interface! {\n        interface Erc721Interface {\n            function balanceOf(address owner) external view returns (uint256 balance);\n            function ownerOf(uint256 token_id) external view returns (address owner);\n            function safeTransferFrom(address from, address to, uint256 token_id, bytes calldata data) external;\n            function transferFrom(address from, address to, uint256 token_id) external;\n            function approve(address to, uint256 token_id) external;\n            function setApprovalForAll(address operator, bool approved) external;\n            function getApproved(uint256 token_id) external view returns (address operator);\n            function isApprovedForAll(address owner, address operator) external view returns (bool);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc721","mod.rs"],"content":"//! Implementation of the [`Erc721`] token standard.\nuse alloc::{\n    string::{String, ToString},\n    vec,\n    vec::Vec,\n};\n\nuse alloy_primitives::{uint, Address, FixedBytes, U128, U256};\nuse openzeppelin_stylus_proc::interface_id;\nuse stylus_sdk::{\n    abi::Bytes,\n    call::{self, Call, MethodError},\n    evm, function_selector, msg,\n    prelude::*,\n    storage::{StorageAddress, StorageBool, StorageMap, StorageU256},\n};\n\nuse crate::utils::{\n    introspection::erc165::IErc165,\n    math::storage::{AddAssignUnchecked, SubAssignUnchecked},\n};\n\npub mod extensions;\npub mod interface;\nmod receiver;\npub use receiver::IERC721Receiver;\n\n/// The expected value returned from [`IERC721Receiver::on_erc_721_received`].\npub const RECEIVER_FN_SELECTOR: [u8; 4] =\n    function_selector!(\"onERC721Received\", Address, Address, U256, Bytes,);\n\npub use sol::*;\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when the `token_id` token is transferred from `from` to `to`.\n        ///\n        /// * `from` - Address from which the token will be transferred.\n        /// * `to` - Address where the token will be transferred to.\n        /// * `token_id` - Token id as a number.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event Transfer(\n            address indexed from,\n            address indexed to,\n            uint256 indexed token_id\n        );\n\n        /// Emitted when `owner` enables `approved` to manage the `token_id` token.\n        ///\n        /// * `owner` - Address of the owner of the token.\n        /// * `approved` - Address of the approver.\n        /// * `token_id` - Token id as a number.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event Approval(\n            address indexed owner,\n            address indexed approved,\n            uint256 indexed token_id\n        );\n\n        /// Emitted when `owner` enables or disables (`approved`) `operator`\n        /// to manage all of its assets.\n        ///\n        /// * `owner` - Address of the owner of the token.\n        /// * `operator` - Address of an operator that\n        ///   will manage operations on the token.\n        /// * `approved` - Whether or not permission has been granted. If true,\n        ///   this means `operator` will be allowed to manage `owner`'s assets.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    }\n\n    sol! {\n        /// Indicates that an address can't be an owner.\n        /// For example, [`Address::ZERO`] is a forbidden owner in [`Erc721`].\n        /// Used in balance queries.\n        ///\n        /// * `owner` - The address deemed to be an invalid owner.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721InvalidOwner(address owner);\n\n        /// Indicates a `token_id` whose `owner` is the zero address.\n        ///\n        /// * `token_id` - Token id as a number.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721NonexistentToken(uint256 token_id);\n\n        /// Indicates an error related to the ownership over a particular token.\n        /// Used in transfers.\n        ///\n        /// * `sender` - Address whose tokens are being transferred.\n        /// * `token_id` - Token id as a number.\n        /// * `owner` - Address of the owner of the token.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721IncorrectOwner(address sender, uint256 token_id, address owner);\n\n        /// Indicates a failure with the token `sender`. Used in transfers.\n        ///\n        /// * `sender` - An address whose token is being transferred.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721InvalidSender(address sender);\n\n        /// Indicates a failure with the token `receiver`. Used in transfers.\n        ///\n        /// * `receiver` - Address that receives the token.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721InvalidReceiver(address receiver);\n\n        /// Indicates a failure with the `operator`’s approval. Used in transfers.\n        ///\n        /// * `operator` - Address that may be allowed to operate on tokens\n        ///   without being their owner.\n        /// * `token_id` - Token id as a number.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721InsufficientApproval(address operator, uint256 token_id);\n\n        /// Indicates a failure with the `approver` of a token to be approved.\n        /// Used in approvals.\n        ///\n        /// * `approver` - Address initiating an approval operation.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721InvalidApprover(address approver);\n\n        /// Indicates a failure with the `operator` to be approved.\n        /// Used in approvals.\n        ///\n        /// * `operator` - Address that may be allowed to operate on tokens\n        ///   without being their owner.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ERC721InvalidOperator(address operator);\n\n        /// Indicates a failure with the receiver reverting with a reason.\n        ///\n        /// * `reason` - Revert reason.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error InvalidReceiverWithReason(string reason);\n    }\n}\n\n/// An [`Erc721`] error defined as described in [ERC-6093].\n///\n/// [ERC-6093]: https://eips.ethereum.org/EIPS/eip-6093\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates that an address can't be an owner.\n    /// For example, [`Address::ZERO`] is a forbidden owner in [`Erc721`].\n    /// Used in balance queries.\n    InvalidOwner(ERC721InvalidOwner),\n    /// Indicates a `token_id` whose `owner` is the zero address.\n    NonexistentToken(ERC721NonexistentToken),\n    /// Indicates an error related to the ownership over a particular token.\n    /// Used in transfers.\n    IncorrectOwner(ERC721IncorrectOwner),\n    /// Indicates a failure with the token `sender`. Used in transfers.\n    InvalidSender(ERC721InvalidSender),\n    /// Indicates a failure with the token `receiver`. Used in transfers.\n    InvalidReceiver(ERC721InvalidReceiver),\n    /// Indicates a failure with the token `receiver`, with the reason\n    /// specified by it.\n    InvalidReceiverWithReason(InvalidReceiverWithReason),\n    /// Indicates a failure with the `operator`’s approval. Used in transfers.\n    InsufficientApproval(ERC721InsufficientApproval),\n    /// Indicates a failure with the `approver` of a token to be approved. Used\n    /// in approvals.\n    InvalidApprover(ERC721InvalidApprover),\n    /// Indicates a failure with the `operator` to be approved. Used in\n    /// approvals.\n    InvalidOperator(ERC721InvalidOperator),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of an [`Erc721`] token.\n#[storage]\npub struct Erc721 {\n    /// Maps tokens to owners.\n    pub(crate) owners: StorageMap\u003cU256, StorageAddress\u003e,\n    /// Maps users to balances.\n    pub(crate) balances: StorageMap\u003cAddress, StorageU256\u003e,\n    /// Maps tokens to approvals.\n    pub(crate) token_approvals: StorageMap\u003cU256, StorageAddress\u003e,\n    /// Maps owners to a mapping of operator approvals.\n    pub(crate) operator_approvals:\n        StorageMap\u003cAddress, StorageMap\u003cAddress, StorageBool\u003e\u003e,\n}\n\n/// NOTE: Implementation of [`TopLevelStorage`] to be able use `\u0026mut self` when\n/// calling other contracts and not `\u0026mut (impl TopLevelStorage +\n/// BorrowMut\u003cSelf\u003e)`. Should be fixed in the future by the Stylus team.\nunsafe impl TopLevelStorage for Erc721 {}\n\n/// Required interface of an [`Erc721`] compliant contract.\n#[interface_id]\npub trait IErc721: IErc165 {\n    /// The error type associated to this ERC-721 trait implementation.\n    type Error: Into\u003calloc::vec::Vec\u003cu8\u003e\u003e;\n\n    /// Returns the number of tokens in `owner`'s account.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `owner` - Account of the token's owner.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidOwner`] - If owner address is [`Address::ZERO`].\n    fn balance_of(\u0026self, owner: Address) -\u003e Result\u003cU256, Self::Error\u003e;\n\n    /// Returns the owner of the `token_id` token.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::NonexistentToken`] - If the token does not exist.\n    fn owner_of(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e;\n\n    /// Safely transfers `token_id` token from `from` to `to`, checking first\n    /// that contract recipients are aware of the [`Erc721`] protocol to\n    /// prevent tokens from being forever locked.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account of the sender.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::IncorrectOwner`]  - If the previous owner is not `from`.\n    /// * [`Error::InsufficientApproval`] - If the caller does not have the\n    ///   right to approve.\n    /// * [`Error::NonexistentToken`] - If the token does not exist.\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`IERC721Receiver::on_erc_721_received`] hasn't returned its\n    /// interface id or returned with error, `to` is [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Safely transfers `token_id` token from `from` to `to`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account of the sender.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    /// * `data` - Additional data with no specified format, sent in the call to\n    ///   [`Erc721::_check_on_erc721_received`].\n    ///\n    /// # Errors\n    ///\n    ///  * [`Error::IncorrectOwner`] - If the previous owner is not `from`.\n    ///  * [`Error::InsufficientApproval`] - If the caller does not have the\n    ///    right to approve.\n    ///  * [`Error::NonexistentToken`] - If the token does not exist.\n    ///  * [`Error::InvalidReceiver`] - If\n    ///    [`IERC721Receiver::on_erc_721_received`] hasn't returned its\n    ///    interface id or returned with error, or `to` is [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    #[selector(name = \"safeTransferFrom\")]\n    fn safe_transfer_from_with_data(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Transfers `token_id` token from `from` to `to`.\n    ///\n    /// WARNING: Note that the caller is responsible to confirm that the\n    /// recipient is capable of receiving [`Erc721`] or else they may be\n    /// permanently lost. Usage of [`Self::safe_transfer_from`] prevents loss,\n    /// though the caller must understand this adds an external call which\n    /// potentially creates a reentrancy vulnerability, unless it is disabled.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account of the sender.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`Error::IncorrectOwner`] - If the previous owner is not `from`.\n    /// * [`Error::InsufficientApproval`] - If the caller does not have the\n    ///   right to approve.\n    /// * [`Error::NonexistentToken`] - If the token does not exist.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Gives permission to `to` to transfer `token_id` token to another\n    /// account. The approval is cleared when the token is transferred.\n    ///\n    /// Only a single account can be approved at a time,\n    /// so approving the [`Address::ZERO`] clears previous approvals.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::NonexistentToken`] - If the token does not exist.\n    /// * [`Error::InvalidApprover`] - If `auth` (param of [`Erc721::_approve`])\n    ///   does not have a right to approve this token.\n    ///\n    /// # Events\n    ///\n    /// * [`Approval`].\n    fn approve(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Approve or remove `operator` as an operator for the caller.\n    ///\n    /// Operators can call [`Self::transfer_from`] or\n    /// [`Self::safe_transfer_from`] for any token owned by the caller.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `operator` - Account to add to the set of authorized operators.\n    /// * `approved` - Flag that determines whether or not permission will be\n    ///   granted to `operator`. If true, this means `operator` will be allowed\n    ///   to manage `msg::sender`'s assets.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidOperator`] - If `operator` is [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`ApprovalForAll`].\n    fn set_approval_for_all(\n        \u0026mut self,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Returns the account approved for `token_id` token.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::NonexistentToken`] - If the token does not exist.\n    fn get_approved(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e;\n\n    /// Returns whether the `operator` is allowed to manage all the assets of\n    /// `owner`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `owner` - Account of the token's owner.\n    /// * `operator` - Account to be checked.\n    fn is_approved_for_all(\u0026self, owner: Address, operator: Address) -\u003e bool;\n}\n\n#[public]\n#[implements(IErc721\u003cError = Error\u003e, IErc165)]\nimpl Erc721 {}\n\n#[public]\nimpl IErc721 for Erc721 {\n    type Error = Error;\n\n    fn balance_of(\u0026self, owner: Address) -\u003e Result\u003cU256, Self::Error\u003e {\n        if owner.is_zero() {\n            return Err(ERC721InvalidOwner { owner: Address::ZERO }.into());\n        }\n        Ok(self.balances.get(owner))\n    }\n\n    fn owner_of(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        self._require_owned(token_id)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.safe_transfer_from_with_data(from, to, token_id, vec![].into())\n    }\n\n    #[selector(name = \"safeTransferFrom\")]\n    fn safe_transfer_from_with_data(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.transfer_from(from, to, token_id)?;\n        self._check_on_erc721_received(msg::sender(), from, to, token_id, \u0026data)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        if to.is_zero() {\n            return Err(\n                ERC721InvalidReceiver { receiver: Address::ZERO }.into()\n            );\n        }\n\n        // Setting an \"auth\" argument enables the `_is_authorized` check which\n        // verifies that the token exists (`from != 0`). Therefore, it is\n        // not needed to verify that the return value is not 0 here.\n        let previous_owner = self._update(to, token_id, msg::sender())?;\n        if previous_owner != from {\n            return Err(ERC721IncorrectOwner {\n                sender: from,\n                token_id,\n                owner: previous_owner,\n            }\n            .into());\n        }\n        Ok(())\n    }\n\n    fn approve(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self._approve(to, token_id, msg::sender(), true)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self._set_approval_for_all(msg::sender(), operator, approved)\n    }\n\n    fn get_approved(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        self._require_owned(token_id)?;\n        Ok(self._get_approved(token_id))\n    }\n\n    fn is_approved_for_all(\u0026self, owner: Address, operator: Address) -\u003e bool {\n        self.operator_approvals.get(owner).get(operator)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc721 {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IErc721\u003e::interface_id() == interface_id\n            || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n    }\n}\n\nimpl Erc721 {\n    /// Returns the owner of the `token_id`. Does NOT revert if the token\n    /// doesn't exist.\n    ///\n    /// IMPORTANT: Any overrides to this function that add ownership of tokens\n    /// not tracked by the core [`Erc721`] logic MUST be matched with the use\n    /// of [`Self::_increase_balance`] to keep balances consistent with\n    /// ownership. The invariant to preserve is that for any address `a` the\n    /// value returned by [`Self::balance_of(a)`] must be equal to the number of\n    /// tokens such that [`Self::_owner_of(token_id)`] is `a`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token_id` - Token id as a number.\n    #[must_use]\n    pub fn _owner_of(\u0026self, token_id: U256) -\u003e Address {\n        self.owners.get(token_id)\n    }\n\n    /// Returns the approved address for `token_id`.\n    /// Returns 0 if `token_id` is not minted.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token_id` - Token id as a number.\n    #[must_use]\n    pub fn _get_approved(\u0026self, token_id: U256) -\u003e Address {\n        self.token_approvals.get(token_id)\n    }\n\n    /// Returns whether `spender` is allowed to manage `owner`'s tokens, or\n    /// `token_id` in particular (ignoring whether it is owned by `owner`).\n    ///\n    /// WARNING: This function assumes that `owner` is the actual owner of\n    /// `token_id` and does not verify this assumption.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `owner` - Account of the token's owner.\n    /// * `spender` - Account that will spend token.\n    /// * `token_id` - Token id as a number.\n    #[must_use]\n    pub fn _is_authorized(\n        \u0026self,\n        owner: Address,\n        spender: Address,\n        token_id: U256,\n    ) -\u003e bool {\n        !spender.is_zero()\n            \u0026\u0026 (owner == spender\n                || self.is_approved_for_all(owner, spender)\n                || self._get_approved(token_id) == spender)\n    }\n\n    /// Checks if `operator` can operate on `token_id`, assuming the provided\n    /// `owner` is the actual owner. Reverts if:\n    /// - `operator` does not have approval from `owner` for `token_id`.\n    /// - `operator` does not have approval to manage all of `owner`'s assets.\n    ///\n    /// WARNING: This function assumes that `owner` is the actual owner of\n    /// `token_id` and does not verify this assumption.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `owner` - Account of the token's owner.\n    /// * `operator` - Account that will spend token.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::NonexistentToken`] - If the token does not exist.\n    /// * [`Error::InsufficientApproval`] - If `spender` does not have the right\n    ///   to approve.\n    pub fn _check_authorized(\n        \u0026self,\n        owner: Address,\n        operator: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if self._is_authorized(owner, operator, token_id) {\n            return Ok(());\n        }\n\n        if owner.is_zero() {\n            Err(ERC721NonexistentToken { token_id }.into())\n        } else {\n            Err(ERC721InsufficientApproval { operator, token_id }.into())\n        }\n    }\n\n    /// Unsafe write access to the balances, used by extensions that \"mint\"\n    /// tokens using an [`Self::owner_of`] override.\n    ///\n    /// NOTE: the value is limited to type(uint128).max. This protects against\n    /// _balance overflow. It is unrealistic that a `U256` would ever\n    /// overflow from increments when these increments are bounded to `u128`\n    /// values.\n    ///\n    /// WARNING: Increasing an account's balance using this function tends to\n    /// be paired with an override of the [`Self::_owner_of`] function to\n    /// resolve the ownership of the corresponding tokens so that balances and\n    /// ownership remain consistent with one another.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `account` - Account to increase balance.\n    /// * `value` - The number of tokens to increase balance.\n    pub fn _increase_balance(\u0026mut self, account: Address, value: U128) {\n        self.balances.setter(account).add_assign_unchecked(U256::from(value));\n    }\n\n    /// Transfers `token_id` from its current owner to `to`, or alternatively\n    /// mints (or burns) if the current owner (or `to`) is the\n    /// [`Address::ZERO`]. Returns the owner of the `token_id` before the\n    /// update.\n    ///\n    /// The `auth` argument is optional. If the value passed is non-zero, then\n    /// this function will check that `auth` is either the owner of the\n    /// token, or approved to operate on the token (by the owner).\n    ///\n    /// NOTE: If overriding this function in a way that tracks balances, see\n    /// also [`Self::_increase_balance`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    /// * `auth` - Account used for authorization of the update.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::NonexistentToken`] - If the token does not exist and `auth`\n    ///   is not [`Address::ZERO`].\n    /// * [`Error::InsufficientApproval`] - If `auth` is not [`Address::ZERO`]\n    ///   and `auth` does not have a right to approve this token.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _update(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n        auth: Address,\n    ) -\u003e Result\u003cAddress, Error\u003e {\n        let from = self._owner_of(token_id);\n\n        // Perform (optional) operator check.\n        if !auth.is_zero() {\n            self._check_authorized(from, auth, token_id)?;\n        }\n\n        // Execute the update.\n        if !from.is_zero() {\n            // Clear approval. No need to re-authorize or emit the `Approval`\n            // event.\n            self._approve(Address::ZERO, token_id, Address::ZERO, false)?;\n            self.balances.setter(from).sub_assign_unchecked(uint!(1_U256));\n        }\n\n        if !to.is_zero() {\n            self.balances.setter(to).add_assign_unchecked(uint!(1_U256));\n        }\n\n        self.owners.setter(token_id).set(to);\n        evm::log(Transfer { from, to, token_id });\n        Ok(from)\n    }\n\n    /// Mints `token_id` and transfers it to `to`.\n    ///\n    /// WARNING: Usage of this method is discouraged, use [`Self::_safe_mint`]\n    /// whenever possible.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSender`] - If `token_id` already exists.\n    /// * [`Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _mint(\u0026mut self, to: Address, token_id: U256) -\u003e Result\u003c(), Error\u003e {\n        if to.is_zero() {\n            return Err(\n                ERC721InvalidReceiver { receiver: Address::ZERO }.into()\n            );\n        }\n\n        let previous_owner = self._update(to, token_id, Address::ZERO)?;\n        if !previous_owner.is_zero() {\n            return Err(ERC721InvalidSender { sender: Address::ZERO }.into());\n        }\n        Ok(())\n    }\n\n    /// Mints `token_id`, transfers it to `to`,\n    /// and checks for `to`'s acceptance.\n    ///\n    /// An additional `data` parameter is forwarded to\n    /// [`IERC721Receiver::on_erc_721_received`] to contract recipients.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    /// * `data` - Additional data with no specified format, sent in the call to\n    ///   [`Erc721::_check_on_erc721_received`].\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidSender`] - If `token_id` already exists.\n    /// * [`Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`IERC721Receiver::on_erc_721_received`] hasn't returned its interface\n    ///   id or returned with an error.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _safe_mint(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self._mint(to, token_id)?;\n        self._check_on_erc721_received(\n            msg::sender(),\n            Address::ZERO,\n            to,\n            token_id,\n            data,\n        )\n    }\n\n    /// Destroys `token_id`.\n    ///\n    /// The approval is cleared when the token is burned. This is an\n    /// internal function that does not check if the sender is authorized\n    /// to operate on the token.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::NonexistentToken`] - If the token does not exist.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _burn(\u0026mut self, token_id: U256) -\u003e Result\u003c(), Error\u003e {\n        let previous_owner =\n            self._update(Address::ZERO, token_id, Address::ZERO)?;\n        if previous_owner.is_zero() {\n            return Err(ERC721NonexistentToken { token_id }.into());\n        }\n        Ok(())\n    }\n\n    /// Transfers `token_id` from `from` to `to`.\n    ///\n    /// As opposed to [`Self::transfer_from`], this imposes no restrictions on\n    /// `msg::sender`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account of the sender.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`Error::NonexistentToken`] - If `token_id` does not exist.\n    /// * [`Error::IncorrectOwner`] - If the previous owner is not `from`.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _transfer(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if to.is_zero() {\n            return Err(\n                ERC721InvalidReceiver { receiver: Address::ZERO }.into()\n            );\n        }\n\n        let previous_owner = self._update(to, token_id, Address::ZERO)?;\n        if previous_owner.is_zero() {\n            return Err(ERC721NonexistentToken { token_id }.into());\n        } else if previous_owner != from {\n            return Err(ERC721IncorrectOwner {\n                sender: from,\n                token_id,\n                owner: previous_owner,\n            }\n            .into());\n        }\n\n        Ok(())\n    }\n\n    /// Safely transfers `token_id` token from `from` to `to`, checking that\n    /// contract recipients are aware of the [`Erc721`] standard to prevent\n    /// tokens from being forever locked.\n    ///\n    /// `data` is additional data, it has\n    /// no specified format and it is sent in call to `to`. This internal\n    /// function is like [`Self::safe_transfer_from`] in the sense that it\n    /// invokes [`IERC721Receiver::on_erc_721_received`] on the receiver,\n    /// and can be used to e.g. implement alternative mechanisms to perform\n    /// token transfer, such as signature-based.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `from` - Account of the sender.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    /// * `data` - Additional data with no specified format, sent in the call to\n    ///   [`Erc721::_check_on_erc721_received`].\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If `to` is [`Address::ZERO`].\n    /// * [`Error::NonexistentToken`] - If `token_id` does not exist.\n    /// * [`Error::IncorrectOwner`] - If the previous owner is not `from`.\n    ///\n    /// # Events\n    ///\n    /// * [`Transfer`].\n    pub fn _safe_transfer(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self._transfer(from, to, token_id)?;\n        self._check_on_erc721_received(msg::sender(), from, to, token_id, data)\n    }\n\n    /// Approve `to` to operate on `token_id`.\n    ///\n    /// The `auth` argument is optional. If the value passed is non 0, then this\n    /// function will check that `auth` is either the owner of the token, or\n    /// approved to operate on all tokens held by this owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    /// * `auth` - Account used for authorization of the update.\n    /// * `emit_event` - Emit an [`Approval`] event flag.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::NonexistentToken`] - If the token does not exist.\n    /// * [`Error::InvalidApprover`] - If `auth` does not have a right to\n    ///   approve this token.\n    ///\n    /// # Events\n    ///\n    /// * [`Approval`].\n    pub fn _approve(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n        auth: Address,\n        emit_event: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        // Avoid reading the owner unless necessary.\n        if emit_event || !auth.is_zero() {\n            let owner = self._require_owned(token_id)?;\n\n            // We do not use [`Self::_is_authorized`] because single-token\n            // approvals should not be able to call `approve`.\n            if !auth.is_zero()\n                \u0026\u0026 owner != auth\n                \u0026\u0026 !self.is_approved_for_all(owner, auth)\n            {\n                return Err(ERC721InvalidApprover { approver: auth }.into());\n            }\n\n            if emit_event {\n                evm::log(Approval { owner, approved: to, token_id });\n            }\n        }\n\n        self.token_approvals.setter(token_id).set(to);\n        Ok(())\n    }\n\n    /// Approve `operator` to operate on all of `owner`'s tokens.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `owner` - Account the token's owner.\n    /// * `operator` - Account to add to the set of authorized operators.\n    /// * `approved` - Whether permission will be granted. If true, this means.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidOperator`] - If `operator` is [`Address::ZERO`].\n    ///\n    /// # Events\n    ///\n    /// * [`ApprovalForAll`].\n    pub fn _set_approval_for_all(\n        \u0026mut self,\n        owner: Address,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if operator.is_zero() {\n            return Err(ERC721InvalidOperator { operator }.into());\n        }\n\n        self.operator_approvals.setter(owner).setter(operator).set(approved);\n        evm::log(ApprovalForAll { owner, operator, approved });\n        Ok(())\n    }\n\n    /// Reverts if the `token_id` doesn't have a current owner (it hasn't been\n    /// minted, or it has been burned). Returns the owner.\n    ///\n    /// Overrides to ownership logic should be done to\n    /// [`Self::_owner_of`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `token_id` - Token id as a number.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::NonexistentToken`] - If token does not exist.\n    pub fn _require_owned(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Error\u003e {\n        let owner = self._owner_of(token_id);\n        if owner.is_zero() {\n            return Err(ERC721NonexistentToken { token_id }.into());\n        }\n        Ok(owner)\n    }\n\n    /// Performs an acceptance check for the provided `operator` by calling\n    /// [`IERC721Receiver::on_erc_721_received`] on the `to` address. The\n    /// `operator` is generally the address that initiated the token transfer\n    /// (i.e. `msg::sender()`).\n    ///\n    /// The acceptance call is not executed and treated as a no-op if the\n    /// target address doesn't contain code (i.e. an EOA). Otherwise, the\n    /// recipient must implement [`IERC721Receiver::on_erc_721_received`] and\n    /// return the acceptance magic value to accept the transfer.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `operator` - Account to add to the set of authorized operators.\n    /// * `from` - Account of the sender.\n    /// * `to` - Account of the recipient.\n    /// * `token_id` - Token id as a number.\n    /// * `data` - Additional data with no specified format, sent in call to\n    ///   `to`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidReceiver`] - If\n    ///   [`IERC721Receiver::on_erc_721_received`] hasn't returned its interface\n    ///   id or returned an error.\n    /// * [`Error::InvalidReceiverWithReason`] - If\n    ///   [`IERC721Receiver::on_erc_721_received`] reverted with revert data.\n    pub fn _check_on_erc721_received(\n        \u0026mut self,\n        operator: Address,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: \u0026Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !to.has_code() {\n            return Ok(());\n        }\n\n        let receiver = IERC721Receiver::new(to);\n        let call = Call::new_in(self);\n        let result = receiver.on_erc_721_received(\n            call,\n            operator,\n            from,\n            token_id,\n            data.to_vec().into(),\n        );\n\n        let id = match result {\n            Ok(id) =\u003e id,\n            Err(e) =\u003e {\n                if let call::Error::Revert(ref reason) = e {\n                    if !reason.is_empty() {\n                        return Err(Error::InvalidReceiverWithReason(\n                            InvalidReceiverWithReason {\n                                reason: String::from_utf8_lossy(reason)\n                                    .to_string(),\n                            },\n                        ));\n                    }\n                }\n\n                // Non-IERC721Receiver implementer.\n                return Err(ERC721InvalidReceiver { receiver: to }.into());\n            }\n        };\n\n        // Token rejected.\n        if id != RECEIVER_FN_SELECTOR {\n            return Err(ERC721InvalidReceiver { receiver: to }.into());\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{fixed_bytes, uint, Address, FixedBytes, U256};\n    use motsu::prelude::*;\n    use stylus_sdk::{abi::Bytes, prelude::*};\n\n    use super::{\n        ERC721IncorrectOwner, ERC721InsufficientApproval,\n        ERC721InvalidApprover, ERC721InvalidOperator, ERC721InvalidOwner,\n        ERC721InvalidReceiver, ERC721InvalidSender, ERC721NonexistentToken,\n        Erc721, Error, IErc721,\n    };\n    use crate::utils::introspection::erc165::IErc165;\n\n    const TOKEN_ID: U256 = uint!(1_U256);\n\n    #[motsu::test]\n    fn error_when_checking_balance_of_invalid_owner(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let invalid_owner = Address::ZERO;\n        let err = contract\n            .sender(alice)\n            .balance_of(invalid_owner)\n            .expect_err(\"should return `Error::InvalidOwner`\");\n        assert!(matches!(\n            err,\n            Error::InvalidOwner(ERC721InvalidOwner { owner: Address::ZERO })\n        ));\n    }\n\n    #[motsu::test]\n    fn balance_of_zero_balance(contract: Contract\u003cErc721\u003e, owner: Address) {\n        let balance = contract\n            .sender(owner)\n            .balance_of(owner)\n            .expect(\"should return `U256::ZERO`\");\n        assert_eq!(U256::ZERO, balance);\n    }\n\n    #[motsu::test]\n    fn error_when_checking_owner_of_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn mints(contract: Contract\u003cErc721\u003e, alice: Address) {\n        let initial_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token for Alice\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n\n        let balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        assert_eq!(initial_balance + uint!(1_U256), balance);\n    }\n\n    #[motsu::test]\n    fn error_when_minting_token_id_twice(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint the token a first time\");\n        let err = contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect_err(\"should not mint a token with `TOKEN_ID` twice\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC721InvalidSender { sender: Address::ZERO })\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_minting_token_invalid_receiver(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            ._mint(invalid_receiver, TOKEN_ID)\n            .expect_err(\"should not mint a token for invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn safe_mints(contract: Contract\u003cErc721\u003e, alice: Address) {\n        let initial_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        contract\n            .sender(alice)\n            ._safe_mint(alice, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect(\"should mint a token for Alice\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n\n        let balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        assert_eq!(initial_balance + uint!(1_U256), balance);\n    }\n\n    #[motsu::test]\n    fn error_when_safe_mint_token_id_twice(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint the token a first time\");\n\n        let err = contract\n            .sender(alice)\n            ._safe_mint(alice, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect_err(\"should not mint a token with `TOKEN_ID` twice\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidSender(ERC721InvalidSender { sender: Address::ZERO })\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_safe_mint_invalid_receiver(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            ._safe_mint(invalid_receiver, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect_err(\"should not mint a token for invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n    }\n\n    #[motsu::test]\n    fn transfers_from(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n        contract\n            .sender(alice)\n            .transfer_from(alice, bob, TOKEN_ID)\n            .expect(\"should transfer a token from Alice to Bob\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, bob);\n    }\n\n    #[motsu::test]\n    fn transfers_from_approved_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n        contract\n            .sender(bob)\n            .approve(alice, TOKEN_ID)\n            .expect(\"should approve Bob's token for Alice\");\n        contract\n            .sender(alice)\n            .transfer_from(bob, alice, TOKEN_ID)\n            .expect(\"should transfer Bob's token to Alice\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn transfers_from_approved_for_all(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve all Bob's tokens for Alice\");\n\n        let approved_for_all =\n            contract.sender(alice).is_approved_for_all(bob, alice);\n        assert!(approved_for_all);\n\n        contract\n            .sender(alice)\n            .transfer_from(bob, alice, TOKEN_ID)\n            .expect(\"should transfer Bob's token to Alice\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn error_when_transfer_from_transfers_to_invalid_receiver(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .transfer_from(alice, invalid_receiver, TOKEN_ID)\n            .expect_err(\"should not transfer the token to invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_transfer_from_transfers_from_incorrect_owner(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .transfer_from(dave, bob, TOKEN_ID)\n            .expect_err(\"should not transfer the token from incorrect owner\");\n        assert!(matches!(\n            err,\n            Error::IncorrectOwner(ERC721IncorrectOwner {\n                sender,\n                token_id: t_id,\n                owner\n            }) if sender == dave \u0026\u0026 t_id == TOKEN_ID \u0026\u0026 owner == alice\n        ));\n\n        // NOTE: We can't check this here, but we cover this in our e2e tests.\n        // let owner = contract\n        // .owner_of(TOKEN_ID)\n        // .expect(\"should return the owner of the token\");\n        // assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_transfer_from_transfers_with_insufficient_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n        let err = contract\n            .sender(alice)\n            .transfer_from(bob, alice, TOKEN_ID)\n            .expect_err(\"should not transfer unapproved token\");\n        assert!(matches!(\n            err,\n            Error::InsufficientApproval(ERC721InsufficientApproval {\n                    operator,\n                    token_id: t_id,\n            }) if operator == alice \u0026\u0026 t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_transfer_from_transfers_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            .transfer_from(alice, bob, TOKEN_ID)\n            .expect_err(\"should not transfer a non-existent token\");\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                    token_id: t_id,\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn safe_transfers_from(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        contract\n            .sender(alice)\n            .safe_transfer_from(alice, bob, TOKEN_ID)\n            .expect(\"should transfer a token from Alice to Bob\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n\n        assert_eq!(owner, bob);\n    }\n\n    #[motsu::test]\n    fn safe_transfers_from_approved_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n        contract.sender(alice).token_approvals.setter(TOKEN_ID).set(alice);\n        contract\n            .sender(alice)\n            .safe_transfer_from(bob, alice, TOKEN_ID)\n            .expect(\"should transfer Bob's token to Alice\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn safe_transfers_from_approved_for_all(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve all Bob's tokens for Alice\");\n\n        let approved_for_all =\n            contract.sender(alice).is_approved_for_all(bob, alice);\n        assert!(approved_for_all);\n\n        contract\n            .sender(alice)\n            .safe_transfer_from(bob, alice, TOKEN_ID)\n            .expect(\"should transfer Bob's token to Alice\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn error_when_safe_transfer_to_invalid_receiver(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(alice, invalid_receiver, TOKEN_ID)\n            .expect_err(\"should not transfer the token to invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_safe_transfer_from_transfers_from_incorrect_owner(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(dave, bob, TOKEN_ID)\n            .expect_err(\"should not transfer the token from incorrect owner\");\n        assert!(matches!(\n            err,\n            Error::IncorrectOwner(ERC721IncorrectOwner {\n                owner,\n                sender,\n                token_id: t_id\n            }) if sender == dave \u0026\u0026 t_id == TOKEN_ID \u0026\u0026 owner == alice\n        ));\n\n        // NOTE: We can't check this here, but we cover this in our e2e tests.\n        // let owner = contract\n        // .owner_of(TOKEN_ID)\n        // .expect(\"should return the owner of the token\");\n        // assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_safe_transfer_from_transfers_with_insufficient_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(bob, alice, TOKEN_ID)\n            .expect_err(\"should not transfer unapproved token\");\n        assert!(matches!(\n            err,\n            Error::InsufficientApproval(ERC721InsufficientApproval {\n                operator,\n                token_id: t_id\n            }) if operator == alice \u0026\u0026 t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_safe_transfer_from_transfers_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from(alice, bob, TOKEN_ID)\n            .expect_err(\"should not transfer a non-existent token\");\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id,\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn safe_transfers_from_with_data(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        contract\n            .sender(alice)\n            .safe_transfer_from_with_data(\n                alice,\n                bob,\n                TOKEN_ID,\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect(\"should transfer a token from Alice to Bob\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n\n        assert_eq!(owner, bob);\n    }\n\n    #[motsu::test]\n    fn safe_transfers_from_with_data_approved_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n        contract\n            .sender(bob)\n            .approve(alice, TOKEN_ID)\n            .expect(\"should approve Bob's token for Alice\");\n        contract\n            .sender(alice)\n            .safe_transfer_from_with_data(\n                bob,\n                alice,\n                TOKEN_ID,\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect(\"should transfer Bob's token to Alice\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn safe_transfers_from_with_data_approved_for_all(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve all Bob's tokens for Alice\");\n\n        let approved_for_all =\n            contract.sender(alice).is_approved_for_all(bob, alice);\n        assert!(approved_for_all);\n\n        contract\n            .sender(alice)\n            .safe_transfer_from_with_data(\n                bob,\n                alice,\n                TOKEN_ID,\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect(\"should transfer Bob's token to Alice\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn error_when_safe_transfer_from_with_data_transfers_to_invalid_receiver(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from_with_data(\n                alice,\n                invalid_receiver,\n                TOKEN_ID,\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer the token to invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_safe_transfer_from_with_data_transfers_from_incorrect_owner(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from_with_data(\n                dave,\n                bob,\n                TOKEN_ID,\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer the token from incorrect owner\");\n        assert!(matches!(\n            err,\n            Error::IncorrectOwner(ERC721IncorrectOwner {\n                sender,\n                token_id: t_id,\n                owner\n            }) if sender == dave \u0026\u0026 t_id == TOKEN_ID \u0026\u0026 owner == alice\n\n        ));\n\n        // NOTE: We can't check this here, but we cover this in our e2e tests.\n        // let owner = contract\n        // .owner_of(TOKEN_ID)\n        // .expect(\"should return the owner of the token\");\n        //\n        // assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_safe_transfer_from_with_data_transfers_with_insufficient_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from_with_data(\n                bob,\n                alice,\n                TOKEN_ID,\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer unapproved token\");\n        assert!(matches!(\n            err,\n            Error::InsufficientApproval(ERC721InsufficientApproval {\n                operator,\n                token_id: t_id,\n            }) if operator == alice \u0026\u0026 t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_safe_transfer_from_with_data_transfers_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            .safe_transfer_from_with_data(\n                alice,\n                bob,\n                TOKEN_ID,\n                vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer a non-existent token\");\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id,\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_approve_for_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            .approve(bob, TOKEN_ID)\n            .expect_err(\"should not approve for a non-existent token\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id\n            }) if TOKEN_ID == t_id\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_approve_by_invalid_approver(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint a token\");\n\n        let err = contract\n            .sender(alice)\n            .approve(dave, TOKEN_ID)\n            .expect_err(\"should not approve when invalid approver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidApprover(ERC721InvalidApprover {\n                approver\n            }) if approver == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_approval_for_all_for_invalid_operator(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let invalid_operator = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            .set_approval_for_all(invalid_operator, true)\n            .expect_err(\"should not approve for all for invalid operator\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidOperator(ERC721InvalidOperator {\n                operator\n            }) if operator == invalid_operator\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_get_approved_of_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            .get_approved(TOKEN_ID)\n            .expect_err(\"should not return approved for a non-existent token\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id\n            }) if TOKEN_ID == t_id\n        ));\n    }\n\n    #[motsu::test]\n    fn owner_of_works(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint a token\");\n\n        let owner = contract.sender(alice)._owner_of(TOKEN_ID);\n        assert_eq!(bob, owner);\n    }\n\n    #[motsu::test]\n    fn owner_of_nonexistent_token(contract: Contract\u003cErc721\u003e, alice: Address) {\n        let owner = contract.sender(alice)._owner_of(TOKEN_ID);\n        assert_eq!(Address::ZERO, owner);\n    }\n\n    #[motsu::test]\n    fn get_approved_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let approved = contract.sender(alice)._get_approved(TOKEN_ID);\n        assert_eq!(Address::ZERO, approved);\n    }\n\n    #[motsu::test]\n    fn get_approved_token_without_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n        let approved = contract.sender(alice)._get_approved(TOKEN_ID);\n        assert_eq!(Address::ZERO, approved);\n    }\n\n    #[motsu::test]\n    fn get_approved_token_with_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n        contract\n            .sender(alice)\n            .approve(bob, TOKEN_ID)\n            .expect(\"should approve Bob for operations on token\");\n\n        let approved = contract.sender(alice)._get_approved(TOKEN_ID);\n        assert_eq!(bob, approved);\n    }\n\n    #[motsu::test]\n    fn get_approved_token_with_approval_for_all(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n        contract\n            .sender(alice)\n            .set_approval_for_all(bob, true)\n            .expect(\"should approve Bob for operations on all Alice's tokens\");\n\n        let approved = contract.sender(alice)._get_approved(TOKEN_ID);\n        assert_eq!(Address::ZERO, approved);\n    }\n\n    #[motsu::test]\n    fn is_authorized_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let authorized =\n            contract.sender(alice)._is_authorized(alice, bob, TOKEN_ID);\n        assert!(!authorized);\n    }\n\n    #[motsu::test]\n    fn is_authorized_token_owner(contract: Contract\u003cErc721\u003e, alice: Address) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n\n        let authorized =\n            contract.sender(alice)._is_authorized(alice, alice, TOKEN_ID);\n        assert!(authorized);\n    }\n\n    #[motsu::test]\n    fn is_authorized_without_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n\n        let authorized =\n            contract.sender(alice)._is_authorized(alice, bob, TOKEN_ID);\n        assert!(!authorized);\n    }\n\n    #[motsu::test]\n    fn is_authorized_with_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n        contract\n            .sender(alice)\n            .approve(bob, TOKEN_ID)\n            .expect(\"should approve Bob for operations on token\");\n\n        let authorized =\n            contract.sender(alice)._is_authorized(alice, bob, TOKEN_ID);\n        assert!(authorized);\n    }\n\n    #[motsu::test]\n    fn is_authorized_with_approval_for_all(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n        contract\n            .sender(alice)\n            .set_approval_for_all(bob, true)\n            .expect(\"should approve Bob for operations on all Alice's tokens\");\n\n        let authorized =\n            contract.sender(alice)._is_authorized(alice, bob, TOKEN_ID);\n        assert!(authorized);\n    }\n\n    #[motsu::test]\n    fn check_authorized_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            ._check_authorized(Address::ZERO, alice, TOKEN_ID)\n            .expect_err(\"should not pass for a non-existent token\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn check_authorized_token_owner(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n\n        let result =\n            contract.sender(alice)._check_authorized(alice, alice, TOKEN_ID);\n\n        assert!(result.is_ok());\n    }\n\n    #[motsu::test]\n    fn check_authorized_without_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n\n        let err = contract\n            .sender(alice)\n            ._check_authorized(alice, bob, TOKEN_ID)\n            .expect_err(\"should not pass without approval\");\n\n        assert!(matches!(\n            err,\n            Error::InsufficientApproval(ERC721InsufficientApproval {\n                operator,\n                token_id: t_id\n            }) if operator == bob \u0026\u0026 t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn check_authorized_with_approval(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n        contract\n            .sender(alice)\n            .approve(bob, TOKEN_ID)\n            .expect(\"should approve Bob for operations on token\");\n\n        let result =\n            contract.sender(alice)._check_authorized(alice, bob, TOKEN_ID);\n        assert!(result.is_ok());\n    }\n\n    #[motsu::test]\n    fn check_authorized_with_approval_for_all(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token\");\n        contract\n            .sender(alice)\n            .set_approval_for_all(bob, true)\n            .expect(\"should approve Bob for operations on all Alice's tokens\");\n\n        let result =\n            contract.sender(alice)._check_authorized(alice, bob, TOKEN_ID);\n        assert!(result.is_ok());\n    }\n\n    #[motsu::test]\n    fn burns(contract: Contract\u003cErc721\u003e, alice: Address) {\n        let one = uint!(1_U256);\n\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token for Alice\");\n\n        let initial_balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        let result = contract.sender(alice)._burn(TOKEN_ID);\n        let balance = contract\n            .sender(alice)\n            .balance_of(alice)\n            .expect(\"should return the balance of Alice\");\n\n        let err = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n                err,\n                Error::NonexistentToken (ERC721NonexistentToken{\n                    token_id: t_id\n                }) if t_id == TOKEN_ID\n        ));\n\n        assert!(result.is_ok());\n\n        assert_eq!(initial_balance - one, balance);\n    }\n\n    #[motsu::test]\n    fn error_when_get_approved_of_previous_approval_burned(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token for Alice\");\n        contract\n            .sender(alice)\n            .approve(bob, TOKEN_ID)\n            .expect(\"should approve a token for Bob\");\n\n        contract\n            .sender(alice)\n            ._burn(TOKEN_ID)\n            .expect(\"should burn previously minted token\");\n\n        let err = contract\n            .sender(alice)\n            .get_approved(TOKEN_ID)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken (ERC721NonexistentToken{\n                token_id: t_id\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_burn_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            ._burn(TOKEN_ID)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken (ERC721NonexistentToken{\n                token_id: t_id\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn transfers(contract: Contract\u003cErc721\u003e, alice: Address, bob: Address) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n        contract\n            .sender(alice)\n            ._transfer(alice, bob, TOKEN_ID)\n            .expect(\"should transfer a token from Alice to Bob\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, bob);\n    }\n\n    #[motsu::test]\n    fn transfers_approved_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n        contract\n            .sender(bob)\n            .approve(alice, TOKEN_ID)\n            .expect(\"should approve Bob's token for Alice\");\n        contract\n            .sender(alice)\n            ._transfer(bob, alice, TOKEN_ID)\n            .expect(\"should transfer Bob's token to Alice\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn transfers_approved_for_all(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve all Bob's tokens for Alice\");\n\n        let approved_for_all =\n            contract.sender(alice).is_approved_for_all(bob, alice);\n        assert!(approved_for_all);\n\n        contract\n            .sender(alice)\n            ._transfer(bob, alice, TOKEN_ID)\n            .expect(\"should transfer Bob's token to Alice\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn error_when_transfer_transfers_to_invalid_receiver(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            ._transfer(alice, invalid_receiver, TOKEN_ID)\n            .expect_err(\"should not transfer to invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_transfer_transfers_from_incorrect_owner(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            ._transfer(dave, bob, TOKEN_ID)\n            .expect_err(\"should not transfer from incorrect owner\");\n\n        assert!(matches!(\n            err,\n            Error::IncorrectOwner(ERC721IncorrectOwner {\n                sender,\n                token_id: t_id,\n                owner\n            }) if sender == dave \u0026\u0026 t_id == TOKEN_ID \u0026\u0026 owner == alice\n        ));\n\n        // NOTE: We can't check this here, but we cover this in our e2e tests.\n        // let owner = contract\n        // .owner_of(TOKEN_ID)\n        // .expect(\"should return the owner of the token\");\n        // assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_transfer_transfers_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            ._transfer(alice, bob, TOKEN_ID)\n            .expect_err(\"should not transfer a non-existent token\");\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id,\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn safe_transfers_internal(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        contract\n            .sender(alice)\n            ._safe_transfer(alice, bob, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect(\"should transfer a token from Alice to Bob\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n\n        assert_eq!(owner, bob);\n    }\n\n    #[motsu::test]\n    fn safe_transfers_internal_approved_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n        contract\n            .sender(bob)\n            .approve(alice, TOKEN_ID)\n            .expect(\"should approve Bob's token for Alice\");\n        contract\n            .sender(alice)\n            ._safe_transfer(bob, alice, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect(\"should transfer Bob's token to Alice\");\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn safe_transfers_internal_approved_for_all(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint token to Bob\");\n\n        contract\n            .sender(bob)\n            .set_approval_for_all(alice, true)\n            .expect(\"should approve all Bob's tokens for Alice\");\n\n        let approved_for_all =\n            contract.sender(alice).is_approved_for_all(bob, alice);\n        assert!(approved_for_all);\n\n        contract\n            .sender(alice)\n            ._safe_transfer(bob, alice, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect(\"should transfer Bob's token to Alice\");\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(owner, alice);\n    }\n\n    #[motsu::test]\n    fn error_when_internal_safe_transfer_to_invalid_receiver(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let invalid_receiver = Address::ZERO;\n\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            ._safe_transfer(\n                alice,\n                invalid_receiver,\n                TOKEN_ID,\n                \u0026vec![0, 1, 2, 3].into(),\n            )\n            .expect_err(\"should not transfer the token to invalid receiver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidReceiver(ERC721InvalidReceiver {\n                receiver\n            }) if receiver == invalid_receiver\n        ));\n\n        let owner = contract\n            .sender(alice)\n            .owner_of(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n        assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_internal_safe_transfer_from_incorrect_owner(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(alice, TOKEN_ID)\n            .expect(\"should mint a token to Alice\");\n\n        let err = contract\n            .sender(alice)\n            ._safe_transfer(dave, bob, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect_err(\"should not transfer the token from incorrect owner\");\n        assert!(matches!(\n            err,\n            Error::IncorrectOwner(ERC721IncorrectOwner {\n                sender,\n                token_id: t_id,\n                owner\n            }) if sender == dave \u0026\u0026 t_id == TOKEN_ID \u0026\u0026 owner == alice\n        ));\n\n        // NOTE: We can't check this here, but we cover this in our e2e tests.\n        // let owner = contract\n        // .owner_of(TOKEN_ID)\n        // .expect(\"should return the owner of the token\");\n        // assert_eq!(alice, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_internal_safe_transfer_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            ._safe_transfer(alice, bob, TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .expect_err(\"should not transfer a non-existent token\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id,\n            }) if t_id == TOKEN_ID\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_approve_internal_for_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            ._approve(bob, TOKEN_ID, alice, false)\n            .expect_err(\"should not approve for a non-existent token\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id\n            }) if TOKEN_ID == t_id\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_approve_internal_by_invalid_approver(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n        dave: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint a token\");\n\n        let err = contract\n            .sender(alice)\n            ._approve(dave, TOKEN_ID, alice, false)\n            .expect_err(\"should not approve when invalid approver\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidApprover(ERC721InvalidApprover {\n                approver\n            }) if approver == alice\n        ));\n    }\n\n    #[motsu::test]\n    fn error_when_approval_for_all_internal_for_invalid_operator(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let invalid_operator = Address::ZERO;\n\n        let err = contract\n            .sender(alice)\n            ._set_approval_for_all(alice, invalid_operator, true)\n            .expect_err(\"should not approve for all for invalid operator\");\n\n        assert!(matches!(\n            err,\n            Error::InvalidOperator(ERC721InvalidOperator {\n                operator\n            }) if operator == invalid_operator\n        ));\n    }\n\n    #[motsu::test]\n    fn require_owned_works(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n        bob: Address,\n    ) {\n        contract\n            .sender(alice)\n            ._mint(bob, TOKEN_ID)\n            .expect(\"should mint a token\");\n\n        let owner = contract\n            .sender(alice)\n            ._require_owned(TOKEN_ID)\n            .expect(\"should return the owner of the token\");\n\n        assert_eq!(bob, owner);\n    }\n\n    #[motsu::test]\n    fn error_when_require_owned_for_nonexistent_token(\n        contract: Contract\u003cErc721\u003e,\n        alice: Address,\n    ) {\n        let err = contract\n            .sender(alice)\n            ._require_owned(TOKEN_ID)\n            .expect_err(\"should return Error::NonexistentToken\");\n\n        assert!(matches!(\n            err,\n            Error::NonexistentToken(ERC721NonexistentToken {\n                token_id: t_id\n            }) if TOKEN_ID == t_id\n        ));\n    }\n\n    #[motsu::test]\n    fn interface_id() {\n        let actual = \u003cErc721 as IErc721\u003e::interface_id();\n        let expected: FixedBytes\u003c4\u003e = fixed_bytes!(\"80ac58cd\");\n        assert_eq!(actual, expected);\n    }\n\n    #[motsu::test]\n    fn supports_interface(contract: Contract\u003cErc721\u003e, alice: Address) {\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc721 as IErc721\u003e::interface_id()));\n        assert!(contract\n            .sender(alice)\n            .supports_interface(\u003cErc721 as IErc165\u003e::interface_id()));\n\n        let fake_interface_id = 0x12345678u32;\n        assert!(!contract\n            .sender(alice)\n            .supports_interface(fake_interface_id.into()));\n    }\n\n    sol_storage! {\n        pub struct Erc721ReceiverMock {\n            uint256 _received_token_id;\n        }\n    }\n\n    #[public]\n    impl Erc721ReceiverMock {\n        #[selector(name = \"onERC721Received\")]\n        fn on_erc721_received(\n            \u0026mut self,\n            _operator: Address,\n            _from: Address,\n            token_id: U256,\n            _data: Bytes,\n        ) -\u003e FixedBytes\u003c4\u003e {\n            self._received_token_id.set(token_id);\n            fixed_bytes!(\"150b7a02\")\n        }\n\n        fn received_token_id(\u0026self) -\u003e U256 {\n            self._received_token_id.get()\n        }\n    }\n\n    unsafe impl TopLevelStorage for Erc721ReceiverMock {}\n\n    #[motsu::test]\n    fn on_erc721_received(\n        erc721: Contract\u003cErc721\u003e,\n        receiver: Contract\u003cErc721ReceiverMock\u003e,\n        alice: Address,\n    ) {\n        erc721\n            .sender(alice)\n            ._safe_mint(receiver.address(), TOKEN_ID, \u0026vec![0, 1, 2, 3].into())\n            .unwrap();\n\n        let received_token_id = receiver.sender(alice).received_token_id();\n\n        assert_eq!(received_token_id, TOKEN_ID);\n    }\n}\n","traces":[{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":47}},{"line":421,"address":[],"length":0,"stats":{"Line":47}},{"line":422,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":33}},{"line":428,"address":[],"length":0,"stats":{"Line":99}},{"line":431,"address":[],"length":0,"stats":{"Line":7}},{"line":437,"address":[],"length":0,"stats":{"Line":49}},{"line":441,"address":[],"length":0,"stats":{"Line":19}},{"line":448,"address":[],"length":0,"stats":{"Line":104}},{"line":449,"address":[],"length":0,"stats":{"Line":10}},{"line":452,"address":[],"length":0,"stats":{"Line":45}},{"line":458,"address":[],"length":0,"stats":{"Line":45}},{"line":459,"address":[],"length":0,"stats":{"Line":4}},{"line":460,"address":[],"length":0,"stats":{"Line":4}},{"line":467,"address":[],"length":0,"stats":{"Line":41}},{"line":469,"address":[],"length":0,"stats":{"Line":3}},{"line":470,"address":[],"length":0,"stats":{"Line":6}},{"line":471,"address":[],"length":0,"stats":{"Line":3}},{"line":472,"address":[],"length":0,"stats":{"Line":3}},{"line":474,"address":[],"length":0,"stats":{"Line":3}},{"line":479,"address":[],"length":0,"stats":{"Line":26}},{"line":484,"address":[],"length":0,"stats":{"Line":130}},{"line":487,"address":[],"length":0,"stats":{"Line":12}},{"line":492,"address":[],"length":0,"stats":{"Line":60}},{"line":495,"address":[],"length":0,"stats":{"Line":3}},{"line":496,"address":[],"length":0,"stats":{"Line":12}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":53}},{"line":501,"address":[],"length":0,"stats":{"Line":159}},{"line":507,"address":[],"length":0,"stats":{"Line":6}},{"line":508,"address":[],"length":0,"stats":{"Line":6}},{"line":509,"address":[],"length":0,"stats":{"Line":4}},{"line":529,"address":[],"length":0,"stats":{"Line":275}},{"line":530,"address":[],"length":0,"stats":{"Line":825}},{"line":541,"address":[],"length":0,"stats":{"Line":41}},{"line":542,"address":[],"length":0,"stats":{"Line":123}},{"line":558,"address":[],"length":0,"stats":{"Line":70}},{"line":564,"address":[],"length":0,"stats":{"Line":70}},{"line":565,"address":[],"length":0,"stats":{"Line":70}},{"line":566,"address":[],"length":0,"stats":{"Line":43}},{"line":567,"address":[],"length":0,"stats":{"Line":37}},{"line":590,"address":[],"length":0,"stats":{"Line":65}},{"line":596,"address":[],"length":0,"stats":{"Line":325}},{"line":597,"address":[],"length":0,"stats":{"Line":51}},{"line":601,"address":[],"length":0,"stats":{"Line":7}},{"line":603,"address":[],"length":0,"stats":{"Line":7}},{"line":625,"address":[],"length":0,"stats":{"Line":4}},{"line":626,"address":[],"length":0,"stats":{"Line":16}},{"line":658,"address":[],"length":0,"stats":{"Line":167}},{"line":664,"address":[],"length":0,"stats":{"Line":668}},{"line":667,"address":[],"length":0,"stats":{"Line":167}},{"line":668,"address":[],"length":0,"stats":{"Line":66}},{"line":672,"address":[],"length":0,"stats":{"Line":155}},{"line":675,"address":[],"length":0,"stats":{"Line":57}},{"line":676,"address":[],"length":0,"stats":{"Line":57}},{"line":679,"address":[],"length":0,"stats":{"Line":298}},{"line":680,"address":[],"length":0,"stats":{"Line":143}},{"line":707,"address":[],"length":0,"stats":{"Line":102}},{"line":708,"address":[],"length":0,"stats":{"Line":102}},{"line":709,"address":[],"length":0,"stats":{"Line":2}},{"line":710,"address":[],"length":0,"stats":{"Line":2}},{"line":714,"address":[],"length":0,"stats":{"Line":100}},{"line":716,"address":[],"length":0,"stats":{"Line":5}},{"line":718,"address":[],"length":0,"stats":{"Line":95}},{"line":746,"address":[],"length":0,"stats":{"Line":22}},{"line":752,"address":[],"length":0,"stats":{"Line":93}},{"line":753,"address":[],"length":0,"stats":{"Line":17}},{"line":780,"address":[],"length":0,"stats":{"Line":3}},{"line":781,"address":[],"length":0,"stats":{"Line":3}},{"line":782,"address":[],"length":0,"stats":{"Line":9}},{"line":784,"address":[],"length":0,"stats":{"Line":1}},{"line":810,"address":[],"length":0,"stats":{"Line":12}},{"line":816,"address":[],"length":0,"stats":{"Line":12}},{"line":817,"address":[],"length":0,"stats":{"Line":2}},{"line":818,"address":[],"length":0,"stats":{"Line":2}},{"line":822,"address":[],"length":0,"stats":{"Line":10}},{"line":824,"address":[],"length":0,"stats":{"Line":2}},{"line":825,"address":[],"length":0,"stats":{"Line":8}},{"line":826,"address":[],"length":0,"stats":{"Line":2}},{"line":827,"address":[],"length":0,"stats":{"Line":4}},{"line":828,"address":[],"length":0,"stats":{"Line":2}},{"line":829,"address":[],"length":0,"stats":{"Line":2}},{"line":831,"address":[],"length":0,"stats":{"Line":2}},{"line":866,"address":[],"length":0,"stats":{"Line":6}},{"line":873,"address":[],"length":0,"stats":{"Line":33}},{"line":874,"address":[],"length":0,"stats":{"Line":3}},{"line":900,"address":[],"length":0,"stats":{"Line":85}},{"line":908,"address":[],"length":0,"stats":{"Line":144}},{"line":909,"address":[],"length":0,"stats":{"Line":56}},{"line":914,"address":[],"length":0,"stats":{"Line":26}},{"line":915,"address":[],"length":0,"stats":{"Line":6}},{"line":917,"address":[],"length":0,"stats":{"Line":2}},{"line":920,"address":[],"length":0,"stats":{"Line":24}},{"line":921,"address":[],"length":0,"stats":{"Line":72}},{"line":925,"address":[],"length":0,"stats":{"Line":81}},{"line":945,"address":[],"length":0,"stats":{"Line":13}},{"line":951,"address":[],"length":0,"stats":{"Line":13}},{"line":952,"address":[],"length":0,"stats":{"Line":2}},{"line":974,"address":[],"length":0,"stats":{"Line":66}},{"line":975,"address":[],"length":0,"stats":{"Line":264}},{"line":976,"address":[],"length":0,"stats":{"Line":66}},{"line":977,"address":[],"length":0,"stats":{"Line":11}},{"line":1009,"address":[],"length":0,"stats":{"Line":34}},{"line":1017,"address":[],"length":0,"stats":{"Line":34}},{"line":1018,"address":[],"length":0,"stats":{"Line":33}},{"line":1021,"address":[],"length":0,"stats":{"Line":3}},{"line":1022,"address":[],"length":0,"stats":{"Line":3}},{"line":1023,"address":[],"length":0,"stats":{"Line":3}},{"line":1024,"address":[],"length":0,"stats":{"Line":1}},{"line":1025,"address":[],"length":0,"stats":{"Line":1}},{"line":1026,"address":[],"length":0,"stats":{"Line":1}},{"line":1027,"address":[],"length":0,"stats":{"Line":1}},{"line":1028,"address":[],"length":0,"stats":{"Line":2}},{"line":1031,"address":[],"length":0,"stats":{"Line":2}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}}],"covered":113,"coverable":124},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","erc721","receiver.rs"],"content":"//! Module with an interface required for smart contract in order to receive\n//! ERC-721 token transfers.\n#![allow(missing_docs)]\n#![cfg_attr(coverage_nightly, coverage(off))]\nuse alloc::vec;\n\nuse stylus_sdk::prelude::sol_interface;\n\nsol_interface! {\n    /// [`super::Erc721`] token receiver interface.\n    ///\n    /// Interface for any contract that wants to support safe transfers from\n    /// [`super::Erc721`] asset contracts.\n    interface IERC721Receiver {\n        /// This function is called whenever an [`super::Erc721`] `token_id`\n        /// token is transferred to this contract via\n        /// [`super::IErc721::safe_transfer_from`].\n        ///\n        /// It must return its function selector to confirm the token transfer.\n        /// If any other value is returned or the interface is not implemented\n        /// by the recipient, the transfer will be reverted.\n        ///\n        /// NOTE: To accept the transfer, this must return\n        /// [`super::RECEIVER_FN_SELECTOR`], or its own function selector.\n        ///\n        /// # Arguments\n        ///\n        /// * `operator` - Account of the operator.\n        /// * `from` - Account of the sender.\n        /// * `token_id` - Token id as a number.\n        /// * `data` - Additional data with no specified format.\n        #[allow(missing_docs)]\n        function onERC721Received(\n            address operator,\n            address from,\n            uint256 token_id,\n            bytes calldata data\n        ) external returns (bytes4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","token","mod.rs"],"content":"//! Token standards.\npub mod common;\npub mod erc1155;\npub mod erc20;\npub mod erc6909;\npub mod erc721;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","cryptography","ecdsa.rs"],"content":"//! Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n//!\n//! These functions can be used to verify that a message was signed\n//! by the holder of the private keys of a given address.\nuse alloc::vec::Vec;\n\nuse alloy_primitives::{address, uint, Address, B256, U256};\nuse alloy_sol_types::SolType;\nuse stylus_sdk::{\n    call::{self, Call, MethodError},\n    prelude::*,\n};\n\nuse crate::utils::cryptography::ecdsa;\n\n/// Address of the `ecrecover` EVM precompile.\npub const ECRECOVER_ADDR: Address =\n    address!(\"0000000000000000000000000000000000000001\");\n\n/// Upper range for `s` value from the signature.\npub const SIGNATURE_S_UPPER_BOUND: U256 = uint!(\n    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0_U256\n);\n\npub use sol::*;\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// The signature derives the [`Address::ZERO`].\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ECDSAInvalidSignature();\n\n        /// The signature has an `S` value that is in the upper half order.\n        ///\n        /// * `s` - Invalid `S` value.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ECDSAInvalidSignatureS(bytes32 s);\n    }\n\n    sol! {\n        /// Struct with callable data to the `ecrecover` precompile.\n        #[allow(missing_docs)]\n        struct EcRecoverData {\n            /// EIP-191 Hash of the message.\n            bytes32 hash;\n            /// `v` value from the signature.\n            uint8 v;\n            /// `r` value from the signature.\n            bytes32 r;\n            /// `s` value from the signature.\n            bytes32 s;\n        }\n    }\n}\n\n/// An error that occurred in the implementation of an `ECDSA` library.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// The signature derives the [`Address::ZERO`].\n    InvalidSignature(ECDSAInvalidSignature),\n    /// The signature has an `S` value that is in the upper half order.\n    InvalidSignatureS(ECDSAInvalidSignatureS),\n}\n\nimpl MethodError for ecdsa::Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// Returns the address that signed a hashed message (`hash`).\n///\n/// # Arguments\n///\n/// * `storage` - Write access to storage.\n/// * `hash` - Hash of the message.\n/// * `v` - `v` value from the signature.\n/// * `r` - `r` value from the signature.\n/// * `s` - `s` value from the signature.\n///\n/// # Errors\n///\n/// * [`Error::InvalidSignatureS`] - If the `s` value is grater than\n///   [`SIGNATURE_S_UPPER_BOUND`].\n/// * [`Error::InvalidSignature`] - If the recovered address is\n///   [`Address::ZERO`].\n///\n/// # Panics\n///\n/// * If the `ecrecover` precompile fails to execute.\npub fn recover(\n    storage: \u0026mut impl TopLevelStorage,\n    hash: B256,\n    v: u8,\n    r: B256,\n    s: B256,\n) -\u003e Result\u003cAddress, Error\u003e {\n    check_if_malleable(\u0026s)?;\n    // If the signature is valid (and not malleable), return the signer address.\n    _recover(storage, hash, v, r, s)\n}\n\n/// Calls `ecrecover` EVM precompile.\n///\n/// The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n/// this function rejects them by requiring the `s` value to be in the lower\n/// half order, and the `v` value to be either 27 or 28.\n///\n/// # Arguments\n///\n/// * `storage` - Write access to storage.\n/// * `hash` - Hash of the message.\n/// * `v` - `v` value from the signature.\n/// * `r` - `r` value from the signature.\n/// * `s` - `s` value from the signature.\n///\n/// # Errors\n///\n/// * [`Error::InvalidSignature`] - If the recovered address is\n///   [`Address::ZERO`].\n///\n/// # Panics\n///\n/// * If the `ecrecover` precompile fails to execute.\nfn _recover(\n    storage: \u0026mut impl TopLevelStorage,\n    hash: B256,\n    v: u8,\n    r: B256,\n    s: B256,\n) -\u003e Result\u003cAddress, Error\u003e {\n    let calldata = encode_calldata(hash, v, r, s);\n\n    if v == 0 || v == 1 {\n        // `ecrecover` panics for these values\n        // but following the Solidity tests\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/utils/cryptography/ECDSA.test.js\n        // it should return `ECDSAInvalidSignature` error.\n        return Err(ECDSAInvalidSignature {}.into());\n    }\n\n    let recovered =\n        call::static_call(Call::new_in(storage), ECRECOVER_ADDR, \u0026calldata)\n            .expect(\"should call `ecrecover` precompile\");\n\n    let recovered = Address::from_slice(\u0026recovered[12..]);\n\n    if recovered.is_zero() {\n        return Err(ECDSAInvalidSignature {}.into());\n    }\n    Ok(recovered)\n}\n\n/// Encodes call data for `ecrecover` EVM precompile.\n///\n/// # Arguments\n///\n/// * `hash` - Hash of the message.\n/// * `v` - `v` value from the signature.\n/// * `r` - `r` value from the signature.\n/// * `s` - `s` value from the signature.\nfn encode_calldata(hash: B256, v: u8, r: B256, s: B256) -\u003e Vec\u003cu8\u003e {\n    let calldata = EcRecoverData { hash, v, r, s };\n    EcRecoverData::abi_encode(\u0026calldata)\n}\n\n/// Validates the `s` value of a signature.\n///\n/// EIP-2 still allows signature malleability for `ecrecover` precompile.\n///\n/// Remove this possibility and make the signature unique.\n///\n/// Appendix F in the [Ethereum Yellow paper], defines the valid range for s in\n/// (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}.\n///\n/// Most signatures from current libraries generate a unique signature\n/// with an s-value in the lower half order.\n///\n/// If your library generates malleable signatures,\n/// such as s-values in the upper range, calculate a new s-value\n/// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 -\n/// s1, and flip v from 27 to 28 or vice versa.\n///\n/// If your library also generates signatures with 0/1 for v instead 27/28,\n/// add 27 to v to accept these malleable signatures as well.\n///\n/// # Arguments\n///\n/// * `s` - `s` value from the signature.\n///\n/// # Errors\n///\n/// * [`Error::InvalidSignatureS`] - If the `s` value is greater than\n///   [`SIGNATURE_S_UPPER_BOUND`].\n///\n/// [Ethereum Yellow paper]: https://ethereum.github.io/yellowpaper/paper.pdf\nfn check_if_malleable(s: \u0026B256) -\u003e Result\u003c(), Error\u003e {\n    let s_u256 = U256::from_be_slice(s.as_slice());\n    if s_u256 \u003e SIGNATURE_S_UPPER_BOUND {\n        return Err(ECDSAInvalidSignatureS { s: *s }.into());\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{b256, B256};\n\n    use super::*;\n\n    const MSG_HASH: B256 = b256!(\n        \"a1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n    );\n    const V: u8 = 28;\n    const R: B256 = b256!(\n        \"65e72b1cf8e189569963750e10ccb88fe89389daeeb8b735277d59cd6885ee82\"\n    );\n    const S: B256 = b256!(\n        \"3eb5a6982b540f185703492dab77b863a88ce01f27e21ade8b2879c10fc9e653\"\n    );\n\n    #[test]\n    fn prepares_calldata() {\n        let expected = alloy_primitives::bytes!(\"a1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2000000000000000000000000000000000000000000000000000000000000001c65e72b1cf8e189569963750e10ccb88fe89389daeeb8b735277d59cd6885ee823eb5a6982b540f185703492dab77b863a88ce01f27e21ade8b2879c10fc9e653\");\n        let calldata = encode_calldata(MSG_HASH, V, R, S);\n        assert_eq!(expected, calldata);\n    }\n\n    #[test]\n    fn rejects_invalid_s() {\n        let invalid_s = SIGNATURE_S_UPPER_BOUND + uint!(1_U256);\n        let invalid_s = B256::from_slice(\u0026invalid_s.to_be_bytes_vec());\n        let err = check_if_malleable(\u0026invalid_s)\n            .expect_err(\"should return ECDSAInvalidSignatureS\");\n\n        assert!(matches!(err,\n                Error::InvalidSignatureS(ECDSAInvalidSignatureS {\n                    s\n                }) if s == invalid_s\n        ));\n    }\n\n    #[test]\n    fn validates_s() {\n        let valid_s = SIGNATURE_S_UPPER_BOUND - uint!(1_U256);\n        let invalid_s = B256::from_slice(\u0026valid_s.to_be_bytes_vec());\n        let result = check_if_malleable(\u0026invalid_s);\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":2}},{"line":204,"address":[],"length":0,"stats":{"Line":1}}],"covered":7,"coverable":22},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","cryptography","eip712.rs"],"content":"//! [EIP-712](https://eips.ethereum.org/EIPS/eip-712) is a standard for hashing\n//! and signing typed structured data.\n//!\n//! The implementation of the domain separator was designed to be as efficient\n//! as possible while still properly updating the chain id to protect against\n//! replay attacks on an eventual fork of the chain.\n//!\n//! NOTE: This contract implements the version of the encoding known as \"v4\", as\n//! implemented by the JSON RPC method [`eth_signTypedDataV4`] in `MetaMask`.\n//!\n//! [`eth_signTypedDataV4`]: https://docs.metamask.io/guide/signing-data.html\n\nuse alloc::{borrow::ToOwned, string::String, vec::Vec};\n\nuse alloy_primitives::{keccak256, Address, B256, U256};\nuse alloy_sol_types::{sol, SolType};\nuse stylus_sdk::{block, contract};\n\n/// Keccak-256 hash of the EIP-712 domain separator type string.\nconst TYPE_HASH: [u8; 32] =\n    keccak_const::Keccak256::new()\n        .update(b\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n        .finalize();\n\n/// Field for the domain separator.\nconst FIELDS: [u8; 1] = [0x0f];\n\n/// Salt for the domain separator.\nconst SALT: [u8; 32] = [0u8; 32];\n\n/// Prefix for ERC-191 version with `0x01`.\nconst TYPED_DATA_PREFIX: [u8; 2] = [0x19, 0x01];\n\n/// Tuple for the domain separator.\ntype DomainSeparatorTuple = sol! {\n    tuple(bytes32, bytes32, bytes32, uint256, address)\n};\n\n/// Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version\n/// `0x01`).\n///\n/// The digest is calculated from a `domain_separator` and a `struct_hash`, by\n/// prefixing them with `[TYPED_DATA_PREFIX]` and hashing the result. It\n/// corresponds to the hash signed by the [eth_signTypedData] JSON-RPC method as\n/// part of EIP-712.\n///\n/// [eth_signTypedData]: https://eips.ethereum.org/EIPS/eip-712\n#[must_use]\npub fn to_typed_data_hash(\n    domain_separator: \u0026[u8; 32],\n    struct_hash: \u0026[u8; 32],\n) -\u003e B256 {\n    let mut preimage = [0u8; 66];\n    preimage[..2].copy_from_slice(\u0026TYPED_DATA_PREFIX);\n    preimage[2..34].copy_from_slice(domain_separator);\n    preimage[34..].copy_from_slice(struct_hash);\n    keccak256(preimage)\n}\n\n/// EIP-712 Contract interface.\npub trait IEip712 {\n    /// Immutable name of EIP-712 instance.\n    const NAME: \u0026'static str;\n    /// Hashed name of EIP-712 instance.\n    const HASHED_NAME: [u8; 32] =\n        keccak_const::Keccak256::new().update(Self::NAME.as_bytes()).finalize();\n\n    /// Immutable version of EIP-712 instance.\n    const VERSION: \u0026'static str;\n    /// Hashed version of EIP-712 instance.\n    const HASHED_VERSION: [u8; 32] = keccak_const::Keccak256::new()\n        .update(Self::VERSION.as_bytes())\n        .finalize();\n\n    /// Returns chain id.\n    #[must_use]\n    fn chain_id() -\u003e U256 {\n        U256::from(block::chainid())\n    }\n\n    /// Returns the contract's address.\n    #[must_use]\n    fn contract_address() -\u003e Address {\n        contract::address()\n    }\n\n    /// Returns the fields and values that describe the domain separator used by\n    /// this contract for EIP-712 signature.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn eip712_domain(\n        \u0026self,\n    ) -\u003e ([u8; 1], String, String, U256, Address, [u8; 32], Vec\u003cU256\u003e) {\n        (\n            FIELDS,\n            Self::NAME.to_owned(),\n            Self::VERSION.to_owned(),\n            Self::chain_id(),\n            Self::contract_address(),\n            SALT,\n            Vec::new(),\n        )\n    }\n\n    /// Returns the domain separator for the current chain.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn domain_separator_v4(\u0026self) -\u003e B256 {\n        let encoded = DomainSeparatorTuple::abi_encode(\u0026(\n            TYPE_HASH,\n            Self::HASHED_NAME,\n            Self::HASHED_VERSION,\n            Self::chain_id(),\n            Self::contract_address(),\n        ));\n\n        keccak256(encoded)\n    }\n\n    /// Given an already [hashed struct], this function returns the hash of the\n    /// fully encoded EIP-712 message for this domain.\n    ///\n    /// [hashed struct]: https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn hash_typed_data_v4(\u0026self, struct_hash: B256) -\u003e B256 {\n        let domain_separator = self.domain_separator_v4();\n        to_typed_data_hash(\u0026domain_separator, \u0026struct_hash)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{address, b256, uint, Address, U256};\n\n    use super::{to_typed_data_hash, IEip712, FIELDS, SALT};\n\n    const CHAIN_ID: U256 = uint!(42161_U256);\n\n    const CONTRACT_ADDRESS: Address =\n        address!(\"000000000000000000000000000000000000dEaD\");\n\n    #[derive(Default)]\n    struct TestEIP712;\n\n    impl IEip712 for TestEIP712 {\n        const NAME: \u0026'static str = \"A Name\";\n        const VERSION: \u0026'static str = \"1\";\n\n        fn chain_id() -\u003e U256 {\n            CHAIN_ID\n        }\n\n        fn contract_address() -\u003e Address {\n            CONTRACT_ADDRESS\n        }\n    }\n\n    #[test]\n    fn domain_test() {\n        let contract = TestEIP712::default();\n        let domain = contract.eip712_domain();\n        assert_eq!(FIELDS, domain.0);\n        assert_eq!(TestEIP712::NAME, domain.1);\n        assert_eq!(TestEIP712::VERSION, domain.2);\n        assert_eq!(CHAIN_ID, domain.3);\n        assert_eq!(CONTRACT_ADDRESS, domain.4);\n        assert_eq!(SALT, domain.5);\n        assert_eq!(Vec::\u003cU256\u003e::new(), domain.6);\n    }\n\n    #[test]\n    fn test_to_typed_data_hash() {\n        // TYPE_HASH\n        let domain_separator = b256!(\n            \"8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f\"\n        );\n        // bytes32(\"stylus\");\n        let struct_hash = b256!(\n            \"7379746c75730000000000000000000000000000000000000000000000000000\"\n        );\n        let expected = b256!(\n            \"cefc47137f8165d8270433dd62e395f5672966b83a113a7bb7b2805730a2197e\"\n        );\n\n        assert_eq!(\n            expected,\n            to_typed_data_hash(\u0026domain_separator, \u0026struct_hash),\n        );\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}}],"covered":14,"coverable":29},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","cryptography","mod.rs"],"content":"//! Smart Contracts with cryptography.\npub mod ecdsa;\npub mod eip712;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","introspection","erc165.rs"],"content":"//! Trait and implementation of the ERC-165 standard, as defined in the [ERC].\n//!\n//! [ERC]: https://eips.ethereum.org/EIPS/eip-165\n\nuse alloy_primitives::FixedBytes;\nuse openzeppelin_stylus_proc::interface_id;\n\n/// Interface of the ERC-165 standard, as defined in the [ERC].\n///\n/// Implementers can declare support of contract interfaces, which others can\n/// query.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// impl IErc165 for Erc20 {\n///     fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n///         \u003cSelf as IErc20\u003e::interface_id() == interface_id\n///             || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n///     }\n/// }\n/// ```\n///\n/// [ERC]: https://eips.ethereum.org/EIPS/eip-165\n#[interface_id]\npub trait IErc165 {\n    /// Returns true if this contract implements the interface defined by\n    /// `interface_id`. See the corresponding [ERC] to learn more about how\n    /// these ids are created.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `interface_id` - The interface identifier, as specified in the [ERC].\n    ///\n    /// [ERC]: https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","introspection","mod.rs"],"content":"//! Stylus contract's introspection helpers library.\npub mod erc165;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","math","alloy.rs"],"content":"//! Standard math utilities missing in `alloy_primitives`.\nuse alloy_primitives::{uint, U256, U512};\n\n/// Trait for standard math utilities missing in `alloy_primitives`.\npub trait Math {\n    /// Returns the square root of a number. If the number is not a perfect\n    /// square, the value is rounded towards zero.\n    /// This method is based on Newton's method for computing square roots; the\n    /// algorithm is restricted to only using integer operations.\n    ///\n    /// # Arguments\n    ///\n    /// * `self` - value to perform square root operation onto.\n    #[must_use]\n    fn sqrt(self) -\u003e Self;\n\n    /// Returns the average of two numbers. The result is rounded towards zero.\n    ///\n    /// # Arguments\n    ///\n    /// * `self` - first value to compute average.\n    /// * `rhs` - second value to compute average.\n    #[must_use]\n    fn average(self, rhs: Self) -\u003e Self;\n\n    /// Calculates floor(`self` * `y` / `denominator`) with full precision,\n    /// following the selected `rounding` direction.\n    ///\n    /// # Arguments\n    ///\n    /// * `self` - first value to compute the result.\n    /// * `y` - second value to compute the result.\n    /// * `denominator` - denominator of the division.\n    /// * `rounding` - rounding technique to use in calculation.\n    #[must_use]\n    fn mul_div(self, y: Self, denominator: Self, rounding: Rounding) -\u003e Self;\n}\n\n/// Enum representing many rounding techniques.\npub enum Rounding {\n    /// Rounding toward negative infinity.\n    Floor,\n    /// Rounding toward positive infinity.\n    Ceil,\n}\n\nimpl Math for U256 {\n    fn sqrt(self) -\u003e Self {\n        let a = self;\n        let one = uint!(1_U256);\n        if a \u003c= one {\n            return a;\n        }\n\n        // In this function, we use Newton's method to get a root of `f(x) := x²\n        // - a`. It involves building a sequence x_n that converges\n        // toward sqrt(a). For each iteration x_n, we also define the\n        // error between the current value as `ε_n = | x_n - sqrt(a) |`.\n        //\n        // For our first estimation, we consider `e` the smallest power of 2\n        // which is bigger than the square root of the target. (i.e.\n        // `2**(e-1) ≤ sqrt(a) \u003c 2**e`). We know that `e ≤ 128` because\n        // `(2¹²⁸)² = 2²⁵⁶` is bigger than any uint256.\n        //\n        // By noticing that\n        // `2**(e-1) ≤ sqrt(a) \u003c 2**e → (2**(e-1))² ≤ a \u003c (2**e)² → 2**(2*e-2) ≤\n        // a \u003c 2**(2*e)` we can deduce that `e - 1` is `log2(a) / 2`. We\n        // can thus compute `x_n = 2**(e-1)` using a method similar to\n        // the msb function.\n        let mut aa = a;\n        let mut xn = one;\n\n        if aa \u003e= (one \u003c\u003c 128) {\n            aa \u003e\u003e= 128;\n            xn \u003c\u003c= 64;\n        }\n        if aa \u003e= (one \u003c\u003c 64) {\n            aa \u003e\u003e= 64;\n            xn \u003c\u003c= 32;\n        }\n        if aa \u003e= (one \u003c\u003c 32) {\n            aa \u003e\u003e= 32;\n            xn \u003c\u003c= 16;\n        }\n        if aa \u003e= (one \u003c\u003c 16) {\n            aa \u003e\u003e= 16;\n            xn \u003c\u003c= 8;\n        }\n        if aa \u003e= (one \u003c\u003c 8) {\n            aa \u003e\u003e= 8;\n            xn \u003c\u003c= 4;\n        }\n        if aa \u003e= (one \u003c\u003c 4) {\n            aa \u003e\u003e= 4;\n            xn \u003c\u003c= 2;\n        }\n        if aa \u003e= (one \u003c\u003c 2) {\n            xn \u003c\u003c= 1;\n        }\n\n        // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) \u003c 2**e = 2 *\n        // x_n`. This implies ε_n ≤ 2**(e-1).\n        //\n        // We can refine our estimation by noticing that the middle of that\n        // interval minimizes the error. If we move x_n to equal\n        // 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤\n        // 2**(e-2). This is going to be our x_0 (and ε_0)\n        xn = (uint!(3_U256) * xn) \u003e\u003e 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n        // From here, Newton's method give us:\n        // x_{n+1} = (x_n + a / x_n) / 2\n        //\n        // One should note that:\n        // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n        //              = ((x_n² + a) / (2 * x_n))² - a\n        //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n        //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n        //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n        //              = (x_n² - a)² / (2 * x_n)²\n        //              = ((x_n² - a) / (2 * x_n))²\n        //              ≥ 0\n        // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n        //\n        // This gives us the proof of quadratic convergence of the sequence:\n        // ε_{n+1} = | x_{n+1} - sqrt(a) |\n        //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n        //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n        //         = | (x_n - sqrt(a))² / (2 * x_n) |\n        //         = | ε_n² / (2 * x_n) |\n        //         = ε_n² / | (2 * x_n) |\n        //\n        // For the first iteration, we have a special case where x_0 is known:\n        // ε_1 = ε_0² / | (2 * x_0) |\n        //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n        //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n        //     ≤ 2**(e-3) / 3\n        //     ≤ 2**(e-3-log2(3))\n        //     ≤ 2**(e-4.5)\n        //\n        // For the following iterations, we use the fact that, 2**(e-1) ≤\n        // sqrt(a) ≤ x_n: ε_{n+1} = ε_n² / | (2 * x_n) |\n        //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n        //         ≤ 2**(2*e-2*k) / 2**e\n        //         ≤ 2**(e-2*k)\n        xn = (xn + a / xn) \u003e\u003e 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n        xn = (xn + a / xn) \u003e\u003e 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n        xn = (xn + a / xn) \u003e\u003e 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n        xn = (xn + a / xn) \u003e\u003e 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n        xn = (xn + a / xn) \u003e\u003e 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n        xn = (xn + a / xn) \u003e\u003e 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n        // Because e ≤ 128 (as discussed during the first estimation phase), we\n        // know have reached a precision ε_6 ≤ 2**(e-144) \u003c 1. Given\n        // we're operating on integers, then we can ensure that xn is\n        // now either sqrt(a) or sqrt(a) + 1.\n        xn - U256::from(xn \u003e a / xn)\n    }\n\n    fn average(self, rhs: Self) -\u003e Self {\n        // `(a + b) / 2` can overflow, so instead we compute\n        // `(2 * (a \u0026 b) + (a ^ b)) / 2`.\n        //\n        // `a ^ b` computes the sum without carries while `2 * (a \u0026 b)` singles\n        // out the carries, so `2 * (a \u0026 b) + (a ^ b) == a + b`. Sum with no\n        // carries + carries.\n        (self \u0026 rhs) + ((self ^ rhs) \u003e\u003e 1)\n    }\n\n    fn mul_div(self, y: Self, denominator: Self, rounding: Rounding) -\u003e Self {\n        assert!(\n            !denominator.is_zero(),\n            \"division by U256::ZERO in `Math::mul_div`\"\n        );\n\n        let prod = U512::from(self)\n            .checked_mul(U512::from(y))\n            .expect(\"should not panic with `U256` * `U256`\");\n\n        // Adjust for rounding if needed.\n        let adjusted = match rounding {\n            Rounding::Floor =\u003e prod, // No adjustment for Rounding::Floor\n            Rounding::Ceil =\u003e prod\n                .checked_add(U512::from(denominator) - U512::from(1))\n                .expect(\"should not exceed `U512`\"),\n        };\n\n        let result = adjusted\n            .checked_div(U512::from(denominator))\n            .expect(\"should not panic with `U512` / `U512`\");\n\n        if result \u003e U512::from(U256::MAX) {\n            panic!(\"should fit into `U256` in `Math::mul_div`\");\n        } else {\n            U256::from(result)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{\n        private::proptest::{prop_assume, proptest},\n        uint, U256, U512,\n    };\n\n    use crate::utils::math::alloy::{Math, Rounding};\n\n    #[test]\n    fn check_sqrt() {\n        proptest!(|(value: U256)| {\n            // U256::root(..) method requires std. Can only be used in tests.\n            assert_eq!(value.sqrt(), value.root(2));\n        });\n    }\n\n    #[test]\n    fn check_average() {\n        proptest!(|(left: U256, right: U256)| {\n            // compute average in straight forward way with overflow and downcast.\n            let expected = (U512::from(left) + U512::from(right)) / uint!(2_U512);\n            assert_eq!(left.average(right), U256::from(expected));\n        });\n    }\n\n    #[test]\n    fn check_mul_div_rounding_floor() {\n        proptest!(|(x: U256, y: U256, denominator: U256)| {\n            prop_assume!(denominator != U256::ZERO, \"division by U256::ZERO in `Math::mul_div`.\");\n            prop_assume!(denominator \u003e y, \"result should fit into `U256` in `Math::mul_div`.\");\n            let value = x.mul_div(y, denominator, Rounding::Floor);\n            let expected = U512::from(x).checked_mul(U512::from(y)).expect(\"should not panic with `U256` * `U256`\");\n            let expected = expected.checked_div(U512::from(denominator)).expect(\"should not panic with `U512` / `U512`\");\n            assert_eq!(U512::from(value), expected);\n        })\n    }\n\n    #[test]\n    fn check_mul_div_rounding_ceil() {\n        proptest!(|(x: U256, y: U256, denominator: U256)| {\n            prop_assume!(denominator != U256::ZERO, \"division by U256::ZERO in `Math::mul_div`.\");\n            prop_assume!(denominator \u003e y, \"result should fit into `U256` in `Math::mul_div`.\");\n            let value = x.mul_div(y, denominator, Rounding::Ceil);\n            let denominator = U512::from(denominator);\n            let expected = U512::from(x).checked_mul(U512::from(y)).expect(\"should not panic with `U256` * `U256`\").checked_add(denominator - U512::from(1)).expect(\"should not exceed `U512`\");\n            let expected = expected.checked_div(U512::from(denominator)).expect(\"should not panic with `U512` / `U512`\");\n            assert_eq!(U512::from(value), expected);\n        })\n    }\n\n    #[test]\n    #[should_panic = \"division by U256::ZERO in `Math::mul_div`\"]\n    fn check_mul_div_panics_when_denominator_is_zero() {\n        proptest!(|(x: U256, y: U256)| {\n            // This should panic.\n            _ = x.mul_div(y, U256::ZERO, Rounding::Floor);\n        })\n    }\n\n    #[test]\n    #[should_panic = \"should fit into `U256` in `Math::mul_div`\"]\n    fn check_mul_div_panics_when_result_overflows() {\n        proptest!(|(x: U256, y: U256)| {\n            prop_assume!(x != U256::ZERO, \"Guaranteed `x` for overflow.\");\n            prop_assume!(y \u003e U256::MAX / x, \"Guaranteed `y` for overflow.\");\n            // This should panic.\n            _ = x.mul_div(y, U256::from(1), Rounding::Floor);\n        })\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":262}},{"line":49,"address":[],"length":0,"stats":{"Line":524}},{"line":50,"address":[],"length":0,"stats":{"Line":524}},{"line":51,"address":[],"length":0,"stats":{"Line":262}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":258}},{"line":74,"address":[],"length":0,"stats":{"Line":258}},{"line":75,"address":[],"length":0,"stats":{"Line":258}},{"line":77,"address":[],"length":0,"stats":{"Line":258}},{"line":78,"address":[],"length":0,"stats":{"Line":258}},{"line":79,"address":[],"length":0,"stats":{"Line":258}},{"line":81,"address":[],"length":0,"stats":{"Line":258}},{"line":82,"address":[],"length":0,"stats":{"Line":258}},{"line":83,"address":[],"length":0,"stats":{"Line":258}},{"line":85,"address":[],"length":0,"stats":{"Line":258}},{"line":86,"address":[],"length":0,"stats":{"Line":258}},{"line":87,"address":[],"length":0,"stats":{"Line":258}},{"line":89,"address":[],"length":0,"stats":{"Line":257}},{"line":90,"address":[],"length":0,"stats":{"Line":257}},{"line":91,"address":[],"length":0,"stats":{"Line":257}},{"line":93,"address":[],"length":0,"stats":{"Line":239}},{"line":94,"address":[],"length":0,"stats":{"Line":239}},{"line":95,"address":[],"length":0,"stats":{"Line":239}},{"line":97,"address":[],"length":0,"stats":{"Line":201}},{"line":98,"address":[],"length":0,"stats":{"Line":201}},{"line":159,"address":[],"length":0,"stats":{"Line":295}},{"line":166,"address":[],"length":0,"stats":{"Line":590}},{"line":169,"address":[],"length":0,"stats":{"Line":1522}},{"line":170,"address":[],"length":0,"stats":{"Line":1522}},{"line":171,"address":[],"length":0,"stats":{"Line":1522}},{"line":172,"address":[],"length":0,"stats":{"Line":505}},{"line":175,"address":[],"length":0,"stats":{"Line":3051}},{"line":176,"address":[],"length":0,"stats":{"Line":3051}},{"line":180,"address":[],"length":0,"stats":{"Line":2034}},{"line":181,"address":[],"length":0,"stats":{"Line":761}},{"line":182,"address":[],"length":0,"stats":{"Line":256}},{"line":183,"address":[],"length":0,"stats":{"Line":768}},{"line":187,"address":[],"length":0,"stats":{"Line":2034}},{"line":188,"address":[],"length":0,"stats":{"Line":3051}},{"line":191,"address":[],"length":0,"stats":{"Line":1017}},{"line":192,"address":[],"length":0,"stats":{"Line":1010}},{"line":194,"address":[],"length":0,"stats":{"Line":512}}],"covered":41,"coverable":42},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","math","mod.rs"],"content":"//! Math helpers for `alloy` and Solidity storage types.\npub mod alloy;\npub mod storage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","math","storage","checked.rs"],"content":"//! Module with \"checked\" math on storage values that panics on overflow.\nuse alloy_primitives::Uint;\nuse alloy_sol_types::sol_data::{IntBitCount, SupportedInt};\nuse stylus_sdk::storage::StorageUint;\n\n/// Adds value and assign the result to `self`, panicking on overflow.\npub(crate) trait AddAssignChecked\u003cT\u003e {\n    /// Adds `rhs` and assign the result to `self`, panicking on overflow.\n    fn add_assign_checked(\u0026mut self, rhs: T, msg: \u0026str);\n}\n\nimpl\u003cconst B: usize, const L: usize\u003e AddAssignChecked\u003cUint\u003cB, L\u003e\u003e\n    for StorageUint\u003cB, L\u003e\nwhere\n    IntBitCount\u003cB\u003e: SupportedInt,\n{\n    fn add_assign_checked(\u0026mut self, rhs: Uint\u003cB, L\u003e, msg: \u0026str) {\n        let new_balance = self.get().checked_add(rhs).expect(msg);\n        self.set(new_balance);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":190}},{"line":18,"address":[],"length":0,"stats":{"Line":1330}},{"line":19,"address":[],"length":0,"stats":{"Line":570}}],"covered":3,"coverable":3},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","math","storage","mod.rs"],"content":"//! Simple math operations missing in `stylus_sdk::storage`.\nmod checked;\nmod unchecked;\n\npub(crate) use checked::AddAssignChecked;\npub(crate) use unchecked::{AddAssignUnchecked, SubAssignUnchecked};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","math","storage","unchecked.rs"],"content":"/// Module with \"unchecked\" math on storage values.\nuse alloy_primitives::Uint;\nuse alloy_sol_types::sol_data::{IntBitCount, SupportedInt};\nuse stylus_sdk::storage::StorageUint;\n\n/// Adds value and assign the result to `self`, ignoring overflow.\npub(crate) trait AddAssignUnchecked\u003cT\u003e {\n    /// Adds `rhs` and assign the result to `self`, ignoring overflow.\n    fn add_assign_unchecked(\u0026mut self, rhs: T);\n}\n\nimpl\u003cconst B: usize, const L: usize\u003e AddAssignUnchecked\u003cUint\u003cB, L\u003e\u003e\n    for StorageUint\u003cB, L\u003e\nwhere\n    IntBitCount\u003cB\u003e: SupportedInt,\n{\n    fn add_assign_unchecked(\u0026mut self, rhs: Uint\u003cB, L\u003e) {\n        let new_balance = self.get() + rhs;\n        self.set(new_balance);\n    }\n}\n\n/// Subtract value and assign the result to `self`, ignoring overflow.\npub(crate) trait SubAssignUnchecked\u003cT\u003e {\n    /// Subtract `rhs` and assign the result to `self`, ignoring overflow.\n    fn sub_assign_unchecked(\u0026mut self, rhs: T);\n}\n\nimpl\u003cconst B: usize, const L: usize\u003e SubAssignUnchecked\u003cUint\u003cB, L\u003e\u003e\n    for StorageUint\u003cB, L\u003e\nwhere\n    IntBitCount\u003cB\u003e: SupportedInt,\n{\n    fn sub_assign_unchecked(\u0026mut self, rhs: Uint\u003cB, L\u003e) {\n        let new_balance = self.get() - rhs;\n        self.set(new_balance);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":213}},{"line":18,"address":[],"length":0,"stats":{"Line":639}},{"line":19,"address":[],"length":0,"stats":{"Line":639}},{"line":34,"address":[],"length":0,"stats":{"Line":111}},{"line":35,"address":[],"length":0,"stats":{"Line":333}},{"line":36,"address":[],"length":0,"stats":{"Line":333}}],"covered":6,"coverable":6},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","metadata.rs"],"content":"//! Common Metadata Smart Contract.\nuse alloc::{string::String, vec, vec::Vec};\n\nuse stylus_sdk::{prelude::*, storage::StorageString};\n\n/// State of a [`Metadata`] contract.\n#[storage]\npub struct Metadata {\n    /// Token name.\n    pub(crate) name: StorageString,\n    /// Token symbol.\n    pub(crate) symbol: StorageString,\n}\n\n#[public]\nimpl Metadata {\n    /// Constructor.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `name` - Token name.\n    /// * `symbol` - Token symbol.\n    #[constructor]\n    pub fn constructor(\u0026mut self, name: String, symbol: String) {\n        self.name.set_str(name);\n        self.symbol.set_str(symbol);\n    }\n\n    /// Returns the name of the token.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    pub fn name(\u0026self) -\u003e String {\n        self.name.get_string()\n    }\n\n    /// Returns the symbol of the token, usually a shorter version of the name.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    pub fn symbol(\u0026self) -\u003e String {\n        self.symbol.get_string()\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":6}},{"line":27,"address":[],"length":0,"stats":{"Line":6}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":4}}],"covered":7,"coverable":7},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","mod.rs"],"content":"//! Common Smart Contracts utilities.\npub mod cryptography;\npub mod introspection;\npub mod math;\npub mod metadata;\npub mod nonces;\npub mod pausable;\npub mod structs;\n\npub use metadata::Metadata;\npub use pausable::{IPausable, Pausable};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","nonces.rs"],"content":"//! Implementation of nonce tracking for addresses.\n//!\n//! Nonces will only increment.\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{uint, Address, U256};\nuse stylus_sdk::{\n    call::MethodError,\n    prelude::*,\n    storage::{StorageMap, StorageU256},\n};\n\nuse crate::utils::math::storage::AddAssignChecked;\n\nconst ONE: U256 = uint!(1_U256);\n\npub use sol::*;\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// The nonce used for an `account` is not the expected current nonce.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error InvalidAccountNonce(address account, uint256 current_nonce);\n    }\n}\n\n/// A Nonces error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// The nonce used for an `account` is not the expected current nonce.\n    InvalidAccountNonce(InvalidAccountNonce),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of a [`Nonces`] Contract.\n#[storage]\npub struct Nonces {\n    /// Mapping from address to its nonce.\n    pub(crate) nonces: StorageMap\u003cAddress, StorageU256\u003e,\n}\n\n/// Interface for [`Nonces`]\npub trait INonces {\n    /// Returns the unused nonce for the given account.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    /// * `owner` - The address for which to return the nonce.\n    #[must_use]\n    fn nonces(\u0026self, owner: Address) -\u003e U256;\n}\n\n#[public]\n#[implements(INonces)]\nimpl Nonces {}\n\n#[public]\nimpl INonces for Nonces {\n    fn nonces(\u0026self, owner: Address) -\u003e U256 {\n        self.nonces.get(owner)\n    }\n}\n\nimpl Nonces {\n    /// Consumes a nonce for the given `account`.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `owner` - The address for which to consume the nonce.\n    ///\n    /// # Panics\n    ///\n    /// * If the nonce for the given `owner` exceeds [`U256::MAX`].\n    pub fn use_nonce(\u0026mut self, owner: Address) -\u003e U256 {\n        let nonce = self.nonces.get(owner);\n\n        self.nonces\n            .setter(owner)\n            .add_assign_checked(ONE, \"nonce should not exceed `U256::MAX`\");\n\n        nonce\n    }\n\n    /// Same as `use_nonce` but checking that the `nonce` is the next valid for\n    /// the owner.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    /// * `owner` - The address for which to consume the nonce.\n    /// * `nonce` - The nonce to consume.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::InvalidAccountNonce`] - Returns an error if the `nonce` is\n    ///   not the next valid nonce for the owner.\n    ///\n    /// # Panics\n    ///\n    /// * If the nonce for the given `owner` exceeds [`U256::MAX`].\n    pub fn use_checked_nonce(\n        \u0026mut self,\n        owner: Address,\n        nonce: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        let current_nonce = self.use_nonce(owner);\n\n        if nonce != current_nonce {\n            return Err(Error::InvalidAccountNonce(InvalidAccountNonce {\n                account: owner,\n                current_nonce,\n            }));\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{Address, U256};\n    use motsu::prelude::Contract;\n    use stylus_sdk::prelude::*;\n\n    use super::ONE;\n    use crate::utils::nonces::{Error, INonces, Nonces};\n\n    unsafe impl TopLevelStorage for Nonces {}\n\n    #[motsu::test]\n    fn initiate_nonce(contract: Contract\u003cNonces\u003e, alice: Address) {\n        assert_eq!(contract.sender(alice).nonces(alice), U256::ZERO);\n    }\n\n    #[motsu::test]\n    fn use_nonce(contract: Contract\u003cNonces\u003e, alice: Address) {\n        let use_nonce = contract.sender(alice).use_nonce(alice);\n        assert_eq!(use_nonce, U256::ZERO);\n\n        let nonce = contract.sender(alice).nonces(alice);\n        assert_eq!(nonce, ONE);\n    }\n\n    #[motsu::test]\n    fn use_checked_nonce(contract: Contract\u003cNonces\u003e, alice: Address) {\n        let use_checked_nonce =\n            contract.sender(alice).use_checked_nonce(alice, U256::ZERO);\n        assert!(use_checked_nonce.is_ok());\n\n        let nonce = contract.sender(alice).nonces(alice);\n        assert_eq!(nonce, ONE);\n    }\n\n    #[motsu::test]\n    fn use_checked_nonce_invalid_nonce(\n        contract: Contract\u003cNonces\u003e,\n        alice: Address,\n    ) {\n        let use_checked_nonce =\n            contract.sender(alice).use_checked_nonce(alice, ONE);\n        assert!(matches!(\n            use_checked_nonce,\n            Err(Error::InvalidAccountNonce(_))\n        ));\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":9}},{"line":85,"address":[],"length":0,"stats":{"Line":3}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":9}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":8}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}}],"covered":14,"coverable":16},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","pausable.rs"],"content":"//! Pausable Contract.\n//!\n//! Contract module which allows implementing an emergency stop mechanism\n//! that can be triggered by an authorized account.\n//!\n//! It provides functions [`Pausable::when_not_paused`]\n//! and [`Pausable::when_paused`],\n//! which can be added to the functions of your contract.\n//!\n//! Note that your contract will not be pausable by simply including this\n//! module, only once and where you use [`Pausable::when_not_paused`].\n//!\n//! Note that [`Pausable::pause`] and [`Pausable::unpause`] methods are not\n//! exposed by default.\n//! You should expose them manually in your contract's abi.\n\nuse alloc::{vec, vec::Vec};\n\npub use sol::*;\nuse stylus_sdk::{\n    call::MethodError, evm, msg, prelude::*, storage::StorageBool,\n};\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// Emitted when pause is triggered by `account`.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event Paused(address account);\n\n        /// Emitted when the pause is lifted by `account`.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        event Unpaused(address account);\n    }\n\n    sol! {\n        /// Indicates an error related to the operation that failed\n        /// because the contract is paused.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error EnforcedPause();\n\n        /// Indicates an error related to the operation that failed\n        /// because the contract is not paused.\n        #[derive(Debug)]\n        #[allow(missing_docs)]\n        error ExpectedPause();\n    }\n}\n\n/// A Pausable error.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// Indicates an error related to the operation that failed\n    /// because the contract had been in `Paused` state.\n    EnforcedPause(EnforcedPause),\n    /// Indicates an error related to the operation that failed\n    /// because the contract had been in `Unpaused` state.\n    ExpectedPause(ExpectedPause),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of a [`Pausable`] Contract.\n#[storage]\npub struct Pausable {\n    /// Indicates whether the contract is `Paused`.\n    pub(crate) paused: StorageBool,\n}\n\n/// Pausable interface.\npub trait IPausable {\n    /// Returns true if the contract is paused, and false otherwise.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    fn paused(\u0026self) -\u003e bool;\n}\n\n#[public]\n#[implements(IPausable)]\nimpl Pausable {}\n\n#[public]\nimpl IPausable for Pausable {\n    fn paused(\u0026self) -\u003e bool {\n        self.paused.get()\n    }\n}\n\nimpl Pausable {\n    /// Triggers `Paused` state.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::EnforcedPause`] - If the contract is in `Paused` state.\n    pub fn pause(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.when_not_paused()?;\n        self.paused.set(true);\n        evm::log(Paused { account: msg::sender() });\n        Ok(())\n    }\n\n    /// Triggers `Unpaused` state.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::ExpectedPause`] - If the contract is in `Unpaused` state.\n    pub fn unpause(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.when_paused()?;\n        self.paused.set(false);\n        evm::log(Unpaused { account: msg::sender() });\n        Ok(())\n    }\n\n    /// Helper to make a function callable only when the contract is NOT\n    /// paused.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::EnforcedPause`] - If the contract is in the `Paused` state.\n    pub fn when_not_paused(\u0026self) -\u003e Result\u003c(), Error\u003e {\n        if self.paused.get() {\n            return Err(Error::EnforcedPause(EnforcedPause {}));\n        }\n        Ok(())\n    }\n\n    /// Helper to make a function callable\n    /// only when the contract is paused.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the contract's state.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::ExpectedPause`] - If the contract is in `Unpaused` state.\n    pub fn when_paused(\u0026self) -\u003e Result\u003c(), Error\u003e {\n        if !self.paused.get() {\n            return Err(Error::ExpectedPause(ExpectedPause {}));\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::Address;\n    use motsu::prelude::Contract;\n    use stylus_sdk::prelude::*;\n\n    use crate::utils::pausable::{Error, IPausable, Pausable};\n\n    unsafe impl TopLevelStorage for Pausable {}\n\n    fn construct_paused(contract: \u0026mut Pausable) {\n        contract.paused.set(true);\n    }\n    fn construct_unpaused(contract: \u0026mut Pausable) {\n        contract.paused.set(false);\n    }\n\n    #[motsu::test]\n    fn paused_works(contract: Contract\u003cPausable\u003e, alice: Address) {\n        contract.init(alice, construct_paused);\n        assert!(contract.sender(alice).paused());\n\n        contract.init(alice, construct_unpaused);\n        assert!(!contract.sender(alice).paused());\n    }\n\n    #[motsu::test]\n    fn when_not_paused_works(contract: Contract\u003cPausable\u003e, alice: Address) {\n        contract.init(alice, construct_unpaused);\n\n        let result = contract.sender(alice).when_not_paused();\n        assert!(result.is_ok());\n    }\n\n    #[motsu::test]\n    fn when_not_paused_errors_when_paused(\n        contract: Contract\u003cPausable\u003e,\n        alice: Address,\n    ) {\n        contract.init(alice, construct_paused);\n        assert!(contract.sender(alice).paused());\n\n        let result = contract.sender(alice).when_not_paused();\n        assert!(matches!(result, Err(Error::EnforcedPause(_))));\n    }\n\n    #[motsu::test]\n    fn when_paused_works(contract: Contract\u003cPausable\u003e, alice: Address) {\n        contract.sender(alice).pause().unwrap();\n        assert!(contract.sender(alice).paused());\n\n        let result = contract.sender(alice).when_paused();\n        assert!(result.is_ok());\n    }\n\n    #[motsu::test]\n    fn when_paused_errors_when_not_paused(\n        contract: Contract\u003cPausable\u003e,\n        alice: Address,\n    ) {\n        contract.init(alice, construct_unpaused);\n        assert!(!contract.sender(alice).paused());\n\n        let result = contract.sender(alice).when_paused();\n        assert!(matches!(result, Err(Error::ExpectedPause(_))));\n    }\n\n    #[motsu::test]\n    fn pause_works(contract: Contract\u003cPausable\u003e, alice: Address) {\n        contract.init(alice, construct_unpaused);\n        assert!(!contract.sender(alice).paused());\n\n        // Pause the contract\n        let res = contract.sender(alice).pause();\n        assert!(res.is_ok());\n        assert!(contract.sender(alice).paused());\n    }\n\n    #[motsu::test]\n    fn pause_errors_when_already_paused(\n        contract: Contract\u003cPausable\u003e,\n        alice: Address,\n    ) {\n        contract.init(alice, construct_paused);\n        assert!(contract.sender(alice).paused());\n\n        let result = contract.sender(alice).pause();\n        assert!(matches!(result, Err(Error::EnforcedPause(_))));\n        assert!(contract.sender(alice).paused());\n    }\n\n    #[motsu::test]\n    fn unpause_works(contract: Contract\u003cPausable\u003e, alice: Address) {\n        contract.init(alice, construct_paused);\n        assert!(contract.sender(alice).paused());\n\n        // Unpause the paused contract\n        let res = contract.sender(alice).unpause();\n        assert!(res.is_ok());\n        assert!(!contract.sender(alice).paused());\n    }\n\n    #[motsu::test]\n    fn unpause_errors_when_already_unpaused(\n        contract: Contract\u003cPausable\u003e,\n        alice: Address,\n    ) {\n        contract.init(alice, construct_unpaused);\n        assert!(!contract.sender(alice).paused());\n\n        // Unpause the unpaused contract\n        let result = contract.sender(alice).unpause();\n        assert!(matches!(result, Err(Error::ExpectedPause(_))));\n        assert!(!contract.sender(alice).paused());\n    }\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":13}},{"line":96,"address":[],"length":0,"stats":{"Line":26}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":7}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":5}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":5}},{"line":144,"address":[],"length":0,"stats":{"Line":10}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":4}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}}],"covered":15,"coverable":17},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","structs","bitmap.rs"],"content":"//! Contract module for managing `U256` to boolean mapping in a compact and\n//! efficient way, provided the keys are sequential. Largely inspired by\n//! Uniswap's [merkle-distributor].\n//!\n//! `BitMap` packs 256 booleans across each bit of a single 256-bit slot of\n//! `U256` type. Hence, booleans corresponding to 256 _sequential_ indices\n//! would only consume a single slot, unlike the regular boolean which would\n//! consume an entire slot for a single value.\n//!\n//! This results in gas savings in two ways:\n//!\n//! - Setting a zero value to non-zero only once every 256 times\n//! - Accessing the same warm slot for every 256 _sequential_ indices\n//!\n//! [merkle-distributor]: https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{uint, U256};\nuse stylus_sdk::{\n    prelude::*,\n    storage::{StorageMap, StorageU256},\n};\nconst ONE: U256 = uint!(0x1_U256);\nconst HEX_FF: U256 = uint!(0xff_U256);\n\n/// State of a [`BitMap`] contract.\n#[storage]\npub struct BitMap {\n    /// Inner laying mapping.\n    pub(crate) data: StorageMap\u003cU256, StorageU256\u003e,\n}\n\nimpl BitMap {\n    /// Returns whether the bit at `index` is set.\n    ///\n    /// # Arguments\n    ///\n    /// * `index` - index of the boolean value in the bit map.\n    #[must_use]\n    pub fn get(\u0026self, index: U256) -\u003e bool {\n        let bucket = Self::get_bucket(index);\n        let mask = Self::get_mask(index);\n        let value = self.data.get(bucket);\n        (value \u0026 mask) != U256::ZERO\n    }\n\n    /// Sets the bit at `index` to the boolean `value`.\n    ///\n    /// # Arguments\n    ///\n    /// * `index` - index of boolean value in the bit map.\n    /// * `value` - boolean value to set in the bit map.\n    pub fn set_to(\u0026mut self, index: U256, value: bool) {\n        if value {\n            self.set(index);\n        } else {\n            self.unset(index);\n        }\n    }\n\n    /// Sets the bit at `index`.\n    ///\n    /// # Arguments\n    ///\n    /// * `index` - index of boolean value that should be set `true`.\n    pub fn set(\u0026mut self, index: U256) {\n        let bucket = Self::get_bucket(index);\n        let mask = Self::get_mask(index);\n        let mut value = self.data.setter(bucket);\n        let prev = value.get();\n        value.set(prev | mask);\n    }\n\n    /// Unsets the bit at `index`.\n    ///\n    /// # Arguments\n    ///\n    /// * `index` - index of boolean value that should be set `false`.\n    pub fn unset(\u0026mut self, index: U256) {\n        let bucket = Self::get_bucket(index);\n        let mask = Self::get_mask(index);\n        let mut value = self.data.setter(bucket);\n        let prev = value.get();\n        value.set(prev \u0026 !mask);\n    }\n\n    /// Get mask of value in the bucket.\n    fn get_mask(index: U256) -\u003e U256 {\n        ONE \u003c\u003c (index \u0026 HEX_FF)\n    }\n\n    /// Get bucket index.\n    fn get_bucket(index: U256) -\u003e U256 {\n        index \u003e\u003e 8\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{\n        private::proptest::{prop_assert, proptest},\n        Address, U256,\n    };\n    use motsu::prelude::Contract;\n    use stylus_sdk::prelude::{public, TopLevelStorage};\n\n    use crate::utils::structs::bitmap::BitMap;\n\n    unsafe impl TopLevelStorage for BitMap {}\n\n    #[public]\n    impl BitMap {}\n\n    #[motsu::test]\n    fn set_value() {\n        proptest!(|(value: U256, alice: Address)| {\n            let bit_map = Contract::\u003cBitMap\u003e::new();\n            let mut bit_map = bit_map.sender(alice);\n            prop_assert!(!bit_map.get(value));\n            bit_map.set(value);\n            prop_assert!(bit_map.get(value));\n        });\n    }\n\n    #[motsu::test]\n    fn unset_value() {\n        proptest!(|(value: U256, alice: Address)| {\n            let bit_map = Contract::\u003cBitMap\u003e::new();\n            let mut bit_map = bit_map.sender(alice);\n            bit_map.set(value);\n            prop_assert!(bit_map.get(value));\n            bit_map.unset(value);\n            prop_assert!(!bit_map.get(value));\n        });\n    }\n\n    #[motsu::test]\n    fn set_to_value() {\n        proptest!(|(value: U256, alice: Address)| {\n            let bit_map = Contract::\u003cBitMap\u003e::new();\n            let mut bit_map = bit_map.sender(alice);\n            bit_map.set_to(value, true);\n            prop_assert!(bit_map.get(value));\n            bit_map.set_to(value, false);\n            prop_assert!(!bit_map.get(value));\n        });\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":1558}},{"line":41,"address":[],"length":0,"stats":{"Line":4674}},{"line":42,"address":[],"length":0,"stats":{"Line":4674}},{"line":43,"address":[],"length":0,"stats":{"Line":6232}},{"line":44,"address":[],"length":0,"stats":{"Line":1558}},{"line":53,"address":[],"length":0,"stats":{"Line":512}},{"line":54,"address":[],"length":0,"stats":{"Line":768}},{"line":55,"address":[],"length":0,"stats":{"Line":512}},{"line":57,"address":[],"length":0,"stats":{"Line":256}},{"line":66,"address":[],"length":0,"stats":{"Line":769}},{"line":67,"address":[],"length":0,"stats":{"Line":2307}},{"line":68,"address":[],"length":0,"stats":{"Line":2307}},{"line":69,"address":[],"length":0,"stats":{"Line":3076}},{"line":70,"address":[],"length":0,"stats":{"Line":1538}},{"line":71,"address":[],"length":0,"stats":{"Line":2307}},{"line":79,"address":[],"length":0,"stats":{"Line":512}},{"line":80,"address":[],"length":0,"stats":{"Line":1536}},{"line":81,"address":[],"length":0,"stats":{"Line":1536}},{"line":82,"address":[],"length":0,"stats":{"Line":2048}},{"line":83,"address":[],"length":0,"stats":{"Line":1024}},{"line":84,"address":[],"length":0,"stats":{"Line":1536}},{"line":88,"address":[],"length":0,"stats":{"Line":2839}},{"line":89,"address":[],"length":0,"stats":{"Line":2839}},{"line":93,"address":[],"length":0,"stats":{"Line":2839}},{"line":94,"address":[],"length":0,"stats":{"Line":2839}}],"covered":25,"coverable":25},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","structs","checkpoints","generic_size.rs"],"content":"//! Contains generic size utilities for checkpoint storage contract.\n\nuse core::ops::{Add, Div, Mul, Sub};\n\nuse alloy_sol_types::sol_data::{IntBitCount, SupportedInt};\nuse stylus_sdk::{alloy_primitives::Uint, prelude::*};\n\n/// Trait that associates types of specific size for checkpoints key and value.\npub trait Size {\n    /// Type of the key in abi.\n    type Key: Num;\n\n    /// Type of the key in storage.\n    type KeyStorage: for\u003c'a\u003e StorageType\u003cWraps\u003c'a\u003e = Self::Key\u003e\n        + Accessor\u003cWraps = Self::Key\u003e;\n\n    /// Type of the value in abi.\n    type Value: Num;\n\n    /// Type of the value in storage.\n    type ValueStorage: for\u003c'a\u003e StorageType\u003cWraps\u003c'a\u003e = Self::Value\u003e\n        + Accessor\u003cWraps = Self::Value\u003e;\n}\n\n/// Defines size of checkpoint storage contract with specific key and value\n/// bits.\n///\n/// # Arguments\n///\n/// * `$name` - Identifier of the typed size.\n/// * `$key_bits` - Number of bits in checkpoint's key.\n/// * `$value_bits` - Number of bits in checkpoint's value.\nmacro_rules! define_checkpoint_size {\n    ($name:ident, $key_bits:expr, $value_bits:expr) =\u003e {\n        #[doc = \"Size of checkpoint storage contract with\"]\n        #[doc = stringify!($key_bits)]\n        #[doc = \"bit key and \"]\n        #[doc = stringify!($value_bits)]\n        #[doc = \"bit value.\"]\n        pub struct $name;\n\n        impl Size for $name {\n            type Key = stylus_sdk::alloy_primitives::Uint\u003c\n                $key_bits,\n                { usize::div_ceil($key_bits, 64) },\n            \u003e;\n            type KeyStorage = stylus_sdk::storage::StorageUint\u003c\n                $key_bits,\n                { usize::div_ceil($key_bits, 64) },\n            \u003e;\n            type Value = stylus_sdk::alloy_primitives::Uint\u003c\n                $value_bits,\n                { usize::div_ceil($value_bits, 64) },\n            \u003e;\n            type ValueStorage = stylus_sdk::storage::StorageUint\u003c\n                $value_bits,\n                { usize::div_ceil($value_bits, 64) },\n            \u003e;\n        }\n    };\n}\n\ndefine_checkpoint_size!(S160, 96, 160);\ndefine_checkpoint_size!(S224, 32, 224);\ndefine_checkpoint_size!(S208, 48, 208);\n\n/// Abstracts number inside the checkpoint contract.\npub trait Num: Add + Sub + Mul + Div + Ord + Sized + Copy {\n    /// Zero value of the number.\n    const ZERO: Self;\n}\n\nimpl\u003cconst B: usize, const L: usize\u003e Num for Uint\u003cB, L\u003e {\n    const ZERO: Self = Self::ZERO;\n}\n\n/// Abstracts accessor inside the checkpoint contract.\npub trait Accessor {\n    /// Type of the number associated with the storage type.\n    type Wraps: Num;\n\n    /// Gets underlying element [`Self::Wraps`] from persistent storage.\n    fn get(\u0026self) -\u003e Self::Wraps;\n\n    /// Sets underlying element [`Self::Wraps`] in persistent storage.\n    fn set(\u0026mut self, value: Self::Wraps);\n}\n\nimpl\u003cconst B: usize, const L: usize\u003e Accessor\n    for stylus_sdk::storage::StorageUint\u003cB, L\u003e\nwhere\n    IntBitCount\u003cB\u003e: SupportedInt,\n{\n    type Wraps = Uint\u003cB, L\u003e;\n\n    fn get(\u0026self) -\u003e Self::Wraps {\n        self.get()\n    }\n\n    fn set(\u0026mut self, value: Self::Wraps) {\n        self.set(value);\n    }\n}\n","traces":[{"line":96,"address":[],"length":0,"stats":{"Line":116}},{"line":97,"address":[],"length":0,"stats":{"Line":232}},{"line":100,"address":[],"length":0,"stats":{"Line":59}},{"line":101,"address":[],"length":0,"stats":{"Line":177}}],"covered":4,"coverable":4},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","structs","checkpoints","mod.rs"],"content":"//! Contract for checkpointing values as they change at different points in\n//! time, and later looking up and later looking up past values by block number.\n//!\n//! To create a history of checkpoints, define a variable type [`Trace`]\n//! in your contract.\n//! Types [`S160`], [`S160`] and [`S160`] can be used to\n//! define sizes for key and value.\n//! Then store a new checkpoint for the current\n//! transaction block using the [`Trace::push`] function.\npub mod generic_size;\n\nuse alloc::{vec, vec::Vec};\n\nuse alloy_primitives::{uint, U256, U32};\npub use generic_size::{Size, S160, S208, S224};\npub use sol::*;\nuse stylus_sdk::{\n    call::MethodError,\n    prelude::*,\n    storage::{StorageGuard, StorageGuardMut, StorageVec},\n};\n\nuse crate::utils::{\n    math::alloy::Math,\n    structs::checkpoints::generic_size::{Accessor, Num},\n};\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nmod sol {\n    use alloy_sol_macro::sol;\n\n    sol! {\n        /// A value was attempted to be inserted into a past checkpoint.\n        #[derive(Debug)]\n        error CheckpointUnorderedInsertion();\n    }\n}\n\n/// An error that occurred while calling the [`Trace`] checkpoint contract.\n#[derive(SolidityError, Debug)]\npub enum Error {\n    /// A value was attempted to be inserted into a past checkpoint.\n    CheckpointUnorderedInsertion(CheckpointUnorderedInsertion),\n}\n\nimpl MethodError for Error {\n    fn encode(self) -\u003e alloc::vec::Vec\u003cu8\u003e {\n        self.into()\n    }\n}\n\n/// State of a [`Trace`] contract.\n#[storage]\npub struct Trace\u003cS: Size\u003e {\n    /// Stores checkpoints in a dynamic array sorted by key.\n    pub(crate) checkpoints: StorageVec\u003cCheckpoint\u003cS\u003e\u003e,\n}\n\n/// State of a [`Checkpoint`] contract.\n#[storage]\npub struct Checkpoint\u003cS: Size\u003e {\n    /// The key of the checkpoint. Used as a sorting key.\n    pub(crate) key: S::KeyStorage,\n    /// The value corresponding to the key.\n    pub(crate) value: S::ValueStorage,\n}\n\nimpl\u003cS: Size\u003e Trace\u003cS\u003e {\n    /// Pushes a (`key`, `value`) pair into a `Trace` so that it is\n    /// stored as the checkpoint.\n    ///\n    /// Returns the previous value and the new value as an ordered pair.\n    ///\n    /// IMPORTANT: Never accept `key` as user input, since an arbitrary\n    /// `U96::MAX` key set will disable the library.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the checkpoint's state.\n    /// * `key` - Latest checkpoint key to insert.\n    /// * `value` - Checkpoint value corresponding to `key`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::CheckpointUnorderedInsertion`] - If the `key` is lower than\n    ///   previously pushed checkpoint's key (necessary to maintain sorted\n    ///   order).\n    pub fn push(\n        \u0026mut self,\n        key: S::Key,\n        value: S::Value,\n    ) -\u003e Result\u003c(S::Value, S::Value), Error\u003e {\n        self._insert(key, value)\n    }\n\n    /// Returns the value in the first (oldest) checkpoint with key greater or\n    /// equal than the search key, or `S::Value::ZERO` if there is none.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the checkpoint's state.\n    /// * `key` - Checkpoint's key to lookup.\n    pub fn lower_lookup(\u0026self, key: S::Key) -\u003e S::Value {\n        let len = self.length();\n        let pos = self._lower_binary_lookup(key, U256::ZERO, len);\n        if pos == len {\n            S::Value::ZERO\n        } else {\n            self._index(pos).value.get()\n        }\n    }\n\n    /// Returns the value in the last (most recent) checkpoint with key\n    /// lower or equal than the search key, or `S::Value::ZERO` if there is\n    /// none.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the checkpoint's state.\n    /// * `key` - Checkpoint's key to lookup.\n    pub fn upper_lookup(\u0026self, key: S::Key) -\u003e S::Value {\n        let len = self.length();\n        let pos = self._upper_binary_lookup(key, U256::ZERO, len);\n        if pos == U256::ZERO {\n            S::Value::ZERO\n        } else {\n            self._index(pos - uint!(1_U256)).value.get()\n        }\n    }\n\n    /// Returns the value in the last (most recent) checkpoint with key lower or\n    /// equal than the search key, or `S::Value::ZERO` if there is none.\n    ///\n    /// This is a variant of [`Self::upper_lookup`] that is optimized to find\n    /// \"recent\" checkpoints (checkpoints with high keys).\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the checkpoint's state.\n    /// * `key` - Checkpoint's key to query.\n    pub fn upper_lookup_recent(\u0026self, key: S::Key) -\u003e S::Value {\n        let len = self.length();\n\n        let mut low = U256::ZERO;\n        let mut high = len;\n\n        if len \u003e uint!(5_U256) {\n            let mid = len - len.sqrt();\n            if key \u003c self._index(mid).key.get() {\n                high = mid;\n            } else {\n                low = mid + uint!(1_U256);\n            }\n        }\n\n        let pos = self._upper_binary_lookup(key, low, high);\n\n        if pos == U256::ZERO {\n            S::Value::ZERO\n        } else {\n            self._index(pos - uint!(1_U256)).value.get()\n        }\n    }\n\n    /// Returns the value in the most recent checkpoint, or `S::Value::ZERO` if\n    /// there are no checkpoints.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the checkpoint's state.\n    pub fn latest(\u0026self) -\u003e S::Value {\n        let pos = self.length();\n        if pos == U256::ZERO {\n            S::Value::ZERO\n        } else {\n            self._index(pos - uint!(1_U256)).value.get()\n        }\n    }\n\n    /// Returns whether there is a checkpoint in the structure (i.g. it is not\n    /// empty), and if so, the key and value in the most recent checkpoint.\n    /// Otherwise, [`None`] will be returned.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the checkpoint's state.\n    pub fn latest_checkpoint(\u0026self) -\u003e Option\u003c(S::Key, S::Value)\u003e {\n        let pos = self.length();\n        if pos == U256::ZERO {\n            None\n        } else {\n            let checkpoint = self._index(pos - uint!(1_U256));\n            Some((checkpoint.key.get(), checkpoint.value.get()))\n        }\n    }\n\n    /// Returns the number of checkpoints.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the checkpoint's state.\n    pub fn length(\u0026self) -\u003e U256 {\n        U256::from(self.checkpoints.len())\n    }\n\n    /// Returns checkpoint at given position.\n    ///\n    /// # Panics\n    ///\n    /// If `pos` exceeds [`Self::length`].\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the checkpoint's state.\n    /// * `pos` - Index of the checkpoint.\n    pub fn at(\u0026self, pos: U32) -\u003e (S::Key, S::Value) {\n        let guard = self.checkpoints.get(pos).unwrap_or_else(|| {\n            panic!(\"should get checkpoint at index `{pos}`\")\n        });\n        (guard.key.get(), guard.value.get())\n    }\n\n    /// Pushes a (`key`, `value`) pair into an ordered list of checkpoints,\n    /// either by inserting a new checkpoint, or by updating the last one.\n    /// Returns the previous value and the new value as an ordered pair.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the checkpoint's state.\n    /// * `key` - The key of the checkpoint to insert.\n    /// * `value` - Checkpoint value corresponding to insertion `key`.\n    ///\n    /// # Errors\n    ///\n    /// * [`Error::CheckpointUnorderedInsertion`] - If the `key` is lower than\n    ///   the previously inserted one.\n    fn _insert(\n        \u0026mut self,\n        key: S::Key,\n        value: S::Value,\n    ) -\u003e Result\u003c(S::Value, S::Value), Error\u003e {\n        let pos = self.length();\n        if pos \u003e U256::ZERO {\n            let last = self._index(pos - uint!(1_U256));\n            let last_key = last.key.get();\n            let last_value = last.value.get();\n\n            // Checkpoint keys must be non-decreasing.\n            if last_key \u003e key {\n                return Err(CheckpointUnorderedInsertion {}.into());\n            }\n\n            // Update or push new checkpoint\n            if last_key == key {\n                self._index_mut(pos - uint!(1_U256)).value.set(value);\n            } else {\n                self._unchecked_push(key, value);\n            }\n            Ok((last_value, value))\n        } else {\n            self._unchecked_push(key, value);\n            Ok((S::Value::ZERO, value))\n        }\n    }\n\n    /// Return the index of the last (most recent) checkpoint with key lower or\n    /// equal than the search key, or `high` if there is none.\n    ///\n    /// Indexes `low` and `high` define a section where to do the search, with\n    /// inclusive `low` and exclusive `high`.\n    ///\n    /// WARNING: `high` should not be greater than the array's length.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the checkpoint's state.\n    /// * `key` - Checkpoint key to lookup.\n    /// * `low` - Inclusive index where search begins.\n    /// * `high` - Exclusive index where search ends.\n    fn _upper_binary_lookup(\n        \u0026self,\n        key: S::Key,\n        mut low: U256,\n        mut high: U256,\n    ) -\u003e U256 {\n        while low \u003c high {\n            let mid = low.average(high);\n            if self._index(mid).key.get() \u003e key {\n                high = mid;\n            } else {\n                low = mid + uint!(1_U256);\n            }\n        }\n        high\n    }\n\n    /// Return the index of the first (oldest) checkpoint with key is greater or\n    /// equal than the search key, or `high` if there is none.\n    ///\n    /// Indexes `low` and `high` define a section where to do the search, with\n    /// inclusive `low` and exclusive `high`.\n    ///\n    /// WARNING: `high` should not be greater than the array's length.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the checkpoint's state.\n    /// * `key` - Checkpoint key to lookup.\n    /// * `low` - Inclusive index where search begins.\n    /// * `high` - Exclusive index where search ends.\n    fn _lower_binary_lookup(\n        \u0026self,\n        key: S::Key,\n        mut low: U256,\n        mut high: U256,\n    ) -\u003e U256 {\n        while low \u003c high {\n            let mid = low.average(high);\n            if self._index(mid).key.get() \u003c key {\n                low = mid + uint!(1_U256);\n            } else {\n                high = mid;\n            }\n        }\n        high\n    }\n\n    /// Immutable access on an element of the checkpoint's array. The position\n    /// is assumed to be within bounds.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Read access to the checkpoint's state.\n    /// * `pos` - Index of the checkpoint.\n    ///\n    /// # Panics\n    ///\n    /// * If `pos` exceeds [`Self::length`].\n    fn _index(\u0026self, pos: U256) -\u003e StorageGuard\u003cCheckpoint\u003cS\u003e\u003e {\n        self.checkpoints\n            .get(pos)\n            .unwrap_or_else(|| panic!(\"should get checkpoint at index `{pos}`\"))\n    }\n\n    /// Mutable access on an element of the checkpoint's array. The position is\n    /// assumed to be within bounds.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the checkpoint's state.\n    /// * `pos` - Index of the checkpoint.\n    ///\n    /// # Panics\n    ///\n    /// * If `pos` exceeds [`Self::length`].\n    fn _index_mut(\u0026mut self, pos: U256) -\u003e StorageGuardMut\u003cCheckpoint\u003cS\u003e\u003e {\n        self.checkpoints\n            .setter(pos)\n            .unwrap_or_else(|| panic!(\"should get checkpoint at index `{pos}`\"))\n    }\n\n    /// Append a checkpoint without checking if the sorted order is kept.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026mut self` - Write access to the checkpoint's state.\n    /// * `key` - Checkpoint key to insert.\n    /// * `value` - Checkpoint value corresponding to insertion `key`.\n    fn _unchecked_push(\u0026mut self, key: S::Key, value: S::Value) {\n        let mut new_checkpoint = self.checkpoints.grow();\n        new_checkpoint.key.set(key);\n        new_checkpoint.value.set(value);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloy_primitives::{uint, Address};\n    use stylus_sdk::prelude::*;\n\n    use super::{\n        generic_size::S160, CheckpointUnorderedInsertion, Error, Trace,\n    };\n\n    unsafe impl TopLevelStorage for Trace\u003cS160\u003e {}\n\n    #[public]\n    impl Trace\u003cS160\u003e {}\n\n    use motsu::prelude::Contract;\n\n    #[motsu::test]\n    fn push(checkpoint: Contract\u003cTrace\u003cS160\u003e\u003e, alice: Address) {\n        let first_key = uint!(1_U96);\n        let first_value = uint!(11_U160);\n\n        let second_key = uint!(2_U96);\n        let second_value = uint!(22_U160);\n\n        let third_key = uint!(3_U96);\n        let third_value = uint!(33_U160);\n\n        checkpoint\n            .sender(alice)\n            .push(first_key, first_value)\n            .expect(\"push first\");\n        checkpoint\n            .sender(alice)\n            .push(second_key, second_value)\n            .expect(\"push second\");\n        checkpoint\n            .sender(alice)\n            .push(third_key, third_value)\n            .expect(\"push third\");\n\n        assert_eq!(checkpoint.sender(alice).length(), uint!(3_U256));\n\n        assert_eq!(\n            checkpoint.sender(alice).at(uint!(0_U32)),\n            (first_key, first_value)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).at(uint!(1_U32)),\n            (second_key, second_value)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).at(uint!(2_U32)),\n            (third_key, third_value)\n        );\n    }\n\n    #[motsu::test]\n    fn push_same_value(checkpoint: Contract\u003cTrace\u003cS160\u003e\u003e, alice: Address) {\n        let first_key = uint!(1_U96);\n        let first_value = uint!(11_U160);\n\n        let second_key = uint!(2_U96);\n        let second_value = uint!(22_U160);\n\n        let third_key = uint!(2_U96);\n        let third_value = uint!(222_U160);\n\n        checkpoint\n            .sender(alice)\n            .push(first_key, first_value)\n            .expect(\"push first\");\n        checkpoint\n            .sender(alice)\n            .push(second_key, second_value)\n            .expect(\"push second\");\n        checkpoint\n            .sender(alice)\n            .push(third_key, third_value)\n            .expect(\"push third\");\n\n        assert_eq!(\n            checkpoint.sender(alice).length(),\n            uint!(2_U256),\n            \"two checkpoints should be stored since third_value overrides second_value\"\n        );\n\n        assert_eq!(\n            checkpoint.sender(alice).at(uint!(0_U32)),\n            (first_key, first_value)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).at(uint!(1_U32)),\n            (third_key, third_value)\n        );\n    }\n    #[motsu::test]\n    fn lower_lookup(checkpoint: Contract\u003cTrace\u003cS160\u003e\u003e, alice: Address) {\n        checkpoint\n            .sender(alice)\n            .push(uint!(1_U96), uint!(11_U160))\n            .expect(\"push first\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(3_U96), uint!(33_U160))\n            .expect(\"push second\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(5_U96), uint!(55_U160))\n            .expect(\"push third\");\n\n        assert_eq!(\n            checkpoint.sender(alice).lower_lookup(uint!(2_U96)),\n            uint!(33_U160)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).lower_lookup(uint!(3_U96)),\n            uint!(33_U160)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).lower_lookup(uint!(4_U96)),\n            uint!(55_U160)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).lower_lookup(uint!(6_U96)),\n            uint!(0_U160)\n        );\n    }\n\n    #[motsu::test]\n    fn upper_lookup(checkpoint: Contract\u003cTrace\u003cS160\u003e\u003e, alice: Address) {\n        checkpoint\n            .sender(alice)\n            .push(uint!(1_U96), uint!(11_U160))\n            .expect(\"push first\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(3_U96), uint!(33_U160))\n            .expect(\"push second\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(5_U96), uint!(55_U160))\n            .expect(\"push third\");\n\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup(uint!(2_U96)),\n            uint!(11_U160)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup(uint!(1_U96)),\n            uint!(11_U160)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup(uint!(4_U96)),\n            uint!(33_U160)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup(uint!(0_U96)),\n            uint!(0_U160)\n        );\n    }\n\n    #[motsu::test]\n    fn upper_lookup_recent(checkpoint: Contract\u003cTrace\u003cS160\u003e\u003e, alice: Address) {\n        // `upper_lookup_recent` has different optimizations for \"short\" (\u003c=5)\n        // and \"long\" (\u003e5) checkpoint arrays.\n        //\n        // Validate the first approach for a short checkpoint array.\n        checkpoint\n            .sender(alice)\n            .push(uint!(1_U96), uint!(11_U160))\n            .expect(\"push first\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(3_U96), uint!(33_U160))\n            .expect(\"push second\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(5_U96), uint!(55_U160))\n            .expect(\"push third\");\n\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup_recent(uint!(2_U96)),\n            uint!(11_U160)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup_recent(uint!(1_U96)),\n            uint!(11_U160)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup_recent(uint!(4_U96)),\n            uint!(33_U160)\n        );\n\n        // Validate the second approach for a long checkpoint array.\n        checkpoint\n            .sender(alice)\n            .push(uint!(7_U96), uint!(77_U160))\n            .expect(\"push fourth\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(9_U96), uint!(99_U160))\n            .expect(\"push fifth\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(11_U96), uint!(111_U160))\n            .expect(\"push sixth\");\n\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup_recent(uint!(7_U96)),\n            uint!(77_U160)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup_recent(uint!(9_U96)),\n            uint!(99_U160)\n        );\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup_recent(uint!(11_U96)),\n            uint!(111_U160)\n        );\n\n        assert_eq!(\n            checkpoint.sender(alice).upper_lookup_recent(uint!(0_U96)),\n            uint!(0_U160)\n        );\n    }\n\n    #[motsu::test]\n    fn latest(checkpoint: Contract\u003cTrace\u003cS160\u003e\u003e, alice: Address) {\n        assert_eq!(checkpoint.sender(alice).latest(), uint!(0_U160));\n        checkpoint\n            .sender(alice)\n            .push(uint!(1_U96), uint!(11_U160))\n            .expect(\"push first\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(3_U96), uint!(33_U160))\n            .expect(\"push second\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(5_U96), uint!(55_U160))\n            .expect(\"push third\");\n        assert_eq!(checkpoint.sender(alice).latest(), uint!(55_U160));\n    }\n\n    #[motsu::test]\n    fn latest_checkpoint(checkpoint: Contract\u003cTrace\u003cS160\u003e\u003e, alice: Address) {\n        assert_eq!(checkpoint.sender(alice).latest_checkpoint(), None);\n        checkpoint\n            .sender(alice)\n            .push(uint!(1_U96), uint!(11_U160))\n            .expect(\"push first\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(3_U96), uint!(33_U160))\n            .expect(\"push second\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(5_U96), uint!(55_U160))\n            .expect(\"push third\");\n        assert_eq!(\n            checkpoint.sender(alice).latest_checkpoint(),\n            Some((uint!(5_U96), uint!(55_U160)))\n        );\n    }\n\n    #[motsu::test]\n    fn error_when_unordered_insertion(\n        checkpoint: Contract\u003cTrace\u003cS160\u003e\u003e,\n        alice: Address,\n    ) {\n        checkpoint\n            .sender(alice)\n            .push(uint!(1_U96), uint!(11_U160))\n            .expect(\"push first\");\n        checkpoint\n            .sender(alice)\n            .push(uint!(3_U96), uint!(33_U160))\n            .expect(\"push second\");\n        let err = checkpoint\n            .sender(alice)\n            .push(uint!(2_U96), uint!(22_U160))\n            .expect_err(\"should not push value lower then last one\");\n        assert!(matches!(\n            err,\n            Error::CheckpointUnorderedInsertion(\n                CheckpointUnorderedInsertion {}\n            )\n        ));\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":31}},{"line":93,"address":[],"length":0,"stats":{"Line":124}},{"line":103,"address":[],"length":0,"stats":{"Line":24}},{"line":104,"address":[],"length":0,"stats":{"Line":72}},{"line":105,"address":[],"length":0,"stats":{"Line":120}},{"line":106,"address":[],"length":0,"stats":{"Line":24}},{"line":107,"address":[],"length":0,"stats":{"Line":19}},{"line":109,"address":[],"length":0,"stats":{"Line":5}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":12}},{"line":123,"address":[],"length":0,"stats":{"Line":20}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":7}},{"line":142,"address":[],"length":0,"stats":{"Line":21}},{"line":144,"address":[],"length":0,"stats":{"Line":14}},{"line":145,"address":[],"length":0,"stats":{"Line":14}},{"line":147,"address":[],"length":0,"stats":{"Line":7}},{"line":148,"address":[],"length":0,"stats":{"Line":12}},{"line":149,"address":[],"length":0,"stats":{"Line":14}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":42}},{"line":158,"address":[],"length":0,"stats":{"Line":7}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":6}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":6}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":11}},{"line":188,"address":[],"length":0,"stats":{"Line":33}},{"line":189,"address":[],"length":0,"stats":{"Line":11}},{"line":190,"address":[],"length":0,"stats":{"Line":6}},{"line":192,"address":[],"length":0,"stats":{"Line":5}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":81}},{"line":203,"address":[],"length":0,"stats":{"Line":243}},{"line":216,"address":[],"length":0,"stats":{"Line":5}},{"line":217,"address":[],"length":0,"stats":{"Line":25}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":15}},{"line":237,"address":[],"length":0,"stats":{"Line":31}},{"line":242,"address":[],"length":0,"stats":{"Line":93}},{"line":243,"address":[],"length":0,"stats":{"Line":31}},{"line":244,"address":[],"length":0,"stats":{"Line":80}},{"line":245,"address":[],"length":0,"stats":{"Line":60}},{"line":246,"address":[],"length":0,"stats":{"Line":60}},{"line":249,"address":[],"length":0,"stats":{"Line":20}},{"line":250,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":18}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":11}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":11}},{"line":286,"address":[],"length":0,"stats":{"Line":32}},{"line":287,"address":[],"length":0,"stats":{"Line":21}},{"line":288,"address":[],"length":0,"stats":{"Line":12}},{"line":289,"address":[],"length":0,"stats":{"Line":12}},{"line":291,"address":[],"length":0,"stats":{"Line":9}},{"line":294,"address":[],"length":0,"stats":{"Line":11}},{"line":311,"address":[],"length":0,"stats":{"Line":24}},{"line":317,"address":[],"length":0,"stats":{"Line":40}},{"line":318,"address":[],"length":0,"stats":{"Line":16}},{"line":319,"address":[],"length":0,"stats":{"Line":10}},{"line":320,"address":[],"length":0,"stats":{"Line":10}},{"line":322,"address":[],"length":0,"stats":{"Line":6}},{"line":325,"address":[],"length":0,"stats":{"Line":24}},{"line":339,"address":[],"length":0,"stats":{"Line":81}},{"line":340,"address":[],"length":0,"stats":{"Line":81}},{"line":341,"address":[],"length":0,"stats":{"Line":162}},{"line":342,"address":[],"length":0,"stats":{"Line":81}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":1}},{"line":358,"address":[],"length":0,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":369,"address":[],"length":0,"stats":{"Line":29}},{"line":370,"address":[],"length":0,"stats":{"Line":87}},{"line":371,"address":[],"length":0,"stats":{"Line":87}},{"line":372,"address":[],"length":0,"stats":{"Line":87}}],"covered":80,"coverable":86},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","src","utils","structs","mod.rs"],"content":"//! Solidity storage types used by other contracts.\npub mod bitmap;\npub mod checkpoints;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","tests","erc6909_extensions.rs"],"content":"// examples/erc6909-extensions.rs\nuse stylus_sdk::testing::TestVM;\nuse alloy_primitives::{Address, U256};\n\n// core + the three extensions\nuse openzeppelin_stylus::token::erc6909::{\n    extensions::{\n        token_supply::Erc6909Supply,\n        metadata_uri::Erc6909MetadataUri,\n        enumerable::Erc6909Enumerable,\n    },\n};\nuse openzeppelin_stylus::token::erc6909::traits::{\n    IErc6909Mintable, IErc6909Supply,\n    IErc6909MetadataUri, IErc6909Enumerable,\n};\n\nfn main() {\n    let vm     = TestVM::default();\n    let alice  = Address::new([0xAA; 20]);\n    let id     = U256::from(42u64);\n    let amount = U256::from(100u64);\n\n    // ── Supply extension ───────────────────────────────\n    let mut supply = Erc6909Supply::from(\u0026vm);\n    supply.mint(alice, alice, id, amount).unwrap();\n    assert_eq!(supply.total_supply(id), amount);\n    println!(\" ✔ total supply = {}\", supply.total_supply(id));\n\n    // ── Metadata extension ────────────────────────────\n    let mut uri_ext = Erc6909MetadataUri::from(\u0026vm);\n    let uri = b\"https://example.com/42\".to_vec();\n    uri_ext.set_token_uri(alice, id, uri.clone()).unwrap();\n    assert_eq!(uri_ext.token_uri(id), uri);\n    println!(\" ✔ metadata URI = {:?}\", uri_ext.token_uri(id));\n\n    // ── Enumerable extension ──────────────────────────\n    let mut enum_ext = Erc6909Enumerable::from(\u0026vm);\n    // record it (in a real contract you'd do this in your _mint hooks)\n    enum_ext._record_id(id);\n\n    assert_eq!(enum_ext.total_ids(), U256::ONE);\n    assert_eq!(enum_ext.id_by_index(U256::ZERO), id);\n    println!(\" ✔ enumerable id[0] = {}\", enum_ext.id_by_index(U256::ZERO));\n\n    println!(\"✅ all three ERC-6909 extensions example OK\");\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts","tests","erc6909_integration.rs"],"content":"use motsu::prelude::*;\nuse stylus_sdk::testing::TestVM;\nuse alloy_primitives::{Address, U256};\nuse openzeppelin_stylus::token::erc6909::Erc6909;\nuse openzeppelin_stylus::token::erc6909::traits::*;\n\n#[motsu::test]\nfn full_mint_transfer_burn_flow() {\n    let vm = TestVM::default();\n    let mut token = Erc6909::from(\u0026vm);\n    let alice = Address::new([0xAA;20]);\n    let bob   = Address::new([0xBB;20]);\n    let id    = U256::from(7u64);\n\n    // mint\n    token.mint(alice, alice, id, U256::from(100u64)).unwrap();\n    assert_eq!(token.balance_of(alice, id), U256::from(100u64));\n\n    // approve + transfer_from\n    token.approve(alice, bob, id, U256::from(30u64)).unwrap();\n    assert!(token.transfer_from(bob, alice, bob, id, U256::from(20u64)).unwrap());\n    assert_eq!(token.balance_of(bob, id), U256::from(20u64));\n    assert_eq!(token.allowance(alice, bob, id), U256::from(10u64));\n\n    // burn\n    token.burn(alice, alice, id, U256::from(10u64)).unwrap();\n    assert_eq!(token.balance_of(alice, id), U256::from(70u64));\n}\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts-proc","src","interface_id.rs"],"content":"//! Defines the `#[interface_id]` procedural macro.\n\nuse std::{collections::HashMap, mem};\n\nuse convert_case::{Case, Casing};\nuse proc_macro::TokenStream;\nuse proc_macro2::Ident;\nuse quote::quote;\nuse syn::{\n    parse::{Parse, ParseStream},\n    parse_macro_input, FnArg, ItemTrait, LitStr, Result, Token, TraitItem,\n};\n\n/// Computes an interface id as an associated function for the trait.\npub(crate) fn interface_id(\n    _attr: \u0026TokenStream,\n    input: TokenStream,\n) -\u003e TokenStream {\n    let mut input = parse_macro_input!(input as ItemTrait);\n\n    let unsafety = input.unsafety;\n    let mut selectors_map =\n        HashMap::\u003cString, (String, proc_macro2::TokenStream)\u003e::new();\n\n    for item in \u0026mut input.items {\n        let TraitItem::Fn(func) = item else {\n            continue;\n        };\n\n        let mut override_fn_name = None;\n        for attr in mem::take(\u0026mut func.attrs) {\n            if attr.path().is_ident(\"selector\") {\n                if override_fn_name.is_some() {\n                    error!(attr.path(), \"more than one selector attribute\");\n                }\n                let args: SelectorArgs = match attr.parse_args() {\n                    Ok(args) =\u003e args,\n                    Err(error) =\u003e error!(attr.path(), \"{}\", error),\n                };\n                override_fn_name = Some(args.name);\n            } else {\n                // Put back any other attributes.\n                func.attrs.push(attr);\n            }\n        }\n\n        let rust_fn_name = func.sig.ident.to_string();\n\n        let solidity_fn_name =\n            override_fn_name.unwrap_or(rust_fn_name.to_case(Case::Camel));\n\n        let arg_types = func.sig.inputs.iter().filter_map(|arg| match arg {\n            FnArg::Typed(t) =\u003e Some(t.ty.clone()),\n            // Opt out any `self` arguments.\n            FnArg::Receiver(_) =\u003e None,\n        });\n\n        // Build the function signature string for selector computation.\n        let type_strings: Vec\u003cString\u003e =\n            arg_types.clone().map(|ty| quote!(#ty).to_string()).collect();\n        let signature =\n            format!(\"{}({})\", solidity_fn_name, type_strings.join(\",\"));\n\n        let selector = quote! { alloy_primitives::FixedBytes::\u003c4\u003e::new(stylus_sdk::function_selector!(#solidity_fn_name #(, #arg_types )*)) };\n\n        // Store selector expression from every function in the trait.\n        match selectors_map.get(\u0026signature) {\n            Some((existing_rust_fn_name, _)) =\u003e {\n                error!(\n                    existing_rust_fn_name,\n                    \"selector collision detected: function '{}' has the same selector as function '{}': {}\",\n                    rust_fn_name,\n                    existing_rust_fn_name,\n                    signature,\n                );\n            }\n            None =\u003e selectors_map.insert(signature, (rust_fn_name, selector)),\n        };\n    }\n\n    let name = input.ident;\n    let vis = input.vis;\n    let attrs = input.attrs;\n    let trait_items = input.items;\n    let generics = input.generics.clone();\n    let where_clause = \u0026generics.where_clause;\n\n    let supertrait_tokens = if input.supertraits.is_empty() {\n        quote! {}\n    } else {\n        let supertraits = \u0026input.supertraits;\n        quote! { : #supertraits }\n    };\n\n    let selectors = selectors_map.values().map(|(_, tokens)| tokens);\n\n    // Keep the same trait with an additional associated function\n    // `interface_id`.\n    quote! {\n        #(#attrs)*\n        #vis #unsafety trait #name #generics #supertrait_tokens #where_clause {\n            #(#trait_items)*\n\n            #[doc = concat!(\"Solidity interface id associated with \", stringify!(#name), \" trait.\")]\n            #[doc = \"Computed as a XOR of selectors for each function in the trait.\"]\n            fn interface_id() -\u003e alloy_primitives::FixedBytes\u003c4\u003e\n            where\n                Self: Sized,\n            {\n                #(#selectors)^*\n            }\n        }\n    }\n    .into()\n}\n\n/// Contains arguments of the `#[selector(..)]` attribute.\nstruct SelectorArgs {\n    name: String,\n}\n\nimpl Parse for SelectorArgs {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let ident: Ident = input.parse()?;\n\n        if ident == \"name\" {\n            let _: Token![=] = input.parse()?;\n            let lit: LitStr = input.parse()?;\n            Ok(SelectorArgs { name: lit.value() })\n        } else {\n            error!(@ident, \"expected identifier 'name'\")\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","contracts-proc","src","lib.rs"],"content":"#![doc = include_str!(\"../README.md\")]\n\nextern crate proc_macro;\nuse proc_macro::TokenStream;\n\n/// Shorthand to print nice errors.\n///\n/// Note that it's defined before the module declarations.\nmacro_rules! error {\n    ($tokens:expr, $($msg:expr),+ $(,)?) =\u003e {{\n        let error = syn::Error::new(syn::spanned::Spanned::span(\u0026$tokens), format!($($msg),+));\n        return error.to_compile_error().into();\n    }};\n    (@ $tokens:expr, $($msg:expr),+ $(,)?) =\u003e {{\n        return Err(syn::Error::new(syn::spanned::Spanned::span(\u0026$tokens), format!($($msg),+)))\n    }};\n}\n\nmod interface_id;\n\n/// Automatically computes the ERC-165 interface ID for a trait.\n///\n/// Adds an `interface_id` associated function to your trait by XOR-ing all\n/// method selectors together, following the ERC-165 standard.\n///\n/// ## Method naming\n///\n/// By default, Rust method names are converted to camelCase for Solidity.\n/// Use `#[selector(name = \"...\")]` to override the Solidity function name.\n///\n/// ## Examples\n///\n/// ### Basic usage\n///\n/// ```rust,ignore\n/// #[interface_id]\n/// pub trait IErc721 {\n///     fn balance_of(\u0026self, owner: Address) -\u003e Result\u003cU256, Vec\u003cu8\u003e\u003e;\n///     fn owner_of(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Vec\u003cu8\u003e\u003e;\n///\n///     // Function overloading: different Rust names, same Solidity name\n///     fn safe_transfer_from(\n///         \u0026mut self,\n///         from: Address,\n///         to: Address,\n///         token_id: U256,\n///     ) -\u003e Result\u003c(), Vec\u003cu8\u003e\u003e;\n///\n///     #[selector(name = \"safeTransferFrom\")]\n///     fn safe_transfer_from_with_data(\n///         \u0026mut self,\n///         from: Address,\n///         to: Address,\n///         token_id: U256,\n///         data: Bytes,\n///     ) -\u003e Result\u003c(), Vec\u003cu8\u003e\u003e;\n/// }\n///\n/// // Now you can use the computed interface ID:\n/// impl IErc165 for Erc721 {\n///     fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n///         \u003cSelf as IErc721\u003e::interface_id() == interface_id\n///             || \u003cSelf as IErc165\u003e::interface_id() == interface_id\n///     }\n/// }\n/// ```\n///\n/// ### Selector collision error\n///\n/// The macro will catch duplicate Solidity signatures at compile time:\n///\n/// ```compile_fail\n/// #[interface_id]\n/// trait BadTrait {\n///     fn transfer(\u0026self, to: Address, amount: U256);          // transfer(address,uint256)\n///\n///     #[selector(name = \"transfer\")]\n///     fn send_tokens(\u0026self, recipient: Address, value: U256); // transfer(address,uint256) ❌ collision!\n/// }\n/// ```\n#[proc_macro_attribute]\npub fn interface_id(attr: TokenStream, input: TokenStream) -\u003e TokenStream {\n    interface_id::interface_id(\u0026attr, input)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","access-control","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse openzeppelin_stylus::{\n    access::control::{self, AccessControl, IAccessControl},\n    token::erc20::{self, Erc20, IErc20},\n};\nuse stylus_sdk::{\n    alloy_primitives::{Address, B256, U256},\n    prelude::*,\n};\n\n#[derive(SolidityError, Debug)]\nenum Error {\n    UnauthorizedAccount(control::AccessControlUnauthorizedAccount),\n    BadConfirmation(control::AccessControlBadConfirmation),\n    InsufficientBalance(erc20::ERC20InsufficientBalance),\n    InvalidSender(erc20::ERC20InvalidSender),\n    InvalidReceiver(erc20::ERC20InvalidReceiver),\n    InsufficientAllowance(erc20::ERC20InsufficientAllowance),\n    InvalidSpender(erc20::ERC20InvalidSpender),\n    InvalidApprover(erc20::ERC20InvalidApprover),\n}\n\nimpl From\u003ccontrol::Error\u003e for Error {\n    fn from(value: control::Error) -\u003e Self {\n        match value {\n            control::Error::UnauthorizedAccount(e) =\u003e {\n                Error::UnauthorizedAccount(e)\n            }\n            control::Error::BadConfirmation(e) =\u003e Error::BadConfirmation(e),\n        }\n    }\n}\n\nimpl From\u003cerc20::Error\u003e for Error {\n    fn from(value: erc20::Error) -\u003e Self {\n        match value {\n            erc20::Error::InsufficientBalance(e) =\u003e {\n                Error::InsufficientBalance(e)\n            }\n            erc20::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc20::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc20::Error::InsufficientAllowance(e) =\u003e {\n                Error::InsufficientAllowance(e)\n            }\n            erc20::Error::InvalidSpender(e) =\u003e Error::InvalidSpender(e),\n            erc20::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n        }\n    }\n}\n\n#[entrypoint]\n#[storage]\nstruct AccessControlExample {\n    erc20: Erc20,\n    access: AccessControl,\n}\n\npub const TRANSFER_ROLE: [u8; 32] =\n    keccak_const::Keccak256::new().update(b\"TRANSFER_ROLE\").finalize();\n\n#[public]\n#[implements(IErc20\u003cError = Error\u003e, IAccessControl\u003cError = Error\u003e)]\nimpl AccessControlExample {\n    #[constructor]\n    fn constructor(\u0026mut self, admin: Address) {\n        self.access\n            ._grant_role(AccessControl::DEFAULT_ADMIN_ROLE.into(), admin);\n    }\n\n    fn make_admin(\u0026mut self, account: Address) -\u003e Result\u003c(), Error\u003e {\n        self.access.only_role(AccessControl::DEFAULT_ADMIN_ROLE.into())?;\n        self.access.grant_role(TRANSFER_ROLE.into(), account)?;\n        Ok(())\n    }\n\n    // WARNING: This should not be part of the public API, it's here for testing\n    // purposes only.\n    fn set_role_admin(\u0026mut self, role: B256, new_admin_role: B256) {\n        self.access._set_role_admin(role, new_admin_role)\n    }\n}\n\n#[public]\nimpl IErc20 for AccessControlExample {\n    type Error = Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.erc20.total_supply()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.erc20.balance_of(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer(to, value)?)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.erc20.allowance(owner, spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.approve(spender, value)?)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.access.only_role(TRANSFER_ROLE.into())?;\n        let transfer_result = self.erc20.transfer_from(from, to, value)?;\n        Ok(transfer_result)\n    }\n}\n\n#[public]\nimpl IAccessControl for AccessControlExample {\n    type Error = Error;\n\n    fn has_role(\u0026self, role: B256, account: Address) -\u003e bool {\n        self.access.has_role(role, account)\n    }\n\n    fn only_role(\u0026self, role: B256) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.access.only_role(role)?)\n    }\n\n    fn get_role_admin(\u0026self, role: B256) -\u003e B256 {\n        self.access.get_role_admin(role)\n    }\n\n    fn grant_role(\n        \u0026mut self,\n        role: B256,\n        account: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.access.grant_role(role, account)?)\n    }\n\n    fn revoke_role(\n        \u0026mut self,\n        role: B256,\n        account: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.access.revoke_role(role, account)?)\n    }\n\n    fn renounce_role(\n        \u0026mut self,\n        role: B256,\n        confirmation: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.access.renounce_role(role, confirmation)?)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","access-control","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    access_control_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","access-control","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n   contract AccessControl {\n        function hasRole(bytes32 role, address account) public view virtual returns (bool hasRole);\n        function getRoleAdmin(bytes32 role) public view virtual returns (bytes32 role);\n        function grantRole(bytes32 role, address account) public virtual;\n        function revokeRole(bytes32 role, address account) public virtual;\n        function renounceRole(bytes32 role, address callerConfirmation) public virtual;\n\n        function setRoleAdmin(bytes32 role, bytes32 adminRole) public virtual;\n\n        error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n        error AccessControlBadConfirmation();\n\n        #[derive(Debug, PartialEq)]\n        event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n        #[derive(Debug, PartialEq)]\n        event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n        #[derive(Debug, PartialEq)]\n        event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","access-control","tests","access_control.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::AccessControl::{\n    self, AccessControlBadConfirmation, AccessControlUnauthorizedAccount,\n    RoleAdminChanged, RoleGranted, RoleRevoked,\n};\nuse alloy::hex;\nuse alloy_primitives::Address;\nuse e2e::{\n    constructor, receipt, send, watch, Account, Constructor, EventExt, Revert,\n    DEPLOYER_ADDRESS,\n};\nuse eyre::Result;\n\nmod abi;\n\nconst DEFAULT_ADMIN_ROLE: [u8; 32] =\n    openzeppelin_stylus::access::control::AccessControl::DEFAULT_ADMIN_ROLE;\nconst ROLE: [u8; 32] = access_control_example::TRANSFER_ROLE;\nconst NEW_ADMIN_ROLE: [u8; 32] =\n    hex!(\"879ce0d4bfd332649ca3552efe772a38d64a315eb70ab69689fd309c735946b5\");\n\nfn ctr(admin: Address) -\u003e Constructor {\n    constructor!(admin)\n}\n\n// ============================================================================\n// Integration Tests: AccessControl\n// ============================================================================\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let receipt = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?;\n    let contract = AccessControl::new(receipt.contract_address, \u0026alice.wallet);\n\n    // StylusDeployer is the message sender, so currently it becomes the\n    // `sender` in the `RoleGranted` event\n    let stylus_deployer = std::env::var(DEPLOYER_ADDRESS)?.parse()?;\n\n    assert!(receipt.emits(RoleGranted {\n        role: DEFAULT_ADMIN_ROLE.into(),\n        account: alice_addr,\n        sender: stylus_deployer\n    }));\n\n    let AccessControl::hasRoleReturn { hasRole } =\n        contract.hasRole(DEFAULT_ADMIN_ROLE.into(), alice_addr).call().await?;\n    assert!(hasRole);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn other_roles_admin_is_the_default_admin_role(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let AccessControl::getRoleAdminReturn { role } =\n        contract.getRoleAdmin(ROLE.into()).call().await?;\n    assert_eq!(*role, DEFAULT_ADMIN_ROLE);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn default_role_is_default_admin(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let AccessControl::getRoleAdminReturn { role } =\n        contract.getRoleAdmin(ROLE.into()).call().await?;\n    assert_eq!(*role, DEFAULT_ADMIN_ROLE);\n\n    let AccessControl::getRoleAdminReturn { role } =\n        contract.getRoleAdmin(DEFAULT_ADMIN_ROLE.into()).call().await?;\n    assert_eq!(*role, DEFAULT_ADMIN_ROLE);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_non_admin_grants_role(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026bob.wallet);\n\n    let err = send!(contract.grantRole(ROLE.into(), alice.address()))\n        .expect_err(\"should not have permission to grant roles\");\n    assert!(err.reverted_with(\n        AccessControl::AccessControlUnauthorizedAccount {\n            account: bob.address(),\n            neededRole: DEFAULT_ADMIN_ROLE.into()\n        }\n    ));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn accounts_can_be_granted_roles_multiple_times(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let receipt = receipt!(contract.grantRole(ROLE.into(), bob_addr))?;\n    assert!(receipt.emits(RoleGranted {\n        role: ROLE.into(),\n        account: bob_addr,\n        sender: alice_addr\n    }));\n    let receipt = receipt!(contract.grantRole(ROLE.into(), bob_addr))?;\n    assert!(!receipt.emits(RoleGranted {\n        role: ROLE.into(),\n        account: bob_addr,\n        sender: alice_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn not_granted_roles_can_be_revoked(alice: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let AccessControl::hasRoleReturn { hasRole } =\n        contract.hasRole(ROLE.into(), alice_addr).call().await?;\n    assert!(!hasRole);\n\n    let receipt = receipt!(contract.revokeRole(ROLE.into(), alice_addr))?;\n    assert!(!receipt.emits(RoleRevoked {\n        role: ROLE.into(),\n        account: alice_addr,\n        sender: alice_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn admin_can_revoke_role(alice: Account, bob: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    watch!(contract.grantRole(ROLE.into(), bob_addr))?;\n\n    let receipt = receipt!(contract.revokeRole(ROLE.into(), bob_addr))?;\n    assert!(receipt.emits(RoleRevoked {\n        role: ROLE.into(),\n        account: bob_addr,\n        sender: alice_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_non_admin_revokes_role(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    watch!(contract.grantRole(ROLE.into(), alice_addr))?;\n\n    let contract = AccessControl::new(contract_addr, \u0026bob.wallet);\n    let err = send!(contract.revokeRole(ROLE.into(), alice_addr))\n        .expect_err(\"non-admin should not be able to revoke role\");\n    assert!(err.reverted_with(AccessControlUnauthorizedAccount {\n        account: bob_addr,\n        neededRole: DEFAULT_ADMIN_ROLE.into()\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn roles_can_be_revoked_multiple_times(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    watch!(contract.revokeRole(ROLE.into(), bob_addr))?;\n    let receipt = receipt!(contract.revokeRole(ROLE.into(), bob_addr))?;\n    assert!(!receipt.emits(RoleRevoked {\n        role: ROLE.into(),\n        account: bob_addr,\n        sender: alice_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn not_granted_roles_can_be_renounced(alice: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let receipt = receipt!(contract.renounceRole(ROLE.into(), alice_addr))?;\n    assert!(!receipt.emits(RoleRevoked {\n        role: ROLE.into(),\n        account: alice_addr,\n        sender: alice_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn bearer_can_renounce_role(alice: Account, bob: Account) -\u003e Result\u003c()\u003e {\n    let bob_addr = bob.address();\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    watch!(contract.grantRole(ROLE.into(), bob_addr))?;\n\n    let contract = AccessControl::new(contract_addr, \u0026bob.wallet);\n    let receipt = receipt!(contract.renounceRole(ROLE.into(), bob_addr))?;\n    assert!(receipt.emits(RoleRevoked {\n        role: ROLE.into(),\n        account: bob_addr,\n        sender: bob_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_the_one_renouncing_is_not_the_sender(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    watch!(contract.grantRole(ROLE.into(), bob_addr))?;\n\n    let contract = AccessControl::new(contract_addr, \u0026bob.wallet);\n    let err = send!(contract.renounceRole(ROLE.into(), alice_addr))\n        .expect_err(\"only sender should be able to renounce\");\n    assert!(err.reverted_with(AccessControlBadConfirmation {}));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn roles_can_be_renounced_multiple_times(alice: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    watch!(contract.renounceRole(ROLE.into(), alice_addr))?;\n    let receipt = receipt!(contract.renounceRole(ROLE.into(), alice_addr))?;\n    assert!(!receipt.emits(RoleRevoked {\n        role: ROLE.into(),\n        account: alice_addr,\n        sender: alice_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn a_roles_admin_role_can_change(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let receipt =\n        receipt!(contract.setRoleAdmin(ROLE.into(), NEW_ADMIN_ROLE.into()))?;\n    assert!(receipt.emits(RoleAdminChanged {\n        role: ROLE.into(),\n        previousAdminRole: DEFAULT_ADMIN_ROLE.into(),\n        newAdminRole: NEW_ADMIN_ROLE.into()\n    }));\n\n    let AccessControl::getRoleAdminReturn { role } =\n        contract.getRoleAdmin(ROLE.into()).call().await?;\n    assert_eq!(*role, NEW_ADMIN_ROLE);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn the_new_admin_can_grant_roles(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let receipt =\n        receipt!(contract.setRoleAdmin(ROLE.into(), NEW_ADMIN_ROLE.into()))?;\n    assert!(receipt.emits(RoleAdminChanged {\n        role: ROLE.into(),\n        previousAdminRole: DEFAULT_ADMIN_ROLE.into(),\n        newAdminRole: NEW_ADMIN_ROLE.into()\n    }));\n\n    watch!(contract.grantRole(NEW_ADMIN_ROLE.into(), bob_addr))?;\n\n    let contract = AccessControl::new(contract_addr, \u0026bob.wallet);\n    let receipt = receipt!(contract.grantRole(ROLE.into(), alice_addr))?;\n    assert!(receipt.emits(RoleGranted {\n        role: ROLE.into(),\n        account: alice_addr,\n        sender: bob_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn the_new_admin_can_revoke_roles(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let receipt =\n        receipt!(contract.setRoleAdmin(ROLE.into(), NEW_ADMIN_ROLE.into()))?;\n    assert!(receipt.emits(RoleAdminChanged {\n        role: ROLE.into(),\n        previousAdminRole: DEFAULT_ADMIN_ROLE.into(),\n        newAdminRole: NEW_ADMIN_ROLE.into()\n    }));\n\n    watch!(contract.grantRole(NEW_ADMIN_ROLE.into(), bob_addr))?;\n\n    let contract = AccessControl::new(contract_addr, \u0026bob.wallet);\n    watch!(contract.grantRole(ROLE.into(), alice_addr))?;\n    let receipt = receipt!(contract.revokeRole(ROLE.into(), alice_addr))?;\n    assert!(receipt.emits(RoleRevoked {\n        role: ROLE.into(),\n        account: alice_addr,\n        sender: bob_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_previous_admin_grants_roles(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let receipt =\n        receipt!(contract.setRoleAdmin(ROLE.into(), NEW_ADMIN_ROLE.into()))?;\n    assert!(receipt.emits(RoleAdminChanged {\n        role: ROLE.into(),\n        previousAdminRole: DEFAULT_ADMIN_ROLE.into(),\n        newAdminRole: NEW_ADMIN_ROLE.into()\n    }));\n\n    let err = send!(contract.grantRole(ROLE.into(), bob_addr))\n        .expect_err(\"previous admins can't grant roles after admin change\");\n    assert!(err.reverted_with(AccessControlUnauthorizedAccount {\n        account: alice_addr,\n        neededRole: NEW_ADMIN_ROLE.into()\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_previous_admin_revokes_roles(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address()))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = AccessControl::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let receipt =\n        receipt!(contract.setRoleAdmin(ROLE.into(), NEW_ADMIN_ROLE.into()))?;\n    assert!(receipt.emits(RoleAdminChanged {\n        role: ROLE.into(),\n        previousAdminRole: DEFAULT_ADMIN_ROLE.into(),\n        newAdminRole: NEW_ADMIN_ROLE.into()\n    }));\n\n    let err = send!(contract.revokeRole(ROLE.into(), bob_addr))\n        .expect_err(\"previous admins can't revoke roles after admin change\");\n    assert!(err.reverted_with(AccessControlUnauthorizedAccount {\n        account: alice_addr,\n        neededRole: NEW_ADMIN_ROLE.into()\n    }));\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","basic","script","src","main.rs"],"content":"use alloy::{\n    network::EthereumWallet, primitives::Address, providers::ProviderBuilder,\n    signers::local::PrivateKeySigner, sol,\n};\nuse e2e::{Account, Constructor};\n\nsol!(\n    #[sol(rpc)]\n    contract BasicToken {\n        constructor(string memory name_, string memory symbol_);\n\n        function name() external view returns (string name);\n        function symbol() external view returns (string symbol);\n    }\n);\n\nconst RPC_URL: \u0026str = \"https://sepolia-rollup.arbitrum.io/rpc\";\nconst PRIVATE_KEY: \u0026str = \"your private key\";\nconst TOKEN_NAME: \u0026str = \"Test Token\";\nconst TOKEN_SYMBOL: \u0026str = \"TTK\";\n\n#[tokio::main]\nasync fn main() {\n    // WARNING: Please use a more secure method for storing your privaket key\n    // than a string at the top of this file. The following code is for testing\n    // purposes only.\n    let signer = PRIVATE_KEY\n        .parse::\u003cPrivateKeySigner\u003e()\n        .expect(\"should parse the private key\");\n    let wallet = EthereumWallet::from(signer.clone());\n    let rpc_url = RPC_URL.parse().expect(\"should parse rpc url\");\n    let provider = ProviderBuilder::new()\n        .with_recommended_fillers()\n        .wallet(wallet)\n        .on_http(rpc_url);\n    let account = Account { signer, wallet: provider.clone() };\n\n    let contract_address = deploy(\u0026account).await;\n\n    let contract = BasicToken::new(contract_address, \u0026provider);\n\n    let call_result = contract.name().call().await.unwrap();\n    assert_eq!(call_result.name, TOKEN_NAME.to_owned());\n\n    let call_result = contract.symbol().call().await.unwrap();\n    assert_eq!(call_result.symbol, TOKEN_SYMBOL.to_owned());\n}\n\n/// Deploy a `BasicToken` contract to `RPC_URL` using `cargo-stylus`.\nasync fn deploy(account: \u0026Account) -\u003e Address {\n    let manifest_dir =\n        std::env::current_dir().expect(\"should get current dir from env\");\n\n    // NOTE: It's expected that you compiled your contract beforehand.\n    //\n    // You should run `cargo build --release --target wasm32-unknown-unknown` to\n    // get a wasm binary at `target/wasm32-unknown-unknown/release/{name}.wasm`.\n    let wasm_path = manifest_dir\n        .join(\"target\")\n        .join(\"wasm32-unknown-unknown\")\n        .join(\"release\")\n        .join(\"basic_example.wasm\");\n\n    let constructor = Constructor {\n        signature: \"constructor(string,string)\".to_string(),\n        args: vec![TOKEN_NAME.to_owned(), TOKEN_SYMBOL.to_owned()],\n    };\n\n    let deployer = account.as_deployer().with_constructor(constructor);\n    let address = deployer\n        .deploy_wasm(\u0026wasm_path)\n        .await\n        .expect(\"contract should be deployed\")\n        .contract_address;\n\n    address\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","basic","token","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse openzeppelin_stylus::{\n    token::erc20::{\n        self,\n        extensions::{Erc20Metadata, IErc20Metadata},\n        Erc20, IErc20,\n    },\n    utils::introspection::erc165::IErc165,\n};\nuse stylus_sdk::{\n    alloy_primitives::{Address, FixedBytes, U256, U8},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct Erc20Example {\n    erc20: Erc20,\n    metadata: Erc20Metadata,\n}\n\n#[public]\n#[implements(IErc20\u003cError = erc20::Error\u003e, IErc20Metadata, IErc165)]\nimpl Erc20Example {\n    #[constructor]\n    fn constructor(\u0026mut self, name: String, symbol: String) {\n        self.metadata.constructor(name, symbol);\n    }\n\n    fn mint(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), erc20::Error\u003e {\n        self.erc20._mint(account, value)\n    }\n}\n\n#[public]\nimpl IErc20 for Erc20Example {\n    type Error = erc20::Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.erc20.total_supply()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.erc20.balance_of(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.erc20.transfer(to, value)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.erc20.allowance(owner, spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.erc20.approve(spender, value)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.erc20.transfer_from(from, to, value)\n    }\n}\n\n#[public]\nimpl IErc20Metadata for Erc20Example {\n    fn name(\u0026self) -\u003e String {\n        self.metadata.name()\n    }\n\n    fn symbol(\u0026self) -\u003e String {\n        self.metadata.symbol()\n    }\n\n    fn decimals(\u0026self) -\u003e U8 {\n        self.metadata.decimals()\n    }\n}\n\n#[public]\nimpl IErc165 for Erc20Example {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        self.erc20.supports_interface(interface_id)\n            || self.metadata.supports_interface(interface_id)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","basic","token","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    basic_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ecdsa","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse alloy_primitives::{Address, B256};\nuse openzeppelin_stylus::utils::cryptography::ecdsa;\nuse stylus_sdk::prelude::*;\n\n#[entrypoint]\n#[storage]\nstruct ECDSAExample;\n\n#[public]\nimpl ECDSAExample {\n    fn recover(\n        \u0026mut self,\n        hash: B256,\n        v: u8,\n        r: B256,\n        s: B256,\n    ) -\u003e Result\u003cAddress, ecdsa::Error\u003e {\n        ecdsa::recover(self, hash, v, r, s)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ecdsa","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    ecdsa_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ecdsa","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n   contract ECDSA {\n        error ECDSAInvalidSignature();\n        error ECDSAInvalidSignatureS(bytes32 s);\n\n        #[derive(Debug)]\n        function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address recovered);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ecdsa","tests","ecdsa.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::ECDSA;\nuse alloy::primitives::{address, b256, uint, Address, B256};\nuse e2e::{Account, Revert};\nuse eyre::Result;\nuse openzeppelin_stylus::utils::cryptography::ecdsa::SIGNATURE_S_UPPER_BOUND;\n\nmod abi;\n\nconst HASH: B256 =\n    b256!(\"a1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\");\n\nconst V: u8 = 28;\nconst R: B256 =\n    b256!(\"65e72b1cf8e189569963750e10ccb88fe89389daeeb8b735277d59cd6885ee82\");\nconst S: B256 =\n    b256!(\"3eb5a6982b540f185703492dab77b863a88ce01f27e21ade8b2879c10fc9e653\");\n\nconst ADDRESS: Address = address!(\"f39Fd6e51aad88F6F4ce6aB8827279cffFb92266\");\n\n// ============================================================================\n// Integration Tests: ECDSA\n// ============================================================================\n\n#[e2e::test]\nasync fn ecrecover_works(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = ECDSA::new(contract_addr, \u0026alice.wallet);\n\n    let ECDSA::recoverReturn { recovered } =\n        contract.recover(HASH, V, R, S).call().await?;\n\n    assert_eq!(ADDRESS, recovered);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn different_hash_recovers_different_address(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = ECDSA::new(contract_addr, \u0026alice.wallet);\n\n    let hash = b256!(\n        \"65e72b1cf8e189569963750e10ccb88fe89389daeeb8b735277d59cd6885ee82\"\n    );\n    let ECDSA::recoverReturn { recovered } =\n        contract.recover(hash, V, R, S).call().await?;\n\n    assert_ne!(ADDRESS, recovered);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn different_v_recovers_different_address(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = ECDSA::new(contract_addr, \u0026alice.wallet);\n\n    let v = 27;\n\n    let ECDSA::recoverReturn { recovered } =\n        contract.recover(HASH, v, R, S).call().await?;\n\n    assert_ne!(ADDRESS, recovered);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn different_r_recovers_different_address(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = ECDSA::new(contract_addr, \u0026alice.wallet);\n\n    let r = b256!(\n        \"b814eaab5953337fed2cf504a5b887cddd65a54b7429d7b191ff1331ca0726b1\"\n    );\n\n    let ECDSA::recoverReturn { recovered } =\n        contract.recover(HASH, V, r, S).call().await?;\n\n    assert_ne!(ADDRESS, recovered);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn different_s_recovers_different_address(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = ECDSA::new(contract_addr, \u0026alice.wallet);\n\n    let s = b256!(\n        \"3eb5a6982b540f185703492dab77b863a99ce01f27e21ade8b2879c10fc9e653\"\n    );\n    let ECDSA::recoverReturn { recovered } =\n        contract.recover(HASH, V, R, s).call().await?;\n\n    assert_ne!(ADDRESS, recovered);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn recovers_from_v_r_s(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = ECDSA::new(contract_addr, \u0026alice.wallet);\n\n    let signature = alice.sign_hash(\u0026HASH).await;\n\n    // converted to non-eip155 `v` value\n    // see https://eips.ethereum.org/EIPS/eip-155\n    let v_byte = signature.v() as u8 + 27;\n\n    let ECDSA::recoverReturn { recovered } = contract\n        .recover(HASH, v_byte, signature.r().into(), signature.s().into())\n        .call()\n        .await?;\n\n    assert_eq!(alice.address(), recovered);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn rejects_v0_with_invalid_signature_error(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = ECDSA::new(contract_addr, \u0026alice.wallet);\n\n    let wrong_v = 0;\n    let err = contract\n        .recover(HASH, wrong_v, R, S)\n        .call()\n        .await\n        .expect_err(\"should return `ECDSAInvalidSignature`\");\n\n    assert!(err.reverted_with(ECDSA::ECDSAInvalidSignature {}));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn rejects_v1_with_invalid_signature_error(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = ECDSA::new(contract_addr, \u0026alice.wallet);\n\n    let wrong_v = 0;\n    let err = contract\n        .recover(HASH, wrong_v, R, S)\n        .call()\n        .await\n        .expect_err(\"should return `ECDSAInvalidSignature`\");\n\n    assert!(err.reverted_with(ECDSA::ECDSAInvalidSignature {}));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_higher_s(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = ECDSA::new(contract_addr, \u0026alice.wallet);\n\n    let higher_s = SIGNATURE_S_UPPER_BOUND + uint!(1_U256);\n\n    let higher_s = B256::from_slice(\u0026higher_s.to_be_bytes_vec());\n\n    let err = contract\n        .recover(HASH, V, R, higher_s)\n        .call()\n        .await\n        .expect_err(\"should return `ECDSAInvalidSignature`\");\n\n    assert!(err.reverted_with(ECDSA::ECDSAInvalidSignatureS { s: higher_s }));\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n#![allow(clippy::result_large_err)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse openzeppelin_stylus::{\n    token::erc1155::{self, extensions::IErc1155Burnable, Erc1155, IErc1155},\n    utils::introspection::erc165::IErc165,\n};\nuse stylus_sdk::{\n    abi::Bytes,\n    alloy_primitives::{Address, FixedBytes, U256},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct Erc1155Example {\n    erc1155: Erc1155,\n}\n\n#[public]\n#[implements(IErc1155\u003cError = erc1155::Error\u003e, IErc1155Burnable\u003cError = erc1155::Error\u003e, IErc165)]\nimpl Erc1155Example {\n    fn mint(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n        amount: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        self.erc1155._mint(to, token_id, amount, \u0026data)\n    }\n\n    fn mint_batch(\n        \u0026mut self,\n        to: Address,\n        token_ids: Vec\u003cU256\u003e,\n        amounts: Vec\u003cU256\u003e,\n        data: Bytes,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        self.erc1155._mint_batch(to, token_ids, amounts, \u0026data)\n    }\n}\n\n#[public]\nimpl IErc1155 for Erc1155Example {\n    type Error = erc1155::Error;\n\n    fn balance_of(\u0026self, account: Address, id: U256) -\u003e U256 {\n        self.erc1155.balance_of(account, id)\n    }\n\n    fn balance_of_batch(\n        \u0026self,\n        accounts: Vec\u003cAddress\u003e,\n        ids: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003cVec\u003cU256\u003e, Self::Error\u003e {\n        self.erc1155.balance_of_batch(accounts, ids)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.set_approval_for_all(operator, approved)\n    }\n\n    fn is_approved_for_all(\u0026self, account: Address, operator: Address) -\u003e bool {\n        self.erc1155.is_approved_for_all(account, operator)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        id: U256,\n        value: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.safe_transfer_from(from, to, id, value, data)\n    }\n\n    fn safe_batch_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.safe_batch_transfer_from(from, to, ids, values, data)\n    }\n}\n\n#[public]\nimpl IErc1155Burnable for Erc1155Example {\n    type Error = erc1155::Error;\n\n    fn burn(\n        \u0026mut self,\n        account: Address,\n        token_id: U256,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.burn(account, token_id, value)\n    }\n\n    fn burn_batch(\n        \u0026mut self,\n        account: Address,\n        token_ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.burn_batch(account, token_ids, values)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc1155Example {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        self.erc1155.supports_interface(interface_id)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc1155_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract Erc1155 {\n        function balanceOf(address account, uint256 id) external view returns (uint256 balance);\n        #[derive(Debug)]\n        function balanceOfBatch(address[] accounts, uint256[] ids) external view returns (uint256[] memory balances);\n        function isApprovedForAll(address account, address operator) external view returns (bool approved);\n        function setApprovalForAll(address operator, bool approved) external;\n        function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) external;\n        function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data) external;\n        function mint(address to, uint256 id, uint256 amount, bytes memory data) external;\n        function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external;\n        function burn(address account, uint256 id, uint256 value) external;\n        function burnBatch(address account, uint256[] memory ids, uint256[] memory values) external;\n\n        error InvalidReceiverWithReason(string message);\n        error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n        error ERC1155InvalidOperator(address operator);\n        error ERC1155InvalidSender(address sender);\n        error ERC1155InvalidReceiver(address receiver);\n        error ERC1155MissingApprovalForAll(address operator, address owner);\n        error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n        error Error(string message);\n        error Panic(uint256 code);\n\n        #[derive(Debug, PartialEq)]\n        event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n        #[derive(Debug, PartialEq)]\n        event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n        #[derive(Debug, PartialEq)]\n        event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155","tests","erc1155.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::Erc1155;\nuse alloy::{\n    primitives::{uint, Address, U256},\n    sol_types::SolError,\n};\nuse e2e::{receipt, send, watch, Account, EventExt, PanicCode, Revert};\nuse mock::{receiver, receiver::ERC1155ReceiverMock};\n\nmod abi;\nmod mock;\n\nfn random_token_ids(size: usize) -\u003e Vec\u003cU256\u003e {\n    (0..size).map(U256::from).collect()\n}\n\nfn random_values(size: usize) -\u003e Vec\u003cU256\u003e {\n    (1..=size).map(U256::from).collect()\n}\n\ntrait EncodeAsStr {\n    fn encode_as_str(\u0026self) -\u003e String;\n}\n\nimpl\u003cT: SolError\u003e EncodeAsStr for T {\n    fn encode_as_str(\u0026self) -\u003e String {\n        let expected_error = self.abi_encode();\n        String::from_utf8_lossy(\u0026expected_error).to_string()\n    }\n}\n\n// ============================================================================\n// Integration Tests: ERC-1155 Token\n// ============================================================================\n\n#[e2e::test]\nasync fn invalid_array_length_error_in_balance_of_batch(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let token_ids = random_token_ids(3);\n    let accounts = vec![alice.address(), bob.address()];\n\n    let err = contract\n        .balanceOfBatch(accounts, token_ids)\n        .call()\n        .await\n        .expect_err(\"should return `ERC1155InvalidArrayLength`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidArrayLength {\n        idsLength: uint!(3_U256),\n        valuesLength: uint!(2_U256)\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn balance_of_zero_balance(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n    let token_ids = random_token_ids(1);\n\n    let Erc1155::balanceOfReturn { balance } =\n        contract.balanceOf(alice.address(), token_ids[0]).call().await?;\n    assert_eq!(U256::ZERO, balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn balance_of_batch_zero_balance(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n    charlie: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n    let accounts =\n        vec![alice.address(), bob.address(), dave.address(), charlie.address()];\n    let token_ids = random_token_ids(4);\n\n    let Erc1155::balanceOfBatchReturn { balances } =\n        contract.balanceOfBatch(accounts, token_ids).call().await?;\n    assert_eq!(vec![U256::ZERO, U256::ZERO, U256::ZERO, U256::ZERO], balances);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mints(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    let receipt = receipt!(contract.mint(\n        alice_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferSingle {\n        operator: alice_addr,\n        from: Address::ZERO,\n        to: alice_addr,\n        id: token_id,\n        value\n    }));\n\n    let Erc1155::balanceOfReturn { balance } =\n        contract.balanceOf(alice_addr, token_id).call().await?;\n    assert_eq!(value, balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mints_to_receiver_contract(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_addr =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::None)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    let Erc1155::balanceOfReturn { balance: initial_receiver_balance } =\n        contract.balanceOf(receiver_addr, token_id).call().await?;\n\n    let receipt =\n        receipt!(contract.mint(receiver_addr, token_id, value, vec![].into()))?;\n\n    assert!(receipt.emits(Erc1155::TransferSingle {\n        operator: alice_addr,\n        from: Address::ZERO,\n        to: receiver_addr,\n        id: token_id,\n        value\n    }));\n\n    assert!(receipt.emits(ERC1155ReceiverMock::Received {\n        operator: alice_addr,\n        from: Address::ZERO,\n        id: token_id,\n        value,\n        data: vec![].into(),\n    }));\n\n    let Erc1155::balanceOfReturn { balance: receiver_balance } =\n        contract.balanceOf(receiver_addr, token_id).call().await?;\n    assert_eq!(initial_receiver_balance + value, receiver_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_reverts_with_reason_in_mint(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC1155ReceiverMock::RevertType::RevertWithMessage,\n    )\n    .await?;\n\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    let err = send!(contract.mint(\n        receiver_address,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))\n    .expect_err(\"should not mint when receiver errors with reason\");\n\n    let message = Erc1155::Error {\n        message: \"ERC1155ReceiverMock: reverting on receive\".to_string(),\n    }\n    .encode_as_str();\n\n    assert!(err.reverted_with(Erc1155::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_reverts_without_reason_in_mint(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC1155ReceiverMock::RevertType::RevertWithoutMessage,\n    )\n    .await?;\n\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    let err = send!(contract.mint(\n        receiver_address,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))\n    .expect_err(\"should not mint when receiver reverts\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidReceiver {\n        receiver: receiver_address\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_panics_in_mint(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::Panic)\n            .await?;\n\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    let err = send!(contract.mint(\n        receiver_address,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))\n    .expect_err(\"should not mint when receiver panics\");\n\n    let message =\n        Erc1155::Panic { code: U256::from(PanicCode::DivisionByZero as u8) }\n            .encode_as_str();\n\n    assert!(err.reverted_with(Erc1155::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_invalid_receiver_contract_in_mint(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    let err = send!(contract.mint(\n        contract_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))\n    .expect_err(\"should not mint when invalid receiver contract\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidReceiver {\n        receiver: contract_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mint_batch(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(3);\n    let values = random_values(3);\n\n    let receipt = receipt!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferBatch {\n        operator: alice_addr,\n        from: Address::ZERO,\n        to: alice_addr,\n        ids: token_ids.clone(),\n        values: values.clone()\n    }));\n\n    for (token_id, value) in token_ids.iter().zip(values.iter()) {\n        let Erc1155::balanceOfReturn { balance } =\n            contract.balanceOf(alice_addr, *token_id).call().await?;\n        assert_eq!(*value, balance);\n    }\n\n    let Erc1155::balanceOfBatchReturn { balances } = contract\n        .balanceOfBatch(\n            vec![alice_addr, alice_addr, alice_addr],\n            token_ids.clone(),\n        )\n        .call()\n        .await?;\n\n    assert_eq!(values, balances);\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mint_batch_transfer_to_receiver_contract(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_addr =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::None)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    let Erc1155::balanceOfBatchReturn { balances: initial_receiver_balances } =\n        contract\n            .balanceOfBatch(\n                vec![receiver_addr, receiver_addr],\n                token_ids.clone(),\n            )\n            .call()\n            .await?;\n\n    let receipt = receipt!(contract.mintBatch(\n        receiver_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferBatch {\n        operator: alice_addr,\n        from: Address::ZERO,\n        to: receiver_addr,\n        ids: token_ids.clone(),\n        values: values.clone()\n    }));\n\n    assert!(receipt.emits(ERC1155ReceiverMock::BatchReceived {\n        operator: alice_addr,\n        from: Address::ZERO,\n        ids: token_ids.clone(),\n        values: values.clone(),\n        data: vec![].into(),\n    }));\n\n    let Erc1155::balanceOfBatchReturn { balances: receiver_balances } =\n        contract\n            .balanceOfBatch(\n                vec![receiver_addr, receiver_addr],\n                token_ids.clone(),\n            )\n            .call()\n            .await?;\n\n    for (idx, value) in values.iter().enumerate() {\n        assert_eq!(\n            initial_receiver_balances[idx] + value,\n            receiver_balances[idx]\n        );\n    }\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_reverts_with_reason_in_batch_mint(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC1155ReceiverMock::RevertType::RevertWithMessage,\n    )\n    .await?;\n\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    let err = send!(contract.mintBatch(\n        receiver_address,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))\n    .expect_err(\"should not mint batch when receiver errors with reason\");\n\n    let message = Erc1155::Error {\n        message: \"ERC1155ReceiverMock: reverting on batch receive\".to_string(),\n    }\n    .encode_as_str();\n\n    assert!(err.reverted_with(Erc1155::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_reverts_without_reason_in_batch_mint(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC1155ReceiverMock::RevertType::RevertWithoutMessage,\n    )\n    .await?;\n\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    let err = send!(contract.mintBatch(\n        receiver_address,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))\n    .expect_err(\"should not mint batch when receiver reverts\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidReceiver {\n        receiver: receiver_address\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_panics_in_batch_mint(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::Panic)\n            .await?;\n\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    let err = send!(contract.mintBatch(\n        receiver_address,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))\n    .expect_err(\"should not mint batch when receiver panics\");\n\n    let message =\n        Erc1155::Panic { code: U256::from(PanicCode::DivisionByZero as u8) }\n            .encode_as_str();\n\n    assert!(err.reverted_with(Erc1155::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_invalid_receiver_contract_in_batch_mint(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    let err = send!(contract.mintBatch(\n        contract_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))\n    .expect_err(\"should not mint batch when invalid receiver contract\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidReceiver {\n        receiver: contract_addr,\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_invalid_array_length_in_batch_mint(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    let err = send!(contract_alice.mintBatch(\n        bob_addr,\n        vec![token_ids[0]],\n        values,\n        vec![].into()\n    ))\n    .expect_err(\"should return `ERC1155InvalidArrayLength`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidArrayLength {\n        idsLength: uint!(1_U256),\n        valuesLength: uint!(2_U256)\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn set_approval_for_all(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let approved_value = true;\n    let receipt =\n        receipt!(contract.setApprovalForAll(bob_addr, approved_value))?;\n\n    assert!(receipt.emits(Erc1155::ApprovalForAll {\n        account: alice_addr,\n        operator: bob_addr,\n        approved: approved_value,\n    }));\n\n    let Erc1155::isApprovedForAllReturn { approved } =\n        contract.isApprovedForAll(alice_addr, bob_addr).call().await?;\n    assert_eq!(approved_value, approved);\n\n    let approved_value = false;\n    let receipt =\n        receipt!(contract.setApprovalForAll(bob_addr, approved_value))?;\n\n    assert!(receipt.emits(Erc1155::ApprovalForAll {\n        account: alice_addr,\n        operator: bob_addr,\n        approved: approved_value,\n    }));\n\n    let Erc1155::isApprovedForAllReturn { approved } =\n        contract.isApprovedForAll(alice_addr, bob_addr).call().await?;\n    assert_eq!(approved_value, approved);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_invalid_operator_approval_for_all(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let invalid_operator = Address::ZERO;\n\n    let err = send!(contract.setApprovalForAll(invalid_operator, true))\n        .expect_err(\"should return `ERC1155InvalidOperator`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidOperator {\n        operator: invalid_operator\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn is_approved_for_all_zero_address(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let invalid_operator = Address::ZERO;\n\n    let Erc1155::isApprovedForAllReturn { approved } = contract\n        .isApprovedForAll(alice.address(), invalid_operator)\n        .call()\n        .await?;\n\n    assert!(!approved);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfer_from(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n    watch!(contract.mint(\n        alice_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    let Erc1155::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr, token_id).call().await?;\n    let Erc1155::balanceOfReturn { balance: initial_bob_balance } =\n        contract.balanceOf(bob_addr, token_id).call().await?;\n\n    let receipt = receipt!(contract.safeTransferFrom(\n        alice_addr,\n        bob_addr,\n        token_id,\n        value,\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferSingle {\n        operator: alice_addr,\n        from: alice_addr,\n        to: bob_addr,\n        id: token_id,\n        value\n    }));\n\n    let Erc1155::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr, token_id).call().await?;\n    assert_eq!(initial_alice_balance - value, alice_balance);\n\n    let Erc1155::balanceOfReturn { balance: bob_balance } =\n        contract.balanceOf(bob_addr, token_id).call().await?;\n    assert_eq!(initial_bob_balance + value, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfer_from_with_approval(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc1155::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc1155::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract_bob.mint(\n        bob_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    watch!(contract_bob.setApprovalForAll(alice_addr, true))?;\n\n    let Erc1155::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr, token_id).call().await?;\n    let Erc1155::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr, token_id).call().await?;\n\n    let receipt = receipt!(contract_alice.safeTransferFrom(\n        bob_addr,\n        alice_addr,\n        token_id,\n        value,\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferSingle {\n        operator: alice_addr,\n        from: bob_addr,\n        to: alice_addr,\n        id: token_id,\n        value\n    }));\n\n    let Erc1155::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr, token_id).call().await?;\n    assert_eq!(initial_alice_balance + value, alice_balance);\n\n    let Erc1155::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr, token_id).call().await?;\n    assert_eq!(initial_bob_balance - value, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfer_to_receiver_contract(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_addr =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::None)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract.mint(\n        alice_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    let Erc1155::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr, token_id).call().await?;\n    let Erc1155::balanceOfReturn { balance: initial_receiver_balance } =\n        contract.balanceOf(receiver_addr, token_id).call().await?;\n\n    let receipt = receipt!(contract.safeTransferFrom(\n        alice_addr,\n        receiver_addr,\n        token_id,\n        value,\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferSingle {\n        operator: alice_addr,\n        from: alice_addr,\n        to: receiver_addr,\n        id: token_id,\n        value\n    }));\n\n    assert!(receipt.emits(ERC1155ReceiverMock::Received {\n        operator: alice_addr,\n        from: alice_addr,\n        id: token_id,\n        value,\n        data: vec![].into(),\n    }));\n\n    let Erc1155::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr, token_id).call().await?;\n    assert_eq!(initial_alice_balance - value, alice_balance);\n\n    let Erc1155::balanceOfReturn { balance: receiver_balance } =\n        contract.balanceOf(receiver_addr, token_id).call().await?;\n    assert_eq!(initial_receiver_balance + value, receiver_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_reverts_with_reason(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC1155ReceiverMock::RevertType::RevertWithMessage,\n    )\n    .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract.mint(\n        alice_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    let err = send!(contract.safeTransferFrom(\n        alice_addr,\n        receiver_address,\n        token_id,\n        value,\n        vec![].into()\n    ))\n    .expect_err(\"should not transfer when receiver errors with reason\");\n\n    let message = Erc1155::Error {\n        message: \"ERC1155ReceiverMock: reverting on receive\".to_string(),\n    }\n    .encode_as_str();\n\n    assert!(err.reverted_with(Erc1155::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_reverts_without_reason(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC1155ReceiverMock::RevertType::RevertWithoutMessage,\n    )\n    .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract.mint(\n        alice_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    let err = send!(contract.safeTransferFrom(\n        alice_addr,\n        receiver_address,\n        token_id,\n        value,\n        vec![].into()\n    ))\n    .expect_err(\"should not transfer when receiver reverts\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidReceiver {\n        receiver: receiver_address\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_panics(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::Panic)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract.mint(\n        alice_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    let err = send!(contract.safeTransferFrom(\n        alice_addr,\n        receiver_address,\n        token_id,\n        value,\n        vec![].into()\n    ))\n    .expect_err(\"should not transfer when receiver panics\");\n\n    let message =\n        Erc1155::Panic { code: U256::from(PanicCode::DivisionByZero as u8) }\n            .encode_as_str();\n\n    assert!(err.reverted_with(Erc1155::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_invalid_receiver_contract(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract.mint(\n        alice_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    let err = send!(contract.safeTransferFrom(\n        alice_addr,\n        contract_addr,\n        token_id,\n        value,\n        vec![].into()\n    ))\n    .expect_err(\"should not transfer when invalid receiver contract\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidReceiver {\n        receiver: contract_addr,\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_invalid_receiver_safe_transfer_from(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let invalid_receiver = Address::ZERO;\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n    watch!(contract.mint(alice_addr, token_id, value, vec![].into()))?;\n\n    let err = send!(contract.safeTransferFrom(\n        alice_addr,\n        invalid_receiver,\n        token_id,\n        value,\n        vec![].into()\n    ))\n    .expect_err(\"should return `ERC1155InvalidReceiver`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidReceiver {\n        receiver: invalid_receiver\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_missing_approval_safe_transfer_from(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let dave_addr = dave.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n    watch!(contract.mint(bob_addr, token_id, value, vec![].into()))?;\n\n    let err = send!(contract.safeTransferFrom(\n        bob_addr,\n        dave_addr,\n        token_id,\n        value,\n        vec![].into()\n    ))\n    .expect_err(\"should return `ERC1155MissingApprovalForAll`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155MissingApprovalForAll {\n        operator: alice_addr,\n        owner: bob_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_insufficient_balance_safe_transfer_from(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc1155::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc1155::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let dave_addr = dave.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract_alice.mint(bob_addr, token_id, value, vec![].into()))?;\n    watch!(contract_bob.setApprovalForAll(alice_addr, true))?;\n\n    let err = send!(contract_alice.safeTransferFrom(\n        bob_addr,\n        dave_addr,\n        token_id,\n        value + uint!(1_U256),\n        vec![].into()\n    ))\n    .expect_err(\"should return `ERC1155InsufficientBalance`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InsufficientBalance {\n        sender: bob_addr,\n        balance: value,\n        needed: value + uint!(1_U256),\n        tokenId: token_id\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_batch_transfer_from(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract_alice.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let Erc1155::balanceOfBatchReturn { balances: initial_alice_balances } =\n        contract_alice\n            .balanceOfBatch(vec![alice_addr, alice_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let Erc1155::balanceOfBatchReturn { balances: initial_bob_balances } =\n        contract_alice\n            .balanceOfBatch(vec![bob_addr, bob_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let receipt = receipt!(contract_alice.safeBatchTransferFrom(\n        alice_addr,\n        bob_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferBatch {\n        operator: alice_addr,\n        from: alice_addr,\n        to: bob_addr,\n        ids: token_ids.clone(),\n        values: values.clone()\n    }));\n\n    let Erc1155::balanceOfBatchReturn { balances: alice_balances } =\n        contract_alice\n            .balanceOfBatch(vec![alice_addr, alice_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let Erc1155::balanceOfBatchReturn { balances: bob_balances } =\n        contract_alice\n            .balanceOfBatch(vec![bob_addr, bob_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    for (idx, value) in values.iter().enumerate() {\n        assert_eq!(initial_alice_balances[idx] - value, alice_balances[idx]);\n        assert_eq!(initial_bob_balances[idx] + value, bob_balances[idx]);\n    }\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_batch_transfer_to_receiver_contract(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_addr =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::None)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let Erc1155::balanceOfBatchReturn { balances: initial_alice_balances } =\n        contract\n            .balanceOfBatch(vec![alice_addr, alice_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let Erc1155::balanceOfBatchReturn { balances: initial_receiver_balances } =\n        contract\n            .balanceOfBatch(\n                vec![receiver_addr, receiver_addr],\n                token_ids.clone(),\n            )\n            .call()\n            .await?;\n\n    let receipt = receipt!(contract.safeBatchTransferFrom(\n        alice_addr,\n        receiver_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferBatch {\n        operator: alice_addr,\n        from: alice_addr,\n        to: receiver_addr,\n        ids: token_ids.clone(),\n        values: values.clone()\n    }));\n\n    assert!(receipt.emits(ERC1155ReceiverMock::BatchReceived {\n        operator: alice_addr,\n        from: alice_addr,\n        ids: token_ids.clone(),\n        values: values.clone(),\n        data: vec![].into(),\n    }));\n\n    let Erc1155::balanceOfBatchReturn { balances: alice_balances } = contract\n        .balanceOfBatch(vec![alice_addr, alice_addr], token_ids.clone())\n        .call()\n        .await?;\n\n    let Erc1155::balanceOfBatchReturn { balances: receiver_balances } =\n        contract\n            .balanceOfBatch(\n                vec![receiver_addr, receiver_addr],\n                token_ids.clone(),\n            )\n            .call()\n            .await?;\n\n    for (idx, value) in values.iter().enumerate() {\n        assert_eq!(initial_alice_balances[idx] - value, alice_balances[idx]);\n        assert_eq!(\n            initial_receiver_balances[idx] + value,\n            receiver_balances[idx]\n        );\n    }\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_reverts_with_reason_in_batch_transfer(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC1155ReceiverMock::RevertType::RevertWithMessage,\n    )\n    .await?;\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let err = send!(contract.safeBatchTransferFrom(\n        alice_addr,\n        receiver_address,\n        token_ids,\n        values,\n        vec![].into()\n    ))\n    .expect_err(\"should not transfer when receiver errors with reason\");\n\n    let message = Erc1155::Error {\n        message: \"ERC1155ReceiverMock: reverting on batch receive\".to_string(),\n    }\n    .encode_as_str();\n\n    assert!(err.reverted_with(Erc1155::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_reverts_without_reason_in_batch_transfer(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC1155ReceiverMock::RevertType::RevertWithoutMessage,\n    )\n    .await?;\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let err = send!(contract.safeBatchTransferFrom(\n        alice_addr,\n        receiver_address,\n        token_ids,\n        values,\n        vec![].into()\n    ))\n    .expect_err(\"should not transfer when receiver reverts\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidReceiver {\n        receiver: receiver_address\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_panics_in_batch_transfer(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::Panic)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let err = send!(contract.safeBatchTransferFrom(\n        alice_addr,\n        receiver_address,\n        token_ids,\n        values,\n        vec![].into()\n    ))\n    .expect_err(\"should not transfer when receiver panics\");\n\n    let message =\n        Erc1155::Panic { code: U256::from(PanicCode::DivisionByZero as u8) }\n            .encode_as_str();\n\n    assert!(err.reverted_with(Erc1155::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_invalid_receiver_contract_in_batch_transfer(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let err = send!(contract.safeBatchTransferFrom(\n        alice_addr,\n        contract_addr,\n        token_ids,\n        values,\n        vec![].into()\n    ))\n    .expect_err(\"should not transfer when invalid receiver contract\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidReceiver {\n        receiver: contract_addr,\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_batch_transfer_from_with_approval(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc1155::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc1155::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let dave_addr = dave.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract_alice.mintBatch(\n        bob_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    watch!(contract_bob.setApprovalForAll(alice_addr, true))?;\n\n    let Erc1155::balanceOfBatchReturn { balances: initial_dave_balances } =\n        contract_alice\n            .balanceOfBatch(vec![dave_addr, dave_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let Erc1155::balanceOfBatchReturn { balances: initial_bob_balances } =\n        contract_alice\n            .balanceOfBatch(vec![bob_addr, bob_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let receipt = receipt!(contract_alice.safeBatchTransferFrom(\n        bob_addr,\n        dave_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferBatch {\n        operator: alice_addr,\n        from: bob_addr,\n        to: dave_addr,\n        ids: token_ids.clone(),\n        values: values.clone()\n    }));\n\n    let Erc1155::balanceOfBatchReturn { balances: bob_balances } =\n        contract_alice\n            .balanceOfBatch(vec![bob_addr, bob_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let Erc1155::balanceOfBatchReturn { balances: dave_balances } =\n        contract_alice\n            .balanceOfBatch(vec![dave_addr, dave_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    for (idx, value) in values.iter().enumerate() {\n        assert_eq!(initial_bob_balances[idx] - value, bob_balances[idx]);\n        assert_eq!(initial_dave_balances[idx] + value, dave_balances[idx]);\n    }\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_invalid_receiver_safe_batch_transfer_from(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let invalid_receiver = Address::ZERO;\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let err = send!(contract.safeBatchTransferFrom(\n        alice_addr,\n        invalid_receiver,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))\n    .expect_err(\"should return `ERC1155InvalidReceiver`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidReceiver {\n        receiver: invalid_receiver\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_invalid_array_length_in_safe_batch_transfer_from(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract_alice.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let err = send!(contract_alice.safeBatchTransferFrom(\n        alice_addr,\n        bob_addr,\n        vec![token_ids[0]],\n        values.clone(),\n        vec![].into()\n    ))\n    .expect_err(\"should return `ERC1155InvalidArrayLength`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InvalidArrayLength {\n        idsLength: uint!(1_U256),\n        valuesLength: uint!(2_U256)\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_missing_approval_safe_batch_transfer_from(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let dave_addr = dave.address();\n    let token_ids = random_token_ids(4);\n    let values = random_values(4);\n\n    watch!(contract.mintBatch(\n        bob_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let err = send!(contract.safeBatchTransferFrom(\n        bob_addr,\n        dave_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))\n    .expect_err(\"should return `ERC1155MissingApprovalForAll`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155MissingApprovalForAll {\n        operator: alice_addr,\n        owner: bob_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_insufficient_balance_safe_batch_transfer_from(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc1155::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc1155::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let dave_addr = dave.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract_alice.mintBatch(\n        bob_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n    watch!(contract_bob.setApprovalForAll(alice_addr, true))?;\n\n    let err = send!(contract_alice.safeBatchTransferFrom(\n        bob_addr,\n        dave_addr,\n        token_ids.clone(),\n        vec![values[0] + uint!(1_U256), values[1]],\n        vec![].into()\n    ))\n    .expect_err(\"should return `ERC1155InsufficientBalance`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InsufficientBalance {\n        sender: bob_addr,\n        balance: values[0],\n        needed: values[0] + uint!(1_U256),\n        tokenId: token_ids[0]\n    }));\n\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-1155 Burnable Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn burns(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(1);\n    let values = random_values(1);\n\n    watch!(contract.mint(alice_addr, token_ids[0], values[0], vec![].into()))?;\n\n    let initial_balance =\n        contract.balanceOf(alice_addr, token_ids[0]).call().await?.balance;\n    assert_eq!(values[0], initial_balance);\n\n    let receipt = receipt!(contract.burn(alice_addr, token_ids[0], values[0]))?;\n\n    assert!(receipt.emits(Erc1155::TransferSingle {\n        operator: alice_addr,\n        from: alice_addr,\n        to: Address::ZERO,\n        id: token_ids[0],\n        value: values[0],\n    }));\n\n    let balance =\n        contract.balanceOf(alice_addr, token_ids[0]).call().await?.balance;\n    assert_eq!(U256::ZERO, balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burns_with_approval(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc1155::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(1);\n    let values = random_values(1);\n\n    watch!(contract.mint(bob_addr, token_ids[0], values[0], vec![].into()))?;\n\n    let initial_balance =\n        contract.balanceOf(bob_addr, token_ids[0]).call().await?.balance;\n    assert_eq!(values[0], initial_balance);\n\n    watch!(contract_bob.setApprovalForAll(alice_addr, true))?;\n\n    let receipt = receipt!(contract.burn(bob_addr, token_ids[0], values[0]))?;\n\n    assert!(receipt.emits(Erc1155::TransferSingle {\n        operator: alice_addr,\n        from: bob_addr,\n        to: Address::ZERO,\n        id: token_ids[0],\n        value: values[0],\n    }));\n\n    let balance =\n        contract.balanceOf(bob_addr, token_ids[0]).call().await?.balance;\n    assert_eq!(U256::ZERO, balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_missing_approval_burn(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(1);\n    let values = random_values(1);\n\n    watch!(contract.mint(bob_addr, token_ids[0], values[0], vec![].into()))?;\n\n    let err = send!(contract.burn(bob_addr, token_ids[0], values[0]))\n        .expect_err(\"should return `ERC1155MissingApprovalForAll`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155MissingApprovalForAll {\n        operator: alice_addr,\n        owner: bob_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_insufficient_balance_burn(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n    let to_burn = value + uint!(1_U256);\n\n    watch!(contract.mint(alice_addr, token_id, value, vec![].into()))?;\n\n    let err = send!(contract.burn(alice_addr, token_id, to_burn))\n        .expect_err(\"should return `ERC1155InsufficientBalance`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InsufficientBalance {\n        sender: alice_addr,\n        balance: value,\n        needed: to_burn,\n        tokenId: token_id\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burns_batch(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(4);\n    let values = random_values(4);\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    for (\u0026id, \u0026value) in token_ids.iter().zip(values.iter()) {\n        let balance = contract.balanceOf(alice_addr, id).call().await?.balance;\n        assert_eq!(value, balance);\n    }\n\n    let receipt = receipt!(contract.burnBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferBatch {\n        operator: alice_addr,\n        from: alice_addr,\n        to: Address::ZERO,\n        ids: token_ids.clone(),\n        values,\n    }));\n\n    for id in token_ids {\n        let balance = contract.balanceOf(alice_addr, id).call().await?.balance;\n        assert_eq!(U256::ZERO, balance);\n    }\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burns_batch_with_approval(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc1155::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(4);\n    let values = random_values(4);\n\n    watch!(contract.mintBatch(\n        bob_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    for (\u0026id, \u0026value) in token_ids.iter().zip(values.iter()) {\n        let balance = contract.balanceOf(bob_addr, id).call().await?.balance;\n        assert_eq!(value, balance);\n    }\n\n    watch!(contract_bob.setApprovalForAll(alice_addr, true))?;\n\n    let receipt = receipt!(contract.burnBatch(\n        bob_addr,\n        token_ids.clone(),\n        values.clone()\n    ))?;\n\n    assert!(receipt.emits(Erc1155::TransferBatch {\n        operator: alice_addr,\n        from: bob_addr,\n        to: Address::ZERO,\n        ids: token_ids.clone(),\n        values,\n    }));\n\n    for id in token_ids {\n        let balance = contract.balanceOf(bob_addr, id).call().await?.balance;\n        assert_eq!(U256::ZERO, balance);\n    }\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_missing_approval_burn_batch(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract.mintBatch(\n        bob_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let err = send!(contract.burnBatch(bob_addr, token_ids, values))\n        .expect_err(\"should return `ERC1155MissingApprovalForAll`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155MissingApprovalForAll {\n        operator: alice_addr,\n        owner: bob_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_insufficient_balance_burn_batch(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n    let to_burn: Vec\u003cU256\u003e = values.iter().map(|v| v + uint!(1_U256)).collect();\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let err = send!(contract.burnBatch(\n        alice_addr,\n        token_ids.clone(),\n        to_burn.clone()\n    ))\n    .expect_err(\"should return `ERC1155InsufficientBalance`\");\n\n    assert!(err.reverted_with(Erc1155::ERC1155InsufficientBalance {\n        sender: alice_addr,\n        balance: values[0],\n        needed: to_burn[0],\n        tokenId: token_ids[0]\n    }));\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155","tests","mock","mod.rs"],"content":"pub mod receiver;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155","tests","mock","receiver.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{\n    primitives::{Address, FixedBytes, U256},\n    sol,\n};\nuse e2e::Wallet;\nuse stylus_sdk::{abi::Bytes, function_selector};\n\nconst REC_RETVAL: FixedBytes\u003c4\u003e = FixedBytes(function_selector!(\n    \"onERC1155Received\",\n    Address,\n    Address,\n    U256,\n    U256,\n    Bytes\n));\n\nconst BAT_RETVAL: FixedBytes\u003c4\u003e = FixedBytes(function_selector!(\n    \"onERC1155BatchReceived\",\n    Address,\n    Address,\n    Vec\u003cU256\u003e,\n    Vec\u003cU256\u003e,\n    Bytes\n));\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc 0.8.24+commit.e11b9ed9\n    #[sol(rpc, bytecode=\"60e060405234801562000010575f80fd5b5060405162000f7e38038062000f7e833981810160405281019062000036919062000181565b827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166080817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681525050817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191660a0817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681525050806004811115620000d857620000d7620001da565b5b60c0816004811115620000f057620000ef620001da565b5b8152505050505062000207565b5f80fd5b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b620001378162000101565b811462000142575f80fd5b50565b5f8151905062000155816200012c565b92915050565b6005811062000168575f80fd5b50565b5f815190506200017b816200015b565b92915050565b5f805f606084860312156200019b576200019a620000fd565b5b5f620001aa8682870162000145565b9350506020620001bd8682870162000145565b9250506040620001d0868287016200016b565b9150509250925092565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b60805160a05160c051610d0d620002715f395f8181610153015281816101a30152818161022a015281816102d2015281816103a4015281816103f40152818161047b015261052301525f61036001525f8181610262015281816104b301526105ad0152610d0d5ff3fe608060405234801561000f575f80fd5b506004361061003f575f3560e01c806301ffc9a714610043578063bc197c8114610073578063f23a6e61146100a3575b5f80fd5b61005d60048036038101906100589190610635565b6100d3565b60405161006a919061067a565b60405180910390f35b61008d600480360381019061008891906107a3565b61013c565b60405161009a9190610889565b60405180910390f35b6100bd60048036038101906100b891906108d5565b61038d565b6040516100ca9190610889565b60405180910390f35b5f7f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916149050919050565b5f600160048111156101515761015061096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156101845761018361096b565b5b0361018d575f80fd5b600260048111156101a1576101a061096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156101d4576101d361096b565b5b03610214576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161020b90610a18565b60405180910390fd5b600360048111156102285761022761096b565b5b7f0000000000000000000000000000000000000000000000000000000000000000600481111561025b5761025a61096b565b5b036102bd577f00000000000000000000000000000000000000000000000000000000000000006040517f66435bc00000000000000000000000000000000000000000000000000000000081526004016102b49190610889565b60405180910390fd5b6004808111156102d0576102cf61096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156103035761030261096b565b5b03610319575f805f6103159190610a63565b9050505b7f9facaeece8596899cc39b65f0d1e262008ade8403076a2dfb6df2004fc8d96528989898989898989604051610356989796959493929190610b74565b60405180910390a17f0000000000000000000000000000000000000000000000000000000000000000905098975050505050505050565b5f600160048111156103a2576103a161096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156103d5576103d461096b565b5b036103de575f80fd5b600260048111156103f2576103f161096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156104255761042461096b565b5b03610465576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161045c90610c50565b60405180910390fd5b600360048111156104795761047861096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156104ac576104ab61096b565b5b0361050e577f00000000000000000000000000000000000000000000000000000000000000006040517f66435bc00000000000000000000000000000000000000000000000000000000081526004016105059190610889565b60405180910390fd5b6004808111156105215761052061096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156105545761055361096b565b5b0361056a575f805f6105669190610a63565b9050505b7fe4b060c773f3fcca980bf840b0e2856ca36598bb4da2c0c3913b89050630df378787878787876040516105a396959493929190610c7d565b60405180910390a17f000000000000000000000000000000000000000000000000000000000000000090509695505050505050565b5f80fd5b5f80fd5b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b610614816105e0565b811461061e575f80fd5b50565b5f8135905061062f8161060b565b92915050565b5f6020828403121561064a576106496105d8565b5b5f61065784828501610621565b91505092915050565b5f8115159050919050565b61067481610660565b82525050565b5f60208201905061068d5f83018461066b565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6106bc82610693565b9050919050565b6106cc816106b2565b81146106d6575f80fd5b50565b5f813590506106e7816106c3565b92915050565b5f80fd5b5f80fd5b5f80fd5b5f8083601f84011261070e5761070d6106ed565b5b8235905067ffffffffffffffff81111561072b5761072a6106f1565b5b602083019150836020820283011115610747576107466106f5565b5b9250929050565b5f8083601f840112610763576107626106ed565b5b8235905067ffffffffffffffff8111156107805761077f6106f1565b5b60208301915083600182028301111561079c5761079b6106f5565b5b9250929050565b5f805f805f805f8060a0898b0312156107bf576107be6105d8565b5b5f6107cc8b828c016106d9565b98505060206107dd8b828c016106d9565b975050604089013567ffffffffffffffff8111156107fe576107fd6105dc565b5b61080a8b828c016106f9565b9650965050606089013567ffffffffffffffff81111561082d5761082c6105dc565b5b6108398b828c016106f9565b9450945050608089013567ffffffffffffffff81111561085c5761085b6105dc565b5b6108688b828c0161074e565b92509250509295985092959890939650565b610883816105e0565b82525050565b5f60208201905061089c5f83018461087a565b92915050565b5f819050919050565b6108b4816108a2565b81146108be575f80fd5b50565b5f813590506108cf816108ab565b92915050565b5f805f805f8060a087890312156108ef576108ee6105d8565b5b5f6108fc89828a016106d9565b965050602061090d89828a016106d9565b955050604061091e89828a016108c1565b945050606061092f89828a016108c1565b935050608087013567ffffffffffffffff8111156109505761094f6105dc565b5b61095c89828a0161074e565b92509250509295509295509295565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f82825260208201905092915050565b7f4552433131353552656365697665724d6f636b3a20726576657274696e67206f5f8201527f6e20626174636820726563656976650000000000000000000000000000000000602082015250565b5f610a02602f83610998565b9150610a0d826109a8565b604082019050919050565b5f6020820190508181035f830152610a2f816109f6565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f610a6d826108a2565b9150610a78836108a2565b925082610a8857610a87610a36565b5b828204905092915050565b610a9c816106b2565b82525050565b5f82825260208201905092915050565b5f80fd5b82818337505050565b5f610aca8385610aa2565b93507f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115610afd57610afc610ab2565b5b602083029250610b0e838584610ab6565b82840190509392505050565b5f82825260208201905092915050565b828183375f83830152505050565b5f601f19601f8301169050919050565b5f610b538385610b1a565b9350610b60838584610b2a565b610b6983610b38565b840190509392505050565b5f60a082019050610b875f83018b610a93565b610b94602083018a610a93565b8181036040830152610ba781888a610abf565b90508181036060830152610bbc818688610abf565b90508181036080830152610bd1818486610b48565b90509998505050505050505050565b7f4552433131353552656365697665724d6f636b3a20726576657274696e67206f5f8201527f6e20726563656976650000000000000000000000000000000000000000000000602082015250565b5f610c3a602983610998565b9150610c4582610be0565b604082019050919050565b5f6020820190508181035f830152610c6781610c2e565b9050919050565b610c77816108a2565b82525050565b5f60a082019050610c905f830189610a93565b610c9d6020830188610a93565b610caa6040830187610c6e565b610cb76060830186610c6e565b8181036080830152610cca818486610b48565b905097965050505050505056fea26469706673582212208c442b680a6062015caa02f3c4c74cff54e26169331c5af35a3fa1703a3cc02364736f6c63430008180033\")]\n    contract ERC1155ReceiverMock is ERC165, IERC1155Receiver {\n        enum RevertType {\n            None,\n            RevertWithoutMessage,\n            RevertWithMessage,\n            RevertWithCustomError,\n            Panic\n        }\n\n        bytes4 private immutable _recRetval;\n        bytes4 private immutable _batRetval;\n        RevertType private immutable _error;\n\n        #[derive(Debug, PartialEq)]\n        event Received(address operator, address from, uint256 id, uint256 value, bytes data);\n\n        #[derive(Debug, PartialEq)]\n        event BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data);\n\n        error CustomError(bytes4);\n\n        constructor(bytes4 recRetval, bytes4 batRetval, RevertType error) {\n            _recRetval = recRetval;\n            _batRetval = batRetval;\n            _error = error;\n        }\n\n        function onERC1155Received(\n            address operator,\n            address from,\n            uint256 id,\n            uint256 value,\n            bytes calldata data\n        ) external returns (bytes4) {\n            if (_error == RevertType.RevertWithoutMessage) {\n                revert();\n            } else if (_error == RevertType.RevertWithMessage) {\n                revert(\"ERC1155ReceiverMock: reverting on receive\");\n            } else if (_error == RevertType.RevertWithCustomError) {\n                revert CustomError(_recRetval);\n            } else if (_error == RevertType.Panic) {\n                uint256 a = uint256(0) / uint256(0);\n                a;\n            }\n\n            emit Received(operator, from, id, value, data);\n            return _recRetval;\n        }\n\n        function onERC1155BatchReceived(\n            address operator,\n            address from,\n            uint256[] calldata ids,\n            uint256[] calldata values,\n            bytes calldata data\n        ) external returns (bytes4) {\n            if (_error == RevertType.RevertWithoutMessage) {\n                revert();\n            } else if (_error == RevertType.RevertWithMessage) {\n                revert(\"ERC1155ReceiverMock: reverting on batch receive\");\n            } else if (_error == RevertType.RevertWithCustomError) {\n                revert CustomError(_recRetval);\n            } else if (_error == RevertType.Panic) {\n                uint256 a = uint256(0) / uint256(0);\n                a;\n            }\n\n            emit BatchReceived(operator, from, ids, values, data);\n            return _batRetval;\n        }\n    }\n}\n\npub async fn deploy(\n    wallet: \u0026Wallet,\n    error: ERC1155ReceiverMock::RevertType,\n) -\u003e eyre::Result\u003cAddress\u003e {\n    let contract =\n        ERC1155ReceiverMock::deploy(wallet, REC_RETVAL, BAT_RETVAL, error)\n            .await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155-metadata-uri","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse openzeppelin_stylus::{\n    token::{\n        erc1155,\n        erc1155::{\n            extensions::{\n                Erc1155MetadataUri, Erc1155UriStorage, IErc1155MetadataUri,\n            },\n            Erc1155, IErc1155,\n        },\n    },\n    utils::introspection::erc165::IErc165,\n};\nuse stylus_sdk::{\n    abi::Bytes,\n    alloy_primitives::{Address, FixedBytes, U256},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct Erc1155MetadataUriExample {\n    erc1155: Erc1155,\n    metadata_uri: Erc1155MetadataUri,\n    uri_storage: Erc1155UriStorage,\n}\n\n#[public]\n#[implements(IErc1155\u003cError = erc1155::Error\u003e, IErc1155MetadataUri, IErc165)]\nimpl Erc1155MetadataUriExample {\n    #[constructor]\n    fn constructor(\u0026mut self, uri: String) {\n        self.metadata_uri.constructor(uri);\n    }\n\n    #[selector(name = \"setTokenURI\")]\n    fn set_token_uri(\u0026mut self, token_id: U256, token_uri: String) {\n        self.uri_storage.set_token_uri(token_id, token_uri, \u0026self.metadata_uri)\n    }\n\n    #[selector(name = \"setBaseURI\")]\n    fn set_base_uri(\u0026mut self, base_uri: String) {\n        self.uri_storage.set_base_uri(base_uri)\n    }\n}\n\n#[public]\nimpl IErc1155 for Erc1155MetadataUriExample {\n    type Error = erc1155::Error;\n\n    fn balance_of(\u0026self, account: Address, id: U256) -\u003e U256 {\n        self.erc1155.balance_of(account, id)\n    }\n\n    fn balance_of_batch(\n        \u0026self,\n        accounts: Vec\u003cAddress\u003e,\n        ids: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003cVec\u003cU256\u003e, Self::Error\u003e {\n        self.erc1155.balance_of_batch(accounts, ids)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.set_approval_for_all(operator, approved)\n    }\n\n    fn is_approved_for_all(\u0026self, account: Address, operator: Address) -\u003e bool {\n        self.erc1155.is_approved_for_all(account, operator)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        id: U256,\n        value: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.safe_transfer_from(from, to, id, value, data)\n    }\n\n    fn safe_batch_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155.safe_batch_transfer_from(from, to, ids, values, data)\n    }\n}\n\n#[public]\nimpl IErc1155MetadataUri for Erc1155MetadataUriExample {\n    fn uri(\u0026self, token_id: U256) -\u003e String {\n        self.uri_storage.uri(token_id, \u0026self.metadata_uri)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc1155MetadataUriExample {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        self.erc1155.supports_interface(interface_id)\n            || self.metadata_uri.supports_interface(interface_id)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155-metadata-uri","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc1155_metadata_uri_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155-metadata-uri","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract Erc1155 {\n        #[derive(Debug)]\n        function uri(uint256 id) external view returns (string memory uri);\n        function setTokenURI(uint256 tokenId, string memory tokenURI) external;\n        function setBaseURI(string memory tokenURI) external;\n\n        #[derive(Debug, PartialEq)]\n        event URI(string value, uint256 indexed id);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155-metadata-uri","tests","erc1155-metadata-uri.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::Erc1155;\nuse alloy::primitives::U256;\nuse e2e::{constructor, receipt, watch, Account, Constructor, EventExt};\n\nmod abi;\n\nconst URI: \u0026str = \"https://github.com/OpenZeppelin/rust-contracts-stylus\";\nconst BASE_URI: \u0026str = \"https://github.com\";\n\nfn ctr(uri: \u0026str) -\u003e Constructor {\n    constructor!(uri.to_string())\n}\n\n// ============================================================================\n// Integration Tests: ERC-1155 URI Storage Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn uri_returns_metadata_uri_when_token_uri_is_not_set(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(URI))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = U256::from(1);\n\n    let uri = contract.uri(token_id).call().await?.uri;\n\n    assert_eq!(URI, uri);\n    Ok(())\n}\n\n#[e2e::test]\nasync fn uri_returns_empty_string_when_no_uri_is_set(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(\"\"))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = U256::from(1);\n\n    let uri = contract.uri(token_id).call().await?.uri;\n\n    assert_eq!(\"\", uri);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn uri_returns_concatenated_base_uri_and_token_uri(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(\"\"))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = U256::from(1);\n    let token_uri = \"/some/token/uri\";\n    let expected_uri = BASE_URI.to_owned() + token_uri;\n\n    watch!(contract.setBaseURI(BASE_URI.to_owned()))?;\n\n    let receipt =\n        receipt!(contract.setTokenURI(token_id, token_uri.to_owned()))?;\n\n    assert!(receipt\n        .emits(Erc1155::URI { value: expected_uri.clone(), id: token_id }));\n\n    let uri = contract.uri(token_id).call().await?.uri;\n\n    assert_eq!(expected_uri, uri);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn uri_returns_token_uri_when_base_uri_is_empty(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(\"\"))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = U256::from(1);\n    let token_uri = \"https://random.uri/some/token/uri\";\n\n    let receipt =\n        receipt!(contract.setTokenURI(token_id, token_uri.to_owned()))?;\n\n    assert!(receipt\n        .emits(Erc1155::URI { value: token_uri.to_owned(), id: token_id }));\n\n    let uri = contract.uri(token_id).call().await?.uri;\n\n    assert_eq!(token_uri, uri);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn uri_ignores_metadata_uri_when_token_uri_is_set(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(URI))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc1155::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = U256::from(1);\n    let token_uri = \"/some/token/uri\";\n    let expected_uri = BASE_URI.to_owned() + token_uri;\n\n    watch!(contract.setBaseURI(BASE_URI.to_owned()))?;\n\n    let receipt =\n        receipt!(contract.setTokenURI(token_id, token_uri.to_owned()))?;\n\n    assert!(receipt\n        .emits(Erc1155::URI { value: expected_uri.clone(), id: token_id }));\n\n    let uri = contract.uri(token_id).call().await?.uri;\n\n    assert_eq!(expected_uri, uri);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155-supply","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n#![allow(clippy::result_large_err)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse alloy_primitives::{Address, FixedBytes, U256};\nuse openzeppelin_stylus::{\n    token::erc1155::{\n        self,\n        extensions::{Erc1155Supply, IErc1155Burnable, IErc1155Supply},\n        IErc1155,\n    },\n    utils::introspection::erc165::IErc165,\n};\nuse stylus_sdk::{abi::Bytes, prelude::*};\n\n#[entrypoint]\n#[storage]\nstruct Erc1155Example {\n    erc1155_supply: Erc1155Supply,\n}\n\n#[public]\n#[implements(IErc1155\u003cError = erc1155::Error\u003e, IErc1155Burnable\u003cError = erc1155::Error\u003e, IErc1155Supply, IErc165)]\nimpl Erc1155Example {\n    // Add token minting feature.\n    fn mint(\n        \u0026mut self,\n        to: Address,\n        id: U256,\n        value: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        self.erc1155_supply._mint(to, id, value, \u0026data)\n    }\n\n    fn mint_batch(\n        \u0026mut self,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: Bytes,\n    ) -\u003e Result\u003c(), erc1155::Error\u003e {\n        self.erc1155_supply._mint_batch(to, ids, values, \u0026data)\n    }\n}\n\n#[public]\nimpl IErc1155 for Erc1155Example {\n    type Error = erc1155::Error;\n\n    fn balance_of(\u0026self, account: Address, id: U256) -\u003e U256 {\n        self.erc1155_supply.balance_of(account, id)\n    }\n\n    fn balance_of_batch(\n        \u0026self,\n        accounts: Vec\u003cAddress\u003e,\n        ids: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003cVec\u003cU256\u003e, Self::Error\u003e {\n        self.erc1155_supply.balance_of_batch(accounts, ids)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155_supply.set_approval_for_all(operator, approved)\n    }\n\n    fn is_approved_for_all(\u0026self, account: Address, operator: Address) -\u003e bool {\n        self.erc1155_supply.is_approved_for_all(account, operator)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        id: U256,\n        value: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155_supply.safe_transfer_from(from, to, id, value, data)\n    }\n\n    fn safe_batch_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155_supply\n            .safe_batch_transfer_from(from, to, ids, values, data)\n    }\n}\n\n#[public]\nimpl IErc1155Burnable for Erc1155Example {\n    type Error = erc1155::Error;\n\n    // Add token burning feature.\n    fn burn(\n        \u0026mut self,\n        from: Address,\n        id: U256,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155_supply._burn(from, id, value)\n    }\n\n    fn burn_batch(\n        \u0026mut self,\n        from: Address,\n        ids: Vec\u003cU256\u003e,\n        values: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc1155_supply._burn_batch(from, ids, values)\n    }\n}\n\n#[public]\nimpl IErc1155Supply for Erc1155Example {\n    fn total_supply(\u0026self, id: U256) -\u003e U256 {\n        self.erc1155_supply.total_supply(id)\n    }\n\n    #[selector(name = \"totalSupply\")]\n    fn total_supply_all(\u0026self) -\u003e U256 {\n        self.erc1155_supply.total_supply_all()\n    }\n\n    fn exists(\u0026self, id: U256) -\u003e bool {\n        self.erc1155_supply.exists(id)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc1155Example {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        self.erc1155_supply.supports_interface(interface_id)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155-supply","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc1155_supply_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155-supply","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract Erc1155Supply {\n        function balanceOf(address account, uint256 id) external view returns (uint256 balance);\n        #[derive(Debug)]\n        function balanceOfBatch(address[] accounts, uint256[] ids) external view returns (uint256[] memory balances);\n        function isApprovedForAll(address account, address operator) external view returns (bool approved);\n        function setApprovalForAll(address operator, bool approved) external;\n        function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) external;\n        function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data) external;\n        function mint(address to, uint256 id, uint256 amount, bytes memory data) external;\n        function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external;\n        function burn(address account, uint256 id, uint256 value) external;\n        function burnBatch(address account, uint256[] memory ids, uint256[] memory values) external;\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\n        function totalSupply(uint256 id) external view returns (uint256);\n        function totalSupply() external view returns (uint256);\n        function exists(uint256 id) external view returns (bool);\n\n        error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n        error ERC1155InvalidOperator(address operator);\n        error ERC1155InvalidSender(address sender);\n        error ERC1155InvalidReceiver(address receiver);\n        error ERC1155MissingApprovalForAll(address operator, address owner);\n        error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n        #[derive(Debug, PartialEq)]\n        event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n        #[derive(Debug, PartialEq)]\n        event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n        #[derive(Debug, PartialEq)]\n        event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155-supply","tests","erc1155-supply.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::Erc1155Supply;\nuse alloy::primitives::{Address, U256};\nuse e2e::{receipt, send, watch, Account, EventExt, Panic, PanicCode};\nuse mock::{receiver, receiver::ERC1155ReceiverMock};\n\nmod abi;\nmod mock;\n\nfn random_token_ids(size: usize) -\u003e Vec\u003cU256\u003e {\n    (0..size).map(U256::from).collect()\n}\n\nfn random_values(size: usize) -\u003e Vec\u003cU256\u003e {\n    (1..=size).map(U256::from).collect()\n}\n\n// ============================================================================\n// Integration Tests: ERC-1155 Supply Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_ids(1)[0];\n\n    let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n    let token_exists = contract.exists(token_id).call().await?._0;\n\n    assert_eq!(U256::ZERO, total_supply);\n    assert_eq!(U256::ZERO, total_supply_all);\n    assert!(!token_exists);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mint(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    let receipt =\n        receipt!(contract.mint(alice_addr, token_id, value, vec![].into()))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferSingle {\n        operator: alice_addr,\n        from: Address::ZERO,\n        to: alice_addr,\n        id: token_id,\n        value,\n    }));\n\n    let balance =\n        contract.balanceOf(alice_addr, token_id).call().await?.balance;\n    let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n    let token_exists = contract.exists(token_id).call().await?._0;\n\n    assert_eq!(value, balance);\n    assert_eq!(value, total_supply);\n    assert_eq!(value, total_supply_all);\n    assert!(token_exists);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mint_to_receiver_contract(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_addr =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::None)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    let initial_receiver_balance =\n        contract.balanceOf(receiver_addr, token_id).call().await?.balance;\n\n    let receipt =\n        receipt!(contract.mint(receiver_addr, token_id, value, vec![].into()))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferSingle {\n        operator: alice_addr,\n        from: Address::ZERO,\n        to: receiver_addr,\n        id: token_id,\n        value\n    }));\n\n    assert!(receipt.emits(ERC1155ReceiverMock::Received {\n        operator: alice_addr,\n        from: Address::ZERO,\n        id: token_id,\n        value,\n        data: vec![].into(),\n    }));\n\n    let receiver_balance =\n        contract.balanceOf(receiver_addr, token_id).call().await?.balance;\n    let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n    let token_exists = contract.exists(token_id).call().await?._0;\n\n    assert_eq!(initial_receiver_balance + value, receiver_balance);\n    assert_eq!(value, total_supply);\n    assert_eq!(value, total_supply_all);\n    assert!(token_exists);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mint_batch(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    let accounts = vec![alice_addr, bob_addr];\n\n    for \u0026account in \u0026accounts {\n        let receipt = receipt!(contract.mintBatch(\n            account,\n            token_ids.clone(),\n            values.clone(),\n            vec![].into()\n        ))?;\n\n        assert!(receipt.emits(Erc1155Supply::TransferBatch {\n            operator: alice_addr,\n            from: Address::ZERO,\n            to: account,\n            ids: token_ids.clone(),\n            values: values.clone()\n        }));\n\n        let balances = contract\n            .balanceOfBatch(vec![account, account], token_ids.clone())\n            .call()\n            .await?\n            .balances;\n\n        assert_eq!(values, balances);\n    }\n\n    let accounts_len = U256::from(accounts.len());\n\n    for (\u0026token_id, \u0026value) in token_ids.iter().zip(values.iter()) {\n        let token_exists = contract.exists(token_id).call().await?._0;\n        let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n\n        assert_eq!(value * accounts_len, total_supply);\n        assert!(token_exists);\n    }\n\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n    assert_eq!(values.iter().sum::\u003cU256\u003e() * accounts_len, total_supply_all);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mint_batch_transfer_to_receiver_contract(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_addr =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::None)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    let initial_receiver_balances = contract\n        .balanceOfBatch(vec![receiver_addr, receiver_addr], token_ids.clone())\n        .call()\n        .await?\n        .balances;\n\n    let receipt = receipt!(contract.mintBatch(\n        receiver_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferBatch {\n        operator: alice_addr,\n        from: Address::ZERO,\n        to: receiver_addr,\n        ids: token_ids.clone(),\n        values: values.clone()\n    }));\n\n    assert!(receipt.emits(ERC1155ReceiverMock::BatchReceived {\n        operator: alice_addr,\n        from: Address::ZERO,\n        ids: token_ids.clone(),\n        values: values.clone(),\n        data: vec![].into(),\n    }));\n\n    let receiver_balances = contract\n        .balanceOfBatch(vec![receiver_addr, receiver_addr], token_ids.clone())\n        .call()\n        .await?\n        .balances;\n\n    for (idx, (\u0026token_id, \u0026value)) in\n        token_ids.iter().zip(values.iter()).enumerate()\n    {\n        let token_exists = contract.exists(token_id).call().await?._0;\n        let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n\n        assert_eq!(\n            initial_receiver_balances[idx] + value,\n            receiver_balances[idx]\n        );\n        assert_eq!(value, total_supply);\n        assert!(token_exists);\n    }\n\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n    assert_eq!(values.iter().sum::\u003cU256\u003e(), total_supply_all);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mint_panics_on_total_supply_overflow(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_ids(1)[0];\n    let two = U256::from(2);\n    let three = U256::from(3);\n\n    watch!(contract.mint(\n        alice_addr,\n        token_id,\n        U256::MAX / two,\n        vec![].into()\n    ))?;\n    watch!(contract.mint(bob_addr, token_id, U256::MAX / two, vec![].into()))?;\n\n    let err = send!(contract.mint(alice_addr, token_id, three, vec![].into()))\n        .expect_err(\"should panic due to total_supply overflow\");\n\n    assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mint_panics_on_total_supply_all_overflow(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(2);\n\n    watch!(contract.mint(alice_addr, token_ids[0], U256::MAX, vec![].into()))?;\n\n    let err = send!(contract.mint(\n        alice_addr,\n        token_ids[1],\n        U256::from(1),\n        vec![].into()\n    ))\n    .expect_err(\"should panic due to total_supply_all overflow\");\n\n    assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burn(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract.mint(alice_addr, token_id, value, vec![].into()))?;\n\n    let receipt = receipt!(contract.burn(alice_addr, token_id, value))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferSingle {\n        operator: alice_addr,\n        from: alice_addr,\n        to: Address::ZERO,\n        id: token_id,\n        value,\n    }));\n\n    let token_exists = contract.exists(token_id).call().await?._0;\n    let balance =\n        contract.balanceOf(alice_addr, token_id).call().await?.balance;\n    let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n\n    assert_eq!(U256::ZERO, balance);\n    assert_eq!(U256::ZERO, total_supply);\n    assert_eq!(U256::ZERO, total_supply_all);\n    assert!(!token_exists);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burn_with_approval(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc1155Supply::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract.mint(bob_addr, token_id, value, vec![].into()))?;\n\n    watch!(contract_bob.setApprovalForAll(alice_addr, true))?;\n\n    let receipt = receipt!(contract.burn(bob_addr, token_id, value))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferSingle {\n        operator: alice_addr,\n        from: bob_addr,\n        to: Address::ZERO,\n        id: token_id,\n        value,\n    }));\n\n    let token_exists = contract.exists(token_id).call().await?._0;\n    let balance = contract.balanceOf(bob_addr, token_id).call().await?.balance;\n    let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n\n    assert_eq!(U256::ZERO, balance);\n    assert_eq!(U256::ZERO, total_supply);\n    assert_eq!(U256::ZERO, total_supply_all);\n    assert!(!token_exists);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burn_batch(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(4);\n    let values = random_values(4);\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let receipt = receipt!(contract.burnBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferBatch {\n        operator: alice_addr,\n        from: alice_addr,\n        to: Address::ZERO,\n        ids: token_ids.clone(),\n        values,\n    }));\n\n    for token_id in token_ids {\n        let balance =\n            contract.balanceOf(alice_addr, token_id).call().await?.balance;\n        let token_exists = contract.exists(token_id).call().await?._0;\n        let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n\n        assert_eq!(U256::ZERO, balance);\n        assert_eq!(U256::ZERO, total_supply);\n        assert!(!token_exists);\n    }\n\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n    assert_eq!(U256::ZERO, total_supply_all);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burn_batch_with_approval(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc1155Supply::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(4);\n    let values = random_values(4);\n\n    watch!(contract.mintBatch(\n        bob_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    watch!(contract_bob.setApprovalForAll(alice_addr, true))?;\n\n    let receipt = receipt!(contract.burnBatch(\n        bob_addr,\n        token_ids.clone(),\n        values.clone()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferBatch {\n        operator: alice_addr,\n        from: bob_addr,\n        to: Address::ZERO,\n        ids: token_ids.clone(),\n        values,\n    }));\n\n    for token_id in token_ids {\n        let balance =\n            contract.balanceOf(bob_addr, token_id).call().await?.balance;\n        let token_exists = contract.exists(token_id).call().await?._0;\n        let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n\n        assert_eq!(U256::ZERO, balance);\n        assert_eq!(U256::ZERO, total_supply);\n        assert!(!token_exists);\n    }\n\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n    assert_eq!(U256::ZERO, total_supply_all);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn supply_unaffected_by_safe_transfer_from(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract.mint(alice_addr, token_id, value, vec![].into()))?;\n\n    // assert balances as expected after mint\n    let alice_balance =\n        contract.balanceOf(alice_addr, token_id).call().await?.balance;\n    let bob_balance =\n        contract.balanceOf(bob_addr, token_id).call().await?.balance;\n\n    assert_eq!(value, alice_balance);\n    assert_eq!(U256::ZERO, bob_balance);\n\n    // total supplies (all) logic has been checked in other tests, assume valid\n    let initial_total_supply =\n        contract.totalSupply_0(token_id).call().await?._0;\n    let initial_total_supply_all = contract.totalSupply_1().call().await?._0;\n\n    let receipt = receipt!(contract.safeTransferFrom(\n        alice_addr,\n        bob_addr,\n        token_id,\n        value,\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferSingle {\n        operator: alice_addr,\n        from: alice_addr,\n        to: bob_addr,\n        id: token_id,\n        value,\n    }));\n\n    // assert balances updated as expected\n    let alice_balance =\n        contract.balanceOf(alice_addr, token_id).call().await?.balance;\n    let bob_balance =\n        contract.balanceOf(bob_addr, token_id).call().await?.balance;\n\n    assert_eq!(U256::ZERO, alice_balance);\n    assert_eq!(value, bob_balance);\n\n    // assert supply-related data remains unchanged\n    let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n    let token_exists = contract.exists(token_id).call().await?._0;\n\n    assert_eq!(initial_total_supply, total_supply);\n    assert_eq!(initial_total_supply_all, total_supply_all);\n    assert!(token_exists);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn supply_unaffected_by_safe_transfer_from_batch(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(4);\n    let values = random_values(4);\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    // assert balances as expected after mint\n    for (\u0026token_id, \u0026value) in token_ids.iter().zip(values.iter()) {\n        let alice_balance =\n            contract.balanceOf(alice_addr, token_id).call().await?.balance;\n        let bob_balance =\n            contract.balanceOf(bob_addr, token_id).call().await?.balance;\n\n        assert_eq!(value, alice_balance);\n        assert_eq!(U256::ZERO, bob_balance);\n    }\n\n    // total supplies (all) logic has been checked in other tests, assume valid\n    let mut initial_total_supplies: Vec\u003cU256\u003e = vec![];\n    for \u0026token_id in \u0026token_ids {\n        let supply = contract.totalSupply_0(token_id).call().await?._0;\n        initial_total_supplies.push(supply);\n    }\n    let initial_total_supply_all = contract.totalSupply_1().call().await?._0;\n\n    let receipt = receipt!(contract.safeBatchTransferFrom(\n        alice_addr,\n        bob_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferBatch {\n        operator: alice_addr,\n        from: alice_addr,\n        to: bob_addr,\n        ids: token_ids.clone(),\n        values: values.clone(),\n    }));\n\n    // assert balances updated as expected\n    for (\u0026token_id, \u0026value) in token_ids.iter().zip(values.iter()) {\n        let alice_balance =\n            contract.balanceOf(alice_addr, token_id).call().await?.balance;\n        let bob_balance =\n            contract.balanceOf(bob_addr, token_id).call().await?.balance;\n\n        assert_eq!(U256::ZERO, alice_balance);\n        assert_eq!(value, bob_balance);\n    }\n\n    // assert supply-related data remains unchanged\n    for (\u0026token_id, \u0026initial_total_supply) in\n        token_ids.iter().zip(initial_total_supplies.iter())\n    {\n        let total_supply = contract.totalSupply_0(token_id).call().await?._0;\n        let token_exists = contract.exists(token_id).call().await?._0;\n\n        assert_eq!(initial_total_supply, total_supply);\n        assert!(token_exists);\n    }\n\n    let total_supply_all = contract.totalSupply_1().call().await?._0;\n    assert_eq!(initial_total_supply_all, total_supply_all);\n\n    Ok(())\n}\n\n// =====================================================================\n// Integration Tests: Happy Paths of Re-exported functions from ERC-1155\n// =====================================================================\n\n#[e2e::test]\nasync fn balance_of_zero_balance(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n    let token_ids = random_token_ids(1);\n\n    let Erc1155Supply::balanceOfReturn { balance } =\n        contract.balanceOf(alice.address(), token_ids[0]).call().await?;\n    assert_eq!(U256::ZERO, balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn balance_of_batch_zero_balance(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n    charlie: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n    let accounts =\n        vec![alice.address(), bob.address(), dave.address(), charlie.address()];\n    let token_ids = random_token_ids(4);\n\n    let Erc1155Supply::balanceOfBatchReturn { balances } =\n        contract.balanceOfBatch(accounts, token_ids).call().await?;\n    assert_eq!(vec![U256::ZERO, U256::ZERO, U256::ZERO, U256::ZERO], balances);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn set_approval_for_all(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let approved_value = true;\n    let receipt =\n        receipt!(contract.setApprovalForAll(bob_addr, approved_value))?;\n\n    assert!(receipt.emits(Erc1155Supply::ApprovalForAll {\n        account: alice_addr,\n        operator: bob_addr,\n        approved: approved_value,\n    }));\n\n    let Erc1155Supply::isApprovedForAllReturn { approved } =\n        contract.isApprovedForAll(alice_addr, bob_addr).call().await?;\n    assert_eq!(approved_value, approved);\n\n    let approved_value = false;\n    let receipt =\n        receipt!(contract.setApprovalForAll(bob_addr, approved_value))?;\n\n    assert!(receipt.emits(Erc1155Supply::ApprovalForAll {\n        account: alice_addr,\n        operator: bob_addr,\n        approved: approved_value,\n    }));\n\n    let Erc1155Supply::isApprovedForAllReturn { approved } =\n        contract.isApprovedForAll(alice_addr, bob_addr).call().await?;\n    assert_eq!(approved_value, approved);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn is_approved_for_all_zero_address(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let invalid_operator = Address::ZERO;\n\n    let Erc1155Supply::isApprovedForAllReturn { approved } = contract\n        .isApprovedForAll(alice.address(), invalid_operator)\n        .call()\n        .await?;\n\n    assert_eq!(false, approved);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfer_from(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n    watch!(contract.mint(\n        alice_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    let Erc1155Supply::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr, token_id).call().await?;\n    let Erc1155Supply::balanceOfReturn { balance: initial_bob_balance } =\n        contract.balanceOf(bob_addr, token_id).call().await?;\n\n    let receipt = receipt!(contract.safeTransferFrom(\n        alice_addr,\n        bob_addr,\n        token_id,\n        value,\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferSingle {\n        operator: alice_addr,\n        from: alice_addr,\n        to: bob_addr,\n        id: token_id,\n        value\n    }));\n\n    let Erc1155Supply::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr, token_id).call().await?;\n    assert_eq!(initial_alice_balance - value, alice_balance);\n\n    let Erc1155Supply::balanceOfReturn { balance: bob_balance } =\n        contract.balanceOf(bob_addr, token_id).call().await?;\n    assert_eq!(initial_bob_balance + value, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfer_from_with_approval(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc1155Supply::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract_bob.mint(\n        bob_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    watch!(contract_bob.setApprovalForAll(alice_addr, true))?;\n\n    let Erc1155Supply::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr, token_id).call().await?;\n    let Erc1155Supply::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr, token_id).call().await?;\n\n    let receipt = receipt!(contract_alice.safeTransferFrom(\n        bob_addr,\n        alice_addr,\n        token_id,\n        value,\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferSingle {\n        operator: alice_addr,\n        from: bob_addr,\n        to: alice_addr,\n        id: token_id,\n        value\n    }));\n\n    let Erc1155Supply::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr, token_id).call().await?;\n    assert_eq!(initial_alice_balance + value, alice_balance);\n\n    let Erc1155Supply::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr, token_id).call().await?;\n    assert_eq!(initial_bob_balance - value, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfer_to_receiver_contract(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_addr =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::None)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_ids(1)[0];\n    let value = random_values(1)[0];\n\n    watch!(contract.mint(\n        alice_addr,\n        token_id,\n        value,\n        vec![0, 1, 2, 3].into()\n    ))?;\n\n    let Erc1155Supply::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr, token_id).call().await?;\n    let Erc1155Supply::balanceOfReturn { balance: initial_receiver_balance } =\n        contract.balanceOf(receiver_addr, token_id).call().await?;\n\n    let receipt = receipt!(contract.safeTransferFrom(\n        alice_addr,\n        receiver_addr,\n        token_id,\n        value,\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferSingle {\n        operator: alice_addr,\n        from: alice_addr,\n        to: receiver_addr,\n        id: token_id,\n        value\n    }));\n\n    assert!(receipt.emits(ERC1155ReceiverMock::Received {\n        operator: alice_addr,\n        from: alice_addr,\n        id: token_id,\n        value,\n        data: vec![].into(),\n    }));\n\n    let Erc1155Supply::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr, token_id).call().await?;\n    assert_eq!(initial_alice_balance - value, alice_balance);\n\n    let Erc1155Supply::balanceOfReturn { balance: receiver_balance } =\n        contract.balanceOf(receiver_addr, token_id).call().await?;\n    assert_eq!(initial_receiver_balance + value, receiver_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_batch_transfer_from(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract_alice.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let Erc1155Supply::balanceOfBatchReturn {\n        balances: initial_alice_balances,\n    } = contract_alice\n        .balanceOfBatch(vec![alice_addr, alice_addr], token_ids.clone())\n        .call()\n        .await?;\n\n    let Erc1155Supply::balanceOfBatchReturn { balances: initial_bob_balances } =\n        contract_alice\n            .balanceOfBatch(vec![bob_addr, bob_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let receipt = receipt!(contract_alice.safeBatchTransferFrom(\n        alice_addr,\n        bob_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferBatch {\n        operator: alice_addr,\n        from: alice_addr,\n        to: bob_addr,\n        ids: token_ids.clone(),\n        values: values.clone()\n    }));\n\n    let Erc1155Supply::balanceOfBatchReturn { balances: alice_balances } =\n        contract_alice\n            .balanceOfBatch(vec![alice_addr, alice_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let Erc1155Supply::balanceOfBatchReturn { balances: bob_balances } =\n        contract_alice\n            .balanceOfBatch(vec![bob_addr, bob_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    for (idx, value) in values.iter().enumerate() {\n        assert_eq!(initial_alice_balances[idx] - value, alice_balances[idx]);\n        assert_eq!(initial_bob_balances[idx] + value, bob_balances[idx]);\n    }\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_batch_transfer_to_receiver_contract(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_addr =\n        receiver::deploy(\u0026alice.wallet, ERC1155ReceiverMock::RevertType::None)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract.mintBatch(\n        alice_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    let Erc1155Supply::balanceOfBatchReturn {\n        balances: initial_alice_balances,\n    } = contract\n        .balanceOfBatch(vec![alice_addr, alice_addr], token_ids.clone())\n        .call()\n        .await?;\n\n    let Erc1155Supply::balanceOfBatchReturn {\n        balances: initial_receiver_balances,\n    } = contract\n        .balanceOfBatch(vec![receiver_addr, receiver_addr], token_ids.clone())\n        .call()\n        .await?;\n\n    let receipt = receipt!(contract.safeBatchTransferFrom(\n        alice_addr,\n        receiver_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferBatch {\n        operator: alice_addr,\n        from: alice_addr,\n        to: receiver_addr,\n        ids: token_ids.clone(),\n        values: values.clone()\n    }));\n\n    assert!(receipt.emits(ERC1155ReceiverMock::BatchReceived {\n        operator: alice_addr,\n        from: alice_addr,\n        ids: token_ids.clone(),\n        values: values.clone(),\n        data: vec![].into(),\n    }));\n\n    let Erc1155Supply::balanceOfBatchReturn { balances: alice_balances } =\n        contract\n            .balanceOfBatch(vec![alice_addr, alice_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let Erc1155Supply::balanceOfBatchReturn { balances: receiver_balances } =\n        contract\n            .balanceOfBatch(\n                vec![receiver_addr, receiver_addr],\n                token_ids.clone(),\n            )\n            .call()\n            .await?;\n\n    for (idx, value) in values.iter().enumerate() {\n        assert_eq!(initial_alice_balances[idx] - value, alice_balances[idx]);\n        assert_eq!(\n            initial_receiver_balances[idx] + value,\n            receiver_balances[idx]\n        );\n    }\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_batch_transfer_from_with_approval(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc1155Supply::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let dave_addr = dave.address();\n    let token_ids = random_token_ids(2);\n    let values = random_values(2);\n\n    watch!(contract_alice.mintBatch(\n        bob_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    watch!(contract_bob.setApprovalForAll(alice_addr, true))?;\n\n    let Erc1155Supply::balanceOfBatchReturn { balances: initial_dave_balances } =\n        contract_alice\n            .balanceOfBatch(vec![dave_addr, dave_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let Erc1155Supply::balanceOfBatchReturn { balances: initial_bob_balances } =\n        contract_alice\n            .balanceOfBatch(vec![bob_addr, bob_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let receipt = receipt!(contract_alice.safeBatchTransferFrom(\n        bob_addr,\n        dave_addr,\n        token_ids.clone(),\n        values.clone(),\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc1155Supply::TransferBatch {\n        operator: alice_addr,\n        from: bob_addr,\n        to: dave_addr,\n        ids: token_ids.clone(),\n        values: values.clone()\n    }));\n\n    let Erc1155Supply::balanceOfBatchReturn { balances: bob_balances } =\n        contract_alice\n            .balanceOfBatch(vec![bob_addr, bob_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    let Erc1155Supply::balanceOfBatchReturn { balances: dave_balances } =\n        contract_alice\n            .balanceOfBatch(vec![dave_addr, dave_addr], token_ids.clone())\n            .call()\n            .await?;\n\n    for (idx, value) in values.iter().enumerate() {\n        assert_eq!(initial_bob_balances[idx] - value, bob_balances[idx]);\n        assert_eq!(initial_dave_balances[idx] + value, dave_balances[idx]);\n    }\n\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-165 Support Interface\n// ============================================================================\n\n#[e2e::test]\nasync fn supports_interface(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc1155Supply::new(contract_addr, \u0026alice.wallet);\n    let invalid_interface_id: u32 = 0xffffffff;\n    let supports_interface = contract\n        .supportsInterface(invalid_interface_id.into())\n        .call()\n        .await?\n        ._0;\n\n    assert!(!supports_interface);\n\n    let erc1155_interface_id: u32 = 0xd9b67a26;\n    let supports_interface = contract\n        .supportsInterface(erc1155_interface_id.into())\n        .call()\n        .await?\n        ._0;\n\n    assert!(supports_interface);\n\n    let erc165_interface_id: u32 = 0x01ffc9a7;\n    let supports_interface =\n        contract.supportsInterface(erc165_interface_id.into()).call().await?._0;\n\n    assert!(supports_interface);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155-supply","tests","mock","mod.rs"],"content":"pub mod receiver;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc1155-supply","tests","mock","receiver.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{\n    primitives::{Address, FixedBytes, U256},\n    sol,\n};\nuse e2e::Wallet;\nuse stylus_sdk::{abi::Bytes, function_selector};\n\nconst REC_RETVAL: FixedBytes\u003c4\u003e = FixedBytes(function_selector!(\n    \"onERC1155Received\",\n    Address,\n    Address,\n    U256,\n    U256,\n    Bytes\n));\n\nconst BAT_RETVAL: FixedBytes\u003c4\u003e = FixedBytes(function_selector!(\n    \"onERC1155BatchReceived\",\n    Address,\n    Address,\n    Vec\u003cU256\u003e,\n    Vec\u003cU256\u003e,\n    Bytes\n));\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc 0.8.24+commit.e11b9ed9\n    #[sol(rpc, bytecode=\"60e060405234801562000010575f80fd5b5060405162000f7e38038062000f7e833981810160405281019062000036919062000181565b827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166080817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681525050817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191660a0817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681525050806004811115620000d857620000d7620001da565b5b60c0816004811115620000f057620000ef620001da565b5b8152505050505062000207565b5f80fd5b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b620001378162000101565b811462000142575f80fd5b50565b5f8151905062000155816200012c565b92915050565b6005811062000168575f80fd5b50565b5f815190506200017b816200015b565b92915050565b5f805f606084860312156200019b576200019a620000fd565b5b5f620001aa8682870162000145565b9350506020620001bd8682870162000145565b9250506040620001d0868287016200016b565b9150509250925092565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b60805160a05160c051610d0d620002715f395f8181610153015281816101a30152818161022a015281816102d2015281816103a4015281816103f40152818161047b015261052301525f61036001525f8181610262015281816104b301526105ad0152610d0d5ff3fe608060405234801561000f575f80fd5b506004361061003f575f3560e01c806301ffc9a714610043578063bc197c8114610073578063f23a6e61146100a3575b5f80fd5b61005d60048036038101906100589190610635565b6100d3565b60405161006a919061067a565b60405180910390f35b61008d600480360381019061008891906107a3565b61013c565b60405161009a9190610889565b60405180910390f35b6100bd60048036038101906100b891906108d5565b61038d565b6040516100ca9190610889565b60405180910390f35b5f7f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916149050919050565b5f600160048111156101515761015061096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156101845761018361096b565b5b0361018d575f80fd5b600260048111156101a1576101a061096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156101d4576101d361096b565b5b03610214576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161020b90610a18565b60405180910390fd5b600360048111156102285761022761096b565b5b7f0000000000000000000000000000000000000000000000000000000000000000600481111561025b5761025a61096b565b5b036102bd577f00000000000000000000000000000000000000000000000000000000000000006040517f66435bc00000000000000000000000000000000000000000000000000000000081526004016102b49190610889565b60405180910390fd5b6004808111156102d0576102cf61096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156103035761030261096b565b5b03610319575f805f6103159190610a63565b9050505b7f9facaeece8596899cc39b65f0d1e262008ade8403076a2dfb6df2004fc8d96528989898989898989604051610356989796959493929190610b74565b60405180910390a17f0000000000000000000000000000000000000000000000000000000000000000905098975050505050505050565b5f600160048111156103a2576103a161096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156103d5576103d461096b565b5b036103de575f80fd5b600260048111156103f2576103f161096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156104255761042461096b565b5b03610465576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161045c90610c50565b60405180910390fd5b600360048111156104795761047861096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156104ac576104ab61096b565b5b0361050e577f00000000000000000000000000000000000000000000000000000000000000006040517f66435bc00000000000000000000000000000000000000000000000000000000081526004016105059190610889565b60405180910390fd5b6004808111156105215761052061096b565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156105545761055361096b565b5b0361056a575f805f6105669190610a63565b9050505b7fe4b060c773f3fcca980bf840b0e2856ca36598bb4da2c0c3913b89050630df378787878787876040516105a396959493929190610c7d565b60405180910390a17f000000000000000000000000000000000000000000000000000000000000000090509695505050505050565b5f80fd5b5f80fd5b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b610614816105e0565b811461061e575f80fd5b50565b5f8135905061062f8161060b565b92915050565b5f6020828403121561064a576106496105d8565b5b5f61065784828501610621565b91505092915050565b5f8115159050919050565b61067481610660565b82525050565b5f60208201905061068d5f83018461066b565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6106bc82610693565b9050919050565b6106cc816106b2565b81146106d6575f80fd5b50565b5f813590506106e7816106c3565b92915050565b5f80fd5b5f80fd5b5f80fd5b5f8083601f84011261070e5761070d6106ed565b5b8235905067ffffffffffffffff81111561072b5761072a6106f1565b5b602083019150836020820283011115610747576107466106f5565b5b9250929050565b5f8083601f840112610763576107626106ed565b5b8235905067ffffffffffffffff8111156107805761077f6106f1565b5b60208301915083600182028301111561079c5761079b6106f5565b5b9250929050565b5f805f805f805f8060a0898b0312156107bf576107be6105d8565b5b5f6107cc8b828c016106d9565b98505060206107dd8b828c016106d9565b975050604089013567ffffffffffffffff8111156107fe576107fd6105dc565b5b61080a8b828c016106f9565b9650965050606089013567ffffffffffffffff81111561082d5761082c6105dc565b5b6108398b828c016106f9565b9450945050608089013567ffffffffffffffff81111561085c5761085b6105dc565b5b6108688b828c0161074e565b92509250509295985092959890939650565b610883816105e0565b82525050565b5f60208201905061089c5f83018461087a565b92915050565b5f819050919050565b6108b4816108a2565b81146108be575f80fd5b50565b5f813590506108cf816108ab565b92915050565b5f805f805f8060a087890312156108ef576108ee6105d8565b5b5f6108fc89828a016106d9565b965050602061090d89828a016106d9565b955050604061091e89828a016108c1565b945050606061092f89828a016108c1565b935050608087013567ffffffffffffffff8111156109505761094f6105dc565b5b61095c89828a0161074e565b92509250509295509295509295565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f82825260208201905092915050565b7f4552433131353552656365697665724d6f636b3a20726576657274696e67206f5f8201527f6e20626174636820726563656976650000000000000000000000000000000000602082015250565b5f610a02602f83610998565b9150610a0d826109a8565b604082019050919050565b5f6020820190508181035f830152610a2f816109f6565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f610a6d826108a2565b9150610a78836108a2565b925082610a8857610a87610a36565b5b828204905092915050565b610a9c816106b2565b82525050565b5f82825260208201905092915050565b5f80fd5b82818337505050565b5f610aca8385610aa2565b93507f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115610afd57610afc610ab2565b5b602083029250610b0e838584610ab6565b82840190509392505050565b5f82825260208201905092915050565b828183375f83830152505050565b5f601f19601f8301169050919050565b5f610b538385610b1a565b9350610b60838584610b2a565b610b6983610b38565b840190509392505050565b5f60a082019050610b875f83018b610a93565b610b94602083018a610a93565b8181036040830152610ba781888a610abf565b90508181036060830152610bbc818688610abf565b90508181036080830152610bd1818486610b48565b90509998505050505050505050565b7f4552433131353552656365697665724d6f636b3a20726576657274696e67206f5f8201527f6e20726563656976650000000000000000000000000000000000000000000000602082015250565b5f610c3a602983610998565b9150610c4582610be0565b604082019050919050565b5f6020820190508181035f830152610c6781610c2e565b9050919050565b610c77816108a2565b82525050565b5f60a082019050610c905f830189610a93565b610c9d6020830188610a93565b610caa6040830187610c6e565b610cb76060830186610c6e565b8181036080830152610cca818486610b48565b905097965050505050505056fea26469706673582212208c442b680a6062015caa02f3c4c74cff54e26169331c5af35a3fa1703a3cc02364736f6c63430008180033\")]\n    contract ERC1155ReceiverMock is ERC165, IERC1155Receiver {\n        enum RevertType {\n            None,\n            RevertWithoutMessage,\n            RevertWithMessage,\n            RevertWithCustomError,\n            Panic\n        }\n\n        bytes4 private immutable _recRetval;\n        bytes4 private immutable _batRetval;\n        RevertType private immutable _error;\n\n        #[derive(Debug, PartialEq)]\n        event Received(address operator, address from, uint256 id, uint256 value, bytes data);\n\n        #[derive(Debug, PartialEq)]\n        event BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data);\n\n        error CustomError(bytes4);\n\n        constructor(bytes4 recRetval, bytes4 batRetval, RevertType error) {\n            _recRetval = recRetval;\n            _batRetval = batRetval;\n            _error = error;\n        }\n\n        function onERC1155Received(\n            address operator,\n            address from,\n            uint256 id,\n            uint256 value,\n            bytes calldata data\n        ) external returns (bytes4) {\n            if (_error == RevertType.RevertWithoutMessage) {\n                revert();\n            } else if (_error == RevertType.RevertWithMessage) {\n                revert(\"ERC1155ReceiverMock: reverting on receive\");\n            } else if (_error == RevertType.RevertWithCustomError) {\n                revert CustomError(_recRetval);\n            } else if (_error == RevertType.Panic) {\n                uint256 a = uint256(0) / uint256(0);\n                a;\n            }\n\n            emit Received(operator, from, id, value, data);\n            return _recRetval;\n        }\n\n        function onERC1155BatchReceived(\n            address operator,\n            address from,\n            uint256[] calldata ids,\n            uint256[] calldata values,\n            bytes calldata data\n        ) external returns (bytes4) {\n            if (_error == RevertType.RevertWithoutMessage) {\n                revert();\n            } else if (_error == RevertType.RevertWithMessage) {\n                revert(\"ERC1155ReceiverMock: reverting on batch receive\");\n            } else if (_error == RevertType.RevertWithCustomError) {\n                revert CustomError(_recRetval);\n            } else if (_error == RevertType.Panic) {\n                uint256 a = uint256(0) / uint256(0);\n                a;\n            }\n\n            emit BatchReceived(operator, from, ids, values, data);\n            return _batRetval;\n        }\n    }\n}\n\npub async fn deploy(\n    wallet: \u0026Wallet,\n    error: ERC1155ReceiverMock::RevertType,\n) -\u003e eyre::Result\u003cAddress\u003e {\n    let contract =\n        ERC1155ReceiverMock::deploy(wallet, REC_RETVAL, BAT_RETVAL, error)\n            .await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse openzeppelin_stylus::{\n    token::erc20::{\n        self,\n        extensions::{\n            capped, Capped, Erc20Metadata, ICapped, IErc20Burnable,\n            IErc20Metadata,\n        },\n        Erc20, IErc20,\n    },\n    utils::{introspection::erc165::IErc165, pausable, IPausable, Pausable},\n};\nuse stylus_sdk::{\n    alloy_primitives::{uint, Address, FixedBytes, U256, U8},\n    prelude::*,\n};\n\nconst DECIMALS: U8 = uint!(10_U8);\n\n#[derive(SolidityError, Debug)]\nenum Error {\n    ExceededCap(capped::ERC20ExceededCap),\n    InvalidCap(capped::ERC20InvalidCap),\n    InsufficientBalance(erc20::ERC20InsufficientBalance),\n    InvalidSender(erc20::ERC20InvalidSender),\n    InvalidReceiver(erc20::ERC20InvalidReceiver),\n    InsufficientAllowance(erc20::ERC20InsufficientAllowance),\n    InvalidSpender(erc20::ERC20InvalidSpender),\n    InvalidApprover(erc20::ERC20InvalidApprover),\n    EnforcedPause(pausable::EnforcedPause),\n    ExpectedPause(pausable::ExpectedPause),\n}\n\nimpl From\u003ccapped::Error\u003e for Error {\n    fn from(value: capped::Error) -\u003e Self {\n        match value {\n            capped::Error::ExceededCap(e) =\u003e Error::ExceededCap(e),\n            capped::Error::InvalidCap(e) =\u003e Error::InvalidCap(e),\n        }\n    }\n}\n\nimpl From\u003cerc20::Error\u003e for Error {\n    fn from(value: erc20::Error) -\u003e Self {\n        match value {\n            erc20::Error::InsufficientBalance(e) =\u003e {\n                Error::InsufficientBalance(e)\n            }\n            erc20::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc20::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc20::Error::InsufficientAllowance(e) =\u003e {\n                Error::InsufficientAllowance(e)\n            }\n            erc20::Error::InvalidSpender(e) =\u003e Error::InvalidSpender(e),\n            erc20::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n        }\n    }\n}\n\nimpl From\u003cpausable::Error\u003e for Error {\n    fn from(value: pausable::Error) -\u003e Self {\n        match value {\n            pausable::Error::EnforcedPause(e) =\u003e Error::EnforcedPause(e),\n            pausable::Error::ExpectedPause(e) =\u003e Error::ExpectedPause(e),\n        }\n    }\n}\n\n#[entrypoint]\n#[storage]\nstruct Erc20Example {\n    erc20: Erc20,\n    metadata: Erc20Metadata,\n    capped: Capped,\n    pausable: Pausable,\n}\n\n#[public]\n#[implements(IErc20\u003cError = Error\u003e, IErc20Burnable\u003cError = Error\u003e, IErc20Metadata, ICapped, IPausable, IErc165)]\nimpl Erc20Example {\n    #[constructor]\n    pub fn constructor(\n        \u0026mut self,\n        name: String,\n        symbol: String,\n        cap: U256,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self.metadata.constructor(name, symbol);\n        self.capped.constructor(cap)?;\n        Ok(())\n    }\n\n    // Add token minting feature.\n    //\n    // Make sure to handle `Capped` properly. You should not call\n    // [`Erc20::_update`] to mint tokens -- it will the break `Capped`\n    // mechanism.\n    fn mint(\u0026mut self, account: Address, value: U256) -\u003e Result\u003c(), Error\u003e {\n        self.pausable.when_not_paused()?;\n        let max_supply = self.capped.cap();\n\n        // Overflow check required.\n        let supply = self\n            .erc20\n            .total_supply()\n            .checked_add(value)\n            .expect(\"new supply should not exceed `U256::MAX`\");\n\n        if supply \u003e max_supply {\n            return Err(capped::Error::ExceededCap(\n                capped::ERC20ExceededCap {\n                    increased_supply: supply,\n                    cap: max_supply,\n                },\n            ))?;\n        }\n\n        self.erc20._mint(account, value)?;\n        Ok(())\n    }\n\n    /// WARNING: These functions are intended for **testing purposes** only. In\n    /// **production**, ensure strict access control to prevent unauthorized\n    /// pausing or unpausing, which can disrupt contract functionality. Remove\n    /// or secure these functions before deployment.\n    fn pause(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        Ok(self.pausable.pause()?)\n    }\n\n    fn unpause(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        Ok(self.pausable.unpause()?)\n    }\n}\n\n#[public]\nimpl IErc20 for Erc20Example {\n    type Error = Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.erc20.total_supply()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.erc20.balance_of(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.pausable.when_not_paused()?;\n        Ok(self.erc20.transfer(to, value)?)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.erc20.allowance(owner, spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.approve(spender, value)?)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.pausable.when_not_paused()?;\n        Ok(self.erc20.transfer_from(from, to, value)?)\n    }\n}\n\n#[public]\nimpl IErc20Metadata for Erc20Example {\n    fn name(\u0026self) -\u003e String {\n        self.metadata.name()\n    }\n\n    fn symbol(\u0026self) -\u003e String {\n        self.metadata.symbol()\n    }\n\n    // Overrides the default [`IErc20Metadata::decimals`], and sets it to `10`.\n    //\n    // If you don't provide this method in the `entrypoint` contract, it will\n    // default to `18`.\n    fn decimals(\u0026self) -\u003e U8 {\n        DECIMALS\n    }\n}\n\n#[public]\nimpl IErc165 for Erc20Example {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        Erc20::supports_interface(\u0026self.erc20, interface_id)\n            || Erc20Metadata::supports_interface(\u0026self.metadata, interface_id)\n    }\n}\n\n#[public]\nimpl IErc20Burnable for Erc20Example {\n    type Error = Error;\n\n    fn burn(\u0026mut self, value: U256) -\u003e Result\u003c(), Self::Error\u003e {\n        self.pausable.when_not_paused()?;\n        Ok(self.erc20.burn(value)?)\n    }\n\n    fn burn_from(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.pausable.when_not_paused()?;\n        Ok(self.erc20.burn_from(account, value)?)\n    }\n}\n\n#[public]\nimpl ICapped for Erc20Example {\n    fn cap(\u0026self) -\u003e U256 {\n        self.capped.cap()\n    }\n}\n\n#[public]\nimpl IPausable for Erc20Example {\n    fn paused(\u0026self) -\u003e bool {\n        self.pausable.paused()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc20_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\n#![allow(clippy::too_many_arguments)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract Erc20 {\n        function name() external view returns (string name);\n        function symbol() external view returns (string symbol);\n        function decimals() external view returns (uint8 decimals);\n        function totalSupply() external view returns (uint256 totalSupply);\n        function balanceOf(address account) external view returns (uint256 balance);\n        function transfer(address recipient, uint256 amount) external returns (bool);\n        function allowance(address owner, address spender) external view returns (uint256 allowance);\n        function approve(address spender, uint256 amount) external returns (bool);\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n        function cap() public view virtual returns (uint256 cap);\n\n        function mint(address account, uint256 amount) external;\n        function burn(uint256 amount) external;\n        function burnFrom(address account, uint256 amount) external;\n\n        function paused() external view returns (bool paused);\n        function pause() external;\n        function unpause() external;\n\n        function supportsInterface(bytes4 interface_id) external view returns (bool supportsInterface);\n\n        error EnforcedPause();\n        error ExpectedPause();\n\n        error ERC20ExceededCap(uint256 increased_supply, uint256 cap);\n        error ERC20InvalidCap(uint256 cap);\n\n        error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n        error ERC20InvalidSender(address sender);\n        error ERC20InvalidReceiver(address receiver);\n        error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n        error ERC20InvalidSpender(address spender);\n\n        #[derive(Debug, PartialEq)]\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        #[derive(Debug, PartialEq)]\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n\n        #[derive(Debug, PartialEq)]\n        event Paused(address account);\n        #[derive(Debug, PartialEq)]\n        event Unpaused(address account);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20","tests","erc20.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::Erc20;\nuse alloy::primitives::{uint, Address, U256};\nuse e2e::{\n    constructor, receipt, send, watch, Account, Constructor,\n    ContractInitializationError, EventExt, Panic, PanicCode, Revert,\n};\nuse eyre::Result;\n\nmod abi;\n\nconst TOKEN_NAME: \u0026str = \"Test Token\";\nconst TOKEN_SYMBOL: \u0026str = \"TTK\";\nconst CAP: U256 = uint!(1_000_000_U256);\n\nfn ctr(cap: U256) -\u003e Constructor {\n    constructor!(TOKEN_NAME.to_string(), TOKEN_SYMBOL.to_string(), cap)\n}\n\nfn default_ctr() -\u003e Constructor {\n    ctr(CAP)\n}\n\n// ============================================================================\n// Integration Tests: ERC-20 Token + Metadata Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n\n    let name = contract.name().call().await?.name;\n    let symbol = contract.symbol().call().await?.symbol;\n    let cap = contract.cap().call().await?.cap;\n    let decimals = contract.decimals().call().await?.decimals;\n    let total_supply = contract.totalSupply().call().await?.totalSupply;\n    let paused = contract.paused().call().await?.paused;\n\n    assert_eq!(name, TOKEN_NAME.to_owned());\n    assert_eq!(symbol, TOKEN_SYMBOL.to_owned());\n    assert_eq!(cap, CAP);\n    assert_eq!(decimals, 10);\n    assert_eq!(total_supply, U256::ZERO);\n    assert!(!paused);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mints(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n\n    let Erc20::balanceOfReturn { balance: initial_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(U256::ZERO, initial_balance);\n    assert_eq!(U256::ZERO, initial_supply);\n\n    let one = uint!(1_U256);\n    let receipt = receipt!(contract.mint(alice_addr, one))?;\n    assert!(receipt.emits(Erc20::Transfer {\n        from: Address::ZERO,\n        to: alice_addr,\n        value: one,\n    }));\n\n    let Erc20::balanceOfReturn { balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: total_supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(initial_balance + one, balance);\n    assert_eq!(initial_supply + one, total_supply);\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mints_rejects_invalid_receiver(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n    let invalid_receiver = Address::ZERO;\n\n    let Erc20::balanceOfReturn { balance: initial_balance } =\n        contract.balanceOf(invalid_receiver).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract.totalSupply().call().await?;\n\n    let value = uint!(10_U256);\n    let err = send!(contract.mint(invalid_receiver, value))\n        .expect_err(\"should not mint tokens for Address::ZERO\");\n    assert!(err.reverted_with(Erc20::ERC20InvalidReceiver {\n        receiver: invalid_receiver\n    }));\n\n    let Erc20::balanceOfReturn { balance } =\n        contract.balanceOf(invalid_receiver).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: total_supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(initial_balance, balance);\n    assert_eq!(initial_supply, total_supply);\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mints_rejects_overflow(alice: Account) -\u003e Result\u003c()\u003e {\n    let max_cap = U256::MAX;\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(max_cap))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n\n    let one = uint!(1_U256);\n\n    watch!(contract.mint(alice_addr, max_cap))?;\n\n    let Erc20::balanceOfReturn { balance: initial_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(initial_supply, max_cap);\n    assert_eq!(initial_balance, max_cap);\n\n    let err = send!(contract.mint(alice_addr, one))\n        .expect_err(\"should not exceed U256::MAX\");\n\n    assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n    let Erc20::balanceOfReturn { balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: total_supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(initial_balance, balance);\n    assert_eq!(initial_supply, total_supply);\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfers(alice: Account, bob: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    let value = uint!(1_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    let receipt = receipt!(contract_alice.transfer(bob_addr, value))?;\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n\n    assert!(receipt.emits(Erc20::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        value\n    }));\n\n    assert_eq!(initial_alice_balance - value, alice_balance);\n    assert_eq!(initial_bob_balance + value, bob_balance);\n    assert_eq!(initial_supply, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfer_rejects_insufficient_balance(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    let value = uint!(11_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    let err = send!(contract_alice.transfer(bob_addr, value))\n        .expect_err(\"should not transfer when insufficient balance\");\n    assert!(err.reverted_with(Erc20::ERC20InsufficientBalance {\n        sender: alice_addr,\n        balance,\n        needed: value\n    }));\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_bob_balance, bob_balance);\n    assert_eq!(initial_supply, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfer_rejects_invalid_receiver(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let invalid_receiver = Address::ZERO;\n\n    let balance = uint!(10_U256);\n    let value = uint!(1_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_receiver_balance } =\n        contract_alice.balanceOf(invalid_receiver).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    let err = send!(contract_alice.transfer(invalid_receiver, value))\n        .expect_err(\"should not transfer to Address::ZERO\");\n    assert!(err.reverted_with(Erc20::ERC20InvalidReceiver {\n        receiver: invalid_receiver\n    }));\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: receiver_balance } =\n        contract_alice.balanceOf(invalid_receiver).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_receiver_balance, receiver_balance);\n    assert_eq!(initial_supply, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn approves(alice: Account, bob: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let one = uint!(1_U256);\n    let ten = uint!(10_U256);\n\n    let Erc20::allowanceReturn { allowance: initial_alice_bob_allowance } =\n        contract.allowance(alice_addr, bob_addr).call().await?;\n    let Erc20::allowanceReturn { allowance: initial_bob_alice_allowance } =\n        contract.allowance(bob_addr, alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(U256::ZERO, initial_alice_bob_allowance);\n    assert_eq!(U256::ZERO, initial_bob_alice_allowance);\n\n    let receipt = receipt!(contract.approve(bob_addr, one))?;\n    assert!(receipt.emits(Erc20::Approval {\n        owner: alice_addr,\n        spender: bob_addr,\n        value: one,\n    }));\n\n    let Erc20::allowanceReturn { allowance: alice_bob_allowance } =\n        contract.allowance(alice_addr, bob_addr).call().await?;\n    let Erc20::allowanceReturn { allowance: bob_alice_allowance } =\n        contract.allowance(bob_addr, alice_addr).call().await?;\n\n    assert_eq!(initial_alice_bob_allowance + one, alice_bob_allowance);\n    assert_eq!(initial_bob_alice_allowance, bob_alice_allowance);\n\n    let receipt = receipt!(contract.approve(bob_addr, ten))?;\n    assert!(receipt.emits(Erc20::Approval {\n        owner: alice_addr,\n        spender: bob_addr,\n        value: ten,\n    }));\n\n    let Erc20::allowanceReturn { allowance: alice_bob_allowance } =\n        contract.allowance(alice_addr, bob_addr).call().await?;\n    let Erc20::allowanceReturn { allowance: bob_alice_allowance } =\n        contract.allowance(bob_addr, alice_addr).call().await?;\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(initial_alice_bob_allowance + ten, alice_bob_allowance);\n    assert_eq!(initial_bob_alice_allowance, bob_alice_allowance);\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_bob_balance, bob_balance);\n    assert_eq!(initial_supply, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn approve_rejects_invalid_spender(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let invalid_spender = Address::ZERO;\n\n    let ten = uint!(10_U256);\n\n    let Erc20::allowanceReturn { allowance: initial_alice_spender_allowance } =\n        contract.allowance(alice_addr, invalid_spender).call().await?;\n    let Erc20::allowanceReturn { allowance: initial_spender_alice_allowance } =\n        contract.allowance(invalid_spender, alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_spender_balance } =\n        contract.balanceOf(invalid_spender).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(U256::ZERO, initial_alice_spender_allowance);\n    assert_eq!(U256::ZERO, initial_spender_alice_allowance);\n\n    let err = send!(contract.approve(invalid_spender, ten))\n        .expect_err(\"should not approve for Address::ZERO\");\n\n    assert!(err.reverted_with(Erc20::ERC20InvalidSpender {\n        spender: invalid_spender\n    }));\n\n    let Erc20::allowanceReturn { allowance: alice_spender_allowance } =\n        contract.allowance(alice_addr, invalid_spender).call().await?;\n    let Erc20::allowanceReturn { allowance: spender_alice_allowance } =\n        contract.allowance(invalid_spender, alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: spender_balance } =\n        contract.balanceOf(invalid_spender).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(initial_alice_spender_allowance, alice_spender_allowance);\n    assert_eq!(initial_spender_alice_allowance, spender_alice_allowance);\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_spender_balance, spender_balance);\n    assert_eq!(initial_supply, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfers_from(alice: Account, bob: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc20::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    let value = uint!(1_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    watch!(contract_alice.approve(bob_addr, balance))?;\n\n    let Erc20::allowanceReturn { allowance: initial_allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    let receipt =\n        receipt!(contract_bob.transferFrom(alice_addr, bob_addr, value))?;\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n    let Erc20::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert!(receipt.emits(Erc20::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        value\n    }));\n\n    assert_eq!(initial_alice_balance - value, alice_balance);\n    assert_eq!(initial_bob_balance + value, bob_balance);\n    assert_eq!(initial_supply, supply);\n    assert_eq!(initial_allowance - value, allowance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfer_from_reverts_insufficient_balance(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc20::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(1_U256);\n    let value = uint!(10_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    watch!(contract_alice.approve(bob_addr, value))?;\n\n    let Erc20::allowanceReturn { allowance: initial_allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    let err = send!(contract_bob.transferFrom(alice_addr, bob_addr, value))\n        .expect_err(\"should not transfer when insufficient balance\");\n\n    assert!(err.reverted_with(Erc20::ERC20InsufficientBalance {\n        sender: alice_addr,\n        balance,\n        needed: value\n    }));\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n    let Erc20::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_bob_balance, bob_balance);\n    assert_eq!(initial_supply, supply);\n    assert_eq!(initial_allowance, allowance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfer_from_rejects_insufficient_allowance(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc20::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    let value = uint!(1_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    let Erc20::allowanceReturn { allowance: initial_allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert_eq!(initial_allowance, U256::ZERO);\n\n    let err = send!(contract_bob.transferFrom(alice_addr, bob_addr, value))\n        .expect_err(\"should not transfer when insufficient allowance\");\n\n    assert!(err.reverted_with(Erc20::ERC20InsufficientAllowance {\n        spender: bob_addr,\n        allowance: U256::ZERO,\n        needed: value\n    }));\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n    let Erc20::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_bob_balance, bob_balance);\n    assert_eq!(initial_supply, supply);\n    assert_eq!(initial_allowance, allowance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfer_from_rejects_invalid_receiver(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc20::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let invalid_receiver = Address::ZERO;\n\n    let balance = uint!(10_U256);\n    let value = uint!(1_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_receiver_balance } =\n        contract_alice.balanceOf(invalid_receiver).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    watch!(contract_alice.approve(bob_addr, balance))?;\n\n    let Erc20::allowanceReturn { allowance: initial_allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    let err =\n        send!(contract_bob.transferFrom(alice_addr, invalid_receiver, value))\n            .expect_err(\"should not transfer to Address::ZERO\");\n\n    assert!(err.reverted_with(Erc20::ERC20InvalidReceiver {\n        receiver: invalid_receiver\n    }));\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: receiver_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n    let Erc20::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_receiver_balance, receiver_balance);\n    assert_eq!(initial_supply, supply);\n    assert_eq!(initial_allowance, allowance);\n\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-20 Burnable Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn burns(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n\n    let balance = uint!(10_U256);\n    let value = uint!(1_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    let receipt = receipt!(contract_alice.burn(value))?;\n\n    let Erc20::balanceOfReturn { balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n\n    assert!(receipt.emits(Erc20::Transfer {\n        from: alice_addr,\n        to: Address::ZERO,\n        value,\n    }));\n\n    assert_eq!(initial_balance - value, balance);\n    assert_eq!(initial_supply - value, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burn_rejects_insufficient_balance(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n\n    let balance = uint!(10_U256);\n    let value = uint!(11_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    let err = send!(contract_alice.burn(value))\n        .expect_err(\"should not burn when insufficient balance\");\n    assert!(err.reverted_with(Erc20::ERC20InsufficientBalance {\n        sender: alice_addr,\n        balance,\n        needed: value\n    }));\n\n    let Erc20::balanceOfReturn { balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n\n    assert_eq!(initial_balance, balance);\n    assert_eq!(initial_supply, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burns_from(alice: Account, bob: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc20::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    let value = uint!(1_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    watch!(contract_alice.approve(bob_addr, balance))?;\n\n    let Erc20::allowanceReturn { allowance: initial_allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    let receipt = receipt!(contract_bob.burnFrom(alice_addr, value))?;\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n    let Erc20::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert!(receipt.emits(Erc20::Transfer {\n        from: alice_addr,\n        to: Address::ZERO,\n        value,\n    }));\n\n    assert_eq!(initial_alice_balance - value, alice_balance);\n    assert_eq!(initial_bob_balance, bob_balance);\n    assert_eq!(initial_supply - value, supply);\n    assert_eq!(initial_allowance - value, allowance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burn_from_reverts_insufficient_balance(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc20::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(1_U256);\n    let value = uint!(10_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    watch!(contract_alice.approve(bob_addr, value))?;\n\n    let Erc20::allowanceReturn { allowance: initial_allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    let err = send!(contract_bob.burnFrom(alice_addr, value))\n        .expect_err(\"should not burn when insufficient balance\");\n\n    assert!(err.reverted_with(Erc20::ERC20InsufficientBalance {\n        sender: alice_addr,\n        balance,\n        needed: value\n    }));\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n    let Erc20::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_bob_balance, bob_balance);\n    assert_eq!(initial_supply, supply);\n    assert_eq!(initial_allowance, allowance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burn_from_rejects_insufficient_allowance(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc20::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    let value = uint!(1_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    let Erc20::allowanceReturn { allowance: initial_allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert_eq!(initial_allowance, U256::ZERO);\n\n    let err = send!(contract_bob.burnFrom(alice_addr, value))\n        .expect_err(\"should not burn when insufficient allowance\");\n\n    assert!(err.reverted_with(Erc20::ERC20InsufficientAllowance {\n        spender: bob_addr,\n        allowance: U256::ZERO,\n        needed: value\n    }));\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n    let Erc20::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_bob_balance, bob_balance);\n    assert_eq!(initial_supply, supply);\n    assert_eq!(initial_allowance, allowance);\n\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-20 Capped Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn mint_rejects_exceeding_cap(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n\n    let one = uint!(1_U256);\n    let two = uint!(2_U256);\n    let cap = CAP;\n    let balance = cap - one;\n\n    watch!(contract_alice.mint(alice_addr, balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    let err = send!(contract_alice.mint(alice_addr, two))\n        .expect_err(\"should not mint when exceeding the cap\");\n    assert!(err.reverted_with(Erc20::ERC20ExceededCap {\n        increased_supply: balance + two,\n        cap\n    }));\n\n    let Erc20::balanceOfReturn { balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n\n    assert_eq!(initial_balance, balance);\n    assert_eq!(initial_supply, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mint_rejects_when_cap_reached(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n\n    let one = uint!(1_U256);\n    let cap = CAP;\n    let balance = cap;\n\n    watch!(contract_alice.mint(alice_addr, balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    let err = send!(contract_alice.mint(alice_addr, one))\n        .expect_err(\"should not mint when the cap is reached\");\n    assert!(err.reverted_with(Erc20::ERC20ExceededCap {\n        increased_supply: balance + one,\n        cap\n    }));\n\n    let Erc20::balanceOfReturn { balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n\n    assert_eq!(initial_balance, balance);\n    assert_eq!(initial_supply, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn should_not_deploy_capped_with_invalid_cap(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let invalid_cap = U256::ZERO;\n    let err = alice\n        .as_deployer()\n        .with_constructor(ctr(invalid_cap))\n        .deploy()\n        .await\n        .expect_err(\"should not deploy due to `ERC20InvalidCap`\");\n\n    // TODO: assert the actual `OwnableInvalidOwner` error was returned once\n    // StylusDeployer is able to return the exact revert reason from\n    // constructors. assert!(err.reverted_with(Erc20::ERC20InvalidCap { cap:\n    // invalid_cap }));\n\n    assert!(err.downcast_ref::\u003cContractInitializationError\u003e().is_some());\n\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-20 Pausable Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn pauses(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n\n    let receipt = receipt!(contract.pause())?;\n\n    assert!(receipt.emits(Erc20::Paused { account: alice.address() }));\n\n    let paused = contract.paused().call().await?.paused;\n\n    assert!(paused);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn pause_reverts_in_paused_state(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n\n    watch!(contract.pause())?;\n\n    let err =\n        send!(contract.pause()).expect_err(\"should return `EnforcedPause`\");\n\n    assert!(err.reverted_with(Erc20::EnforcedPause {}));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn unpauses(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n\n    watch!(contract.pause())?;\n\n    let receipt = receipt!(contract.unpause())?;\n\n    assert!(receipt.emits(Erc20::Unpaused { account: alice.address() }));\n\n    let paused = contract.paused().call().await?.paused;\n\n    assert!(!paused);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn unpause_reverts_in_unpaused_state(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n\n    let paused = contract.paused().call().await?.paused;\n\n    assert!(!paused);\n\n    let err =\n        send!(contract.unpause()).expect_err(\"should return `ExpectedPause`\");\n\n    assert!(err.reverted_with(Erc20::ExpectedPause {}));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_burn_in_paused_state(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n\n    let balance = uint!(10_U256);\n    let value = uint!(1_U256);\n\n    watch!(contract.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract.totalSupply().call().await?;\n\n    watch!(contract.pause())?;\n\n    let err =\n        send!(contract.burn(value)).expect_err(\"should return `EnforcedPause`\");\n    assert!(err.reverted_with(Erc20::EnforcedPause {}));\n\n    let Erc20::balanceOfReturn { balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(initial_balance, balance);\n    assert_eq!(initial_supply, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_burn_from_in_paused_state(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc20::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    let value = uint!(1_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    watch!(contract_alice.approve(bob_addr, balance))?;\n\n    let Erc20::allowanceReturn { allowance: initial_allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    watch!(contract_alice.pause())?;\n\n    let err = send!(contract_bob.burnFrom(alice_addr, value))\n        .expect_err(\"should return `EnforcedPause`\");\n    assert!(err.reverted_with(Erc20::EnforcedPause {}));\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n    let Erc20::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_bob_balance, bob_balance);\n    assert_eq!(initial_supply, supply);\n    assert_eq!(initial_allowance, allowance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_mint_in_paused_state(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n\n    let Erc20::balanceOfReturn { balance: initial_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(U256::ZERO, initial_balance);\n    assert_eq!(U256::ZERO, initial_supply);\n\n    watch!(contract.pause())?;\n\n    let err = send!(contract.mint(alice_addr, uint!(1_U256)))\n        .expect_err(\"should return `EnforcedPause`\");\n    assert!(err.reverted_with(Erc20::EnforcedPause {}));\n\n    let Erc20::balanceOfReturn { balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: total_supply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(initial_balance, balance);\n    assert_eq!(initial_supply, total_supply);\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_transfer_in_paused_state(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    watch!(contract_alice.pause())?;\n\n    let err = send!(contract_alice.transfer(bob_addr, uint!(1_U256)))\n        .expect_err(\"should return `EnforcedPause`\");\n    assert!(err.reverted_with(Erc20::EnforcedPause {}));\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_bob_balance, bob_balance);\n    assert_eq!(initial_supply, supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_transfer_from(alice: Account, bob: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract_alice = Erc20::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc20::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n\n    watch!(contract_alice.mint(alice.address(), balance))?;\n\n    let Erc20::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: initial_supply } =\n        contract_alice.totalSupply().call().await?;\n\n    watch!(contract_alice.approve(bob_addr, balance))?;\n\n    let Erc20::allowanceReturn { allowance: initial_allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    watch!(contract_alice.pause())?;\n\n    let err =\n        send!(contract_bob.transferFrom(alice_addr, bob_addr, uint!(1_U256)))\n            .expect_err(\"should return `EnforcedPause`\");\n    assert!(err.reverted_with(Erc20::EnforcedPause {}));\n\n    let Erc20::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20::totalSupplyReturn { totalSupply: supply } =\n        contract_alice.totalSupply().call().await?;\n    let Erc20::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert_eq!(initial_alice_balance, alice_balance);\n    assert_eq!(initial_bob_balance, bob_balance);\n    assert_eq!(initial_supply, supply);\n    assert_eq!(initial_allowance, allowance);\n\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-165 Support Interface\n// ============================================================================\n\n#[e2e::test]\nasync fn supports_interface(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(default_ctr())\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20::new(contract_addr, \u0026alice.wallet);\n\n    let invalid_interface_id: u32 = 0xffffffff;\n    let supports_interface = contract\n        .supportsInterface(invalid_interface_id.into())\n        .call()\n        .await?\n        .supportsInterface;\n\n    assert!(!supports_interface);\n\n    let erc20_interface_id: u32 = 0x36372b07;\n    let supports_interface = contract\n        .supportsInterface(erc20_interface_id.into())\n        .call()\n        .await?\n        .supportsInterface;\n\n    assert!(supports_interface);\n\n    let erc165_interface_id: u32 = 0x01ffc9a7;\n    let supports_interface = contract\n        .supportsInterface(erc165_interface_id.into())\n        .call()\n        .await?\n        .supportsInterface;\n\n    assert!(supports_interface);\n\n    let erc20_metadata_interface_id: u32 = 0xa219a025;\n    let supports_interface = contract\n        .supportsInterface(erc20_metadata_interface_id.into())\n        .call()\n        .await?\n        .supportsInterface;\n\n    assert!(supports_interface);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-flash-mint","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse openzeppelin_stylus::{\n    token::erc20::{\n        extensions::{flash_mint, Erc20FlashMint, IErc3156FlashLender},\n        Erc20, IErc20,\n    },\n    utils::introspection::erc165::IErc165,\n};\nuse stylus_sdk::{\n    abi::Bytes,\n    alloy_primitives::{Address, FixedBytes, U256},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct Erc20FlashMintExample {\n    erc20: Erc20,\n    flash_mint: Erc20FlashMint,\n}\n\n#[public]\n#[implements(IErc20\u003cError = flash_mint::Error\u003e, IErc3156FlashLender\u003cError = flash_mint::Error\u003e, IErc165)]\nimpl Erc20FlashMintExample {\n    fn mint(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), flash_mint::Error\u003e {\n        Ok(self.erc20._mint(to, value)?)\n    }\n\n    /// WARNING: These functions are intended for **testing purposes** only. In\n    /// **production**, ensure strict access control to prevent unauthorized\n    /// operations, which can disrupt contract functionality. Remove or secure\n    /// these functions before deployment.\n    fn set_flash_fee_receiver(\u0026mut self, new_receiver: Address) {\n        self.flash_mint.flash_fee_receiver_address.set(new_receiver);\n    }\n\n    fn set_flash_fee_value(\u0026mut self, new_value: U256) {\n        self.flash_mint.flash_fee_value.set(new_value);\n    }\n}\n\n#[public]\nimpl IErc3156FlashLender for Erc20FlashMintExample {\n    type Error = flash_mint::Error;\n\n    fn max_flash_loan(\u0026self, token: Address) -\u003e U256 {\n        self.flash_mint.max_flash_loan(token, \u0026self.erc20)\n    }\n\n    fn flash_fee(\n        \u0026self,\n        token: Address,\n        value: U256,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.flash_mint.flash_fee(token, value)\n    }\n\n    fn flash_loan(\n        \u0026mut self,\n        receiver: Address,\n        token: Address,\n        value: U256,\n        data: Bytes,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.flash_mint.flash_loan(\n            receiver,\n            token,\n            value,\n            \u0026data,\n            \u0026mut self.erc20,\n        )\n    }\n}\n\n#[public]\nimpl IErc20 for Erc20FlashMintExample {\n    type Error = flash_mint::Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.erc20.total_supply()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.erc20.balance_of(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer(to, value)?)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.erc20.allowance(owner, spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.approve(spender, value)?)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer_from(from, to, value)?)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc20FlashMintExample {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IErc3156FlashLender\u003e::interface_id() == interface_id\n            || self.erc20.supports_interface(interface_id)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-flash-mint","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc20_flash_mint_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-flash-mint","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract Erc20FlashMint {\n        function totalSupply() external view returns (uint256 totalSupply);\n        function balanceOf(address account) external view returns (uint256 balance);\n        function transfer(address recipient, uint256 amount) external returns (bool);\n        function allowance(address owner, address spender) external view returns (uint256 allowance);\n        function approve(address spender, uint256 amount) external returns (bool);\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n        function mint(address account, uint256 amount) external;\n\n        function maxFlashLoan(address token) external view returns (uint256 maxLoan);\n        #[derive(Debug)]\n        function flashFee(address token, uint256 amount) external view returns (uint256 fee);\n        function flashLoan(address receiver, address token, uint256 amount, bytes calldata data) external returns (bool);\n\n        function setFlashFeeReceiver(address newReceiver) external;\n        function setFlashFeeValue(uint256 newValue) external;\n\n        error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n        error ERC20InvalidSender(address sender);\n        error ERC20InvalidReceiver(address receiver);\n        error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n        error ERC20InvalidSpender(address spender);\n\n        error ERC3156UnsupportedToken(address token);\n        error ERC3156ExceededMaxLoan(uint256 maxLoan);\n        error ERC3156InvalidReceiver(address receiver);\n\n        #[derive(Debug, PartialEq)]\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        #[derive(Debug, PartialEq)]\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-flash-mint","tests","erc20_flash_mint.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::Erc20FlashMint;\nuse alloy::primitives::{address, uint, Address, U256};\nuse e2e::{receipt, send, watch, Account, EventExt, Panic, PanicCode, Revert};\nuse eyre::Result;\nuse mock::{borrower, borrower::ERC3156FlashBorrowerMock};\nuse stylus_sdk::alloy_sol_types::SolCall;\n\nmod abi;\nmod mock;\n\nconst FEE_RECEIVER: Address =\n    address!(\"F4EaCDAbEf3c8f1EdE91b6f2A6840bc2E4DD3526\");\nconst FLASH_FEE_VALUE: U256 = uint!(100_U256);\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc20FlashMint::new(contract_addr, \u0026alice.wallet);\n    watch!(contract.setFlashFeeReceiver(FEE_RECEIVER))?;\n    watch!(contract.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let max = contract.maxFlashLoan(contract_addr).call().await?.maxLoan;\n    let fee = contract.flashFee(contract_addr, U256::from(1)).call().await?.fee;\n\n    assert_eq!(max, U256::MAX);\n    assert_eq!(fee, FLASH_FEE_VALUE);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn max_flash_loan(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc20FlashMint::new(contract_addr, \u0026alice.wallet);\n    watch!(contract.setFlashFeeReceiver(FEE_RECEIVER))?;\n    watch!(contract.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let alice_addr = alice.address();\n    let mint_amount = uint!(1_000_000_U256);\n    watch!(contract.mint(alice_addr, mint_amount))?;\n\n    let max_loan = contract.maxFlashLoan(contract_addr).call().await?.maxLoan;\n    assert_eq!(U256::MAX - mint_amount, max_loan);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn max_flash_loan_return_zero_if_no_more_tokens_to_mint(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc20FlashMint::new(contract_addr, \u0026alice.wallet);\n    watch!(contract.setFlashFeeReceiver(FEE_RECEIVER))?;\n    watch!(contract.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let alice_addr = alice.address();\n    watch!(contract.mint(alice_addr, U256::MAX))?;\n\n    let max_loan = contract.maxFlashLoan(contract_addr).call().await?.maxLoan;\n    assert_eq!(U256::MIN, max_loan);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn max_flash_loan_returns_zero_on_invalid_address(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc20FlashMint::new(contract_addr, \u0026alice.wallet);\n    watch!(contract.setFlashFeeReceiver(FEE_RECEIVER))?;\n    watch!(contract.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let alice_addr = alice.address();\n    let mint_amount = uint!(1_000_000_U256);\n    watch!(contract.mint(alice_addr, mint_amount))?;\n\n    // non-token address\n    let max_loan = contract.maxFlashLoan(alice_addr).call().await?.maxLoan;\n    assert_eq!(U256::MIN, max_loan);\n\n    // works for zero address too\n    let max_loan = contract.maxFlashLoan(Address::ZERO).call().await?.maxLoan;\n    assert_eq!(U256::MIN, max_loan);\n\n    Ok(())\n}\n\n// NOTE: this behavior is assumed for our implementation, but other\n// implementations may have different behavior (e.g. return fee as a percentage\n// of the passed amount).\n#[e2e::test]\nasync fn flash_fee_returns_same_value_regardless_of_amount(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc20FlashMint::new(contract_addr, \u0026alice.wallet);\n    watch!(contract.setFlashFeeReceiver(FEE_RECEIVER))?;\n    watch!(contract.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let amounts = \u0026[U256::ZERO, U256::from(1), U256::from(1000), U256::MAX];\n    for \u0026amount in amounts {\n        let fee = contract.flashFee(contract_addr, amount).call().await?.fee;\n        assert_eq!(fee, FLASH_FEE_VALUE);\n    }\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_fee_reverts_on_unsupported_token(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc20FlashMint::new(contract_addr, \u0026alice.wallet);\n    watch!(contract.setFlashFeeReceiver(FEE_RECEIVER))?;\n    watch!(contract.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let unsupported_token = alice.address();\n\n    let err = contract\n        .flashFee(unsupported_token, U256::from(1))\n        .call()\n        .await\n        .expect_err(\"should return `UnsupportedToken`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC3156UnsupportedToken {\n        token: unsupported_token\n    }));\n\n    let err = contract\n        .flashFee(Address::ZERO, U256::from(1))\n        .call()\n        .await\n        .expect_err(\"should return `UnsupportedToken`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC3156UnsupportedToken {\n        token: Address::ZERO\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_with_fee(alice: Account) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(Address::ZERO))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    watch!(erc20.mint(borrower_addr, FLASH_FEE_VALUE))?;\n    let loan_amount = uint!(1_000_000_U256);\n\n    let borrower_balance = erc20.balanceOf(borrower_addr).call().await?.balance;\n    let total_supply = erc20.totalSupply().call().await?.totalSupply;\n\n    assert_eq!(FLASH_FEE_VALUE, borrower_balance);\n    assert_eq!(FLASH_FEE_VALUE, total_supply);\n\n    let receipt = receipt!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc20FlashMint::Transfer {\n        from: Address::ZERO,\n        to: borrower_addr,\n        value: loan_amount,\n    }));\n    assert!(receipt.emits(ERC3156FlashBorrowerMock::BalanceOf {\n        token: erc20_addr,\n        account: borrower_addr,\n        value: loan_amount + FLASH_FEE_VALUE,\n    }));\n    assert!(receipt.emits(ERC3156FlashBorrowerMock::TotalSupply {\n        token: erc20_addr,\n        value: loan_amount + FLASH_FEE_VALUE,\n    }));\n    assert!(receipt.emits(Erc20FlashMint::Transfer {\n        from: borrower_addr,\n        to: Address::ZERO,\n        value: loan_amount + FLASH_FEE_VALUE,\n    }));\n\n    let borrower_balance = erc20.balanceOf(borrower_addr).call().await?.balance;\n    let total_supply = erc20.totalSupply().call().await?.totalSupply;\n\n    assert_eq!(U256::ZERO, borrower_balance);\n    assert_eq!(U256::ZERO, total_supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_with_fee_receiver(alice: Account) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(U256::ZERO))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    let loan_amount = uint!(1_000_000_U256);\n\n    let borrower_balance = erc20.balanceOf(borrower_addr).call().await?.balance;\n    let fee_receiver_balance =\n        erc20.balanceOf(FEE_RECEIVER).call().await?.balance;\n    let total_supply = erc20.totalSupply().call().await?.totalSupply;\n\n    assert_eq!(U256::ZERO, borrower_balance);\n    assert_eq!(U256::ZERO, fee_receiver_balance);\n    assert_eq!(U256::ZERO, total_supply);\n\n    let receipt = receipt!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc20FlashMint::Transfer {\n        from: Address::ZERO,\n        to: borrower_addr,\n        value: loan_amount,\n    }));\n    assert!(receipt.emits(ERC3156FlashBorrowerMock::BalanceOf {\n        token: erc20_addr,\n        account: borrower_addr,\n        value: loan_amount,\n    }));\n    assert!(receipt.emits(ERC3156FlashBorrowerMock::TotalSupply {\n        token: erc20_addr,\n        value: loan_amount,\n    }));\n    assert!(receipt.emits(Erc20FlashMint::Transfer {\n        from: borrower_addr,\n        to: Address::ZERO,\n        value: loan_amount,\n    }));\n\n    let borrower_balance = erc20.balanceOf(borrower_addr).call().await?.balance;\n    let fee_receiver_balance =\n        erc20.balanceOf(FEE_RECEIVER).call().await?.balance;\n    let total_supply = erc20.totalSupply().call().await?.totalSupply;\n\n    assert_eq!(U256::ZERO, borrower_balance);\n    assert_eq!(U256::ZERO, fee_receiver_balance);\n    assert_eq!(U256::ZERO, total_supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_with_fee_and_fee_receiver(alice: Account) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    watch!(erc20.mint(borrower_addr, FLASH_FEE_VALUE))?;\n    let loan_amount = uint!(1_000_000_U256);\n\n    let borrower_balance = erc20.balanceOf(borrower_addr).call().await?.balance;\n    let fee_receiver_balance =\n        erc20.balanceOf(FEE_RECEIVER).call().await?.balance;\n    let total_supply = erc20.totalSupply().call().await?.totalSupply;\n\n    assert_eq!(FLASH_FEE_VALUE, borrower_balance);\n    assert_eq!(U256::ZERO, fee_receiver_balance);\n    assert_eq!(FLASH_FEE_VALUE, total_supply);\n\n    let receipt = receipt!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        vec![].into()\n    ))?;\n\n    assert!(receipt.emits(Erc20FlashMint::Transfer {\n        from: Address::ZERO,\n        to: borrower_addr,\n        value: loan_amount,\n    }));\n    assert!(receipt.emits(ERC3156FlashBorrowerMock::BalanceOf {\n        token: erc20_addr,\n        account: borrower_addr,\n        value: loan_amount + FLASH_FEE_VALUE,\n    }));\n    assert!(receipt.emits(ERC3156FlashBorrowerMock::TotalSupply {\n        token: erc20_addr,\n        value: loan_amount + FLASH_FEE_VALUE,\n    }));\n    assert!(receipt.emits(Erc20FlashMint::Transfer {\n        from: borrower_addr,\n        to: Address::ZERO,\n        value: loan_amount,\n    }));\n    assert!(receipt.emits(Erc20FlashMint::Transfer {\n        from: borrower_addr,\n        to: FEE_RECEIVER,\n        value: FLASH_FEE_VALUE,\n    }));\n\n    let borrower_balance = erc20.balanceOf(borrower_addr).call().await?.balance;\n    let fee_receiver_balance =\n        erc20.balanceOf(FEE_RECEIVER).call().await?.balance;\n    let total_supply = erc20.totalSupply().call().await?.totalSupply;\n\n    assert_eq!(U256::ZERO, borrower_balance);\n    assert_eq!(FLASH_FEE_VALUE, fee_receiver_balance);\n    assert_eq!(FLASH_FEE_VALUE, total_supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_when_loan_amount_greater_than_max_loan(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    let max_loan = U256::from(1);\n    let loan_amount = U256::from(2);\n\n    watch!(erc20.mint(borrower_addr, U256::MAX - max_loan))?;\n\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        vec![].into(),\n    ))\n    .expect_err(\"should revert with `ERC3156ExceededMaxLoan`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC3156ExceededMaxLoan {\n        maxLoan: max_loan\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_with_exceeded_max_with_unsupported_token(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    let invalid_token = alice.address();\n    let loan_amount = U256::from(1);\n\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        invalid_token,\n        loan_amount,\n        vec![].into()\n    ))\n    .expect_err(\"should revert with `ERC3156ExceededMaxLoan`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC3156ExceededMaxLoan {\n        maxLoan: U256::ZERO\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_with_unsupported_token_with_zero_loan_amount_and_unsupported_token(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    let invalid_token = alice.address();\n    let loan_amount = U256::ZERO;\n\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        invalid_token,\n        loan_amount,\n        vec![].into()\n    ))\n    .expect_err(\"should revert with `ERC3156UnsupportedToken`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC3156UnsupportedToken {\n        token: invalid_token\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_when_invalid_receiver(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    watch!(erc20.mint(borrower_addr, FLASH_FEE_VALUE))?;\n    let loan_amount = U256::from(1);\n\n    let invalid_receivers = \u0026[alice.address(), Address::ZERO];\n\n    for \u0026invalid_receiver in invalid_receivers {\n        let err = send!(erc20.flashLoan(\n            invalid_receiver,\n            erc20_addr,\n            loan_amount,\n            vec![].into()\n        ))\n        .expect_err(\"should revert with `ERC3156InvalidReceiver`\");\n\n        assert!(err.reverted_with(Erc20FlashMint::ERC3156InvalidReceiver {\n            receiver: invalid_receiver\n        }),);\n    }\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_when_receiver_callback_reverts(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    watch!(erc20.mint(borrower_addr, FLASH_FEE_VALUE))?;\n    let loan_amount = U256::from(1);\n\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        vec![1, 2].into()\n    ))\n    .expect_err(\"should revert with `ERC3156InvalidReceiver`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC3156InvalidReceiver {\n        receiver: borrower_addr\n    }),);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_when_receiver_returns_invalid_callback_value(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, false, true).await?;\n    watch!(erc20.mint(borrower_addr, FLASH_FEE_VALUE))?;\n    let loan_amount = U256::from(1);\n\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        vec![].into()\n    ))\n    .expect_err(\"should revert with `ERC3156InvalidReceiver`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC3156InvalidReceiver {\n        receiver: borrower_addr\n    }),);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_when_receiver_doesnt_approve_allowance(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, false).await?;\n    watch!(erc20.mint(borrower_addr, FLASH_FEE_VALUE))?;\n    let loan_amount = U256::from(1);\n\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        vec![].into()\n    ))\n    .expect_err(\"should revert with `ERC20InsufficientAllowance`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC20InsufficientAllowance {\n        spender: erc20_addr,\n        allowance: U256::ZERO,\n        needed: loan_amount + FLASH_FEE_VALUE\n    }),);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_when_allowance_overflows(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, false).await?;\n    let loan_amount = U256::MAX;\n\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        vec![].into()\n    ))\n    .expect_err(\"should panic due to allowance overflow\");\n\n    assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_when_receiver_doesnt_have_enough_tokens(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    let loan_amount = U256::from(1);\n\n    // test when not enough to cover fees\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        vec![].into(),\n    ))\n    .expect_err(\"should revert with `ERC20InsufficientBalance`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC20InsufficientBalance {\n        sender: borrower_addr,\n        balance: U256::ZERO,\n        needed: FLASH_FEE_VALUE\n    }));\n\n    // test when not enough to return the loaned tokens\n    let call = Erc20FlashMint::transferCall {\n        recipient: alice.address(),\n        amount: loan_amount,\n    };\n\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        call.abi_encode().into(),\n    ))\n    .expect_err(\"should revert with `ERC20InsufficientBalance`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC20InsufficientBalance {\n        sender: borrower_addr,\n        balance: U256::ZERO,\n        needed: loan_amount,\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_when_receiver_doesnt_have_enough_tokens_and_fee_is_zero(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(FEE_RECEIVER))?;\n    _ = watch!(erc20.setFlashFeeValue(U256::ZERO))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    let loan_amount = U256::from(1);\n\n    let call = Erc20FlashMint::transferCall {\n        recipient: alice.address(),\n        amount: loan_amount,\n    };\n\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        call.abi_encode().into(),\n    ))\n    .expect_err(\"should revert with `ERC20InsufficientBalance`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC20InsufficientBalance {\n        sender: borrower_addr,\n        balance: U256::ZERO,\n        needed: loan_amount,\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn flash_loan_reverts_when_receiver_doesnt_have_enough_tokens_and_fee_receiver_is_zero(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let erc20 = Erc20FlashMint::new(erc20_addr, \u0026alice.wallet);\n    _ = watch!(erc20.setFlashFeeReceiver(Address::ZERO))?;\n    _ = watch!(erc20.setFlashFeeValue(FLASH_FEE_VALUE))?;\n\n    let borrower_addr = borrower::deploy(\u0026alice.wallet, true, true).await?;\n    let loan_amount = U256::from(1);\n\n    let err = send!(erc20.flashLoan(\n        borrower_addr,\n        erc20_addr,\n        loan_amount,\n        vec![].into(),\n    ))\n    .expect_err(\"should revert with `ERC20InsufficientBalance`\");\n\n    assert!(err.reverted_with(Erc20FlashMint::ERC20InsufficientBalance {\n        sender: borrower_addr,\n        balance: loan_amount,\n        needed: loan_amount + FLASH_FEE_VALUE\n    }));\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-flash-mint","tests","mock","borrower.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.24+commit.e11b9ed9; optimization: 200\n    #[sol(rpc, bytecode=\"60c060405234801561000f575f80fd5b5060405161069f38038061069f83398101604081905261002e91610051565b1515608052151560a052610082565b8051801515811461004c575f80fd5b919050565b5f8060408385031215610062575f80fd5b61006b8361003d565b91506100796020840161003d565b90509250929050565b60805160a0516105fc6100a35f395f6102f901525f61024b01526105fc5ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c806323e30c8b1461002d575b5f80fd5b61004061003b3660046104a7565b610052565b60405190815260200160405180910390f35b5f336001600160a01b038716146100a85760405162461bcd60e51b8152602060048201526015602482015274496e76616c696420746f6b656e206164647265737360581b60448201526064015b60405180910390fd5b6040516370a0823160e01b815230600482018190527f6ff2acfcb07917b1e80e53f0fe390b467b1151d15b38730a6e08397799c05a8b918891906001600160a01b038316906370a0823190602401602060405180830381865afa158015610111573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101359190610545565b604080516001600160a01b0394851681529390921660208401529082015260600160405180910390a17f7249fd4c03cce09b30a13d77804b198e2647c0ccd59eadf4de4e7c16099badc586876001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101bc573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101e09190610545565b604080516001600160a01b03909316835260208301919091520160405180910390a18115610249576102478684848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061034f92505050565b505b7f0000000000000000000000000000000000000000000000000000000000000000156102f7576001600160a01b03861663095ea7b387610289878961055c565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303815f875af11580156102d1573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102f5919061057b565b505b7f0000000000000000000000000000000000000000000000000000000000000000610322575f610344565b7f439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd95b979650505050505050565b606061035c83835f610365565b90505b92915050565b6060814710156103915760405163cf47918160e01b81524760048201526024810183905260440161009f565b5f80856001600160a01b031684866040516103ac919061059a565b5f6040518083038185875af1925050503d805f81146103e6576040519150601f19603f3d011682016040523d82523d5f602084013e6103eb565b606091505b50915091506103fb868383610407565b925050505b9392505050565b60608261041c5761041782610463565b610400565b815115801561043357506001600160a01b0384163b155b1561045c57604051639996b31560e01b81526001600160a01b038516600482015260240161009f565b5080610400565b8051156104735780518082602001fd5b60405163d6bda27560e01b815260040160405180910390fd5b80356001600160a01b03811681146104a2575f80fd5b919050565b5f805f805f8060a087890312156104bc575f80fd5b6104c58761048c565b95506104d36020880161048c565b94506040870135935060608701359250608087013567ffffffffffffffff808211156104fd575f80fd5b818901915089601f830112610510575f80fd5b81358181111561051e575f80fd5b8a602082850101111561052f575f80fd5b6020830194508093505050509295509295509295565b5f60208284031215610555575f80fd5b5051919050565b8082018082111561035f57634e487b7160e01b5f52601160045260245ffd5b5f6020828403121561058b575f80fd5b81518015158114610400575f80fd5b5f82515f5b818110156105b9576020818601810151858301520161059f565b505f92019182525091905056fea264697066735822122072bcfdbac0cd2f50d6eb0f6c882d0babb57a52e62164f6dd7962b0938dbc2ac364736f6c63430008180033\")]\n    contract ERC3156FlashBorrowerMock is IERC3156FlashBorrower {\n        bytes32 internal constant _RETURN_VALUE =\n            keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n        bool immutable _enableApprove;\n        bool immutable _validReturn;\n\n        #[derive(Debug, PartialEq)]\n        event BalanceOf(address token, address account, uint256 value);\n        #[derive(Debug, PartialEq)]\n        event TotalSupply(address token, uint256 value);\n\n        constructor(bool validReturn, bool enableApprove) {\n            _enableApprove = enableApprove;\n            _validReturn = validReturn;\n        }\n\n        function onFlashLoan(\n            address /* initiator */,\n            address token,\n            uint256 amount,\n            uint256 fee,\n            bytes calldata data\n        ) public returns (bytes32) {\n            require(msg.sender == token, \"Invalid token address\");\n\n            emit BalanceOf(\n                token,\n                address(this),\n                IERC20(token).balanceOf(address(this))\n            );\n\n            emit TotalSupply(token, IERC20(token).totalSupply());\n\n            if (data.length \u003e 0) {\n                // WARNING: This code is for testing purposes only! Do not use in production.\n                Address.functionCall(token, data);\n            }\n\n            if (_enableApprove) {\n                IERC20(token).approve(token, amount + fee);\n            }\n\n            return _validReturn ? _RETURN_VALUE : bytes32(0);\n        }\n    }\n}\n\npub async fn deploy(\n    wallet: \u0026Wallet,\n    enable_return: bool,\n    enable_approve: bool,\n) -\u003e eyre::Result\u003cAddress\u003e {\n    let contract =\n        ERC3156FlashBorrowerMock::deploy(wallet, enable_return, enable_approve)\n            .await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-flash-mint","tests","mock","mod.rs"],"content":"pub mod borrower;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-permit","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse alloy_primitives::{Address, B256, U256};\nuse openzeppelin_stylus::{\n    token::erc20::{\n        extensions::{permit, Erc20Permit, IErc20Permit},\n        Erc20, IErc20,\n    },\n    utils::{\n        cryptography::eip712::IEip712,\n        nonces::{INonces, Nonces},\n    },\n};\nuse stylus_sdk::prelude::*;\n\n#[entrypoint]\n#[storage]\nstruct Erc20PermitExample {\n    erc20: Erc20,\n    nonces: Nonces,\n    erc20_permit: Erc20Permit\u003cEip712\u003e,\n}\n\n#[storage]\nstruct Eip712;\n\nimpl IEip712 for Eip712 {\n    const NAME: \u0026'static str = \"ERC-20 Permit Example\";\n    const VERSION: \u0026'static str = \"1\";\n}\n\n#[public]\n#[implements(IErc20\u003cError = permit::Error\u003e, INonces, IErc20Permit\u003cError = permit::Error\u003e)]\nimpl Erc20PermitExample {\n    // Add token minting feature.\n    fn mint(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), permit::Error\u003e {\n        Ok(self.erc20._mint(account, value)?)\n    }\n}\n\n#[public]\nimpl IErc20 for Erc20PermitExample {\n    type Error = permit::Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.erc20.total_supply()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.erc20.balance_of(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer(to, value)?)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.erc20.allowance(owner, spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.approve(spender, value)?)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer_from(from, to, value)?)\n    }\n}\n\n#[public]\nimpl INonces for Erc20PermitExample {\n    fn nonces(\u0026self, owner: Address) -\u003e U256 {\n        self.nonces.nonces(owner)\n    }\n}\n\n#[public]\nimpl IErc20Permit for Erc20PermitExample {\n    type Error = permit::Error;\n\n    #[selector(name = \"DOMAIN_SEPARATOR\")]\n    fn domain_separator(\u0026self) -\u003e B256 {\n        self.erc20_permit.domain_separator()\n    }\n\n    fn permit(\n        \u0026mut self,\n        owner: Address,\n        spender: Address,\n        value: U256,\n        deadline: U256,\n        v: u8,\n        r: B256,\n        s: B256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc20_permit.permit(\n            owner,\n            spender,\n            value,\n            deadline,\n            v,\n            r,\n            s,\n            \u0026mut self.erc20,\n            \u0026mut self.nonces,\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-permit","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc20_permit_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-permit","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\n#![allow(clippy::too_many_arguments)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract Erc20Permit {\n        function totalSupply() external view returns (uint256 totalSupply);\n        function balanceOf(address account) external view returns (uint256 balance);\n        function transfer(address recipient, uint256 amount) external returns (bool);\n        function allowance(address owner, address spender) external view returns (uint256 allowance);\n        function approve(address spender, uint256 amount) external returns (bool);\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n        function mint(address account, uint256 amount) external;\n\n        function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n        function nonces(address owner) external view returns (uint256 nonce);\n        function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator);\n\n        error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n        error ERC20InvalidSender(address sender);\n        error ERC20InvalidReceiver(address receiver);\n        error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n        error ERC20InvalidSpender(address spender);\n\n        error ERC2612ExpiredSignature(uint256 deadline);\n        error ERC2612InvalidSigner(address signer, address owner);\n\n        #[derive(Debug, PartialEq)]\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        #[derive(Debug, PartialEq)]\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-permit","tests","erc20_permit.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::Erc20Permit;\nuse alloy::{\n    primitives::{keccak256, Address, B256, U256},\n    sol,\n    sol_types::SolType,\n};\nuse alloy_primitives::uint;\nuse e2e::{receipt, send, watch, Account, EventExt, Revert};\nuse eyre::Result;\nmod abi;\n\n// Saturday, 1 January 2000 00:00:00\nconst EXPIRED_DEADLINE: U256 = uint!(946_684_800_U256);\n\n// Wednesday, 1 January 3000 00:00:00\nconst FAIR_DEADLINE: U256 = uint!(32_503_680_000_U256);\n\nconst PERMIT_TYPEHASH: [u8; 32] =\n    keccak_const::Keccak256::new()\n        .update(b\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n        .finalize();\n\ntype PermitStructHashTuple = sol! {\n    tuple(bytes32, address, address, uint256, uint256, uint256)\n};\n\nmacro_rules! domain_separator {\n    ($contract:expr) =\u003e {{\n        let Erc20Permit::DOMAIN_SEPARATORReturn { domainSeparator } = $contract\n            .DOMAIN_SEPARATOR()\n            .call()\n            .await\n            .expect(\"should return `DOMAIN_SEPARATOR`\");\n        B256::from_slice(domainSeparator.as_slice())\n    }};\n}\n\nfn to_typed_data_hash(domain_separator: B256, struct_hash: B256) -\u003e B256 {\n    let typed_dat_hash =\n        openzeppelin_stylus::utils::cryptography::eip712::to_typed_data_hash(\n            \u0026domain_separator,\n            \u0026struct_hash,\n        );\n\n    B256::from_slice(typed_dat_hash.as_slice())\n}\n\nfn permit_struct_hash(\n    owner: Address,\n    spender: Address,\n    value: U256,\n    nonce: U256,\n    deadline: U256,\n) -\u003e B256 {\n    keccak256(PermitStructHashTuple::abi_encode(\u0026(\n        PERMIT_TYPEHASH,\n        owner,\n        spender,\n        value,\n        nonce,\n        deadline,\n    )))\n}\n\n// I was unable to find a function in alloy that converts `v` into [non-eip155\n// value], so I implemented the logic manually.\n//\n// [non-eip155 value]: https://eips.ethereum.org/EIPS/eip-155\nfn to_non_eip155_v(v: bool) -\u003e u8 {\n    v as u8 + 27\n}\n\n// ============================================================================\n// Integration Tests: ERC-20 Permit Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn error_when_expired_deadline_for_permit(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc20Permit::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    watch!(contract_alice.mint(alice_addr, balance))?;\n\n    let struct_hash = permit_struct_hash(\n        alice_addr,\n        bob_addr,\n        balance,\n        U256::ZERO,\n        EXPIRED_DEADLINE,\n    );\n\n    let typed_data_hash =\n        to_typed_data_hash(domain_separator!(contract_alice), struct_hash);\n    let signature = alice\n        .sign_hash(\u0026alloy::primitives::B256::from_slice(\n            typed_data_hash.as_slice(),\n        ))\n        .await;\n\n    let err = send!(contract_alice.permit(\n        alice_addr,\n        bob_addr,\n        balance,\n        EXPIRED_DEADLINE,\n        to_non_eip155_v(signature.v()),\n        signature.r().into(),\n        signature.s().into()\n    ))\n    .expect_err(\"should return `ERC2612ExpiredSignature`\");\n    assert!(err.reverted_with(Erc20Permit::ERC2612ExpiredSignature {\n        deadline: EXPIRED_DEADLINE\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn permit_works(alice: Account, bob: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc20Permit::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    watch!(contract_alice.mint(alice_addr, balance))?;\n\n    let struct_hash = permit_struct_hash(\n        alice_addr,\n        bob_addr,\n        balance,\n        U256::ZERO,\n        FAIR_DEADLINE,\n    );\n\n    let typed_data_hash =\n        to_typed_data_hash(domain_separator!(contract_alice), struct_hash);\n    let signature = alice\n        .sign_hash(\u0026alloy::primitives::B256::from_slice(\n            typed_data_hash.as_slice(),\n        ))\n        .await;\n\n    let Erc20Permit::noncesReturn { nonce: initial_nonce } =\n        contract_alice.nonces(alice_addr).call().await?;\n\n    let Erc20Permit::allowanceReturn { allowance: initial_allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    let receipt = receipt!(contract_alice.permit(\n        alice_addr,\n        bob_addr,\n        balance,\n        FAIR_DEADLINE,\n        to_non_eip155_v(signature.v()),\n        signature.r().into(),\n        signature.s().into()\n    ))?;\n\n    assert!(receipt.emits(Erc20Permit::Approval {\n        owner: alice_addr,\n        spender: bob_addr,\n        value: balance,\n    }));\n\n    let Erc20Permit::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert_eq!(initial_allowance + balance, allowance);\n\n    let Erc20Permit::noncesReturn { nonce } =\n        contract_alice.nonces(alice_addr).call().await?;\n\n    assert_eq!(initial_nonce + uint!(1_U256), nonce);\n\n    let contract_bob = Erc20Permit::new(contract_addr, \u0026bob.wallet);\n    let value = balance - uint!(1_U256);\n    let Erc20Permit::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20Permit::balanceOfReturn { balance: initial_bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n\n    let receipt =\n        receipt!(contract_bob.transferFrom(alice_addr, bob_addr, value))?;\n\n    let Erc20Permit::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n    let Erc20Permit::balanceOfReturn { balance: bob_balance } =\n        contract_alice.balanceOf(bob_addr).call().await?;\n    let Erc20Permit::allowanceReturn { allowance } =\n        contract_alice.allowance(alice_addr, bob_addr).call().await?;\n\n    assert!(receipt.emits(Erc20Permit::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        value\n    }));\n\n    assert_eq!(initial_alice_balance - value, alice_balance);\n    assert_eq!(initial_bob_balance + value, bob_balance);\n    assert_eq!(initial_allowance + balance - value, allowance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn permit_rejects_reused_signature(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc20Permit::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    watch!(contract_alice.mint(alice_addr, balance))?;\n\n    let struct_hash = permit_struct_hash(\n        alice_addr,\n        bob_addr,\n        balance,\n        U256::ZERO,\n        FAIR_DEADLINE,\n    );\n\n    let typed_data_hash =\n        to_typed_data_hash(domain_separator!(contract_alice), struct_hash);\n    let signature = alice\n        .sign_hash(\u0026alloy::primitives::B256::from_slice(\n            typed_data_hash.as_slice(),\n        ))\n        .await;\n\n    watch!(contract_alice.permit(\n        alice_addr,\n        bob_addr,\n        balance,\n        FAIR_DEADLINE,\n        to_non_eip155_v(signature.v()),\n        signature.r().into(),\n        signature.s().into()\n    ))?;\n\n    let err = send!(contract_alice.permit(\n        alice_addr,\n        bob_addr,\n        balance,\n        FAIR_DEADLINE,\n        to_non_eip155_v(signature.v()),\n        signature.r().into(),\n        signature.s().into()\n    ))\n    .expect_err(\"should return `ERC2612InvalidSigner`\");\n\n    let struct_hash = permit_struct_hash(\n        alice_addr,\n        bob_addr,\n        balance,\n        U256::from(1),\n        FAIR_DEADLINE,\n    );\n\n    let typed_data_hash =\n        to_typed_data_hash(domain_separator!(contract_alice), struct_hash);\n\n    let recovered = signature\n        .recover_address_from_prehash(\u0026alloy::primitives::B256::from_slice(\n            typed_data_hash.as_slice(),\n        ))\n        .expect(\"should recover\");\n\n    assert!(err.reverted_with(Erc20Permit::ERC2612InvalidSigner {\n        signer: recovered,\n        owner: alice_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn permit_rejects_invalid_signature(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc20Permit::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let balance = uint!(10_U256);\n    watch!(contract_alice.mint(alice_addr, balance))?;\n\n    let struct_hash = permit_struct_hash(\n        alice_addr,\n        bob_addr,\n        balance,\n        U256::ZERO,\n        FAIR_DEADLINE,\n    );\n\n    let typed_data_hash =\n        to_typed_data_hash(domain_separator!(contract_alice), struct_hash);\n    let signature = bob\n        .sign_hash(\u0026alloy::primitives::B256::from_slice(\n            typed_data_hash.as_slice(),\n        ))\n        .await;\n\n    let err = send!(contract_alice.permit(\n        alice_addr,\n        bob_addr,\n        balance,\n        FAIR_DEADLINE,\n        to_non_eip155_v(signature.v()),\n        signature.r().into(),\n        signature.s().into()\n    ))\n    .expect_err(\"should return `ERC2612InvalidSigner`\");\n\n    assert!(err.reverted_with(Erc20Permit::ERC2612InvalidSigner {\n        signer: bob_addr,\n        owner: alice_addr\n    }));\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-wrapper","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::{vec, vec::Vec};\n\nuse openzeppelin_stylus::token::erc20::{\n    extensions::{wrapper, Erc20Wrapper, IErc20Wrapper},\n    Erc20, IErc20,\n};\nuse stylus_sdk::{\n    alloy_primitives::{Address, U256, U8},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct Erc20WrapperExample {\n    erc20: Erc20,\n    erc20_wrapper: Erc20Wrapper,\n}\n\n#[public]\n#[implements(IErc20\u003cError = wrapper::Error\u003e, IErc20Wrapper\u003cError = wrapper::Error\u003e)]\nimpl Erc20WrapperExample {\n    #[constructor]\n    fn constructor(\n        \u0026mut self,\n        underlying_token: Address,\n    ) -\u003e Result\u003c(), wrapper::Error\u003e {\n        self.erc20_wrapper.constructor(underlying_token)?;\n        Ok(())\n    }\n}\n\n#[public]\nimpl IErc20 for Erc20WrapperExample {\n    type Error = wrapper::Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.erc20.total_supply()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.erc20.balance_of(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer(to, value)?)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.erc20.allowance(owner, spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.approve(spender, value)?)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer_from(from, to, value)?)\n    }\n}\n\n#[public]\nimpl IErc20Wrapper for Erc20WrapperExample {\n    type Error = wrapper::Error;\n\n    fn underlying(\u0026self) -\u003e Address {\n        self.erc20_wrapper.underlying()\n    }\n\n    fn decimals(\u0026self) -\u003e U8 {\n        self.erc20_wrapper.decimals()\n    }\n\n    fn deposit_for(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.erc20_wrapper.deposit_for(account, value, \u0026mut self.erc20)\n    }\n\n    fn withdraw_to(\n        \u0026mut self,\n        account: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.erc20_wrapper.withdraw_to(account, value, \u0026mut self.erc20)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-wrapper","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc20_wrapper_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-wrapper","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\n#![allow(clippy::too_many_arguments)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract Erc20Wrapper {\n        function totalSupply() external view returns (uint256 totalSupply);\n        function balanceOf(address account) external view returns (uint256 balance);\n        function transfer(address recipient, uint256 amount) external returns (bool);\n        function allowance(address owner, address spender) external view returns (uint256 allowance);\n        function approve(address spender, uint256 amount) external returns (bool);\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n        #[derive(Debug)]\n        function decimals() external view returns (uint8 decimals);\n        #[derive(Debug)]\n        function underlying() external view returns (address underlying);\n        #[derive(Debug)]\n        function depositFor(address account, uint256 value) external  returns (bool);\n        #[derive(Debug)]\n        function withdrawTo(address account, uint256 value) external  returns (bool);\n\n        error ERC20InvalidUnderlying(address token);\n        error ERC20InvalidSender(address sender);\n        error ERC20InvalidReceiver(address receiver);\n\n    }\n\n    contract Erc20 {\n        #[derive(Debug, PartialEq)]\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        #[derive(Debug, PartialEq)]\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n\n        error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n    }\n\n    #[sol(rpc)]\n    contract SafeErc20 {\n        error SafeErc20FailedOperation(address token);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-wrapper","tests","erc20_wrapper.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::{Erc20, Erc20Wrapper};\nuse alloy::primitives::{uint, Address, U256};\nuse e2e::{constructor, receipt, watch, Account, Constructor, EventExt};\nuse eyre::Result;\n\nmod abi;\nmod mock;\n\nuse mock::{erc20, erc20::ERC20Mock};\n\nconst DECIMALS: u8 = 18;\n\nfn ctr(asset_addr: Address) -\u003e Constructor {\n    constructor!(asset_addr)\n}\n\n/// Deploy a new [`Erc20`] contract and [`Erc20Wrapper`] contract and mint\n/// initial ERC-20 tokens to `account`.\nasync fn deploy(\n    account: \u0026Account,\n    initial_tokens: U256,\n) -\u003e Result\u003c(Address, Address)\u003e {\n    let asset_addr = erc20::deploy(\u0026account.wallet).await?;\n\n    let contract_addr = account\n        .as_deployer()\n        .with_constructor(ctr(asset_addr))\n        .deploy()\n        .await?\n        .contract_address;\n\n    if initial_tokens \u003e U256::ZERO {\n        let asset = ERC20Mock::new(asset_addr, \u0026account.wallet);\n        watch!(asset.mint(account.address(), initial_tokens))?;\n    }\n\n    Ok((contract_addr, asset_addr))\n}\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e Result\u003c()\u003e {\n    let asset_address = erc20::deploy(\u0026alice.wallet).await?;\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(asset_address))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc20Wrapper::new(contract_addr, alice.wallet);\n\n    let underlying = contract.underlying().call().await?.underlying;\n    assert_eq!(underlying, asset_address);\n\n    let decimals = contract.decimals().call().await?.decimals;\n    assert_eq!(decimals, DECIMALS);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn deposit_for_success(alice: Account) -\u003e Result\u003c()\u003e {\n    let initial_supply = uint!(1000_U256);\n    let (contract_addr, asset_addr) = deploy(\u0026alice, initial_supply).await?;\n    let alice_address = alice.address();\n    let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n    let contract = Erc20Wrapper::new(contract_addr, \u0026alice.wallet);\n\n    watch!(asset.approve(contract_addr, initial_supply))?;\n\n    let initial_wrapped_balance =\n        contract.balanceOf(alice_address).call().await?.balance;\n    let initial_wrapped_supply =\n        contract.totalSupply().call().await?.totalSupply;\n\n    let value = initial_supply;\n    let receipt = receipt!(contract.depositFor(alice_address, value))?;\n\n    // `Transfer` event for ERC-20 token transfer from Alice to the\n    // [`Erc20Wrapper`] contract should be emitted.\n    assert!(receipt.emits(Erc20::Transfer {\n        from: alice_address,\n        to: contract_addr,\n        value\n    }));\n\n    // `Transfer` event for ERC-20 Wrapped token should be emitted (minting\n    // wrapped tokens to Alice).\n    assert!(receipt.emits(Erc20::Transfer {\n        from: Address::ZERO,\n        to: alice_address,\n        value\n    }));\n\n    let wrapped_balance =\n        contract.balanceOf(alice_address).call().await?.balance;\n    assert_eq!(initial_wrapped_balance + value, wrapped_balance);\n\n    let wrapped_supply = contract.totalSupply().call().await?.totalSupply;\n    assert_eq!(initial_wrapped_supply + value, wrapped_supply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn withdraw_to_success(alice: Account) -\u003e Result\u003c()\u003e {\n    let initial_tokens = uint!(1000_U256);\n    let (contract_addr, asset_addr) = deploy(\u0026alice, initial_tokens).await?;\n\n    let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n    let contract = Erc20Wrapper::new(contract_addr, \u0026alice.wallet);\n\n    watch!(asset.approve(contract_addr, initial_tokens))?;\n\n    watch!(contract.depositFor(alice.address(), initial_tokens))?;\n\n    let initial_wrapped_balance =\n        contract.balanceOf(alice.address()).call().await?.balance;\n    assert_eq!(initial_tokens, initial_wrapped_balance);\n\n    let initial_wrapped_supply =\n        contract.totalSupply().call().await?.totalSupply;\n\n    let value = uint!(10_U256);\n    let receipt = receipt!(contract.withdrawTo(alice.address(), value))?;\n\n    // `Transfer` event for ERC-20 Wrapped token should be emitted (burning\n    // wrapped tokens from Alice).\n    assert!(receipt.emits(Erc20::Transfer {\n        from: alice.address(),\n        to: Address::ZERO,\n        value\n    }));\n\n    // `Transfer` event for ERC-20 token transfer from\n    // [`Erc20Wrapper`] contract to Alice should be emitted.\n    assert!(receipt.emits(Erc20::Transfer {\n        from: contract_addr,\n        to: alice.address(),\n        value\n    }));\n\n    let wrapped_balance =\n        contract.balanceOf(alice.address()).call().await?.balance;\n    assert_eq!(initial_wrapped_balance - value, wrapped_balance);\n\n    let wrapped_supply = contract.totalSupply().call().await?.totalSupply;\n    assert_eq!(initial_wrapped_supply - value, wrapped_supply);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-wrapper","tests","mock","erc20.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.21+commit.d9974bed\n    #[sol(rpc, bytecode=\"608060405234801562000010575f80fd5b506040518060400160405280600981526020017f45524332304d6f636b00000000000000000000000000000000000000000000008152506040518060400160405280600381526020017f4d544b000000000000000000000000000000000000000000000000000000000081525081600390816200008e91906200030d565b508060049081620000a091906200030d565b505050620003f1565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806200012557607f821691505b6020821081036200013b576200013a620000e0565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026200019f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000162565b620001ab868362000162565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f620001f5620001ef620001e984620001c3565b620001cc565b620001c3565b9050919050565b5f819050919050565b6200021083620001d5565b620002286200021f82620001fc565b8484546200016e565b825550505050565b5f90565b6200023e62000230565b6200024b81848462000205565b505050565b5b818110156200027257620002665f8262000234565b60018101905062000251565b5050565b601f821115620002c1576200028b8162000141565b620002968462000153565b81016020851015620002a6578190505b620002be620002b58562000153565b83018262000250565b50505b505050565b5f82821c905092915050565b5f620002e35f1984600802620002c6565b1980831691505092915050565b5f620002fd8383620002d2565b9150826002028217905092915050565b6200031882620000a9565b67ffffffffffffffff811115620003345762000333620000b3565b5b6200034082546200010d565b6200034d82828562000276565b5f60209050601f83116001811462000383575f84156200036e578287015190505b6200037a8582620002f0565b865550620003e9565b601f198416620003938662000141565b5f5b82811015620003bc5784890151825560018201915060208501945060208101905062000395565b86831015620003dc5784890151620003d8601f891682620002d2565b8355505b6001600288020188555050505b505050505050565b610f4580620003ff5f395ff3fe608060405234801561000f575f80fd5b50600436106100a7575f3560e01c806340c10f191161006f57806340c10f191461016557806370a08231146101815780638483acfe146101b157806395d89b41146101cd578063a9059cbb146101eb578063dd62ed3e1461021b576100a7565b806306fdde03146100ab578063095ea7b3146100c957806318160ddd146100f957806323b872dd14610117578063313ce56714610147575b5f80fd5b6100b361024b565b6040516100c09190610bbe565b60405180910390f35b6100e360048036038101906100de9190610c6f565b6102db565b6040516100f09190610cc7565b60405180910390f35b6101016102ee565b60405161010e9190610cef565b60405180910390f35b610131600480360381019061012c9190610d08565b6102f7565b60405161013e9190610cc7565b60405180910390f35b61014f61030c565b60405161015c9190610d73565b60405180910390f35b61017f600480360381019061017a9190610c6f565b610314565b005b61019b60048036038101906101969190610d8c565b610322565b6040516101a89190610cef565b60405180910390f35b6101cb60048036038101906101c69190610d08565b610333565b005b6101d5610343565b6040516101e29190610bbe565b60405180910390f35b61020560048036038101906102009190610c6f565b6103d3565b6040516102129190610cc7565b60405180910390f35b61023560048036038101906102309190610db7565b6103e6565b6040516102429190610cef565b60405180910390f35b60606003805461025a90610e22565b80601f016020809104026020016040519081016040528092919081815260200182805461028690610e22565b80156102d15780601f106102a8576101008083540402835291602001916102d1565b820191905f5260205f20905b8154815290600101906020018083116102b457829003601f168201915b5050505050905090565b5f6102e683836103f9565b905092915050565b5f600254905090565b5f61030384848461041b565b90509392505050565b5f6012905090565b61031e8282610449565b5050565b5f61032c826104c8565b9050919050565b61033e83838361050d565b505050565b60606004805461035290610e22565b80601f016020809104026020016040519081016040528092919081815260200182805461037e90610e22565b80156103c95780601f106103a0576101008083540402835291602001916103c9565b820191905f5260205f20905b8154815290600101906020018083116103ac57829003601f168201915b5050505050905090565b5f6103de838361051f565b905092915050565b5f6103f18383610541565b905092915050565b5f806104036105c3565b905061041081858561050d565b600191505092915050565b5f806104256105c3565b90506104328582856105ca565b61043d85858561065c565b60019150509392505050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036104b9575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016104b09190610e61565b60405180910390fd5b6104c45f838361074c565b5050565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b61051a8383836001610965565b505050565b5f806105296105c3565b905061053681858561065c565b600191505092915050565b5f60015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f33905090565b5f6105d584846103e6565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146106565781811015610647578281836040517ffb8f41b200000000000000000000000000000000000000000000000000000000815260040161063e93929190610e7a565b60405180910390fd5b61065584848484035f610965565b5b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036106cc575f6040517f96c6fd1e0000000000000000000000000000000000000000000000000000000081526004016106c39190610e61565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361073c575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016107339190610e61565b60405180910390fd5b61074783838361074c565b505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361079c578060025f8282546107909190610edc565b9250508190555061086a565b5f805f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905081811015610825578381836040517fe450d38c00000000000000000000000000000000000000000000000000000000815260040161081c93929190610e7a565b60405180910390fd5b8181035f808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036108b1578060025f82825403925050819055506108fb565b805f808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516109589190610cef565b60405180910390a3505050565b5f73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16036109d5575f6040517fe602df050000000000000000000000000000000000000000000000000000000081526004016109cc9190610e61565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610a45575f6040517f94280d62000000000000000000000000000000000000000000000000000000008152600401610a3c9190610e61565b60405180910390fd5b8160015f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055508015610b2e578273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92584604051610b259190610cef565b60405180910390a35b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015610b6b578082015181840152602081019050610b50565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610b9082610b34565b610b9a8185610b3e565b9350610baa818560208601610b4e565b610bb381610b76565b840191505092915050565b5f6020820190508181035f830152610bd68184610b86565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610c0b82610be2565b9050919050565b610c1b81610c01565b8114610c25575f80fd5b50565b5f81359050610c3681610c12565b92915050565b5f819050919050565b610c4e81610c3c565b8114610c58575f80fd5b50565b5f81359050610c6981610c45565b92915050565b5f8060408385031215610c8557610c84610bde565b5b5f610c9285828601610c28565b9250506020610ca385828601610c5b565b9150509250929050565b5f8115159050919050565b610cc181610cad565b82525050565b5f602082019050610cda5f830184610cb8565b92915050565b610ce981610c3c565b82525050565b5f602082019050610d025f830184610ce0565b92915050565b5f805f60608486031215610d1f57610d1e610bde565b5b5f610d2c86828701610c28565b9350506020610d3d86828701610c28565b9250506040610d4e86828701610c5b565b9150509250925092565b5f60ff82169050919050565b610d6d81610d58565b82525050565b5f602082019050610d865f830184610d64565b92915050565b5f60208284031215610da157610da0610bde565b5b5f610dae84828501610c28565b91505092915050565b5f8060408385031215610dcd57610dcc610bde565b5b5f610dda85828601610c28565b9250506020610deb85828601610c28565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610e3957607f821691505b602082108103610e4c57610e4b610df5565b5b50919050565b610e5b81610c01565b82525050565b5f602082019050610e745f830184610e52565b92915050565b5f606082019050610e8d5f830186610e52565b610e9a6020830185610ce0565b610ea76040830184610ce0565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610ee682610c3c565b9150610ef183610c3c565b9250828201905080821115610f0957610f08610eaf565b5b9291505056fea2646970667358221220383e898342e74543d1bfb6186eff00b4ae7a39d4ecde6190742c5e9f2a7a2e9364736f6c63430008150033\")]\n    // SPDX-License-Identifier: MIT\n    contract ERC20Mock is ERC20 {\n        constructor() ERC20(\"ERC20Mock\", \"MTK\") {}\n\n        function approve(address spender, uint256 value) public override returns (bool) {\n            return super.approve(spender, value);\n        }\n\n        function regular_approve(address owner, address spender, uint256 amount) public {\n            super._approve(owner, spender, amount);\n        }\n\n        function balanceOf(address account) public override view returns (uint256) {\n            return super.balanceOf(account);\n        }\n\n        function mint(address account, uint256 value) public {\n            super._mint(account, value);\n        }\n\n        function transfer(address to, uint256 amount) public override returns (bool) {\n            return super.transfer(to, amount);\n        }\n\n        function transferFrom(address from, address to, uint256 value) public override returns (bool) {\n            return super.transferFrom(from, to, value);\n        }\n\n        function allowance(address owner, address spender) public view override returns (uint256) {\n            return super.allowance(owner, spender);\n        }\n    }\n}\n\npub async fn deploy(wallet: \u0026Wallet) -\u003e eyre::Result\u003cAddress\u003e {\n    // Deploy the contract.\n    let contract = ERC20Mock::deploy(wallet).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc20-wrapper","tests","mock","mod.rs"],"content":"pub mod erc20;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc4626","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse openzeppelin_stylus::{\n    token::erc20::{\n        extensions::{\n            erc4626, Erc20Metadata, Erc4626, IErc20Metadata, IErc4626,\n        },\n        Erc20, IErc20,\n    },\n    utils::introspection::erc165::IErc165,\n};\nuse stylus_sdk::{\n    alloy_primitives::{Address, FixedBytes, U256, U8},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct Erc4626Example {\n    erc4626: Erc4626,\n    erc20: Erc20,\n    metadata: Erc20Metadata,\n}\n\n#[public]\n#[implements(IErc4626\u003cError = erc4626::Error\u003e, IErc20\u003cError = erc4626::Error\u003e, IErc20Metadata, IErc165)]\nimpl Erc4626Example {\n    #[constructor]\n    fn constructor(\n        \u0026mut self,\n        asset: Address,\n        decimals_offset: U8,\n        name: String,\n        symbol: String,\n    ) {\n        self.erc4626.constructor(asset, decimals_offset);\n        self.metadata.constructor(name, symbol);\n    }\n}\n\n#[public]\nimpl IErc4626 for Erc4626Example {\n    type Error = erc4626::Error;\n\n    fn asset(\u0026self) -\u003e Address {\n        self.erc4626.asset()\n    }\n\n    fn total_assets(\u0026self) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.total_assets()\n    }\n\n    fn convert_to_shares(\u0026self, assets: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.convert_to_shares(assets, \u0026self.erc20)\n    }\n\n    fn convert_to_assets(\u0026self, shares: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.convert_to_assets(shares, \u0026self.erc20)\n    }\n\n    fn max_deposit(\u0026self, receiver: Address) -\u003e U256 {\n        self.erc4626.max_deposit(receiver)\n    }\n\n    fn preview_deposit(\u0026self, assets: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.preview_deposit(assets, \u0026self.erc20)\n    }\n\n    fn deposit(\n        \u0026mut self,\n        assets: U256,\n        receiver: Address,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.deposit(assets, receiver, \u0026mut self.erc20)\n    }\n\n    fn max_mint(\u0026self, receiver: Address) -\u003e U256 {\n        self.erc4626.max_mint(receiver)\n    }\n\n    fn preview_mint(\u0026self, shares: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.preview_mint(shares, \u0026self.erc20)\n    }\n\n    fn mint(\n        \u0026mut self,\n        shares: U256,\n        receiver: Address,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.mint(shares, receiver, \u0026mut self.erc20)\n    }\n\n    fn max_withdraw(\u0026self, owner: Address) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.max_withdraw(owner, \u0026self.erc20)\n    }\n\n    fn preview_withdraw(\u0026self, assets: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.preview_withdraw(assets, \u0026self.erc20)\n    }\n\n    fn withdraw(\n        \u0026mut self,\n        assets: U256,\n        receiver: Address,\n        owner: Address,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.withdraw(assets, receiver, owner, \u0026mut self.erc20)\n    }\n\n    fn max_redeem(\u0026self, owner: Address) -\u003e U256 {\n        self.erc4626.max_redeem(owner, \u0026self.erc20)\n    }\n\n    fn preview_redeem(\u0026self, shares: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.preview_redeem(shares, \u0026self.erc20)\n    }\n\n    fn redeem(\n        \u0026mut self,\n        shares: U256,\n        receiver: Address,\n        owner: Address,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc4626.redeem(shares, receiver, owner, \u0026mut self.erc20)\n    }\n}\n\n#[public]\nimpl IErc20 for Erc4626Example {\n    type Error = erc4626::Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.erc20.total_supply()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.erc20.balance_of(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer(to, value)?)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.erc20.allowance(owner, spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.approve(spender, value)?)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer_from(from, to, value)?)\n    }\n}\n\n#[public]\nimpl IErc20Metadata for Erc4626Example {\n    fn name(\u0026self) -\u003e String {\n        self.metadata.name()\n    }\n\n    fn symbol(\u0026self) -\u003e String {\n        self.metadata.symbol()\n    }\n\n    fn decimals(\u0026self) -\u003e U8 {\n        self.erc4626.decimals()\n    }\n}\n\n#[public]\nimpl IErc165 for Erc4626Example {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        \u003cSelf as IErc4626\u003e::interface_id() == interface_id\n            || self.erc20.supports_interface(interface_id)\n            || self.metadata.supports_interface(interface_id)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc4626","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc4626_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc4626","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\n#![allow(clippy::too_many_arguments)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract Erc4626 {\n        function decimals() external view  returns (uint8 decimals);\n\n        function totalSupply() external view returns (uint256 totalSupply);\n        function balanceOf(address account) external view returns (uint256 balance);\n        function transfer(address recipient, uint256 amount) external returns (bool);\n        function allowance(address owner, address spender) external view returns (uint256 allowance);\n        function approve(address spender, uint256 amount) external returns (bool);\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n        function asset() external view  returns (address asset);\n        #[derive(Debug)]\n        function totalAssets() external view returns (uint256 totalAssets);\n        #[derive(Debug)]\n        function convertToShares(uint256 assets) external view  returns (uint256 shares);\n        #[derive(Debug)]\n        function convertToAssets(uint256 shares) external view  returns (uint256 assets);\n        #[derive(Debug)]\n        function maxMint(address) external view  returns (uint256 maxMint);\n        #[derive(Debug)]\n        function maxDeposit(address) external view  returns (uint256 maxDeposit);\n        #[derive(Debug) ]\n        function maxWithdraw(address owner) external view  returns (uint256 maxWithdraw);\n        #[derive(Debug)]\n        function maxRedeem(address owner) external view  returns (uint256 maxRedeem);\n        #[derive(Debug)]\n        function previewDeposit(uint256 assets) external view  returns (uint256 shares);\n        #[derive(Debug)]\n        function previewMint(uint256 shares) external view  returns (uint256 assets);\n        #[derive(Debug)]\n        function previewRedeem(uint256 shares) external view  returns (uint256 assets);\n        #[derive(Debug)]\n        function previewWithdraw(uint256 assets) external view  returns (uint256 shares);\n        function deposit(uint256 assets, address receiver) external  returns (uint256);\n        function mint(uint256 shares, address receiver) external  returns (uint256);\n        function redeem(uint256 shares, address receiver,address owner) external returns (uint256);\n        function withdraw(uint256 assets, address receiver,address owner) external returns (uint256);\n\n        error SafeErc20FailedOperation(address token);\n\n        error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n        error ERC20InvalidApprover(address approver);\n\n        error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n        error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n        error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n        error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n        error InvalidAsset(address asset);\n\n        #[derive(Debug, PartialEq)]\n        event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n        #[derive(Debug, PartialEq)]\n        event Withdraw(address indexed sender,address indexed receiver,address indexed owner,uint256 assets, uint256 shares);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc4626","tests","erc4626.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::Erc4626;\nuse alloy::primitives::{uint, Address, U256};\nuse e2e::{\n    constructor, receipt, send, watch, Account, Constructor, EventExt, Panic,\n    PanicCode, Revert,\n};\nuse eyre::Result;\nuse mock::{\n    erc20, erc20::ERC20Mock, erc20_failing_transfer,\n    erc20_failing_transfer::ERC20FailingTransferMock,\n};\n\nconst DECIMALS_OFFSET: u8 = 0;\n/// The minimum decimal offset needed to induce overflow\nconst MIN_OVERFLOW_DECIMAL_OFFSET: u8 = 78;\nconst TOKEN_NAME: \u0026str = \"Test Token\";\nconst TOKEN_SYMBOL: \u0026str = \"TTK\";\n\nmod abi;\nmod mock;\n\nfn ctr(asset: Address) -\u003e Constructor {\n    constructor!(\n        asset,\n        DECIMALS_OFFSET,\n        TOKEN_NAME.to_string(),\n        TOKEN_SYMBOL.to_string(),\n    )\n}\n\nfn dec_offset_overflow_ctr(asset: Address) -\u003e Constructor {\n    constructor!(\n        asset,\n        MIN_OVERFLOW_DECIMAL_OFFSET,\n        TOKEN_NAME.to_string(),\n        TOKEN_SYMBOL.to_string(),\n    )\n}\n\nasync fn deploy(\n    account: \u0026Account,\n    initial_tokens: U256,\n) -\u003e Result\u003c(Address, Address)\u003e {\n    let asset_addr = erc20::deploy(\u0026account.wallet).await?;\n\n    let contract_addr = account\n        .as_deployer()\n        .with_constructor(ctr(asset_addr))\n        .deploy()\n        .await?\n        .contract_address;\n\n    // Mint initial tokens to the vault\n    if initial_tokens \u003e U256::ZERO {\n        let asset = ERC20Mock::new(asset_addr, \u0026account.wallet);\n        watch!(asset.mint(contract_addr, initial_tokens))?;\n    }\n\n    Ok((contract_addr, asset_addr))\n}\n\nmod constructor {\n    use super::*;\n    #[e2e::test]\n    async fn success(alice: Account) -\u003e Result\u003c()\u003e {\n        let asset_address = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(asset_address))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let decimals = contract.decimals().call().await?.decimals;\n        assert_eq!(decimals, 18);\n\n        let asset = contract.asset().call().await?.asset;\n        assert_eq!(asset, asset_address);\n\n        Ok(())\n    }\n}\n\nmod total_assets {\n    use super::*;\n\n    #[e2e::test]\n    async fn reports_zero_total_assets_when_empty(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let total = contract.totalAssets().call().await?.totalAssets;\n        assert_eq!(U256::ZERO, total);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reports_correct_total_assets_after_deposit(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_deposit = uint!(1000_U256);\n        let (contract_addr, _) = deploy(\u0026alice, initial_deposit).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let total = contract.totalAssets().call().await?.totalAssets;\n        assert_eq!(initial_deposit, total);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn updates_after_external_transfer(alice: Account) -\u003e Result\u003c()\u003e {\n        let initial_deposit = uint!(1000_U256);\n        let additional_amount = uint!(500_U256);\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_deposit).await?;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        // Transfer additional tokens directly to the vault\n        watch!(asset.mint(contract_addr, additional_amount))?;\n\n        let total = contract.totalAssets().call().await?.totalAssets;\n        assert_eq!(initial_deposit + additional_amount, total);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn handles_max_uint256_balance(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::MAX).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let total = contract.totalAssets().call().await?.totalAssets;\n        assert_eq!(U256::MAX, total);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_for_zero_address_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        // Deploy with zero address as asset\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(Address::ZERO))\n            .deploy()\n            .await?\n            .contract_address;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .totalAssets()\n            .call()\n            .await\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: Address::ZERO })\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_for_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        // Deploy with zero address as asset\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(alice.address()))\n            .deploy()\n            .await?\n            .contract_address;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .totalAssets()\n            .call()\n            .await\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: alice.address() })\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reflects_balance_after_withdrawal(alice: Account) -\u003e Result\u003c()\u003e {\n        let initial_deposit = uint!(1000_U256);\n        let withdrawal = uint!(400_U256);\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_deposit).await?;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let alice_addr = alice.address();\n\n        // Simulate withdrawal by transferring tokens out\n        watch!(asset.regular_approve(contract_addr, alice_addr, withdrawal))?;\n        watch!(asset.transferFrom(contract_addr, alice_addr, withdrawal))?;\n\n        let total = contract.totalAssets().call().await?.totalAssets;\n        assert_eq!(initial_deposit - withdrawal, total);\n\n        Ok(())\n    }\n}\n\nmod convert_to_shares {\n    use super::*;\n\n    #[e2e::test]\n    async fn converts_zero_assets_to_zero_shares(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares = contract.convertToShares(U256::ZERO).call().await?.shares;\n        assert_eq!(U256::ZERO, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_zero_shares_for_asset_amount_less_then_vault_assets(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(1000_U256);\n        let assets_to_convert = uint!(100_U256);\n        let (contract_addr, _) = deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares =\n            contract.convertToShares(assets_to_convert).call().await?.shares;\n\n        assert_eq!(U256::ZERO, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_shares_equal_to_deposit_when_vault_is_empty(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let assets_to_convert = uint!(101_U256);\n        let (contract_addr, _) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares =\n            contract.convertToShares(assets_to_convert).call().await?.shares;\n\n        assert_eq!(assets_to_convert, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_shares_proportional_to_deposit_when_vault_has_assets(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let assets_to_convert = uint!(101_U256);\n        let (contract_addr, _) = deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let expected_shares = uint!(1_U256);\n        let shares =\n            contract.convertToShares(assets_to_convert).call().await?.shares;\n\n        assert_eq!(expected_shares, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        let invalid_asset = alice.address();\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(invalid_asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .convertToShares(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: invalid_asset })\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_result_overflows(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::MAX).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .convertToShares(U256::MAX)\n            .call()\n            .await\n            .expect_err(\"should panics due to `Overflow`\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_decimals_offset_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let asset = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(dec_offset_overflow_ctr(asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .convertToShares(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should panic due to decimal offset overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\n\nmod convert_to_assets {\n    use super::*;\n\n    #[e2e::test]\n    async fn converts_zero_shares_to_zero_assets(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let assets = contract.convertToAssets(U256::ZERO).call().await?.assets;\n        assert_eq!(U256::ZERO, assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_more_assets_than_expected_when_no_shares_were_ever_minted(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let tokens = uint!(100_U256);\n\n        let (contract_addr, _) = deploy(\u0026alice, tokens).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares = uint!(69_U256);\n        let expected_assets = uint!(6969_U256);\n\n        let assets = contract.convertToAssets(shares).call().await?.assets;\n\n        assert_eq!(assets, expected_assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_assets_proportional_to_shares(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let (contract_addr, asset_addr) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let shares = uint!(10_U256);\n        // conversion is 1:1 for empty vaults\n        let expected_assets = shares;\n\n        // Mint shares\n        watch!(asset.mint(alice.address(), expected_assets))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            expected_assets\n        ))?;\n        watch!(contract.mint(shares, alice.address()))?;\n\n        let assets = contract.convertToAssets(shares).call().await?.assets;\n\n        assert_eq!(assets, expected_assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        let invalid_asset = alice.address();\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(invalid_asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .convertToAssets(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: invalid_asset })\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_decimals_offset_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let asset = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(dec_offset_overflow_ctr(asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .convertToAssets(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should panic due to decimal offset overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\n\nmod max_deposit {\n    use super::*;\n\n    #[e2e::test]\n    async fn returns_max_uint256_for_any_address(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let max = contract.maxDeposit(alice.address()).call().await?.maxDeposit;\n        assert_eq!(U256::MAX, max);\n\n        let max = contract.maxDeposit(Address::ZERO).call().await?.maxDeposit;\n        assert_eq!(U256::MAX, max);\n\n        Ok(())\n    }\n}\n\nmod preview_deposit {\n    use super::*;\n\n    #[e2e::test]\n    async fn returns_zero_assets_for_zero_shares(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares = contract.previewDeposit(U256::ZERO).call().await?.shares;\n        assert_eq!(U256::ZERO, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_zero_shares_for_asset_amount_less_then_vault_assets(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(1000_U256);\n        let assets_to_convert = uint!(100_U256);\n        let (contract_addr, _) = deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares =\n            contract.previewDeposit(assets_to_convert).call().await?.shares;\n\n        assert_eq!(U256::ZERO, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_shares_equal_to_deposit_when_vault_is_empty(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let assets_to_convert = uint!(101_U256);\n        let (contract_addr, _) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares =\n            contract.previewDeposit(assets_to_convert).call().await?.shares;\n\n        assert_eq!(assets_to_convert, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_shares_proportional_to_deposit_when_vault_has_assets(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let assets_to_convert = uint!(101_U256);\n        let (contract_addr, _) = deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let expected_shares = uint!(1_U256);\n        let shares =\n            contract.previewDeposit(assets_to_convert).call().await?.shares;\n\n        assert_eq!(expected_shares, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        let invalid_asset = alice.address();\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(invalid_asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewDeposit(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: invalid_asset })\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_result_overflows(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::MAX).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewDeposit(U256::MAX)\n            .call()\n            .await\n            .expect_err(\"should panics due to `Overflow`\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_decimals_offset_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let asset = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(dec_offset_overflow_ctr(asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewDeposit(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should panic due to decimal offset overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\n\nmod deposit {\n    use super::*;\n\n    #[e2e::test]\n    async fn reverts_when_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        let invalid_asset = alice.address();\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(invalid_asset))\n            .deploy()\n            .await?\n            .contract_address;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.deposit(uint!(10_U256), alice.address()))\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: invalid_asset })\n        );\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn mints_zero_shares_for_zero_assets(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let erc20_alice = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n        let alice_address = alice.address();\n\n        watch!(erc20_alice.mint(alice_address, uint!(1000_U256)))?;\n\n        let initial_alice_balance =\n            erc20_alice.balanceOf(alice_address).call().await?._0;\n        let initial_alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n\n        let receipt = receipt!(contract.deposit(U256::ZERO, alice.address()))?;\n        assert!(receipt.emits(Erc4626::Deposit {\n            sender: alice_address,\n            owner: alice_address,\n            assets: U256::ZERO,\n            shares: U256::ZERO,\n        }));\n\n        let alice_balance =\n            erc20_alice.balanceOf(alice_address).call().await?._0;\n        assert_eq!(initial_alice_balance, alice_balance);\n\n        let alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n        assert_eq!(initial_alice_shares, alice_shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn mints_zero_shares_for_asset_amount_less_then_vault_assets(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(1000_U256);\n        let assets_to_convert = uint!(100_U256);\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let erc20_alice = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n        let alice_address = alice.address();\n\n        watch!(erc20_alice.mint(alice_address, assets_to_convert))?;\n\n        let initial_alice_balance =\n            erc20_alice.balanceOf(alice_address).call().await?._0;\n        let initial_alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n\n        watch!(erc20_alice.regular_approve(\n            alice_address,\n            contract_addr,\n            assets_to_convert\n        ))?;\n\n        let receipt =\n            receipt!(contract.deposit(assets_to_convert, alice.address()))?;\n\n        assert!(receipt.emits(Erc4626::Deposit {\n            sender: alice_address,\n            owner: alice_address,\n            assets: assets_to_convert,\n            shares: U256::ZERO,\n        }));\n\n        let alice_balance =\n            erc20_alice.balanceOf(alice_address).call().await?._0;\n        assert_eq!(initial_alice_balance - assets_to_convert, alice_balance);\n\n        let alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n        assert_eq!(initial_alice_shares, alice_shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn mints_shares_equal_to_deposit_when_vault_is_empty(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let assets_to_convert = uint!(101_U256);\n        let (contract_addr, asset_addr) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let erc20_alice = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n        let alice_address = alice.address();\n\n        watch!(erc20_alice.mint(alice_address, assets_to_convert))?;\n\n        let initial_alice_balance =\n            erc20_alice.balanceOf(alice_address).call().await?._0;\n        let initial_alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n\n        watch!(erc20_alice.regular_approve(\n            alice_address,\n            contract_addr,\n            assets_to_convert\n        ))?;\n\n        let receipt =\n            receipt!(contract.deposit(assets_to_convert, alice.address()))?;\n\n        assert!(receipt.emits(Erc4626::Deposit {\n            sender: alice_address,\n            owner: alice_address,\n            assets: assets_to_convert,\n            shares: assets_to_convert,\n        }));\n\n        let alice_balance =\n            erc20_alice.balanceOf(alice_address).call().await?._0;\n        assert_eq!(initial_alice_balance - assets_to_convert, alice_balance);\n\n        let alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n        assert_eq!(initial_alice_shares + assets_to_convert, alice_shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn mints_shares_proportional_to_deposit_when_vault_has_assets(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let assets_to_convert = uint!(101_U256);\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let erc20_alice = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n        let alice_address = alice.address();\n\n        watch!(erc20_alice.mint(alice_address, assets_to_convert))?;\n        watch!(erc20_alice.regular_approve(\n            alice_address,\n            contract_addr,\n            assets_to_convert\n        ))?;\n\n        let initial_alice_balance =\n            erc20_alice.balanceOf(alice_address).call().await?._0;\n        let initial_alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n\n        let receipt =\n            receipt!(contract.deposit(assets_to_convert, alice.address()))?;\n\n        let expected_shares = uint!(1_U256);\n\n        assert!(receipt.emits(Erc4626::Deposit {\n            sender: alice_address,\n            owner: alice_address,\n            assets: assets_to_convert,\n            shares: expected_shares,\n        }));\n\n        let alice_balance =\n            erc20_alice.balanceOf(alice_address).call().await?._0;\n        assert_eq!(initial_alice_balance - assets_to_convert, alice_balance);\n\n        let alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n        assert_eq!(initial_alice_shares + expected_shares, alice_shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_no_approval_on_assets(alice: Account) -\u003e Result\u003c()\u003e {\n        let assets_to_convert = uint!(101_U256);\n        let (contract_addr, asset_addr) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let erc20_alice = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n        let alice_address = alice.address();\n\n        watch!(erc20_alice.mint(alice_address, assets_to_convert))?;\n\n        let err = send!(contract.deposit(assets_to_convert, alice_address))\n            .expect_err(\"should return `SafeErc20FailedOperation`\");\n\n        assert!(err.reverted_with(Erc4626::SafeErc20FailedOperation {\n            token: asset_addr\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_result_overflows(\n        alice: Account,\n        bob: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::MAX).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.deposit(U256::MAX, bob.address()))\n            .expect_err(\"should panics due to `Overflow`\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_decimals_offset_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let asset = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(dec_offset_overflow_ctr(asset))\n            .deploy()\n            .await?\n            .contract_address;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset, \u0026alice.wallet);\n\n        let assets = uint!(10_U256);\n\n        watch!(asset.mint(alice.address(), assets))?;\n        watch!(asset.regular_approve(alice.address(), contract_addr, assets))?;\n\n        let err = send!(contract.deposit(assets, alice.address()))\n            .expect_err(\"should panic due to decimal offset overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\nmod max_mint {\n    use super::*;\n\n    #[e2e::test]\n    async fn returns_max_uint256_for_any_address(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let max = contract.maxMint(alice.address()).call().await?.maxMint;\n        assert_eq!(U256::MAX, max);\n\n        let max = contract.maxMint(Address::ZERO).call().await?.maxMint;\n        assert_eq!(U256::MAX, max);\n\n        Ok(())\n    }\n}\n\nmod preview_mint {\n    use super::*;\n\n    #[e2e::test]\n    async fn returns_zero_shares_to_zero_assets(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let assets = contract.previewMint(U256::ZERO).call().await?.assets;\n        assert_eq!(U256::ZERO, assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_more_assets_than_expected_when_no_shares_were_ever_minted(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let tokens = uint!(100_U256);\n\n        let (contract_addr, _) = deploy(\u0026alice, tokens).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares = uint!(69_U256);\n        let expected_assets = uint!(6969_U256);\n\n        let assets = contract.previewMint(shares).call().await?.assets;\n\n        assert_eq!(assets, expected_assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        let invalid_asset = alice.address();\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(invalid_asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewMint(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: invalid_asset })\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_overflows(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::from(1)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewMint(U256::MAX)\n            .call()\n            .await\n            .expect_err(\"should return `Overflow`\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_decimals_offset_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let asset = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(dec_offset_overflow_ctr(asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewMint(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should panic due to decimal offset overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\n\nmod mint {\n    use super::*;\n\n    #[e2e::test]\n    async fn reverts_when_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        let invalid_asset = alice.address();\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(invalid_asset))\n            .deploy()\n            .await?\n            .contract_address;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.mint(uint!(10_U256), alice.address()))\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: invalid_asset })\n        );\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn creates_zero_shares_for_zero_assets(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let alice_address = alice.address();\n        let shares = U256::ZERO;\n        let alice_assets = U256::ZERO;\n        let receipt = receipt!(contract.mint(shares, alice_address))?;\n\n        assert!(receipt.emits(Erc4626::Deposit {\n            sender: alice_address,\n            owner: alice_address,\n            assets: alice_assets,\n            shares,\n        }));\n\n        let alice_balance =\n            contract.balanceOf(alice_address).call().await?.balance;\n        assert_eq!(alice_balance, shares);\n\n        let alice_assets_balance =\n            asset.balanceOf(alice_address).call().await?._0;\n        assert_eq!(alice_assets_balance, alice_assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn requires_more_assets_than_expected_when_no_shares_were_ever_minted(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let tokens = uint!(100_U256);\n\n        let (contract_addr, asset_addr) = deploy(\u0026alice, tokens).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let alice_address = alice.address();\n        let shares = uint!(69_U256);\n        let assets = uint!(6969_U256);\n\n        watch!(asset.mint(alice.address(), assets))?;\n        watch!(asset.regular_approve(alice_address, contract_addr, assets))?;\n\n        let initial_alice_assets =\n            asset.balanceOf(alice_address).call().await?._0;\n        let initial_alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n\n        let receipt = receipt!(contract.mint(shares, alice_address))?;\n\n        assert!(receipt.emits(Erc4626::Deposit {\n            sender: alice_address,\n            owner: alice_address,\n            assets,\n            shares,\n        }));\n\n        let alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n        assert_eq!(alice_shares, shares + initial_alice_shares);\n\n        let alice_assets = asset.balanceOf(alice_address).call().await?._0;\n        assert_eq!(alice_assets, initial_alice_assets - assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_no_approval_on_assets(alice: Account) -\u003e Result\u003c()\u003e {\n        let tokens = uint!(100_U256);\n\n        let (contract_addr, asset_addr) = deploy(\u0026alice, tokens).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let alice_address = alice.address();\n        let shares = uint!(69_U256);\n        let assets = uint!(6969_U256);\n\n        watch!(asset.mint(alice.address(), assets))?;\n\n        let err = send!(contract.mint(shares, alice_address))\n            .expect_err(\"should return `SafeErc20FailedOperation`\");\n\n        assert!(err.reverted_with(Erc4626::SafeErc20FailedOperation {\n            token: asset_addr\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_overflows(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::from(1)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.mint(U256::MAX, alice.address()))\n            .expect_err(\"should return `Overflow`\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_decimals_offset_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let asset = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(dec_offset_overflow_ctr(asset))\n            .deploy()\n            .await?\n            .contract_address;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset, \u0026alice.wallet);\n\n        let shares = uint!(10_U256);\n        let assets = shares; // expected 1:1\n\n        watch!(asset.mint(alice.address(), assets))?;\n        watch!(asset.regular_approve(alice.address(), contract_addr, assets))?;\n\n        let err = send!(contract.mint(shares, alice.address()))\n            .expect_err(\"should panic due to decimal offset overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\n\nmod max_withdraw {\n    use super::*;\n\n    #[e2e::test]\n    async fn returns_zero_for_vault_with_no_shares(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(1000_U256);\n        let (contract_addr, _) = deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let max =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        assert_eq!(U256::ZERO, max);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_zero_when_vault_is_empty(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let max =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        assert_eq!(U256::ZERO, max);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_convertible_assets_for_sole_share_owner(\n        alice: Account,\n        bob: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let shares_to_mint = uint!(10_U256);\n        let assets_to_deposit = uint!(1010_U256);\n\n        // Mint some shares to alice\n        watch!(asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        let max =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        assert_eq!(assets_to_deposit, max);\n\n        let max = contract.maxWithdraw(bob.address()).call().await?.maxWithdraw;\n        assert_eq!(U256::ZERO, max);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_convertible_assets_for_sole_share_owner_when_vault_was_empty(\n        alice: Account,\n        bob: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let (contract_addr, asset_addr) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let shares_to_mint = uint!(10_U256);\n        // conversion is 1:1 for empty vaults\n        let assets_to_deposit = shares_to_mint;\n\n        // Mint some shares to alice\n        watch!(asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        let max =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        assert_eq!(assets_to_deposit, max);\n\n        let max = contract.maxWithdraw(bob.address()).call().await?.maxWithdraw;\n        assert_eq!(U256::ZERO, max);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_convertible_assets_to_multiple_share_owners(\n        alice: Account,\n        bob: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let (contract_addr, asset_addr) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let contract_bob = Erc4626::new(contract_addr, \u0026bob.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let shares_to_mint = uint!(10_U256);\n        // conversion is 1:1 for empty vaults\n        let assets_to_deposit = shares_to_mint;\n        let assets_to_deposit_bob = uint!(100_U256);\n\n        // Mint some shares to alice\n        watch!(asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        // Mint some shares to bob\n        watch!(asset.mint(bob.address(), assets_to_deposit_bob))?;\n        watch!(asset.regular_approve(\n            bob.address(),\n            contract_addr,\n            assets_to_deposit_bob\n        ))?;\n        watch!(contract_bob.mint(shares_to_mint, bob.address()))?;\n\n        let max =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        assert_eq!(assets_to_deposit, max);\n\n        let max = contract.maxWithdraw(bob.address()).call().await?.maxWithdraw;\n        assert_eq!(assets_to_deposit, max);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_for_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        let invalid_asset = alice.address();\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(invalid_asset))\n            .deploy()\n            .await?\n            .contract_address;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .maxWithdraw(alice.address())\n            .call()\n            .await\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: invalid_asset })\n        );\n\n        Ok(())\n    }\n\n    // Cannot test when denominator overflows, as amount of shares is always \u003e=\n    // amount of assets\n    #[e2e::test]\n    async fn reverts_when_multiplier_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::MAX).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .maxWithdraw(alice.address())\n            .call()\n            .await\n            .expect_err(\"should panic due to overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_decimals_offset_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let asset = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(dec_offset_overflow_ctr(asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .maxWithdraw(alice.address())\n            .call()\n            .await\n            .expect_err(\"should panic due to decimal offset overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\n\nmod preview_withdraw {\n    use super::*;\n\n    #[e2e::test]\n    async fn reverts_when_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        let invalid_asset = alice.address();\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(invalid_asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewWithdraw(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: invalid_asset })\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_zero_assets_for_zero_shares(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares = contract.previewWithdraw(U256::ZERO).call().await?.shares;\n        assert_eq!(U256::ZERO, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_one_share_for_asset_amount_less_then_vault_assets(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(1000_U256);\n        let assets_to_convert = uint!(100_U256);\n        let (contract_addr, _) = deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares =\n            contract.previewWithdraw(assets_to_convert).call().await?.shares;\n\n        assert_eq!(uint!(1_U256), shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_shares_equal_to_deposit_when_vault_is_empty(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let assets_to_convert = uint!(101_U256);\n        let (contract_addr, _) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares =\n            contract.previewWithdraw(assets_to_convert).call().await?.shares;\n\n        assert_eq!(assets_to_convert, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_shares_proportional_to_deposit_when_vault_has_assets(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let assets_to_convert = uint!(101_U256);\n        let (contract_addr, _) = deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let expected_shares = uint!(1_U256);\n        let shares =\n            contract.previewWithdraw(assets_to_convert).call().await?.shares;\n\n        assert_eq!(expected_shares, shares);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_result_overflows(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::MAX).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewDeposit(U256::MAX)\n            .call()\n            .await\n            .expect_err(\"should panics due to `Overflow`\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_decimals_offset_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let asset = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(dec_offset_overflow_ctr(asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewWithdraw(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should panic due to decimal offset overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\n\nmod withdraw {\n    use super::*;\n\n    #[e2e::test]\n    async fn reverts_when_exceeds_max_withdraw(alice: Account) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let shares_to_mint = uint!(10_U256);\n        let assets_to_deposit = uint!(1010_U256);\n        let assets_to_withdraw = uint!(1011_U256); // More than deposited\n\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        // Mint shares\n        watch!(asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        let max_withdraw =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n\n        let err = send!(contract.withdraw(\n            assets_to_withdraw,\n            alice.address(),\n            alice.address()\n        ))\n        .expect_err(\"should fail due to exceeding max withdraw\");\n\n        assert!(err.reverted_with(Erc4626::ERC4626ExceededMaxWithdraw {\n            owner: alice.address(),\n            assets: assets_to_withdraw,\n            max: max_withdraw\n        }));\n        assert_eq!(assets_to_deposit, max_withdraw);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_withdrawing_from_empty_vault(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.withdraw(\n            uint!(100_U256),\n            alice.address(),\n            alice.address()\n        ))\n        .expect_err(\"should fail due to empty vault\");\n\n        assert!(err.reverted_with(Erc4626::ERC4626ExceededMaxWithdraw {\n            owner: alice.address(),\n            assets: uint!(100_U256),\n            max: U256::ZERO\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_caller_lacks_allowance(\n        alice: Account,\n        bob: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let shares_to_mint = uint!(10_U256);\n        let assets_to_deposit = uint!(1010_U256);\n        let shares_to_redeem = uint!(1_U256);\n        let assets_to_withdraw = uint!(101_U256);\n\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let bob_contract = Erc4626::new(contract_addr, \u0026bob.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        // Mint shares to alice\n        watch!(asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        // Bob tries to withdraw without allowance\n        let err = send!(bob_contract.withdraw(\n            assets_to_withdraw,\n            bob.address(),\n            alice.address()\n        ))\n        .expect_err(\"should fail due to insufficient allowance\");\n\n        assert!(err.reverted_with(Erc4626::ERC20InsufficientAllowance {\n            spender: bob.address(),\n            allowance: U256::ZERO,\n            needed: shares_to_redeem\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_withdrawing_from_zero_address(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.withdraw(\n            U256::ZERO,\n            alice.address(),\n            Address::ZERO\n        ))\n        .expect_err(\"should fail due to invalid approver\");\n\n        assert!(err.reverted_with(Erc4626::ERC20InvalidApprover {\n            approver: Address::ZERO\n        }));\n\n        let err = send!(contract.withdraw(\n            uint!(1_U256),\n            alice.address(),\n            Address::ZERO\n        ))\n        .expect_err(\"should fail due to exceeding max withdraw\");\n\n        assert!(err.reverted_with(Erc4626::ERC4626ExceededMaxWithdraw {\n            owner: Address::ZERO,\n            assets: uint!(1_U256),\n            max: U256::ZERO\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_transfer_fails(alice: Account) -\u003e Result\u003c()\u003e {\n        let shares_to_mint = uint!(10_U256);\n        let assets_to_deposit = shares_to_mint;\n        let assets_to_withdraw = uint!(1_U256);\n\n        // Deploy failing ERC20\n        let failing = erc20_failing_transfer::deploy(\u0026alice.wallet).await?;\n        let failing_asset =\n            ERC20FailingTransferMock::new(failing, \u0026alice.wallet);\n\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(failing))\n            .deploy()\n            .await?\n            .contract_address;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        // Setup failing asset\n        watch!(failing_asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(failing_asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        let err = send!(contract.withdraw(\n            assets_to_withdraw,\n            alice.address(),\n            alice.address()\n        ))\n        .expect_err(\"should fail due to failed transfer\");\n\n        assert!(err.reverted_with(Erc4626::SafeErc20FailedOperation {\n            token: failing\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_calculation_overflows(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, asset_addr) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        // Mint maximum shares\n        watch!(asset.mint(alice.address(), U256::MAX))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            U256::MAX\n        ))?;\n        watch!(contract.mint(U256::MAX, alice.address()))?;\n\n        let err = send!(contract.withdraw(\n            U256::MAX,\n            alice.address(),\n            alice.address()\n        ))\n        .expect_err(\"should panic due to overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn succeeds_with_no_initial_assets(\n        alice: Account,\n        bob: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let shares_to_mint = uint!(10_U256);\n        let assets_to_deposit = shares_to_mint;\n        let assets_to_withdraw = uint!(5_U256);\n\n        let (contract_addr, asset_addr) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        // Initial state check\n        let initial_max_withdraw =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        assert_eq!(U256::ZERO, initial_max_withdraw);\n\n        // Mint shares\n        watch!(asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        let alice_balance = asset.balanceOf(alice.address()).call().await?._0;\n        let bob_balance = asset.balanceOf(bob.address()).call().await?._0;\n        assert_eq!(U256::ZERO, alice_balance);\n        assert_eq!(U256::ZERO, bob_balance);\n\n        // Perform withdrawal\n        let receipt = receipt!(contract.withdraw(\n            assets_to_withdraw,\n            alice.address(),\n            alice.address()\n        ))?;\n\n        // Verify event\n        assert!(receipt.emits(Erc4626::Withdraw {\n            sender: alice.address(),\n            receiver: alice.address(),\n            owner: alice.address(),\n            assets: assets_to_withdraw,\n            shares: assets_to_withdraw, // 1:1 ratio expected\n        }));\n\n        // Verify updated state\n        let final_max_withdraw =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        let final_max_redeem =\n            contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n        assert_eq!(assets_to_deposit - assets_to_withdraw, final_max_withdraw);\n        assert_eq!(shares_to_mint - assets_to_withdraw, final_max_redeem);\n\n        // Perform withdrawal to a different recipient\n        let receipt = receipt!(contract.withdraw(\n            assets_to_withdraw,\n            bob.address(),\n            alice.address()\n        ))?;\n\n        // Verify event\n        assert!(receipt.emits(Erc4626::Withdraw {\n            sender: alice.address(),\n            receiver: bob.address(),\n            owner: alice.address(),\n            assets: assets_to_withdraw,\n            shares: assets_to_withdraw, // 1:1 ratio expected\n        }));\n\n        // Verify final state\n        let final_max_withdraw =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        let final_max_redeem =\n            contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n        assert_eq!(U256::ZERO, final_max_withdraw);\n        assert_eq!(U256::ZERO, final_max_redeem);\n\n        let alice_balance = asset.balanceOf(alice.address()).call().await?._0;\n        let bob_balance = asset.balanceOf(bob.address()).call().await?._0;\n        assert_eq!(assets_to_withdraw, alice_balance);\n        assert_eq!(assets_to_withdraw, bob_balance);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn succeeds_with_initial_assets(\n        alice: Account,\n        bob: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let shares_to_mint = uint!(10_U256);\n        let assets_to_deposit = uint!(1010_U256);\n        let shares_to_redeem = uint!(1_U256);\n        let assets_to_withdraw = uint!(101_U256);\n\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        // Initial state check\n        let initial_total_assets =\n            contract.totalAssets().call().await?.totalAssets;\n        assert_eq!(initial_assets, initial_total_assets);\n\n        // Mint shares\n        watch!(asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        let alice_balance = asset.balanceOf(alice.address()).call().await?._0;\n        let bob_balance = asset.balanceOf(bob.address()).call().await?._0;\n        assert_eq!(U256::ZERO, alice_balance);\n        assert_eq!(U256::ZERO, bob_balance);\n\n        let pre_withdraw_assets =\n            contract.totalAssets().call().await?.totalAssets;\n\n        // Perform withdrawal\n        let receipt = receipt!(contract.withdraw(\n            assets_to_withdraw,\n            alice.address(),\n            alice.address()\n        ))?;\n\n        // Verify event\n        assert!(receipt.emits(Erc4626::Withdraw {\n            sender: alice.address(),\n            receiver: alice.address(),\n            owner: alice.address(),\n            assets: assets_to_withdraw,\n            shares: shares_to_redeem,\n        }));\n\n        let post_withdraw_assets =\n            contract.totalAssets().call().await?.totalAssets;\n        assert_eq!(\n            pre_withdraw_assets - assets_to_withdraw,\n            post_withdraw_assets\n        );\n\n        let pre_withdraw_assets = post_withdraw_assets;\n\n        // Perform withdrawal to different recipient\n        let receipt = receipt!(contract.withdraw(\n            assets_to_withdraw,\n            bob.address(),\n            alice.address()\n        ))?;\n\n        // Verify event\n        assert!(receipt.emits(Erc4626::Withdraw {\n            sender: alice.address(),\n            receiver: bob.address(),\n            owner: alice.address(),\n            assets: assets_to_withdraw,\n            shares: shares_to_redeem,\n        }));\n\n        // Verify the final state\n        let post_withdraw_assets =\n            contract.totalAssets().call().await?.totalAssets;\n        assert_eq!(\n            pre_withdraw_assets - assets_to_withdraw,\n            post_withdraw_assets\n        );\n\n        let final_max_withdraw =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        let final_max_redeem =\n            contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n        assert_eq!(\n            assets_to_deposit - assets_to_withdraw - assets_to_withdraw,\n            final_max_withdraw\n        );\n        assert_eq!(\n            shares_to_mint - shares_to_redeem - shares_to_redeem,\n            final_max_redeem\n        );\n\n        let alice_balance = asset.balanceOf(alice.address()).call().await?._0;\n        let bob_balance = asset.balanceOf(bob.address()).call().await?._0;\n        assert_eq!(assets_to_withdraw, alice_balance);\n        assert_eq!(assets_to_withdraw, bob_balance);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_for_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        let invalid_asset = alice.address();\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(invalid_asset))\n            .deploy()\n            .await?\n            .contract_address;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.withdraw(\n            uint!(100_U256),\n            alice.address(),\n            alice.address()\n        ))\n        .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: invalid_asset })\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn succeeds_with_multiple_holders_no_initial_assets(\n        alice: Account,\n        bob: Account,\n        charlie: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let (contract_addr, asset_addr) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract_alice = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let contract_bob = Erc4626::new(contract_addr, \u0026bob.wallet);\n        let contract_charlie = Erc4626::new(contract_addr, \u0026charlie.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        // Mint and approve for all users\n        for user in [\u0026alice, \u0026bob, \u0026charlie] {\n            watch!(asset.mint(user.address(), uint!(1000_U256)))?;\n            watch!(asset.regular_approve(\n                user.address(),\n                contract_addr,\n                uint!(1000_U256)\n            ))?;\n        }\n\n        // Each user deposits different amounts\n        watch!(contract_alice.mint(uint!(100_U256), alice.address()))?;\n        watch!(contract_bob.mint(uint!(200_U256), bob.address()))?;\n        watch!(contract_charlie.mint(uint!(300_U256), charlie.address()))?;\n\n        // Each user withdraws different percentages\n        watch!(contract_alice.withdraw(\n            uint!(50_U256),\n            alice.address(),\n            alice.address()\n        ))?; // 50% for alice\n        watch!(contract_bob.withdraw(\n            uint!(100_U256),\n            bob.address(),\n            bob.address()\n        ))?; // 50% for bob\n        watch!(contract_charlie.withdraw(\n            uint!(300_U256),\n            charlie.address(),\n            charlie.address()\n        ))?; // 100% for charlie\n\n        // Verify final balances\n        assert_eq!(\n            uint!(50_U256),\n            contract_alice\n                .maxWithdraw(alice.address())\n                .call()\n                .await?\n                .maxWithdraw\n        );\n        assert_eq!(\n            uint!(100_U256),\n            contract_alice.maxWithdraw(bob.address()).call().await?.maxWithdraw\n        );\n        assert_eq!(\n            U256::ZERO,\n            contract_alice\n                .maxWithdraw(charlie.address())\n                .call()\n                .await?\n                .maxWithdraw\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn succeeds_with_multiple_holders_with_initial_assets(\n        alice: Account,\n        bob: Account,\n        charlie: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract_alice = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let contract_bob = Erc4626::new(contract_addr, \u0026bob.wallet);\n        let contract_charlie = Erc4626::new(contract_addr, \u0026charlie.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        // Record initial total assets\n        let initial_total =\n            contract_alice.totalAssets().call().await?.totalAssets;\n\n        // Mint and approve for all users\n        for user in [\u0026alice, \u0026bob, \u0026charlie] {\n            watch!(asset.mint(user.address(), uint!(10000_U256)))?;\n            watch!(asset.regular_approve(\n                user.address(),\n                contract_addr,\n                uint!(10000_U256)\n            ))?;\n        }\n\n        // Each user deposits different amounts\n        watch!(contract_alice.mint(uint!(10_U256), alice.address()))?;\n        watch!(contract_bob.mint(uint!(20_U256), bob.address()))?;\n        watch!(contract_charlie.mint(uint!(30_U256), charlie.address()))?;\n\n        // Verify share distribution considers initial assets\n        let alice_assets_before = contract_alice\n            .maxWithdraw(alice.address())\n            .call()\n            .await?\n            .maxWithdraw;\n        let bob_assets_before =\n            contract_alice.maxWithdraw(bob.address()).call().await?.maxWithdraw;\n        let charlie_assets_before = contract_alice\n            .maxWithdraw(charlie.address())\n            .call()\n            .await?\n            .maxWithdraw;\n\n        // Each user withdraws\n        watch!(contract_alice.withdraw(\n            alice_assets_before,\n            alice.address(),\n            alice.address()\n        ))?; // 100%\n        watch!(contract_bob.withdraw(\n            uint!(1010_U256),\n            bob.address(),\n            bob.address()\n        ))?; // 50%\n        watch!(contract_charlie.withdraw(\n            charlie_assets_before,\n            charlie.address(),\n            charlie.address()\n        ))?; // 100%\n\n        // Verify proportional distribution of initial assets was maintained\n        let remaining_bob =\n            contract_alice.maxWithdraw(bob.address()).call().await?.maxWithdraw;\n        assert_eq!(bob_assets_before - uint!(1010_U256), remaining_bob);\n\n        // Verify total assets consistency\n        let final_total =\n            contract_alice.totalAssets().call().await?.totalAssets;\n        let expected_remaining = initial_total + uint!(6060_U256)\n            - alice_assets_before\n            - uint!(1010_U256)\n            - charlie_assets_before;\n        assert_eq!(expected_remaining, final_total);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn maintains_share_price_ratio(alice: Account) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let shares = uint!(10_U256);\n        let assets = uint!(2000_U256);\n\n        // Setup deposits\n        watch!(asset.mint(alice.address(), assets))?;\n        watch!(asset.regular_approve(alice.address(), contract_addr, assets))?;\n        watch!(contract.mint(shares, alice.address()))?;\n\n        // Record initial conversion rate\n        let initial_rate =\n            contract.convertToAssets(uint!(1_U256)).call().await?.assets;\n\n        // Perform partial withdrawal\n        watch!(contract.withdraw(\n            uint!(500_U256),\n            alice.address(),\n            alice.address()\n        ))?;\n\n        // Verify conversion rate remains the same\n        let final_rate =\n            contract.convertToAssets(uint!(1_U256)).call().await?.assets;\n        assert_eq!(initial_rate, final_rate);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn maintains_state_consistency_after_failed_withdrawal(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let shares_to_mint = uint!(10_U256);\n        let assets_to_deposit = uint!(1010_U256);\n        let excessive_assets_to_withdraw = uint!(1011_U256);\n\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        // Setup initial state\n        watch!(asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        // Record state before failed withdrawal\n        let pre_total_assets = contract.totalAssets().call().await?.totalAssets;\n        let pre_max_withdraw =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        let pre_max_redeem =\n            contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n\n        // Attempt excessive withdrawal\n        send!(contract.withdraw(\n            excessive_assets_to_withdraw,\n            alice.address(),\n            alice.address()\n        ))\n        .expect_err(\"should fail due to exceeding max withdraw\");\n\n        // Verify state remains unchanged\n        let post_total_assets =\n            contract.totalAssets().call().await?.totalAssets;\n        let post_max_withdraw =\n            contract.maxWithdraw(alice.address()).call().await?.maxWithdraw;\n        let post_max_redeem =\n            contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n\n        assert_eq!(pre_total_assets, post_total_assets);\n        assert_eq!(pre_max_withdraw, post_max_withdraw);\n        assert_eq!(pre_max_redeem, post_max_redeem);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_decimals_offset_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let asset = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(dec_offset_overflow_ctr(asset))\n            .deploy()\n            .await?\n            .contract_address;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.withdraw(\n            uint!(10_U256),\n            alice.address(),\n            alice.address()\n        ))\n        .expect_err(\"should panic due to decimal offset overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\n\nmod max_redeem {\n    use super::*;\n\n    #[e2e::test]\n    async fn returns_zero_for_vault_with_no_shares(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(1000_U256);\n        let (contract_addr, _) = deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let max = contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n        assert_eq!(U256::ZERO, max);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_zero_when_vault_is_empty(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let max = contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n        assert_eq!(U256::ZERO, max);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_full_share_balance_for_owner(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let assets_to_deposit = uint!(6969_U256);\n        let shares_to_mint = uint!(69_U256);\n\n        // Mint some shares to alice\n        watch!(asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        let max = contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n        assert_eq!(shares_to_mint, max);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_balance_after_partial_transfer(\n        alice: Account,\n        bob: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let assets_to_deposit = uint!(8080_U256);\n        let shares_to_mint = uint!(80_U256);\n        let transfer_amount = uint!(40_U256);\n\n        // Mint shares to alice\n        watch!(asset.mint(alice.address(), assets_to_deposit))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_to_deposit\n        ))?;\n        watch!(contract.mint(shares_to_mint, alice.address()))?;\n\n        // Transfer some shares to bob\n        watch!(contract.transfer(bob.address(), transfer_amount))?;\n\n        let alice_max =\n            contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n        let bob_max = contract.maxRedeem(bob.address()).call().await?.maxRedeem;\n\n        assert_eq!(shares_to_mint - transfer_amount, alice_max);\n        assert_eq!(transfer_amount, bob_max);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_updated_balance_after_mint(alice: Account) -\u003e Result\u003c()\u003e {\n        let initial_assets = uint!(100_U256);\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, initial_assets).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n\n        let first_mint = uint!(10_U256);\n        let second_mint = uint!(50_U256);\n        let assets_for_first_mint = uint!(1010_U256);\n        let assets_for_second_mint = uint!(5050_U256);\n\n        // First mint\n        watch!(asset.mint(alice.address(), assets_for_first_mint))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_for_first_mint\n        ))?;\n        watch!(contract.mint(first_mint, alice.address()))?;\n\n        let max_after_first =\n            contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n        assert_eq!(first_mint, max_after_first);\n\n        // Second mint\n        watch!(asset.mint(alice.address(), assets_for_second_mint))?;\n        watch!(asset.regular_approve(\n            alice.address(),\n            contract_addr,\n            assets_for_second_mint\n        ))?;\n        watch!(contract.mint(second_mint, alice.address()))?;\n\n        let max_after_second =\n            contract.maxRedeem(alice.address()).call().await?.maxRedeem;\n        assert_eq!(first_mint + second_mint, max_after_second);\n\n        Ok(())\n    }\n}\n\nmod preview_redeem {\n    use super::*;\n\n    #[e2e::test]\n    async fn reverts_when_invalid_asset(alice: Account) -\u003e Result\u003c()\u003e {\n        let invalid_asset = alice.address();\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(ctr(invalid_asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewRedeem(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should return `InvalidAsset`\");\n\n        assert!(\n            err.reverted_with(Erc4626::InvalidAsset { asset: invalid_asset })\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_zero_shares_to_zero_assets(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let assets = contract.previewRedeem(U256::ZERO).call().await?.assets;\n        assert_eq!(U256::ZERO, assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn returns_more_assets_than_expected_when_no_shares_were_ever_minted(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let tokens = uint!(100_U256);\n\n        let (contract_addr, _) = deploy(\u0026alice, tokens).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares = uint!(69_U256);\n        let expected_assets = uint!(6969_U256);\n\n        let assets = contract.previewRedeem(shares).call().await?.assets;\n\n        assert_eq!(assets, expected_assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_overflows(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::from(1)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewRedeem(U256::MAX)\n            .call()\n            .await\n            .expect_err(\"should return `Overflow`\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_decimals_offset_overflows_during_conversion(\n        alice: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let asset = erc20::deploy(\u0026alice.wallet).await?;\n        let contract_addr = alice\n            .as_deployer()\n            .with_constructor(dec_offset_overflow_ctr(asset))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let err = contract\n            .previewRedeem(uint!(10_U256))\n            .call()\n            .await\n            .expect_err(\"should panic due to decimal offset overflow\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\n\nmod redeem {\n    use super::*;\n\n    #[e2e::test]\n    async fn reverts_when_exceeded_max_redeem_zero_balance(\n        alice: Account,\n        bob: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let (contract_addr, _) = deploy(\u0026alice, U256::ZERO).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n\n        let shares = uint!(10_U256);\n        let err =\n            send!(contract.redeem(shares, bob.address(), alice.address()))\n                .expect_err(\"should return `ERC4626ExceededMaxRedeem`\");\n\n        assert!(err.reverted_with(Erc4626::ERC4626ExceededMaxRedeem {\n            owner: alice.address(),\n            shares,\n            max: U256::ZERO,\n        }));\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn zero_shares_for_zero_assets(alice: Account) -\u003e Result\u003c()\u003e {\n        let (contract_addr, asset_addr) =\n            deploy(\u0026alice, uint!(1000_U256)).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n        let alice_address = alice.address();\n\n        let initial_alice_assets =\n            asset.balanceOf(alice_address).call().await?._0;\n        let initial_alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n\n        let receipt = receipt!(contract.redeem(\n            U256::ZERO,\n            alice_address,\n            alice_address\n        ))?;\n\n        assert!(receipt.emits(Erc4626::Withdraw {\n            sender: alice_address,\n            receiver: alice_address,\n            owner: alice_address,\n            assets: U256::ZERO,\n            shares: U256::ZERO,\n        }));\n\n        let alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n        assert_eq!(initial_alice_shares, alice_shares);\n\n        let alice_assets = asset.balanceOf(alice_address).call().await?._0;\n        assert_eq!(initial_alice_assets, alice_assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn full_share_balance_for_owner(alice: Account) -\u003e Result\u003c()\u003e {\n        let tokens = uint!(100_U256);\n\n        let (contract_addr, asset_addr) = deploy(\u0026alice, tokens).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n        let alice_address = alice.address();\n\n        let assets = uint!(6969_U256);\n        let shares = uint!(69_U256);\n\n        // Mint some shares to alice\n        watch!(asset.mint(alice.address(), assets))?;\n        watch!(asset.regular_approve(alice.address(), contract_addr, assets))?;\n        watch!(contract.mint(shares, alice.address()))?;\n\n        let initial_alice_assets =\n            asset.balanceOf(alice_address).call().await?._0;\n        let initial_alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n\n        let receipt =\n            receipt!(contract.redeem(shares, alice_address, alice_address))?;\n\n        assert!(receipt.emits(Erc4626::Withdraw {\n            sender: alice_address,\n            receiver: alice_address,\n            owner: alice_address,\n            assets,\n            shares\n        }));\n\n        let alice_shares =\n            contract.balanceOf(alice_address).call().await?.balance;\n        assert_eq!(initial_alice_shares - shares, alice_shares);\n\n        let alice_assets = asset.balanceOf(alice_address).call().await?._0;\n        assert_eq!(initial_alice_assets + assets, alice_assets);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_insufficient_allowance(\n        alice: Account,\n        bob: Account,\n    ) -\u003e Result\u003c()\u003e {\n        let tokens = uint!(100_U256);\n\n        let (contract_addr, asset_addr) = deploy(\u0026alice, tokens).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n        let contract_bob = Erc4626::new(contract_addr, \u0026bob.wallet);\n        let alice_address = alice.address();\n\n        let assets = uint!(6969_U256);\n        let shares = uint!(69_U256);\n\n        // Mint some shares to alice\n        watch!(asset.mint(alice.address(), assets))?;\n        watch!(asset.regular_approve(alice.address(), contract_addr, assets))?;\n        watch!(contract.mint(shares, alice.address()))?;\n\n        let err =\n            send!(contract_bob.redeem(shares, alice_address, alice_address))\n                .expect_err(\"should return `ERC20InsufficientAllowance`\");\n\n        assert!(err.reverted_with(Erc4626::ERC20InsufficientAllowance {\n            spender: bob.address(),\n            allowance: U256::ZERO,\n            needed: shares,\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_when_exceeded_max_redeem(alice: Account) -\u003e Result\u003c()\u003e {\n        let tokens = uint!(100_U256);\n\n        let (contract_addr, asset_addr) = deploy(\u0026alice, tokens).await?;\n        let contract = Erc4626::new(contract_addr, \u0026alice.wallet);\n        let asset = ERC20Mock::new(asset_addr, \u0026alice.wallet);\n        let alice_address = alice.address();\n\n        let assets = uint!(6969_U256);\n        let shares = uint!(69_U256);\n\n        // Mint some shares to alice\n        watch!(asset.mint(alice.address(), assets))?;\n        watch!(asset.regular_approve(alice.address(), contract_addr, assets))?;\n        watch!(contract.mint(shares, alice.address()))?;\n\n        let err = send!(contract.redeem(\n            shares + uint!(1_U256),\n            alice_address,\n            alice_address\n        ))\n        .expect_err(\"should return `ERC4626ExceededMaxRedeem`\");\n\n        assert!(err.reverted_with(Erc4626::ERC4626ExceededMaxRedeem {\n            owner: alice.address(),\n            shares: shares + uint!(1_U256),\n            max: shares,\n        }));\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc4626","tests","mock","erc20.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.21+commit.d9974bed\n    #[sol(rpc, bytecode=\"608060405234801562000010575f80fd5b506040518060400160405280600981526020017f45524332304d6f636b00000000000000000000000000000000000000000000008152506040518060400160405280600381526020017f4d544b000000000000000000000000000000000000000000000000000000000081525081600390816200008e91906200030d565b508060049081620000a091906200030d565b505050620003f1565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806200012557607f821691505b6020821081036200013b576200013a620000e0565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026200019f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000162565b620001ab868362000162565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f620001f5620001ef620001e984620001c3565b620001cc565b620001c3565b9050919050565b5f819050919050565b6200021083620001d5565b620002286200021f82620001fc565b8484546200016e565b825550505050565b5f90565b6200023e62000230565b6200024b81848462000205565b505050565b5b818110156200027257620002665f8262000234565b60018101905062000251565b5050565b601f821115620002c1576200028b8162000141565b620002968462000153565b81016020851015620002a6578190505b620002be620002b58562000153565b83018262000250565b50505b505050565b5f82821c905092915050565b5f620002e35f1984600802620002c6565b1980831691505092915050565b5f620002fd8383620002d2565b9150826002028217905092915050565b6200031882620000a9565b67ffffffffffffffff811115620003345762000333620000b3565b5b6200034082546200010d565b6200034d82828562000276565b5f60209050601f83116001811462000383575f84156200036e578287015190505b6200037a8582620002f0565b865550620003e9565b601f198416620003938662000141565b5f5b82811015620003bc5784890151825560018201915060208501945060208101905062000395565b86831015620003dc5784890151620003d8601f891682620002d2565b8355505b6001600288020188555050505b505050505050565b610f4580620003ff5f395ff3fe608060405234801561000f575f80fd5b50600436106100a7575f3560e01c806340c10f191161006f57806340c10f191461016557806370a08231146101815780638483acfe146101b157806395d89b41146101cd578063a9059cbb146101eb578063dd62ed3e1461021b576100a7565b806306fdde03146100ab578063095ea7b3146100c957806318160ddd146100f957806323b872dd14610117578063313ce56714610147575b5f80fd5b6100b361024b565b6040516100c09190610bbe565b60405180910390f35b6100e360048036038101906100de9190610c6f565b6102db565b6040516100f09190610cc7565b60405180910390f35b6101016102ee565b60405161010e9190610cef565b60405180910390f35b610131600480360381019061012c9190610d08565b6102f7565b60405161013e9190610cc7565b60405180910390f35b61014f61030c565b60405161015c9190610d73565b60405180910390f35b61017f600480360381019061017a9190610c6f565b610314565b005b61019b60048036038101906101969190610d8c565b610322565b6040516101a89190610cef565b60405180910390f35b6101cb60048036038101906101c69190610d08565b610333565b005b6101d5610343565b6040516101e29190610bbe565b60405180910390f35b61020560048036038101906102009190610c6f565b6103d3565b6040516102129190610cc7565b60405180910390f35b61023560048036038101906102309190610db7565b6103e6565b6040516102429190610cef565b60405180910390f35b60606003805461025a90610e22565b80601f016020809104026020016040519081016040528092919081815260200182805461028690610e22565b80156102d15780601f106102a8576101008083540402835291602001916102d1565b820191905f5260205f20905b8154815290600101906020018083116102b457829003601f168201915b5050505050905090565b5f6102e683836103f9565b905092915050565b5f600254905090565b5f61030384848461041b565b90509392505050565b5f6012905090565b61031e8282610449565b5050565b5f61032c826104c8565b9050919050565b61033e83838361050d565b505050565b60606004805461035290610e22565b80601f016020809104026020016040519081016040528092919081815260200182805461037e90610e22565b80156103c95780601f106103a0576101008083540402835291602001916103c9565b820191905f5260205f20905b8154815290600101906020018083116103ac57829003601f168201915b5050505050905090565b5f6103de838361051f565b905092915050565b5f6103f18383610541565b905092915050565b5f806104036105c3565b905061041081858561050d565b600191505092915050565b5f806104256105c3565b90506104328582856105ca565b61043d85858561065c565b60019150509392505050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036104b9575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016104b09190610e61565b60405180910390fd5b6104c45f838361074c565b5050565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b61051a8383836001610965565b505050565b5f806105296105c3565b905061053681858561065c565b600191505092915050565b5f60015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f33905090565b5f6105d584846103e6565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146106565781811015610647578281836040517ffb8f41b200000000000000000000000000000000000000000000000000000000815260040161063e93929190610e7a565b60405180910390fd5b61065584848484035f610965565b5b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036106cc575f6040517f96c6fd1e0000000000000000000000000000000000000000000000000000000081526004016106c39190610e61565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361073c575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016107339190610e61565b60405180910390fd5b61074783838361074c565b505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361079c578060025f8282546107909190610edc565b9250508190555061086a565b5f805f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905081811015610825578381836040517fe450d38c00000000000000000000000000000000000000000000000000000000815260040161081c93929190610e7a565b60405180910390fd5b8181035f808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036108b1578060025f82825403925050819055506108fb565b805f808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516109589190610cef565b60405180910390a3505050565b5f73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16036109d5575f6040517fe602df050000000000000000000000000000000000000000000000000000000081526004016109cc9190610e61565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610a45575f6040517f94280d62000000000000000000000000000000000000000000000000000000008152600401610a3c9190610e61565b60405180910390fd5b8160015f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055508015610b2e578273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92584604051610b259190610cef565b60405180910390a35b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015610b6b578082015181840152602081019050610b50565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610b9082610b34565b610b9a8185610b3e565b9350610baa818560208601610b4e565b610bb381610b76565b840191505092915050565b5f6020820190508181035f830152610bd68184610b86565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610c0b82610be2565b9050919050565b610c1b81610c01565b8114610c25575f80fd5b50565b5f81359050610c3681610c12565b92915050565b5f819050919050565b610c4e81610c3c565b8114610c58575f80fd5b50565b5f81359050610c6981610c45565b92915050565b5f8060408385031215610c8557610c84610bde565b5b5f610c9285828601610c28565b9250506020610ca385828601610c5b565b9150509250929050565b5f8115159050919050565b610cc181610cad565b82525050565b5f602082019050610cda5f830184610cb8565b92915050565b610ce981610c3c565b82525050565b5f602082019050610d025f830184610ce0565b92915050565b5f805f60608486031215610d1f57610d1e610bde565b5b5f610d2c86828701610c28565b9350506020610d3d86828701610c28565b9250506040610d4e86828701610c5b565b9150509250925092565b5f60ff82169050919050565b610d6d81610d58565b82525050565b5f602082019050610d865f830184610d64565b92915050565b5f60208284031215610da157610da0610bde565b5b5f610dae84828501610c28565b91505092915050565b5f8060408385031215610dcd57610dcc610bde565b5b5f610dda85828601610c28565b9250506020610deb85828601610c28565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610e3957607f821691505b602082108103610e4c57610e4b610df5565b5b50919050565b610e5b81610c01565b82525050565b5f602082019050610e745f830184610e52565b92915050565b5f606082019050610e8d5f830186610e52565b610e9a6020830185610ce0565b610ea76040830184610ce0565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610ee682610c3c565b9150610ef183610c3c565b9250828201905080821115610f0957610f08610eaf565b5b9291505056fea2646970667358221220383e898342e74543d1bfb6186eff00b4ae7a39d4ecde6190742c5e9f2a7a2e9364736f6c63430008150033\")]\n    // SPDX-License-Identifier: MIT\n    contract ERC20Mock is ERC20 {\n        constructor() ERC20(\"ERC20Mock\", \"MTK\") {}\n\n        function approve(address spender, uint256 value) public override returns (bool) {\n            return super.approve(spender, value);\n        }\n\n        // WARNING: This code is for testing purposes only! Do not use in production.\n        function regular_approve(address owner, address spender, uint256 amount) public {\n            super._approve(owner, spender, amount);\n        }\n\n        function balanceOf(address account) public override view returns (uint256) {\n            return super.balanceOf(account);\n        }\n\n        function mint(address account, uint256 value) public {\n            super._mint(account, value);\n        }\n\n        function transfer(address to, uint256 amount) public override returns (bool) {\n            return super.transfer(to, amount);\n        }\n\n        function transferFrom(address from, address to, uint256 value) public override returns (bool) {\n            return super.transferFrom(from, to, value);\n        }\n\n        function allowance(address owner, address spender) public view override returns (uint256) {\n            return super.allowance(owner, spender);\n        }\n    }\n}\n\npub async fn deploy(wallet: \u0026Wallet) -\u003e eyre::Result\u003cAddress\u003e {\n    // Deploy the contract.\n    let contract = ERC20Mock::deploy(wallet).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc4626","tests","mock","erc20_failing_transfer.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.24+commit.e11b9ed9\n    #[sol(rpc, bytecode=\"608060405234801562000010575f80fd5b506040518060400160405280601881526020017f45524332304661696c696e675472616e736665724d6f636b00000000000000008152506040518060400160405280600381526020017f52464d000000000000000000000000000000000000000000000000000000000081525081600390816200008e91906200030d565b508060049081620000a091906200030d565b505050620003f1565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806200012557607f821691505b6020821081036200013b576200013a620000e0565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026200019f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000162565b620001ab868362000162565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f620001f5620001ef620001e984620001c3565b620001cc565b620001c3565b9050919050565b5f819050919050565b6200021083620001d5565b620002286200021f82620001fc565b8484546200016e565b825550505050565b5f90565b6200023e62000230565b6200024b81848462000205565b505050565b5b818110156200027257620002665f8262000234565b60018101905062000251565b5050565b601f821115620002c1576200028b8162000141565b620002968462000153565b81016020851015620002a6578190505b620002be620002b58562000153565b83018262000250565b50505b505050565b5f82821c905092915050565b5f620002e35f1984600802620002c6565b1980831691505092915050565b5f620002fd8383620002d2565b9150826002028217905092915050565b6200031882620000a9565b67ffffffffffffffff811115620003345762000333620000b3565b5b6200034082546200010d565b6200034d82828562000276565b5f60209050601f83116001811462000383575f84156200036e578287015190505b6200037a8582620002f0565b865550620003e9565b601f198416620003938662000141565b5f5b82811015620003bc5784890151825560018201915060208501945060208101905062000395565b86831015620003dc5784890151620003d8601f891682620002d2565b8355505b6001600288020188555050505b505050505050565b610f1780620003ff5f395ff3fe608060405234801561000f575f80fd5b50600436106100a7575f3560e01c806340c10f191161006f57806340c10f191461016557806370a08231146101815780638483acfe146101b157806395d89b41146101cd578063a9059cbb146101eb578063dd62ed3e1461021b576100a7565b806306fdde03146100ab578063095ea7b3146100c957806318160ddd146100f957806323b872dd14610117578063313ce56714610147575b5f80fd5b6100b361024b565b6040516100c09190610b90565b60405180910390f35b6100e360048036038101906100de9190610c41565b6102db565b6040516100f09190610c99565b60405180910390f35b6101016102ee565b60405161010e9190610cc1565b60405180910390f35b610131600480360381019061012c9190610cda565b6102f7565b60405161013e9190610c99565b60405180910390f35b61014f61030c565b60405161015c9190610d45565b60405180910390f35b61017f600480360381019061017a9190610c41565b610314565b005b61019b60048036038101906101969190610d5e565b610322565b6040516101a89190610cc1565b60405180910390f35b6101cb60048036038101906101c69190610cda565b610333565b005b6101d5610343565b6040516101e29190610b90565b60405180910390f35b61020560048036038101906102009190610c41565b6103d3565b6040516102129190610c99565b60405180910390f35b61023560048036038101906102309190610d89565b6103da565b6040516102429190610cc1565b60405180910390f35b60606003805461025a90610df4565b80601f016020809104026020016040519081016040528092919081815260200182805461028690610df4565b80156102d15780601f106102a8576101008083540402835291602001916102d1565b820191905f5260205f20905b8154815290600101906020018083116102b457829003601f168201915b5050505050905090565b5f6102e683836103ed565b905092915050565b5f600254905090565b5f61030384848461040f565b90509392505050565b5f6012905090565b61031e828261043d565b5050565b5f61032c826104bc565b9050919050565b61033e838383610501565b505050565b60606004805461035290610df4565b80601f016020809104026020016040519081016040528092919081815260200182805461037e90610df4565b80156103c95780601f106103a0576101008083540402835291602001916103c9565b820191905f5260205f20905b8154815290600101906020018083116103ac57829003601f168201915b5050505050905090565b5f92915050565b5f6103e58383610513565b905092915050565b5f806103f7610595565b9050610404818585610501565b600191505092915050565b5f80610419610595565b905061042685828561059c565b61043185858561062e565b60019150509392505050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036104ad575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016104a49190610e33565b60405180910390fd5b6104b85f838361071e565b5050565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b61050e8383836001610937565b505050565b5f60015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f33905090565b5f6105a784846103da565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146106285781811015610619578281836040517ffb8f41b200000000000000000000000000000000000000000000000000000000815260040161061093929190610e4c565b60405180910390fd5b61062784848484035f610937565b5b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361069e575f6040517f96c6fd1e0000000000000000000000000000000000000000000000000000000081526004016106959190610e33565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361070e575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016107059190610e33565b60405180910390fd5b61071983838361071e565b505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361076e578060025f8282546107629190610eae565b9250508190555061083c565b5f805f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050818110156107f7578381836040517fe450d38c0000000000000000000000000000000000000000000000000000000081526004016107ee93929190610e4c565b60405180910390fd5b8181035f808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610883578060025f82825403925050819055506108cd565b805f808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8360405161092a9190610cc1565b60405180910390a3505050565b5f73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16036109a7575f6040517fe602df0500000000000000000000000000000000000000000000000000000000815260040161099e9190610e33565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610a17575f6040517f94280d62000000000000000000000000000000000000000000000000000000008152600401610a0e9190610e33565b60405180910390fd5b8160015f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055508015610b00578273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92584604051610af79190610cc1565b60405180910390a35b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015610b3d578082015181840152602081019050610b22565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610b6282610b06565b610b6c8185610b10565b9350610b7c818560208601610b20565b610b8581610b48565b840191505092915050565b5f6020820190508181035f830152610ba88184610b58565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610bdd82610bb4565b9050919050565b610bed81610bd3565b8114610bf7575f80fd5b50565b5f81359050610c0881610be4565b92915050565b5f819050919050565b610c2081610c0e565b8114610c2a575f80fd5b50565b5f81359050610c3b81610c17565b92915050565b5f8060408385031215610c5757610c56610bb0565b5b5f610c6485828601610bfa565b9250506020610c7585828601610c2d565b9150509250929050565b5f8115159050919050565b610c9381610c7f565b82525050565b5f602082019050610cac5f830184610c8a565b92915050565b610cbb81610c0e565b82525050565b5f602082019050610cd45f830184610cb2565b92915050565b5f805f60608486031215610cf157610cf0610bb0565b5b5f610cfe86828701610bfa565b9350506020610d0f86828701610bfa565b9250506040610d2086828701610c2d565b9150509250925092565b5f60ff82169050919050565b610d3f81610d2a565b82525050565b5f602082019050610d585f830184610d36565b92915050565b5f60208284031215610d7357610d72610bb0565b5b5f610d8084828501610bfa565b91505092915050565b5f8060408385031215610d9f57610d9e610bb0565b5b5f610dac85828601610bfa565b9250506020610dbd85828601610bfa565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610e0b57607f821691505b602082108103610e1e57610e1d610dc7565b5b50919050565b610e2d81610bd3565b82525050565b5f602082019050610e465f830184610e24565b92915050565b5f606082019050610e5f5f830186610e24565b610e6c6020830185610cb2565b610e796040830184610cb2565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610eb882610c0e565b9150610ec383610c0e565b9250828201905080821115610edb57610eda610e81565b5b9291505056fea264697066735822122067beaed7a6a24d711579cadb98788abdcb4406e94f02fba0b0b2e7a7a5e78eee64736f6c63430008180033\")]\n    // SPDX-License-Identifier: MIT\n    contract ERC20FailingTransferMock is ERC20 {\n        constructor() ERC20(\"ERC20FailingTransferMock\", \"RFM\") {}\n\n        function approve(address spender, uint256 value)\n            public\n            override\n            returns (bool)\n        {\n            return super.approve(spender, value);\n        }\n\n        // WARNING: This code is for testing purposes only! Do not use in production.\n        function regular_approve(\n            address owner,\n            address spender,\n            uint256 amount\n        ) public {\n            super._approve(owner, spender, amount);\n        }\n\n        function transfer(address, uint256) public override returns (bool) {\n            return false;\n        }\n\n        function transferFrom(\n            address from,\n            address to,\n            uint256 value\n        ) public override returns (bool) {\n            return super.transferFrom(from, to, value);\n        }\n\n        function balanceOf(address account) public view override returns (uint256) {\n            return super.balanceOf(account);\n        }\n\n        function mint(address account, uint256 value) public {\n            super._mint(account, value);\n        }\n\n        function allowance(address owner, address spender)\n            public\n            view\n            override\n            returns (uint256)\n        {\n            return super.allowance(owner, spender);\n        }\n    }\n}\n\npub async fn deploy(wallet: \u0026Wallet) -\u003e eyre::Result\u003cAddress\u003e {\n    // Deploy the contract.\n    let contract = ERC20FailingTransferMock::deploy(wallet).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc4626","tests","mock","mod.rs"],"content":"pub mod erc20;\npub mod erc20_failing_transfer;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc6909","src","lib.rs"],"content":"#![no_std]\n\nuse stylus_sdk::{entrypoint, storage};\nuse alloy_primitives::{Address, U256};\nuse openzeppelin_stylus::token::erc6909::{\n    Erc6909Supply, IErc6909, IErc6909Supply, Error,\n};\n\n#[entrypoint]\n#[storage]\npub struct MultiToken {\n    token: Erc6909Supply,\n}\n\nimpl IErc6909 for MultiToken {\n    fn balance_of(\u0026self, owner: Address, id: U256) -\u003e U256 {\n        self.token.base.balance_of(owner, id)\n    }\n    fn allowance(\u0026self, owner: Address, spender: Address, id: U256) -\u003e U256 {\n        self.token.base.allowance(owner, spender, id)\n    }\n    fn is_operator(\u0026self, owner: Address, operator: Address) -\u003e bool {\n        self.token.base.is_operator(owner, operator)\n    }\n    fn approve(\n        \u0026mut self,\n        caller: Address,\n        spender: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.token.base.approve(caller, spender, id, amount)\n    }\n    fn set_operator(\n        \u0026mut self,\n        caller: Address,\n        operator: Address,\n        approved: bool,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.token.base.set_operator(caller, operator, approved)\n    }\n    fn transfer(\n        \u0026mut self,\n        caller: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.token.base.transfer(caller, to, id, amount)\n    }\n    fn transfer_from(\n        \u0026mut self,\n        caller: Address,\n        from: Address,\n        to: Address,\n        id: U256,\n        amount: U256,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.token.base.transfer_from(caller, from, to, id, amount)\n    }\n}\n\nimpl IErc6909Supply for MultiToken {\n    fn total_supply(\u0026self, id: U256) -\u003e U256 {\n        self.token.total_supply(id)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc6909","tests","erc6909.rs"],"content":"use motsu::prelude::*;\nuse alloy_primitives::{Address, U256};\nuse openzeppelin_stylus::token::erc6909::{Erc6909Supply, Error};\n\n#[motsu::test]\nfn mint_and_transfer(env: TestEnv) {\n    let mut tok = Erc6909Supply::default();\n    let alice = Address::repeat_byte(0xAA);\n    let bob   = Address::repeat_byte(0xBB);\n    let id = U256::from(1);\n\n    // mint\n    tok.mint(alice, id, 100u8.into()).unwrap();\n    assert_eq!(tok.base.balance_of(alice, id), 100u8.into());\n    assert_eq!(tok.total_supply(id),            100u8.into());\n\n    // transfer 40 to Bob\n    tok.base\n        .transfer_from(alice, alice, bob, id, 40u8.into())\n        .unwrap();\n    assert_eq!(tok.base.balance_of(alice, id), 60u8.into());\n    assert_eq!(tok.base.balance_of(bob,   id), 40u8.into());\n    assert_eq!(tok.total_supply(id),            100u8.into());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse openzeppelin_stylus::{\n    token::erc721::{\n        self,\n        extensions::{\n            enumerable, Erc721Enumerable, IErc721Burnable, IErc721Enumerable,\n        },\n        Erc721, IErc721,\n    },\n    utils::introspection::erc165::IErc165,\n};\nuse stylus_sdk::{\n    abi::Bytes,\n    alloy_primitives::{Address, FixedBytes, U256},\n    prelude::*,\n};\n\n#[derive(SolidityError, Debug)]\nenum Error {\n    OutOfBoundsIndex(enumerable::ERC721OutOfBoundsIndex),\n    EnumerableForbiddenBatchMint(\n        enumerable::ERC721EnumerableForbiddenBatchMint,\n    ),\n    InvalidOwner(erc721::ERC721InvalidOwner),\n    NonexistentToken(erc721::ERC721NonexistentToken),\n    IncorrectOwner(erc721::ERC721IncorrectOwner),\n    InvalidSender(erc721::ERC721InvalidSender),\n    InvalidReceiver(erc721::ERC721InvalidReceiver),\n    InvalidReceiverWithReason(erc721::InvalidReceiverWithReason),\n    InsufficientApproval(erc721::ERC721InsufficientApproval),\n    InvalidApprover(erc721::ERC721InvalidApprover),\n    InvalidOperator(erc721::ERC721InvalidOperator),\n}\n\nimpl From\u003cenumerable::Error\u003e for Error {\n    fn from(value: enumerable::Error) -\u003e Self {\n        match value {\n            enumerable::Error::OutOfBoundsIndex(e) =\u003e {\n                Error::OutOfBoundsIndex(e)\n            }\n            enumerable::Error::EnumerableForbiddenBatchMint(e) =\u003e {\n                Error::EnumerableForbiddenBatchMint(e)\n            }\n        }\n    }\n}\n\nimpl From\u003cerc721::Error\u003e for Error {\n    fn from(value: erc721::Error) -\u003e Self {\n        match value {\n            erc721::Error::InvalidOwner(e) =\u003e Error::InvalidOwner(e),\n            erc721::Error::NonexistentToken(e) =\u003e Error::NonexistentToken(e),\n            erc721::Error::IncorrectOwner(e) =\u003e Error::IncorrectOwner(e),\n            erc721::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc721::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc721::Error::InvalidReceiverWithReason(e) =\u003e {\n                Error::InvalidReceiverWithReason(e)\n            }\n            erc721::Error::InsufficientApproval(e) =\u003e {\n                Error::InsufficientApproval(e)\n            }\n            erc721::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n            erc721::Error::InvalidOperator(e) =\u003e Error::InvalidOperator(e),\n        }\n    }\n}\n\n#[entrypoint]\n#[storage]\nstruct Erc721Example {\n    erc721: Erc721,\n    enumerable: Erc721Enumerable,\n}\n\n#[public]\n#[implements(IErc721\u003cError = Error\u003e, IErc721Burnable\u003cError = Error\u003e, IErc721Enumerable\u003cError = Error\u003e, IErc165)]\nimpl Erc721Example {\n    fn mint(\u0026mut self, to: Address, token_id: U256) -\u003e Result\u003c(), Error\u003e {\n        self.erc721._mint(to, token_id)?;\n\n        // Update the extension's state.\n        self.enumerable._add_token_to_all_tokens_enumeration(token_id);\n        self.enumerable._add_token_to_owner_enumeration(\n            to,\n            token_id,\n            \u0026self.erc721,\n        )?;\n\n        Ok(())\n    }\n\n    fn safe_mint(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self.erc721._safe_mint(to, token_id, \u0026data)?;\n\n        // Update the extension's state.\n        self.enumerable._add_token_to_all_tokens_enumeration(token_id);\n        self.enumerable._add_token_to_owner_enumeration(\n            to,\n            token_id,\n            \u0026self.erc721,\n        )?;\n\n        Ok(())\n    }\n}\n\n#[public]\nimpl IErc721 for Erc721Example {\n    type Error = Error;\n\n    fn balance_of(\u0026self, owner: Address) -\u003e Result\u003cU256, Self::Error\u003e {\n        Ok(self.erc721.balance_of(owner)?)\n    }\n\n    fn owner_of(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        Ok(self.erc721.owner_of(token_id)?)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        // Retrieve the previous owner.\n        let previous_owner = self.erc721.owner_of(token_id)?;\n\n        self.erc721.safe_transfer_from(from, to, token_id)?;\n\n        // Update the extension's state.\n        self.enumerable._remove_token_from_owner_enumeration(\n            previous_owner,\n            token_id,\n            \u0026self.erc721,\n        )?;\n        self.enumerable._add_token_to_owner_enumeration(\n            to,\n            token_id,\n            \u0026self.erc721,\n        )?;\n\n        Ok(())\n    }\n\n    #[selector(name = \"safeTransferFrom\")]\n    fn safe_transfer_from_with_data(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        // Retrieve the previous owner.\n        let previous_owner = self.erc721.owner_of(token_id)?;\n\n        self.erc721.safe_transfer_from_with_data(from, to, token_id, data)?;\n\n        // Update the extension's state.\n        self.enumerable._remove_token_from_owner_enumeration(\n            previous_owner,\n            token_id,\n            \u0026self.erc721,\n        )?;\n        self.enumerable._add_token_to_owner_enumeration(\n            to,\n            token_id,\n            \u0026self.erc721,\n        )?;\n\n        Ok(())\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        // Retrieve the previous owner.\n        let previous_owner = self.erc721.owner_of(token_id)?;\n\n        self.erc721.transfer_from(from, to, token_id)?;\n\n        // Update the extension's state.\n        self.enumerable._remove_token_from_owner_enumeration(\n            previous_owner,\n            token_id,\n            \u0026self.erc721,\n        )?;\n        self.enumerable._add_token_to_owner_enumeration(\n            to,\n            token_id,\n            \u0026self.erc721,\n        )?;\n\n        Ok(())\n    }\n\n    fn approve(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.erc721.approve(to, token_id)?)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        to: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.erc721.set_approval_for_all(to, approved)?)\n    }\n\n    fn get_approved(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        Ok(self.erc721.get_approved(token_id)?)\n    }\n\n    fn is_approved_for_all(\u0026self, owner: Address, operator: Address) -\u003e bool {\n        self.erc721.is_approved_for_all(owner, operator)\n    }\n}\n\n#[public]\nimpl IErc721Burnable for Erc721Example {\n    type Error = Error;\n\n    fn burn(\u0026mut self, token_id: U256) -\u003e Result\u003c(), Self::Error\u003e {\n        // Retrieve the owner.\n        let owner = self.erc721.owner_of(token_id)?;\n\n        self.erc721.burn(token_id)?;\n\n        // Update the extension's state.\n        self.enumerable._remove_token_from_owner_enumeration(\n            owner,\n            token_id,\n            \u0026self.erc721,\n        )?;\n        self.enumerable._remove_token_from_all_tokens_enumeration(token_id);\n\n        Ok(())\n    }\n}\n\n#[public]\nimpl IErc721Enumerable for Erc721Example {\n    type Error = Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.enumerable.total_supply()\n    }\n\n    fn token_by_index(\u0026self, index: U256) -\u003e Result\u003cU256, Self::Error\u003e {\n        Ok(self.enumerable.token_by_index(index)?)\n    }\n\n    fn token_of_owner_by_index(\n        \u0026self,\n        owner: Address,\n        index: U256,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        Ok(self.enumerable.token_of_owner_by_index(owner, index)?)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc721Example {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        self.erc721.supports_interface(interface_id)\n            || self.enumerable.supports_interface(interface_id)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc721_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n   contract Erc721 {\n        function approve(address to, uint256 tokenId) external;\n        #[derive(Debug)]\n        function balanceOf(address owner) external view returns (uint256 balance);\n        #[derive(Debug)]\n        function getApproved(uint256 tokenId) external view returns (address approved);\n        #[derive(Debug)]\n        function isApprovedForAll(address owner, address operator) external view returns (bool approved);\n        #[derive(Debug)]\n        function ownerOf(uint256 tokenId) external view returns (address ownerOf);\n        function safeTransferFrom(address from, address to, uint256 tokenId) external;\n        function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n        function setApprovalForAll(address operator, bool approved) external;\n        function totalSupply() external view returns (uint256 totalSupply);\n        function transferFrom(address from, address to, uint256 tokenId) external;\n        function safeMint(address to, uint256 tokenId, bytes calldata data) external;\n        function mint(address to, uint256 tokenId) external;\n        function burn(uint256 tokenId) external;\n\n        #[derive(Debug)]\n        function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n        #[derive(Debug)]\n        function tokenByIndex(uint256 index) external view returns (uint256 tokenId);\n\n        function supportsInterface(bytes4 interface_id) external view returns (bool supportsInterface);\n\n        error Error(string message);\n        error Panic(uint256 code);\n\n        error InvalidReceiverWithReason(string message);\n        error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n        error ERC721InsufficientApproval(address operator, uint256 tokenId);\n        error ERC721InvalidApprover(address approver);\n        error ERC721InvalidOperator(address operator);\n        error ERC721InvalidOwner(address owner);\n        error ERC721InvalidReceiver(address receiver);\n        error ERC721InvalidSender(address sender);\n        error ERC721NonexistentToken(uint256 tokenId);\n        error ERC721OutOfBoundsIndex(address owner, uint256 index);\n        error ERC721EnumerableForbiddenBatchMint();\n\n        #[derive(Debug, PartialEq)]\n        event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n        #[derive(Debug, PartialEq)]\n        event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n        #[derive(Debug, PartialEq)]\n        event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n   }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721","tests","erc721.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::Erc721;\nuse alloy::{\n    primitives::{fixed_bytes, uint, Address, Bytes, U256},\n    sol_types::SolError,\n};\nuse e2e::{receipt, send, watch, Account, EventExt, PanicCode, Revert};\nuse mock::{receiver, receiver::ERC721ReceiverMock};\n\nmod abi;\nmod mock;\n\nfn random_token_id() -\u003e U256 {\n    let num: u32 = rand::random();\n    U256::from(num)\n}\n\ntrait EncodeAsStr {\n    fn encode_as_str(\u0026self) -\u003e String;\n}\n\nimpl\u003cT: SolError\u003e EncodeAsStr for T {\n    fn encode_as_str(\u0026self) -\u003e String {\n        let expected_error = self.abi_encode();\n        String::from_utf8_lossy(\u0026expected_error).to_string()\n    }\n}\n\n// ============================================================================\n// Integration Tests: ERC-721 Token\n// ============================================================================\n\n#[e2e::test]\nasync fn error_when_checking_balance_of_invalid_owner(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n    let invalid_owner = Address::ZERO;\n\n    let err = contract\n        .balanceOf(invalid_owner)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721InvalidOwner`\");\n    assert!(\n        err.reverted_with(Erc721::ERC721InvalidOwner { owner: invalid_owner })\n    );\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn balance_of_zero_balance(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let Erc721::balanceOfReturn { balance } =\n        contract.balanceOf(alice.address()).call().await?;\n    assert_eq!(uint!(0_U256), balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_checking_owner_of_nonexistent_token(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n    let token_id = random_token_id();\n\n    let err = contract\n        .ownerOf(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mints(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n    let receipt = receipt!(contract.mint(alice_addr, token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: Address::ZERO,\n        to: alice_addr,\n        tokenId: token_id\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf: owner_of } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, owner_of);\n\n    let Erc721::balanceOfReturn { balance } =\n        contract.balanceOf(alice_addr).call().await?;\n    assert_eq!(uint!(1_U256), balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_minting_token_id_twice(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let err = send!(contract.mint(alice_addr, token_id))\n        .expect_err(\"should not mint a token id twice\");\n    assert!(err\n        .reverted_with(Erc721::ERC721InvalidSender { sender: Address::ZERO }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_minting_token_to_invalid_receiver(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n    let invalid_receiver = Address::ZERO;\n\n    let err = send!(contract.mint(invalid_receiver, token_id))\n        .expect_err(\"should not mint a token for invalid receiver\");\n    assert!(err.reverted_with(Erc721::ERC721InvalidReceiver {\n        receiver: invalid_receiver\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfers_from(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_bob_balance } =\n        contract.balanceOf(bob_addr).call().await?;\n\n    let receipt =\n        receipt!(contract.transferFrom(alice_addr, bob_addr, token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(bob_addr, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: bob_balance } =\n        contract.balanceOf(bob_addr).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_bob_balance + one, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfers_from_approved_token(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc721::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    watch!(contract_alice.mint(alice_addr, token_id))?;\n    watch!(contract_alice.approve(bob_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let receipt =\n        receipt!(contract_bob.transferFrom(alice_addr, bob_addr, token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract_alice.ownerOf(token_id).call().await?;\n    assert_eq!(bob_addr, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_bob_balance + one, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfers_from_approved_for_all(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc721::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    watch!(contract_alice.mint(alice_addr, token_id))?;\n    watch!(contract_alice.setApprovalForAll(bob_addr, true))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let receipt =\n        receipt!(contract_bob.transferFrom(alice_addr, bob_addr, token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract_alice.ownerOf(token_id).call().await?;\n    assert_eq!(bob_addr, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_bob_balance + one, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_transfer_to_invalid_receiver(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let invalid_receiver = Address::ZERO;\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let err =\n        send!(contract.transferFrom(alice_addr, invalid_receiver, token_id))\n            .expect_err(\"should not transfer the token to invalid receiver\");\n\n    assert!(err.reverted_with(Erc721::ERC721InvalidReceiver {\n        receiver: invalid_receiver\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, ownerOf);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_transfer_from_incorrect_owner(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let dave_addr = dave.address();\n\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let err = send!(contract.transferFrom(dave_addr, bob_addr, token_id))\n        .expect_err(\"should not transfer the token from incorrect owner\");\n\n    assert!(err.reverted_with(Erc721::ERC721IncorrectOwner {\n        sender: dave_addr,\n        owner: alice_addr,\n        tokenId: token_id\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, ownerOf);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_transfer_with_insufficient_approval(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let contract = Erc721::new(contract_addr, \u0026bob.wallet);\n    let err = send!(contract.transferFrom(alice_addr, bob_addr, token_id))\n        .expect_err(\"should not transfer unapproved token\");\n\n    assert!(err.reverted_with(Erc721::ERC721InsufficientApproval {\n        operator: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, ownerOf);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_transfer_nonexistent_token(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n\n    let err = send!(contract.transferFrom(alice_addr, bob.address(), token_id))\n        .expect_err(\"should not transfer a non-existent token\");\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    let err = contract\n        .ownerOf(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfers_from(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_bob_balance } =\n        contract.balanceOf(bob_addr).call().await?;\n\n    let receipt =\n        receipt!(contract.safeTransferFrom_0(alice_addr, bob_addr, token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(bob_addr, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: bob_balance } =\n        contract.balanceOf(bob_addr).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_bob_balance + one, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfers_to_receiver_contract(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address =\n        receiver::deploy(\u0026alice.wallet, ERC721ReceiverMock::RevertType::None)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_receiver_balance } =\n        contract.balanceOf(receiver_address).call().await?;\n\n    let receipt = receipt!(contract.safeTransferFrom_0(\n        alice_addr,\n        receiver_address,\n        token_id\n    ))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: receiver_address,\n        tokenId: token_id,\n    }));\n\n    assert!(receipt.emits(ERC721ReceiverMock::Received {\n        operator: alice_addr,\n        from: alice_addr,\n        tokenId: token_id,\n        data: fixed_bytes!(\"\").into(),\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(receiver_address, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: receiver_balance } =\n        contract.balanceOf(receiver_address).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_receiver_balance + one, receiver_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfers_from_approved_token(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc721::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    watch!(contract_alice.mint(alice_addr, token_id))?;\n    watch!(contract_alice.approve(bob_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let receipt = receipt!(\n        contract_bob.safeTransferFrom_0(alice_addr, bob_addr, token_id)\n    )?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract_alice.ownerOf(token_id).call().await?;\n    assert_eq!(bob_addr, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_bob_balance + one, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfers_from_approved_for_all(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc721::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    watch!(contract_alice.mint(alice_addr, token_id))?;\n    watch!(contract_alice.setApprovalForAll(bob_addr, true))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let receipt = receipt!(\n        contract_bob.safeTransferFrom_0(alice_addr, bob_addr, token_id)\n    )?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract_alice.ownerOf(token_id).call().await?;\n    assert_eq!(bob_addr, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_bob_balance + one, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_safe_transfer_to_invalid_receiver(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let invalid_receiver = Address::ZERO;\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let err = send!(contract.safeTransferFrom_0(\n        alice_addr,\n        invalid_receiver,\n        token_id\n    ))\n    .expect_err(\"should not transfer the token to invalid receiver\");\n    assert!(err.reverted_with(Erc721::ERC721InvalidReceiver {\n        receiver: invalid_receiver\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, ownerOf);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_safe_transfer_from_incorrect_owner(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let dave_addr = dave.address();\n\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let err = send!(contract.safeTransferFrom_0(dave_addr, bob_addr, token_id))\n        .expect_err(\"should not transfer the token from incorrect owner\");\n\n    assert!(err.reverted_with(Erc721::ERC721IncorrectOwner {\n        sender: dave_addr,\n        owner: alice_addr,\n        tokenId: token_id\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, ownerOf);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_safe_transfer_with_insufficient_approval(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let contract = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let err =\n        send!(contract.safeTransferFrom_0(alice_addr, bob_addr, token_id))\n            .expect_err(\"should not transfer unapproved token\");\n\n    assert!(err.reverted_with(Erc721::ERC721InsufficientApproval {\n        operator: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, ownerOf);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_safe_transfer_nonexistent_token(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n\n    let err =\n        send!(contract.safeTransferFrom_0(alice_addr, bob.address(), token_id))\n            .expect_err(\"should not transfer a non-existent token\");\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    let err = contract\n        .ownerOf(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfers_from_with_data(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_bob_balance } =\n        contract.balanceOf(bob_addr).call().await?;\n\n    let receipt = receipt!(contract.safeTransferFrom_1(\n        alice_addr,\n        bob_addr,\n        token_id,\n        fixed_bytes!(\"deadbeef\").into()\n    ))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(bob_addr, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: bob_balance } =\n        contract.balanceOf(bob_addr).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_bob_balance + one, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfers_with_data_to_receiver_contract(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address =\n        receiver::deploy(\u0026alice.wallet, ERC721ReceiverMock::RevertType::None)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n    let data: Bytes = fixed_bytes!(\"deadbeef\").into();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_receiver_balance } =\n        contract.balanceOf(receiver_address).call().await?;\n\n    let receipt = receipt!(contract.safeTransferFrom_1(\n        alice_addr,\n        receiver_address,\n        token_id,\n        data.clone()\n    ))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: receiver_address,\n        tokenId: token_id,\n    }));\n\n    assert!(receipt.emits(ERC721ReceiverMock::Received {\n        operator: alice_addr,\n        from: alice_addr,\n        tokenId: token_id,\n        data,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(receiver_address, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: receiver_balance } =\n        contract.balanceOf(receiver_address).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_receiver_balance + one, receiver_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfers_from_with_data_approved_token(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc721::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    watch!(contract_alice.mint(alice_addr, token_id))?;\n    watch!(contract_alice.approve(bob_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let receipt = receipt!(contract_bob.safeTransferFrom_1(\n        alice_addr,\n        bob_addr,\n        token_id,\n        fixed_bytes!(\"deadbeef\").into()\n    ))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract_alice.ownerOf(token_id).call().await?;\n    assert_eq!(bob_addr, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_bob_balance + one, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_transfers_from_with_data_approved_for_all(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc721::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    watch!(contract_alice.mint(alice_addr, token_id))?;\n    watch!(contract_alice.setApprovalForAll(bob_addr, true))?;\n\n    let Erc721::balanceOfReturn { balance: initial_alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: initial_bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let receipt = receipt!(contract_bob.safeTransferFrom_1(\n        alice_addr,\n        bob_addr,\n        token_id,\n        fixed_bytes!(\"deadbeef\").into()\n    ))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract_alice.ownerOf(token_id).call().await?;\n    assert_eq!(bob_addr, ownerOf);\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let Erc721::balanceOfReturn { balance: bob_balance } =\n        contract_bob.balanceOf(bob_addr).call().await?;\n\n    let one = uint!(1_U256);\n    assert_eq!(initial_alice_balance - one, alice_balance);\n    assert_eq!(initial_bob_balance + one, bob_balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_safe_transfer_with_data_to_invalid_receiver(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let invalid_receiver = Address::ZERO;\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let err = send!(contract.safeTransferFrom_1(\n        alice_addr,\n        invalid_receiver,\n        token_id,\n        fixed_bytes!(\"deadbeef\").into()\n    ))\n    .expect_err(\"should not transfer the token to invalid receiver\");\n    assert!(err.reverted_with(Erc721::ERC721InvalidReceiver {\n        receiver: invalid_receiver\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, ownerOf);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_safe_transfer_with_data_from_incorrect_owner(\n    alice: Account,\n    bob: Account,\n    dave: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let dave_addr = dave.address();\n\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let err = send!(contract.safeTransferFrom_1(\n        dave_addr,\n        bob_addr,\n        token_id,\n        fixed_bytes!(\"deadbeef\").into()\n    ))\n    .expect_err(\"should not transfer the token from incorrect owner\");\n\n    assert!(err.reverted_with(Erc721::ERC721IncorrectOwner {\n        sender: dave_addr,\n        owner: alice_addr,\n        tokenId: token_id\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, ownerOf);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_safe_transfer_with_data_with_insufficient_approval(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let contract = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let err = send!(contract.safeTransferFrom_1(\n        alice_addr,\n        bob_addr,\n        token_id,\n        fixed_bytes!(\"deadbeef\").into()\n    ))\n    .expect_err(\"should not transfer unapproved token\");\n\n    assert!(err.reverted_with(Erc721::ERC721InsufficientApproval {\n        operator: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, ownerOf);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_safe_transfer_with_data_nonexistent_token(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n\n    let err = send!(contract.safeTransferFrom_1(\n        alice_addr,\n        bob.address(),\n        token_id,\n        fixed_bytes!(\"deadbeef\").into()\n    ))\n    .expect_err(\"should not transfer a non-existent token\");\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    let err = contract\n        .ownerOf(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_reverts_with_reason(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC721ReceiverMock::RevertType::RevertWithMessage,\n    )\n    .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let err = send!(contract.safeTransferFrom_0(\n        alice_addr,\n        receiver_address,\n        token_id\n    ))\n    .expect_err(\"should not transfer when receiver errors with reason\");\n\n    let message =\n        Erc721::Error { message: \"ERC721ReceiverMock: reverting\".to_string() }\n            .encode_as_str();\n\n    assert!(err.reverted_with(Erc721::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_reverts_without_reason(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC721ReceiverMock::RevertType::RevertWithoutMessage,\n    )\n    .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let err = send!(contract.safeTransferFrom_0(\n        alice_addr,\n        receiver_address,\n        token_id\n    ))\n    .expect_err(\"should not transfer when receiver reverts\");\n\n    assert!(err.reverted_with(Erc721::ERC721InvalidReceiver {\n        receiver: receiver_address\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn errors_when_receiver_panics(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address =\n        receiver::deploy(\u0026alice.wallet, ERC721ReceiverMock::RevertType::Panic)\n            .await?;\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let err = send!(contract.safeTransferFrom_0(\n        alice_addr,\n        receiver_address,\n        token_id\n    ))\n    .expect_err(\"should not transfer when receiver panics\");\n\n    let message =\n        Erc721::Panic { code: U256::from(PanicCode::DivisionByZero as u8) }\n            .encode_as_str();\n    assert!(err.reverted_with(Erc721::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn approves(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let Erc721::getApprovedReturn { approved } =\n        contract.getApproved(token_id).call().await?;\n    assert_eq!(Address::ZERO, approved);\n\n    let receipt = receipt!(contract.approve(bob_addr, token_id))?;\n\n    assert!(receipt.emits(Erc721::Approval {\n        owner: alice_addr,\n        approved: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::getApprovedReturn { approved } =\n        contract.getApproved(token_id).call().await?;\n    assert_eq!(bob_addr, approved);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_approve_for_nonexistent_token(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    let err = send!(contract.approve(bob_addr, token_id))\n        .expect_err(\"should not approve for a non-existent token\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_approve_by_invalid_approver(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc721::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    watch!(contract_alice.mint(alice_addr, token_id))?;\n\n    let err = send!(contract_bob.approve(bob_addr, token_id))\n        .expect_err(\"should not approve when invalid approver\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721InvalidApprover { approver: bob_addr })\n    );\n\n    let Erc721::getApprovedReturn { approved } =\n        contract_bob.getApproved(token_id).call().await?;\n    assert_eq!(Address::ZERO, approved);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_checking_approved_of_nonexistent_token(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n\n    let err = contract\n        .getApproved(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n    Ok(())\n}\n\n#[e2e::test]\nasync fn sets_approval_for_all(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let approved_value = true;\n    let receipt =\n        receipt!(contract.setApprovalForAll(bob_addr, approved_value))?;\n\n    assert!(receipt.emits(Erc721::ApprovalForAll {\n        owner: alice_addr,\n        operator: bob_addr,\n        approved: approved_value,\n    }));\n\n    let Erc721::isApprovedForAllReturn { approved } =\n        contract.isApprovedForAll(alice_addr, bob_addr).call().await?;\n    assert_eq!(approved_value, approved);\n\n    let approved_value = false;\n    let receipt =\n        receipt!(contract.setApprovalForAll(bob_addr, approved_value))?;\n\n    assert!(receipt.emits(Erc721::ApprovalForAll {\n        owner: alice_addr,\n        operator: bob_addr,\n        approved: approved_value,\n    }));\n\n    let Erc721::isApprovedForAllReturn { approved } =\n        contract.isApprovedForAll(alice_addr, bob_addr).call().await?;\n    assert_eq!(approved_value, approved);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_set_approval_for_all_by_invalid_operator(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let invalid_operator = Address::ZERO;\n\n    let err = send!(contract.setApprovalForAll(invalid_operator, true))\n        .expect_err(\"should return ERC721InvalidOperator\");\n\n    assert!(err.reverted_with(Erc721::ERC721InvalidOperator {\n        operator: invalid_operator\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn is_approved_for_all_invalid_operator(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let invalid_operator = Address::ZERO;\n\n    let Erc721::isApprovedForAllReturn { approved } = contract\n        .isApprovedForAll(alice.address(), invalid_operator)\n        .call()\n        .await?;\n\n    assert!(!approved);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_mint_to_eoa_without_data(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n\n    let token_id = random_token_id();\n    let data = Bytes::new();\n\n    let initial_balance =\n        contract.balanceOf(alice.address()).call().await?.balance;\n\n    let receipt = receipt!(contract.safeMint(alice_addr, token_id, data))?;\n    assert!(receipt.emits(Erc721::Transfer {\n        from: Address::ZERO,\n        to: alice_addr,\n        tokenId: token_id,\n    }));\n\n    let owner_of = contract.ownerOf(token_id).call().await?.ownerOf;\n    assert_eq!(alice_addr, owner_of);\n\n    let balance = contract.balanceOf(alice.address()).call().await?.balance;\n    assert_eq!(balance, initial_balance + uint!(1_U256));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_mint_to_eoa_with_data(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n\n    let token_id = random_token_id();\n    let data: Bytes = fixed_bytes!(\"deadbeef\").into();\n\n    let initial_balance =\n        contract.balanceOf(alice.address()).call().await?.balance;\n\n    let receipt = receipt!(contract.safeMint(alice_addr, token_id, data))?;\n    assert!(receipt.emits(Erc721::Transfer {\n        from: Address::ZERO,\n        to: alice_addr,\n        tokenId: token_id,\n    }));\n\n    let owner_of = contract.ownerOf(token_id).call().await?.ownerOf;\n    assert_eq!(alice_addr, owner_of);\n\n    let balance = contract.balanceOf(alice.address()).call().await?.balance;\n    assert_eq!(balance, initial_balance + uint!(1_U256));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_mint_to_receiver_contract_without_data(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n    let receiver_address =\n        receiver::deploy(\u0026alice.wallet, ERC721ReceiverMock::RevertType::None)\n            .await?;\n\n    let token_id = random_token_id();\n    let data = Bytes::new();\n\n    let initial_balance =\n        contract.balanceOf(alice.address()).call().await?.balance;\n\n    let receipt =\n        receipt!(contract.safeMint(receiver_address, token_id, data.clone()))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: Address::ZERO,\n        to: receiver_address,\n        tokenId: token_id,\n    }));\n\n    assert!(receipt.emits(ERC721ReceiverMock::Received {\n        operator: alice.address(),\n        from: Address::ZERO,\n        tokenId: token_id,\n        data,\n    }));\n\n    let owner_of = contract.ownerOf(token_id).call().await?.ownerOf;\n    assert_eq!(receiver_address, owner_of);\n\n    let balance = contract.balanceOf(receiver_address).call().await?.balance;\n    assert_eq!(balance, initial_balance + uint!(1_U256));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_mint_to_receiver_contract_with_data(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n    let receiver_address =\n        receiver::deploy(\u0026alice.wallet, ERC721ReceiverMock::RevertType::None)\n            .await?;\n\n    let token_id = random_token_id();\n    let data: Bytes = fixed_bytes!(\"deadbeef\").into();\n\n    let initial_balance =\n        contract.balanceOf(alice.address()).call().await?.balance;\n\n    let receipt =\n        receipt!(contract.safeMint(receiver_address, token_id, data.clone()))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: Address::ZERO,\n        to: receiver_address,\n        tokenId: token_id,\n    }));\n\n    assert!(receipt.emits(ERC721ReceiverMock::Received {\n        operator: alice.address(),\n        from: Address::ZERO,\n        tokenId: token_id,\n        data,\n    }));\n\n    let owner_of = contract.ownerOf(token_id).call().await?.ownerOf;\n    assert_eq!(receiver_address, owner_of);\n\n    let balance = contract.balanceOf(receiver_address).call().await?.balance;\n    assert_eq!(balance, initial_balance + uint!(1_U256));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_safe_mint_to_invalid_receiver_contract(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n    let data: Bytes = fixed_bytes!(\"deadbeef\").into();\n\n    let err = send!(contract.safeMint(contract_addr, token_id, data))\n        .expect_err(\"should not safe mint the token to invalid receiver\");\n\n    assert!(err.reverted_with(Erc721::ERC721InvalidReceiver {\n        receiver: contract_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_safe_mint_to_invalid_sender_with_data(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n    let data: Bytes = fixed_bytes!(\"deadbeef\").into();\n\n    watch!(contract.mint(alice.address(), token_id))?;\n\n    let err = send!(contract.safeMint(bob.address(), token_id, data))\n        .expect_err(\"should not safe mint an existing token\");\n\n    assert!(err\n        .reverted_with(Erc721::ERC721InvalidSender { sender: Address::ZERO }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_receiver_reverts_with_reason_on_safe_mint_with_data(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC721ReceiverMock::RevertType::RevertWithMessage,\n    )\n    .await?;\n\n    let token_id = random_token_id();\n    let data: Bytes = fixed_bytes!(\"deadbeef\").into();\n\n    let err = send!(contract.safeMint(receiver_address, token_id, data))\n        .expect_err(\"should not safe mint when receiver errors with reason\");\n\n    let message =\n        Erc721::Error { message: \"ERC721ReceiverMock: reverting\".to_string() }\n            .encode_as_str();\n\n    assert!(err.reverted_with(Erc721::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_receiver_reverts_without_reason_on_safe_mint_with_data(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address = receiver::deploy(\n        \u0026alice.wallet,\n        ERC721ReceiverMock::RevertType::RevertWithoutMessage,\n    )\n    .await?;\n\n    let token_id = random_token_id();\n    let data: Bytes = fixed_bytes!(\"deadbeef\").into();\n\n    let err = send!(contract.safeMint(receiver_address, token_id, data))\n        .expect_err(\n            \"should not safe mint when receiver reverts without reason\",\n        );\n\n    assert!(err.reverted_with(Erc721::ERC721InvalidReceiver {\n        receiver: receiver_address\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_receiver_panics_on_safe_mint_with_data(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let receiver_address =\n        receiver::deploy(\u0026alice.wallet, ERC721ReceiverMock::RevertType::Panic)\n            .await?;\n\n    let token_id = random_token_id();\n    let data: Bytes = fixed_bytes!(\"deadbeef\").into();\n\n    let err = send!(contract.safeMint(receiver_address, token_id, data))\n        .expect_err(\"should not safe mint when receiver panics\");\n\n    let message =\n        Erc721::Panic { code: U256::from(PanicCode::DivisionByZero as u8) }\n            .encode_as_str();\n    assert!(err.reverted_with(Erc721::InvalidReceiverWithReason { message }));\n\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-721 Burnable Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn burns(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let token_id = random_token_id();\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let receipt = receipt!(contract.burn(token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: Address::ZERO,\n        tokenId: token_id,\n    }));\n\n    let Erc721::balanceOfReturn { balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    assert_eq!(initial_balance - uint!(1_U256), balance);\n\n    let err = contract\n        .ownerOf(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burns_approved_token(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc721::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    watch!(contract_alice.mint(alice_addr, token_id))?;\n    watch!(contract_alice.approve(bob_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let receipt = receipt!(contract_bob.burn(token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: Address::ZERO,\n        tokenId: token_id,\n    }));\n\n    let Erc721::balanceOfReturn { balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    assert_eq!(initial_balance - uint!(1_U256), balance);\n\n    let err = contract_bob\n        .ownerOf(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burns_approved_for_all(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract_alice = Erc721::new(contract_addr, \u0026alice.wallet);\n    let contract_bob = Erc721::new(contract_addr, \u0026bob.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n\n    watch!(contract_alice.mint(alice_addr, token_id))?;\n    watch!(contract_alice.setApprovalForAll(bob_addr, true))?;\n\n    let Erc721::balanceOfReturn { balance: initial_balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    let receipt = receipt!(contract_bob.burn(token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: Address::ZERO,\n        tokenId: token_id,\n    }));\n\n    let Erc721::balanceOfReturn { balance } =\n        contract_alice.balanceOf(alice_addr).call().await?;\n\n    assert_eq!(initial_balance - uint!(1_U256), balance);\n\n    let err = contract_bob\n        .ownerOf(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_burn_with_insufficient_approval(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let token_id = random_token_id();\n    watch!(contract.mint(alice_addr, token_id))?;\n\n    let Erc721::balanceOfReturn { balance: initial_balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    let contract = Erc721::new(contract_addr, \u0026bob.wallet);\n    let err = send!(contract.burn(token_id))\n        .expect_err(\"should not burn unapproved token\");\n\n    assert!(err.reverted_with(Erc721::ERC721InsufficientApproval {\n        operator: bob_addr,\n        tokenId: token_id,\n    }));\n\n    let Erc721::balanceOfReturn { balance } =\n        contract.balanceOf(alice_addr).call().await?;\n\n    assert_eq!(initial_balance, balance);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_burn_nonexistent_token(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n\n    let err = send!(contract.burn(token_id))\n        .expect_err(\"should not burn a non-existent token\");\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-721 Enumerable Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn totally_supply_works(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n\n    let token_1 = random_token_id();\n    watch!(contract.mint(alice_addr, token_1))?;\n\n    let token_2 = random_token_id();\n    watch!(contract.mint(alice_addr, token_2))?;\n\n    let Erc721::totalSupplyReturn { totalSupply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(uint!(2_U256), totalSupply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_checking_token_of_owner_by_index_out_of_bound(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n\n    watch!(contract.mint(alice_addr, random_token_id()))?;\n    watch!(contract.mint(alice_addr, random_token_id()))?;\n\n    let index_out_of_bound = uint!(2_U256);\n\n    let err = contract\n        .tokenOfOwnerByIndex(alice_addr, index_out_of_bound)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721OutOfBoundsIndex`\");\n\n    assert!(err.reverted_with(Erc721::ERC721OutOfBoundsIndex {\n        owner: alice_addr,\n        index: index_out_of_bound\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_checking_token_of_owner_by_index_account_has_no_tokens(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n\n    let index = uint!(0_U256);\n\n    let err = contract\n        .tokenOfOwnerByIndex(alice_addr, index)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721OutOfBoundsIndex`\");\n\n    assert!(err.reverted_with(Erc721::ERC721OutOfBoundsIndex {\n        owner: alice_addr,\n        index\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn token_of_owner_by_index_works(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n\n    let token_0 = random_token_id();\n    watch!(contract.mint(alice_addr, token_0))?;\n\n    let token_1 = random_token_id();\n    watch!(contract.mint(alice_addr, token_1))?;\n\n    let Erc721::tokenOfOwnerByIndexReturn { tokenId } =\n        contract.tokenOfOwnerByIndex(alice_addr, uint!(0_U256)).call().await?;\n    assert_eq!(token_0, tokenId);\n\n    let Erc721::tokenOfOwnerByIndexReturn { tokenId } =\n        contract.tokenOfOwnerByIndex(alice_addr, uint!(1_U256)).call().await?;\n    assert_eq!(token_1, tokenId);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn token_of_owner_by_index_after_transfer_to_another_account(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let token_0 = random_token_id();\n    watch!(contract.mint(alice_addr, token_0))?;\n\n    let token_1 = random_token_id();\n    watch!(contract.mint(alice_addr, token_1))?;\n\n    watch!(contract.transferFrom(alice_addr, bob_addr, token_1))?;\n    watch!(contract.transferFrom(alice_addr, bob_addr, token_0))?;\n\n    // should be in reverse order\n    let index = uint!(0_U256);\n    let Erc721::tokenOfOwnerByIndexReturn { tokenId } =\n        contract.tokenOfOwnerByIndex(bob_addr, index).call().await?;\n    assert_eq!(token_1, tokenId);\n    let err = contract\n        .tokenOfOwnerByIndex(alice_addr, index)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721OutOfBoundsIndex`\");\n    assert!(err.reverted_with(Erc721::ERC721OutOfBoundsIndex {\n        owner: alice_addr,\n        index\n    }));\n\n    let index = uint!(1_U256);\n    let Erc721::tokenOfOwnerByIndexReturn { tokenId } =\n        contract.tokenOfOwnerByIndex(bob_addr, index).call().await?;\n    assert_eq!(token_0, tokenId);\n    let err = contract\n        .tokenOfOwnerByIndex(alice_addr, index)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721OutOfBoundsIndex`\");\n    assert!(err.reverted_with(Erc721::ERC721OutOfBoundsIndex {\n        owner: alice_addr,\n        index\n    }));\n\n    let Erc721::totalSupplyReturn { totalSupply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(uint!(2_U256), totalSupply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_checking_token_by_index_account_has_no_tokens(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let index = uint!(0_U256);\n\n    let err = contract\n        .tokenByIndex(index)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721OutOfBoundsIndex`\");\n\n    assert!(err.reverted_with(Erc721::ERC721OutOfBoundsIndex {\n        owner: Address::ZERO,\n        index\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_checking_token_by_index_out_of_bound(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n\n    watch!(contract.mint(alice_addr, random_token_id()))?;\n    watch!(contract.mint(alice_addr, random_token_id()))?;\n\n    let index_out_of_bound = uint!(2_U256);\n\n    let err = contract\n        .tokenByIndex(index_out_of_bound)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721OutOfBoundsIndex`\");\n\n    assert!(err.reverted_with(Erc721::ERC721OutOfBoundsIndex {\n        owner: Address::ZERO,\n        index: index_out_of_bound\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn token_by_index_works(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n\n    let token_0 = random_token_id();\n    watch!(contract.mint(alice_addr, token_0))?;\n\n    let token_1 = random_token_id();\n    watch!(contract.mint(alice_addr, token_1))?;\n\n    let Erc721::tokenByIndexReturn { tokenId } =\n        contract.tokenByIndex(uint!(0_U256)).call().await?;\n    assert_eq!(token_0, tokenId);\n\n    let Erc721::tokenByIndexReturn { tokenId } =\n        contract.tokenByIndex(uint!(1_U256)).call().await?;\n    assert_eq!(token_1, tokenId);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn token_by_index_after_burn(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n\n    let token_0 = random_token_id();\n    watch!(contract.mint(alice_addr, token_0))?;\n\n    let token_1 = random_token_id();\n    watch!(contract.mint(alice_addr, token_1))?;\n\n    watch!(contract.burn(token_1))?;\n\n    let Erc721::tokenByIndexReturn { tokenId } =\n        contract.tokenByIndex(uint!(0_U256)).call().await?;\n    assert_eq!(token_0, tokenId);\n\n    let index_of_burnt_token = uint!(1_U256);\n    let err = contract\n        .tokenByIndex(index_of_burnt_token)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721OutOfBoundsIndex`\");\n\n    assert!(err.reverted_with(Erc721::ERC721OutOfBoundsIndex {\n        owner: Address::ZERO,\n        index: index_of_burnt_token\n    }));\n\n    let Erc721::totalSupplyReturn { totalSupply } =\n        contract.totalSupply().call().await?;\n\n    assert_eq!(uint!(1_U256), totalSupply);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn token_by_index_after_burn_and_some_mints(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let alice_addr = alice.address();\n\n    let token_0 = random_token_id();\n    watch!(contract.mint(alice_addr, token_0))?;\n\n    let token_1 = random_token_id();\n    watch!(contract.mint(alice_addr, token_1))?;\n\n    watch!(contract.burn(token_1))?;\n\n    let token_2 = random_token_id();\n    watch!(contract.mint(alice_addr, token_2))?;\n\n    let token_3 = random_token_id();\n    watch!(contract.mint(alice_addr, token_3))?;\n\n    let Erc721::tokenByIndexReturn { tokenId } =\n        contract.tokenByIndex(uint!(0_U256)).call().await?;\n    assert_eq!(token_0, tokenId);\n\n    let Erc721::tokenByIndexReturn { tokenId } =\n        contract.tokenByIndex(uint!(1_U256)).call().await?;\n    assert_eq!(token_2, tokenId);\n\n    let Erc721::tokenByIndexReturn { tokenId } =\n        contract.tokenByIndex(uint!(2_U256)).call().await?;\n    assert_eq!(token_3, tokenId);\n\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-165 Support Interface\n// ============================================================================\n\n#[e2e::test]\nasync fn supports_interface(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n    let invalid_interface_id: u32 = 0x_ffffffff;\n    let Erc721::supportsInterfaceReturn {\n        supportsInterface: supports_interface,\n    } = contract.supportsInterface(invalid_interface_id.into()).call().await?;\n\n    assert!(!supports_interface);\n\n    let erc721_interface_id: u32 = 0x80ac58cd;\n    let Erc721::supportsInterfaceReturn {\n        supportsInterface: supports_interface,\n    } = contract.supportsInterface(erc721_interface_id.into()).call().await?;\n\n    assert!(supports_interface);\n\n    let erc165_interface_id: u32 = 0x01ffc9a7;\n    let Erc721::supportsInterfaceReturn {\n        supportsInterface: supports_interface,\n    } = contract.supportsInterface(erc165_interface_id.into()).call().await?;\n\n    assert!(supports_interface);\n\n    let erc721_enumerable_interface_id: u32 = 0x780e9d63;\n    let Erc721::supportsInterfaceReturn {\n        supportsInterface: supports_interface,\n    } = contract\n        .supportsInterface(erc721_enumerable_interface_id.into())\n        .call()\n        .await?;\n\n    assert!(supports_interface);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721","tests","mock","mod.rs"],"content":"pub mod receiver;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721","tests","mock","receiver.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{\n    primitives::{Address, FixedBytes, U256},\n    sol,\n};\nuse e2e::Wallet;\nuse stylus_sdk::{abi::Bytes, function_selector};\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.24+commit.e11b9ed9\n    #[sol(rpc, bytecode=\"60c060405234801561000f575f80fd5b5060405161093438038061093483398181016040528101906100319190610126565b817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166080817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152505080600481111561008a57610089610164565b5b60a081600481111561009f5761009e610164565b5b815250505050610191565b5f80fd5b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6100e2816100ae565b81146100ec575f80fd5b50565b5f815190506100fd816100d9565b92915050565b6005811061010f575f80fd5b50565b5f8151905061012081610103565b92915050565b5f806040838503121561013c5761013b6100aa565b5b5f610149858286016100ef565b925050602061015a85828601610112565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b60805160a0516107686101cc5f395f818160740152818160c40152818161014b01526101f301525f8181610183015261027801526107685ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063150b7a021461002d575b5f80fd5b6100476004803603810190610042919061047b565b61005d565b6040516100549190610535565b60405180910390f35b5f600160048111156100725761007161054e565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156100a5576100a461054e565b5b036100ae575f80fd5b600260048111156100c2576100c161054e565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156100f5576100f461054e565b5b03610135576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161012c906105d5565b60405180910390fd5b600360048111156101495761014861054e565b5b7f0000000000000000000000000000000000000000000000000000000000000000600481111561017c5761017b61054e565b5b036101de577f00000000000000000000000000000000000000000000000000000000000000006040517f66435bc00000000000000000000000000000000000000000000000000000000081526004016101d59190610535565b60405180910390fd5b6004808111156101f1576101f061054e565b5b7f000000000000000000000000000000000000000000000000000000000000000060048111156102245761022361054e565b5b0361023a575f805f6102369190610620565b9050505b7ed9411ae77b2bacabe5cbe62a2abdbeb78992a0182c6f3c83e0029c7615d6b68585858560405161026e94939291906106e8565b60405180910390a17f00000000000000000000000000000000000000000000000000000000000000009050949350505050565b5f604051905090565b5f80fd5b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6102db826102b2565b9050919050565b6102eb816102d1565b81146102f5575f80fd5b50565b5f81359050610306816102e2565b92915050565b5f819050919050565b61031e8161030c565b8114610328575f80fd5b50565b5f8135905061033981610315565b92915050565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b61038d82610347565b810181811067ffffffffffffffff821117156103ac576103ab610357565b5b80604052505050565b5f6103be6102a1565b90506103ca8282610384565b919050565b5f67ffffffffffffffff8211156103e9576103e8610357565b5b6103f282610347565b9050602081019050919050565b828183375f83830152505050565b5f61041f61041a846103cf565b6103b5565b90508281526020810184848401111561043b5761043a610343565b5b6104468482856103ff565b509392505050565b5f82601f8301126104625761046161033f565b5b813561047284826020860161040d565b91505092915050565b5f805f8060808587031215610493576104926102aa565b5b5f6104a0878288016102f8565b94505060206104b1878288016102f8565b93505060406104c28782880161032b565b925050606085013567ffffffffffffffff8111156104e3576104e26102ae565b5b6104ef8782880161044e565b91505092959194509250565b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b61052f816104fb565b82525050565b5f6020820190506105485f830184610526565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f82825260208201905092915050565b7f45524337323152656365697665724d6f636b3a20726576657274696e670000005f82015250565b5f6105bf601d8361057b565b91506105ca8261058b565b602082019050919050565b5f6020820190508181035f8301526105ec816105b3565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f61062a8261030c565b91506106358361030c565b925082610645576106446105f3565b5b828204905092915050565b610659816102d1565b82525050565b6106688161030c565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156106a557808201518184015260208101905061068a565b5f8484015250505050565b5f6106ba8261066e565b6106c48185610678565b93506106d4818560208601610688565b6106dd81610347565b840191505092915050565b5f6080820190506106fb5f830187610650565b6107086020830186610650565b610715604083018561065f565b818103606083015261072781846106b0565b90509594505050505056fea264697066735822122004a48ee4b48ae5d18b1de592a6ebe9356a4406e5c046600af1ad7eb0a2b45a9564736f6c63430008180033\")]\n    contract ERC721ReceiverMock is IERC721Receiver {\n        enum RevertType {\n            None,\n            RevertWithoutMessage,\n            RevertWithMessage,\n            RevertWithCustomError,\n            Panic\n        }\n\n        bytes4 private immutable _retval;\n        RevertType private immutable _error;\n\n        #[derive(Debug, PartialEq)]\n        event Received(address operator, address from, uint256 tokenId, bytes data);\n\n        error CustomError(bytes4);\n\n        constructor(bytes4 retval, RevertType error) {\n            _retval = retval;\n            _error = error;\n        }\n\n        function onERC721Received(\n            address operator,\n            address from,\n            uint256 tokenId,\n            bytes memory data\n        ) public returns (bytes4) {\n            if (_error == RevertType.RevertWithoutMessage) {\n                revert();\n            } else if (_error == RevertType.RevertWithMessage) {\n                revert(\"ERC721ReceiverMock: reverting\");\n            } else if (_error == RevertType.RevertWithCustomError) {\n                revert CustomError(_retval);\n            } else if (_error == RevertType.Panic) {\n                uint256 a = uint256(0) / uint256(0);\n                a;\n            }\n\n            emit Received(operator, from, tokenId, data);\n            return _retval;\n        }\n    }\n}\n\nconst RET_VAL: FixedBytes\u003c4\u003e = FixedBytes(function_selector!(\n    \"onERC721Received\",\n    Address,\n    Address,\n    U256,\n    Bytes,\n));\n\npub async fn deploy(\n    wallet: \u0026Wallet,\n    error: ERC721ReceiverMock::RevertType,\n) -\u003e eyre::Result\u003cAddress\u003e {\n    let contract = ERC721ReceiverMock::deploy(wallet, RET_VAL, error).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-consecutive","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloy_primitives::{aliases::U96, Address, FixedBytes, U256};\nuse openzeppelin_stylus::{\n    token::erc721::{\n        extensions::{consecutive, Erc721Consecutive, IErc721Burnable},\n        IErc721,\n    },\n    utils::introspection::erc165::IErc165,\n};\nuse stylus_sdk::{abi::Bytes, prelude::*};\n\n#[entrypoint]\n#[storage]\nstruct Erc721ConsecutiveExample {\n    erc721: Erc721Consecutive,\n}\n\n#[public]\n#[implements(IErc721\u003cError = consecutive::Error\u003e, IErc721Burnable\u003cError = consecutive::Error\u003e, IErc165)]\nimpl Erc721ConsecutiveExample {\n    #[constructor]\n    fn constructor(\n        \u0026mut self,\n        receivers: Vec\u003cAddress\u003e,\n        amounts: Vec\u003cU96\u003e,\n        first_consecutive_id: U96,\n        max_batch_size: U96,\n    ) -\u003e Result\u003c(), consecutive::Error\u003e {\n        self.erc721.first_consecutive_id.set(first_consecutive_id);\n        self.erc721.max_batch_size.set(max_batch_size);\n        for (\u0026receiver, \u0026amount) in receivers.iter().zip(amounts.iter()) {\n            self.erc721._mint_consecutive(receiver, amount)?;\n        }\n        Ok(())\n    }\n\n    fn mint(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), consecutive::Error\u003e {\n        self.erc721._mint(to, token_id)\n    }\n}\n\n#[public]\nimpl IErc721 for Erc721ConsecutiveExample {\n    type Error = consecutive::Error;\n\n    fn balance_of(\u0026self, owner: Address) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc721.balance_of(owner)\n    }\n\n    fn owner_of(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        self.erc721.owner_of(token_id)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.safe_transfer_from(from, to, token_id)\n    }\n\n    fn safe_transfer_from_with_data(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.safe_transfer_from_with_data(from, to, token_id, data)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.transfer_from(from, to, token_id)\n    }\n\n    fn approve(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.approve(to, token_id)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        to: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.set_approval_for_all(to, approved)\n    }\n\n    fn get_approved(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        self.erc721.get_approved(token_id)\n    }\n\n    fn is_approved_for_all(\u0026self, owner: Address, operator: Address) -\u003e bool {\n        self.erc721.is_approved_for_all(owner, operator)\n    }\n}\n\n#[public]\nimpl IErc721Burnable for Erc721ConsecutiveExample {\n    type Error = consecutive::Error;\n\n    fn burn(\u0026mut self, token_id: U256) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721._burn(token_id)\n    }\n}\n\n#[public]\nimpl IErc165 for Erc721ConsecutiveExample {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        self.erc721.supports_interface(interface_id)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-consecutive","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc721_consecutive_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-consecutive","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n   contract Erc721 {\n        #[derive(Debug)]\n        function balanceOf(address owner) external view returns (uint256 balance);\n        #[derive(Debug)]\n        function ownerOf(uint256 tokenId) external view returns (address ownerOf);\n        function safeTransferFrom(address from, address to, uint256 tokenId) external;\n        function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n        function transferFrom(address from, address to, uint256 tokenId) external;\n        function approve(address to, uint256 tokenId) external;\n        function setApprovalForAll(address operator, bool approved) external;\n        function getApproved(uint256 tokenId) external view returns (address);\n        function isApprovedForAll(address owner, address operator) external view returns (bool);\n        function mint(address to, uint256 tokenId) external;\n\n        function burn(uint256 tokenId) external;\n\n        error ERC721InvalidOwner(address owner);\n        error ERC721NonexistentToken(uint256 tokenId);\n        error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n        error ERC721InvalidSender(address sender);\n        error ERC721InvalidReceiver(address receiver);\n        error ERC721InsufficientApproval(address operator, uint256 tokenId);\n        error ERC721InvalidApprover(address approver);\n        error ERC721InvalidOperator(address operator);\n\n        error ERC721ForbiddenBatchMint();\n        error ERC721ExceededMaxBatchMint(uint256 batchSize, uint256 maxBatch);\n        error ERC721ForbiddenMint();\n        error ERC721ForbiddenBatchBurn();\n\n        #[derive(Debug, PartialEq)]\n        event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n        #[derive(Debug, PartialEq)]\n        event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n        #[derive(Debug, PartialEq)]\n        event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n        #[derive(Debug, PartialEq)]\n        event ConsecutiveTransfer(\n               uint256 indexed fromTokenId,\n               uint256 toTokenId,\n               address indexed fromAddress,\n               address indexed toAddress\n          );\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-consecutive","tests","erc721_consecutive.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse alloy::primitives::{Address, U256};\nuse alloy_primitives::{aliases::U96, uint};\nuse e2e::{\n    receipt, watch, Account, Constructor, ContractInitializationError,\n    EventExt, Revert,\n};\n\nuse crate::abi::Erc721;\n\nmod abi;\n\nconst FIRST_CONSECUTIVE_ID: U96 = U96::ZERO;\nconst MAX_BATCH_SIZE: U96 = uint!(5000_U96);\n\nfn random_token_id() -\u003e U256 {\n    let num: u32 = rand::random();\n    U256::from(num)\n}\n\nfn ctr(receivers: Vec\u003cAddress\u003e, amounts: Vec\u003cU96\u003e) -\u003e Constructor {\n    let receivers =\n        receivers.iter().map(|r| format!(\"{r}\")).collect::\u003cVec\u003c_\u003e\u003e().join(\",\");\n    let amounts =\n        amounts.iter().map(|r| format!(\"{r}\")).collect::\u003cVec\u003c_\u003e\u003e().join(\",\");\n\n    Constructor {\n        signature: \"constructor(address[],uint96[],uint96,uint96)\".to_string(),\n        args: vec![\n            format!(\"[{receivers}]\"),\n            format!(\"[{amounts}]\"),\n            FIRST_CONSECUTIVE_ID.to_string(),\n            MAX_BATCH_SIZE.to_string(),\n        ],\n    }\n}\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let receivers = vec![alice_addr];\n    let amounts = vec![uint!(10_U96)];\n    let receipt = alice\n        .as_deployer()\n        .with_constructor(ctr(receivers, amounts))\n        .deploy()\n        .await?;\n    let contract = Erc721::new(receipt.contract_address, \u0026alice.wallet);\n\n    let balance = contract.balanceOf(alice_addr).call().await?.balance;\n    assert_eq!(balance, uint!(10_U256));\n    Ok(())\n}\n\n#[e2e::test]\nasync fn mints(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let batch_size = uint!(10_U96);\n    let receivers = vec![alice.address()];\n    let amounts = vec![batch_size];\n    let receipt = alice\n        .as_deployer()\n        .with_constructor(ctr(receivers, amounts))\n        .deploy()\n        .await?;\n    let contract = Erc721::new(receipt.contract_address, \u0026alice.wallet);\n\n    assert!(receipt.emits(Erc721::ConsecutiveTransfer {\n        fromTokenId: U256::from(FIRST_CONSECUTIVE_ID),\n        toTokenId: uint!(9_U256),\n        fromAddress: Address::ZERO,\n        toAddress: alice.address(),\n    }));\n\n    let Erc721::balanceOfReturn { balance: balance1 } =\n        contract.balanceOf(alice.address()).call().await?;\n    assert_eq!(balance1, U256::from(batch_size));\n\n    let token_id = random_token_id();\n    watch!(contract.mint(alice.address(), token_id))?;\n\n    let Erc721::balanceOfReturn { balance: balance2 } =\n        contract.balanceOf(alice.address()).call().await?;\n\n    assert_eq!(balance2, balance1 + uint!(1_U256));\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_to_is_zero(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let receivers = vec![Address::ZERO];\n    let amounts = vec![uint!(10_U96)];\n    let err = alice\n        .as_deployer()\n        .with_constructor(ctr(receivers, amounts))\n        .deploy()\n        .await\n        .expect_err(\"should not mint consecutive\");\n\n    // TODO: assert the actual `ERC721InvalidReceiver` error was returned once\n    // StylusDeployer is able to return the exact revert reason from\n    // constructors.\n    // assert!(err.reverted_with(Erc721::ERC721InvalidReceiver {\n    //     receiver: Address::ZERO\n    // }));\n\n    assert!(err.downcast_ref::\u003cContractInitializationError\u003e().is_some());\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn error_when_exceed_batch_size(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let receivers = vec![alice.address()];\n    let amounts = vec![MAX_BATCH_SIZE + uint!(1_U96)];\n    let err = alice\n        .as_deployer()\n        .with_constructor(ctr(receivers, amounts))\n        .deploy()\n        .await\n        .expect_err(\"should not mint consecutive\");\n\n    // TODO: assert the actual `ERC721ExceededMaxBatchMint` error was returned\n    // once StylusDeployer is able to return the exact revert reason from\n    // constructors.\n    // assert!(err.reverted_with(Erc721::ERC721ExceededMaxBatchMint {\n    //     batchSize: U256::from(MAX_BATCH_SIZE + uint!(1_U96)),\n    //     maxBatch: U256::from(MAX_BATCH_SIZE),\n    // }));\n\n    assert!(err.downcast_ref::\u003cContractInitializationError\u003e().is_some());\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfers_from(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let receivers = vec![alice.address(), bob.address()];\n    let amounts = vec![uint!(1000_U96), uint!(1000_U96)];\n    // Deploy and mint batches of 1000 tokens to Alice and Bob.\n    let receipt = alice\n        .as_deployer()\n        .with_constructor(ctr(receivers, amounts))\n        .deploy()\n        .await?;\n    let contract = Erc721::new(receipt.contract_address, \u0026alice.wallet);\n\n    let first_consecutive_token_id = U256::from(FIRST_CONSECUTIVE_ID);\n\n    // Transfer first consecutive token from Alice to Bob.\n    watch!(contract.transferFrom(\n        alice.address(),\n        bob.address(),\n        first_consecutive_token_id\n    ))?;\n\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(first_consecutive_token_id).call().await?;\n    assert_eq!(ownerOf, bob.address());\n\n    // Check that balances changed.\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice.address()).call().await?;\n    assert_eq!(alice_balance, uint!(1000_U256) - uint!(1_U256));\n    let Erc721::balanceOfReturn { balance: bob_balance } =\n        contract.balanceOf(bob.address()).call().await?;\n    assert_eq!(bob_balance, uint!(1000_U256) + uint!(1_U256));\n\n    // Test non-consecutive mint.\n    let token_id = random_token_id();\n    watch!(contract.mint(alice.address(), token_id))?;\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice.address()).call().await?;\n    assert_eq!(alice_balance, uint!(1000_U256));\n\n    // Test transfer of the token that wasn't minted consecutive.\n    watch!(contract.transferFrom(alice.address(), bob.address(), token_id))?;\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice.address()).call().await?;\n    assert_eq!(alice_balance, uint!(1000_U256) - uint!(1_U256));\n    Ok(())\n}\n\n#[e2e::test]\nasync fn burns(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let receivers = vec![alice.address()];\n    let amounts = vec![uint!(1000_U96)];\n    // Mint batch of 1000 tokens to Alice.\n    let receipt = alice\n        .as_deployer()\n        .with_constructor(ctr(receivers, amounts))\n        .deploy()\n        .await?;\n    let contract = Erc721::new(receipt.contract_address, \u0026alice.wallet);\n\n    let first_consecutive_token_id = U256::from(FIRST_CONSECUTIVE_ID);\n\n    // Check consecutive token burn.\n    let receipt = receipt!(contract.burn(first_consecutive_token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice.address(),\n        to: Address::ZERO,\n        tokenId: first_consecutive_token_id,\n    }));\n\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice.address()).call().await?;\n    assert_eq!(alice_balance, uint!(1000_U256) - uint!(1_U256));\n\n    let err = contract\n        .ownerOf(first_consecutive_token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(err.reverted_with(Erc721::ERC721NonexistentToken {\n        tokenId: first_consecutive_token_id\n    }));\n\n    // Check non-consecutive token burn.\n    let non_consecutive_token_id = random_token_id();\n    watch!(contract.mint(alice.address(), non_consecutive_token_id))?;\n    let Erc721::ownerOfReturn { ownerOf } =\n        contract.ownerOf(non_consecutive_token_id).call().await?;\n    assert_eq!(ownerOf, alice.address());\n    let Erc721::balanceOfReturn { balance: alice_balance } =\n        contract.balanceOf(alice.address()).call().await?;\n    assert_eq!(alice_balance, uint!(1000_U256));\n\n    let receipt = receipt!(contract.burn(non_consecutive_token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice.address(),\n        to: Address::ZERO,\n        tokenId: non_consecutive_token_id,\n    }));\n\n    let err = contract\n        .ownerOf(non_consecutive_token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(err.reverted_with(Erc721::ERC721NonexistentToken {\n        tokenId: non_consecutive_token_id\n    }));\n    Ok(())\n}\n\n// No need to test for `IErc165` impl, as this is already tested in\n// ../../examples/erc721 e2e tests\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-metadata","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::{string::String, vec::Vec};\n\nuse openzeppelin_stylus::{\n    token::erc721::{\n        self,\n        extensions::{\n            Erc721Metadata, Erc721UriStorage, IErc721Burnable, IErc721Metadata,\n            IErc721UriStorage,\n        },\n        Erc721, IErc721,\n    },\n    utils::introspection::erc165::IErc165,\n};\nuse stylus_sdk::{\n    abi::Bytes,\n    alloy_primitives::{Address, FixedBytes, U256},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct Erc721MetadataExample {\n    erc721: Erc721,\n    metadata: Erc721Metadata,\n    uri_storage: Erc721UriStorage,\n}\n\n#[public]\n#[implements(IErc721\u003cError = erc721::Error\u003e, IErc721Burnable\u003cError = erc721::Error\u003e, IErc721Metadata\u003cError = erc721::Error\u003e, IErc165)]\nimpl Erc721MetadataExample {\n    #[constructor]\n    fn constructor(\u0026mut self, name: String, symbol: String, base_uri: String) {\n        self.metadata.constructor(name, symbol);\n        self.metadata.base_uri.set_str(base_uri);\n    }\n\n    fn mint(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), erc721::Error\u003e {\n        self.erc721._mint(to, token_id)\n    }\n\n    #[selector(name = \"setTokenURI\")]\n    fn set_token_uri(\u0026mut self, token_id: U256, token_uri: String) {\n        self.uri_storage._set_token_uri(token_id, token_uri)\n    }\n}\n\n#[public]\nimpl IErc721 for Erc721MetadataExample {\n    type Error = erc721::Error;\n\n    fn balance_of(\u0026self, owner: Address) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc721.balance_of(owner)\n    }\n\n    fn owner_of(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        self.erc721.owner_of(token_id)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.safe_transfer_from(from, to, token_id)\n    }\n\n    fn safe_transfer_from_with_data(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.safe_transfer_from_with_data(from, to, token_id, data)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.transfer_from(from, to, token_id)\n    }\n\n    fn approve(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.approve(to, token_id)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        to: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.set_approval_for_all(to, approved)\n    }\n\n    fn get_approved(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        self.erc721.get_approved(token_id)\n    }\n\n    fn is_approved_for_all(\u0026self, owner: Address, operator: Address) -\u003e bool {\n        self.erc721.is_approved_for_all(owner, operator)\n    }\n}\n\n#[public]\nimpl IErc721Burnable for Erc721MetadataExample {\n    type Error = erc721::Error;\n\n    fn burn(\u0026mut self, token_id: U256) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721._burn(token_id)\n    }\n}\n\n#[public]\nimpl IErc721Metadata for Erc721MetadataExample {\n    type Error = erc721::Error;\n\n    fn name(\u0026self) -\u003e String {\n        self.metadata.name()\n    }\n\n    fn symbol(\u0026self) -\u003e String {\n        self.metadata.symbol()\n    }\n\n    #[selector(name = \"tokenURI\")]\n    fn token_uri(\u0026self, token_id: U256) -\u003e Result\u003cString, Self::Error\u003e {\n        self.uri_storage.token_uri(token_id, \u0026self.erc721, \u0026self.metadata)\n    }\n}\n\nimpl IErc721UriStorage for Erc721MetadataExample {}\n\n#[public]\nimpl IErc165 for Erc721MetadataExample {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        self.erc721.supports_interface(interface_id)\n            || \u003cSelf as IErc721Metadata\u003e::interface_id() == interface_id\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-metadata","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc721_metadata_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-metadata","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n   contract Erc721 {\n        function approve(address to, uint256 tokenId) external;\n        #[derive(Debug)]\n        function balanceOf(address owner) external view returns (uint256 balance);\n        #[derive(Debug)]\n        function getApproved(uint256 tokenId) external view returns (address approved);\n        #[derive(Debug)]\n        function isApprovedForAll(address owner, address operator) external view returns (bool approved);\n        #[derive(Debug)]\n        function ownerOf(uint256 tokenId) external view returns (address ownerOf);\n        function safeTransferFrom(address from, address to, uint256 tokenId) external;\n        function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n        function setApprovalForAll(address operator, bool approved) external;\n        function transferFrom(address from, address to, uint256 tokenId) external;\n        function mint(address to, uint256 tokenId) external;\n        function burn(uint256 tokenId) external;\n        function name() external view returns (string memory name);\n        function symbol() external view returns (string memory symbol);\n        #[derive(Debug)]\n        function tokenURI(uint256 tokenId) external view returns (string memory tokenURI);\n        function setTokenURI(uint256 tokenId, string memory tokenURI) external;\n        function supportsInterface(bytes4 interfaceId) external pure returns (bool);\n\n        error ERC721InvalidOwner(address owner);\n        error ERC721NonexistentToken(uint256 tokenId);\n        error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n        error ERC721InvalidSender(address sender);\n        error ERC721InvalidReceiver(address receiver);\n        error ERC721InsufficientApproval(address operator, uint256 tokenId);\n        error ERC721InvalidApprover(address approver);\n        error ERC721InvalidOperator(address operator);\n\n        #[derive(Debug, PartialEq)]\n        event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n        #[derive(Debug, PartialEq)]\n        event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n        #[derive(Debug, PartialEq)]\n        event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n        #[derive(Debug, PartialEq)]\n        event MetadataUpdate(uint256 tokenId);\n   }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-metadata","tests","erc721_metadata.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::Erc721;\nuse alloy::primitives::{Address, U256};\nuse e2e::{\n    constructor, receipt, watch, Account, Constructor, EventExt, Revert,\n};\n\nmod abi;\n\nconst TOKEN_NAME: \u0026str = \"Test Token\";\nconst TOKEN_SYMBOL: \u0026str = \"NFT\";\n\nfn random_token_id() -\u003e U256 {\n    let num: u32 = rand::random();\n    U256::from(num)\n}\n\nfn ctr(base_uri: \u0026str) -\u003e Constructor {\n    constructor!(\n        TOKEN_NAME.to_string(),\n        TOKEN_SYMBOL.to_string(),\n        base_uri.to_string()\n    )\n}\n\n// ============================================================================\n// Integration Tests: ERC-721 Metadata Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(\n            \"https://github.com/OpenZeppelin/rust-contracts-stylus\",\n        ))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let Erc721::nameReturn { name } = contract.name().call().await?;\n    let Erc721::symbolReturn { symbol } = contract.symbol().call().await?;\n\n    assert_eq!(TOKEN_NAME.to_owned(), name);\n    assert_eq!(TOKEN_SYMBOL.to_owned(), symbol);\n\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-721 URI Storage Extension\n// ============================================================================\n\n#[e2e::test]\nasync fn error_when_checking_token_uri_for_nonexistent_token(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(\"\"))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n\n    let err = contract\n        .tokenURI(token_id)\n        .call()\n        .await\n        .expect_err(\"should return ERC721NonexistentToken\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n    Ok(())\n}\n\n#[e2e::test]\nasync fn return_empty_token_uri_when_without_base_uri_and_token_uri(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(\"\"))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice.address(), token_id))?;\n\n    let Erc721::tokenURIReturn { tokenURI } =\n        contract.tokenURI(token_id).call().await?;\n\n    assert_eq!(\"\", tokenURI);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn return_token_uri_with_base_uri_and_without_token_uri(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let base_uri = \"https://github.com/OpenZeppelin/rust-contracts-stylus/\";\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(base_uri))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice.address(), token_id))?;\n\n    let Erc721::tokenURIReturn { tokenURI } =\n        contract.tokenURI(token_id).call().await?;\n\n    assert_eq!(base_uri.to_owned() + \u0026token_id.to_string(), tokenURI);\n    Ok(())\n}\n\n#[e2e::test]\nasync fn return_token_uri_with_base_uri_and_token_uri(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let base_uri = \"https://github.com/OpenZeppelin/rust-contracts-stylus/\";\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(base_uri))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice.address(), token_id))?;\n\n    let token_uri = String::from(\n        \"blob/main/contracts/src/token/erc721/extensions/uri_storage.rs\",\n    );\n\n    let receipt = receipt!(contract.setTokenURI(token_id, token_uri.clone()))?;\n\n    assert!(receipt.emits(Erc721::MetadataUpdate { tokenId: token_id }));\n\n    let Erc721::tokenURIReturn { tokenURI } =\n        contract.tokenURI(token_id).call().await?;\n\n    assert_eq!(base_uri.to_owned() + \u0026token_uri, tokenURI);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn set_token_uri_before_mint(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let base_uri = \"https://github.com/OpenZeppelin/rust-contracts-stylus/\";\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(base_uri))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n\n    let err = contract\n        .ownerOf(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    let token_uri = String::from(\n        \"blob/main/contracts/src/token/erc721/extensions/uri_storage.rs\",\n    );\n\n    let receipt = receipt!(contract.setTokenURI(token_id, token_uri.clone()))?;\n\n    assert!(receipt.emits(Erc721::MetadataUpdate { tokenId: token_id }));\n\n    watch!(contract.mint(alice.address(), token_id))?;\n\n    let Erc721::tokenURIReturn { tokenURI } =\n        contract.tokenURI(token_id).call().await?;\n\n    assert_eq!(base_uri.to_owned() + \u0026token_uri, tokenURI);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn return_token_uri_after_burn_and_remint(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let base_uri = \"https://github.com/OpenZeppelin/rust-contracts-stylus/\";\n\n    let alice_addr = alice.address();\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(base_uri))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let token_id = random_token_id();\n\n    watch!(contract.mint(alice.address(), token_id))?;\n\n    let receipt = receipt!(contract.burn(token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_addr,\n        to: Address::ZERO,\n        tokenId: token_id,\n    }));\n\n    let err = contract\n        .ownerOf(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(\n        err.reverted_with(Erc721::ERC721NonexistentToken { tokenId: token_id })\n    );\n\n    let receipt = receipt!(contract.mint(alice_addr, token_id))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: Address::ZERO,\n        to: alice_addr,\n        tokenId: token_id\n    }));\n\n    let Erc721::ownerOfReturn { ownerOf: owner_of } =\n        contract.ownerOf(token_id).call().await?;\n    assert_eq!(alice_addr, owner_of);\n\n    let Erc721::tokenURIReturn { tokenURI } =\n        contract.tokenURI(token_id).call().await?;\n\n    assert_eq!(base_uri.to_owned() + \u0026token_id.to_string(), tokenURI);\n    Ok(())\n}\n\n// ============================================================================\n// Integration Tests: ERC-165 Support Interface\n// ============================================================================\n\n#[e2e::test]\nasync fn supports_interface(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(\n            \"https://github.com/OpenZeppelin/rust-contracts-stylus\",\n        ))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n\n    let erc721_metadata_interface_id: u32 = 0x5b5e139f;\n    let supports_interface = contract\n        .supportsInterface(erc721_metadata_interface_id.into())\n        .call()\n        .await?\n        ._0;\n\n    assert!(supports_interface);\n\n    let erc721_interface_id: u32 = 0x80ac58cd;\n    let supports_interface =\n        contract.supportsInterface(erc721_interface_id.into()).call().await?._0;\n\n    assert!(supports_interface);\n\n    let erc165_interface_id: u32 = 0x01ffc9a7;\n    let supports_interface =\n        contract.supportsInterface(erc165_interface_id.into()).call().await?._0;\n\n    assert!(supports_interface);\n\n    let invalid_interface_id: u32 = 0xffffffff;\n    let supports_interface = contract\n        .supportsInterface(invalid_interface_id.into())\n        .call()\n        .await?\n        ._0;\n\n    assert!(!supports_interface);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-wrapper","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::{vec, vec::Vec};\n\nuse openzeppelin_stylus::{\n    token::erc721::{\n        self,\n        extensions::{wrapper, Erc721Wrapper, IErc721Burnable, IErc721Wrapper},\n        Erc721, IErc721,\n    },\n    utils::introspection::erc165::IErc165,\n};\nuse stylus_sdk::{\n    abi::Bytes,\n    alloy_primitives::{Address, FixedBytes, U256},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct Erc721WrapperExample {\n    erc721: Erc721,\n    erc721_wrapper: Erc721Wrapper,\n}\n\n#[public]\n#[implements(IErc721\u003cError = erc721::Error\u003e, IErc721Burnable\u003cError = erc721::Error\u003e, IErc721Wrapper\u003cError = wrapper::Error\u003e, IErc165)]\nimpl Erc721WrapperExample {\n    #[constructor]\n    fn constructor(\u0026mut self, underlying_token: Address) {\n        self.erc721_wrapper.constructor(underlying_token);\n    }\n}\n\n#[public]\nimpl IErc721 for Erc721WrapperExample {\n    type Error = erc721::Error;\n\n    fn balance_of(\u0026self, owner: Address) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.erc721.balance_of(owner)\n    }\n\n    fn owner_of(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        self.erc721.owner_of(token_id)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.safe_transfer_from(from, to, token_id)\n    }\n\n    fn safe_transfer_from_with_data(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.safe_transfer_from_with_data(from, to, token_id, data)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.transfer_from(from, to, token_id)\n    }\n\n    fn approve(\n        \u0026mut self,\n        to: Address,\n        token_id: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.approve(to, token_id)\n    }\n\n    fn set_approval_for_all(\n        \u0026mut self,\n        to: Address,\n        approved: bool,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721.set_approval_for_all(to, approved)\n    }\n\n    fn get_approved(\u0026self, token_id: U256) -\u003e Result\u003cAddress, Self::Error\u003e {\n        self.erc721.get_approved(token_id)\n    }\n\n    fn is_approved_for_all(\u0026self, owner: Address, operator: Address) -\u003e bool {\n        self.erc721.is_approved_for_all(owner, operator)\n    }\n}\n\n#[public]\nimpl IErc721Burnable for Erc721WrapperExample {\n    type Error = erc721::Error;\n\n    fn burn(\u0026mut self, token_id: U256) -\u003e Result\u003c(), Self::Error\u003e {\n        self.erc721._burn(token_id)\n    }\n}\n\n#[public]\nimpl IErc721Wrapper for Erc721WrapperExample {\n    type Error = wrapper::Error;\n\n    fn underlying(\u0026self) -\u003e Address {\n        self.erc721_wrapper.underlying()\n    }\n\n    fn deposit_for(\n        \u0026mut self,\n        account: Address,\n        token_ids: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.erc721_wrapper.deposit_for(account, token_ids, \u0026mut self.erc721)\n    }\n\n    fn withdraw_to(\n        \u0026mut self,\n        account: Address,\n        token_ids: Vec\u003cU256\u003e,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.erc721_wrapper.withdraw_to(account, token_ids, \u0026mut self.erc721)\n    }\n\n    fn on_erc721_received(\n        \u0026mut self,\n        operator: Address,\n        from: Address,\n        token_id: U256,\n        data: Bytes,\n    ) -\u003e Result\u003cFixedBytes\u003c4\u003e, Self::Error\u003e {\n        self.erc721_wrapper.on_erc721_received(\n            operator,\n            from,\n            token_id,\n            \u0026data,\n            \u0026mut self.erc721,\n        )\n    }\n}\n\n#[public]\nimpl IErc165 for Erc721WrapperExample {\n    fn supports_interface(\u0026self, interface_id: FixedBytes\u003c4\u003e) -\u003e bool {\n        self.erc721.supports_interface(interface_id)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-wrapper","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    erc721_wrapper_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-wrapper","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract Erc721Wrapper {\n        #[derive(Debug)]\n        function balanceOf(address owner) external view returns (uint256 balance);\n        #[derive(Debug)]\n        function underlying() external view returns (address underlying);\n        #[derive(Debug)]\n        function ownerOf(uint256 tokenId) external view returns (address owner);\n        #[derive(Debug)]\n        function depositFor(address account, uint256[] memory tokenIds) external returns (bool);\n        #[derive(Debug)]\n        function withdrawTo(address account, uint256[] memory tokenIds) external returns (bool);\n\n\n        #[derive(Debug, PartialEq)]\n        event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n        error ERC721NonexistentToken(uint256 tokenId);\n    }\n\n    contract Erc721 {\n        function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n        #[derive(Debug)]\n        function ownerOf(uint256 tokenId) external view returns (address owner);\n\n        #[derive(Debug, PartialEq)]\n        event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-wrapper","tests","erc721_wrapper.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::{Erc721, Erc721Wrapper};\nuse alloy::primitives::{uint, Address};\nuse e2e::{\n    constructor, receipt, watch, Account, Constructor, EventExt, Revert,\n};\nuse eyre::Result;\n\nmod abi;\nmod mock;\nuse mock::{erc721, erc721::ERC721Mock};\n\nfn ctr(asset_addr: Address) -\u003e Constructor {\n    constructor!(asset_addr)\n}\n\nasync fn deploy(account: \u0026Account) -\u003e Result\u003c(Address, Address)\u003e {\n    let asset_addr = erc721::deploy(\u0026account.wallet).await?;\n\n    let contract_addr = account\n        .as_deployer()\n        .with_constructor(ctr(asset_addr))\n        .deploy()\n        .await?\n        .contract_address;\n\n    Ok((asset_addr, contract_addr))\n}\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e Result\u003c()\u003e {\n    let asset_address = erc721::deploy(\u0026alice.wallet).await?;\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(asset_address))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Erc721Wrapper::new(contract_addr, alice.wallet);\n\n    let underlying = contract.underlying().call().await?.underlying;\n    assert_eq!(underlying, asset_address);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn deposit_for_success(alice: Account) -\u003e Result\u003c()\u003e {\n    let token_id = uint!(1_U256);\n    let (asset_addr, contract_addr) = deploy(\u0026alice).await?;\n    let alice_address = alice.address();\n    let asset = ERC721Mock::new(asset_addr, \u0026alice.wallet);\n    let contract = Erc721Wrapper::new(contract_addr, \u0026alice.wallet);\n\n    watch!(asset.safeMint(alice_address, token_id))?;\n    watch!(asset.approve(contract_addr, token_id))?;\n\n    let initial_alice_balance = asset.balanceOf(alice_address).call().await?._0;\n    let initial_contract_balance =\n        asset.balanceOf(contract_addr).call().await?._0;\n    let initial_wrapped_balance =\n        contract.balanceOf(alice_address).call().await?.balance;\n\n    let receipt = receipt!(contract.depositFor(alice_address, vec![token_id]))?;\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: alice_address,\n        to: contract_addr,\n        tokenId: token_id,\n    }));\n\n    assert!(receipt.emits(Erc721Wrapper::Transfer {\n        from: Address::ZERO,\n        to: alice_address,\n        tokenId: token_id,\n    }));\n\n    let wrapped_owner = contract.ownerOf(token_id).call().await?.owner;\n    assert_eq!(wrapped_owner, alice_address);\n\n    let underlying_owner = asset.ownerOf(token_id).call().await?._0;\n    assert_eq!(underlying_owner, contract_addr);\n\n    let one = uint!(1_U256);\n\n    assert_eq!(\n        initial_alice_balance - one,\n        asset.balanceOf(alice_address).call().await?._0\n    );\n    assert_eq!(\n        initial_contract_balance + one,\n        asset.balanceOf(contract_addr).call().await?._0\n    );\n    assert_eq!(\n        initial_wrapped_balance + one,\n        contract.balanceOf(alice_address).call().await?.balance\n    );\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn withdraw_to_success(alice: Account) -\u003e Result\u003c()\u003e {\n    let token_id = uint!(1_U256);\n    let (asset_addr, contract_addr) = deploy(\u0026alice).await?;\n    let alice_address = alice.address();\n    let asset = ERC721Mock::new(asset_addr, \u0026alice.wallet);\n    let contract = Erc721Wrapper::new(contract_addr, \u0026alice.wallet);\n\n    watch!(asset.safeMint(alice_address, token_id))?;\n    watch!(asset.approve(contract_addr, token_id))?;\n    watch!(contract.depositFor(alice_address, vec![token_id]))?;\n\n    let initial_alice_balance = asset.balanceOf(alice_address).call().await?._0;\n    let initial_contract_balance =\n        asset.balanceOf(contract_addr).call().await?._0;\n    let initial_wrapped_balance =\n        contract.balanceOf(alice_address).call().await?.balance;\n\n    let receipt = receipt!(contract.withdrawTo(alice_address, vec![token_id]))?;\n\n    assert!(receipt.emits(Erc721Wrapper::Transfer {\n        from: alice_address,\n        to: Address::ZERO,\n        tokenId: token_id,\n    }));\n\n    assert!(receipt.emits(Erc721::Transfer {\n        from: contract_addr,\n        to: alice_address,\n        tokenId: token_id,\n    }));\n\n    let err = contract\n        .ownerOf(token_id)\n        .call()\n        .await\n        .expect_err(\"should return `ERC721NonexistentToken`\");\n\n    assert!(err.reverted_with(Erc721Wrapper::ERC721NonexistentToken {\n        tokenId: token_id\n    }));\n\n    let underlying_owner = asset.ownerOf(token_id).call().await?._0;\n    assert_eq!(underlying_owner, alice_address);\n\n    let one = uint!(1_U256);\n\n    assert_eq!(\n        initial_alice_balance + one,\n        asset.balanceOf(alice_address).call().await?._0\n    );\n    assert_eq!(\n        initial_contract_balance - one,\n        asset.balanceOf(contract_addr).call().await?._0\n    );\n    assert_eq!(\n        initial_wrapped_balance - one,\n        contract.balanceOf(alice_address).call().await?.balance\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-wrapper","tests","mock","erc721.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc 0.8.24+commit.e11b9ed9\n    #[sol(rpc, bytecode=\"608060405234801562000010575f80fd5b506040518060400160405280600a81526020017f4552433732314d6f636b000000000000000000000000000000000000000000008152506040518060400160405280600381526020017f4d544b0000000000000000000000000000000000000000000000000000000000815250815f90816200008d91906200030c565b5080600190816200009f91906200030c565b505050620003f0565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806200012457607f821691505b6020821081036200013a5762000139620000df565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026200019e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000161565b620001aa868362000161565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f620001f4620001ee620001e884620001c2565b620001cb565b620001c2565b9050919050565b5f819050919050565b6200020f83620001d4565b620002276200021e82620001fb565b8484546200016d565b825550505050565b5f90565b6200023d6200022f565b6200024a81848462000204565b505050565b5b818110156200027157620002655f8262000233565b60018101905062000250565b5050565b601f821115620002c0576200028a8162000140565b620002958462000152565b81016020851015620002a5578190505b620002bd620002b48562000152565b8301826200024f565b50505b505050565b5f82821c905092915050565b5f620002e25f1984600802620002c5565b1980831691505092915050565b5f620002fc8383620002d1565b9150826002028217905092915050565b6200031782620000a8565b67ffffffffffffffff811115620003335762000332620000b2565b5b6200033f82546200010c565b6200034c82828562000275565b5f60209050601f83116001811462000382575f84156200036d578287015190505b620003798582620002ef565b865550620003e8565b601f198416620003928662000140565b5f5b82811015620003bb5784890151825560018201915060208501945060208101905062000394565b86831015620003db5784890151620003d7601f891682620002d1565b8355505b6001600288020188555050505b505050505050565b611d7780620003fe5f395ff3fe608060405234801561000f575f80fd5b50600436106100e8575f3560e01c806370a082311161008a578063a22cb46511610064578063a22cb46514610258578063b88d4fde14610274578063c87b56dd14610290578063e985e9c5146102c0576100e8565b806370a08231146101ee57806395d89b411461021e578063a14481941461023c576100e8565b8063095ea7b3116100c6578063095ea7b31461016a57806323b872dd1461018657806342842e0e146101a25780636352211e146101be576100e8565b806301ffc9a7146100ec57806306fdde031461011c578063081812fc1461013a575b5f80fd5b61010660048036038101906101019190611608565b6102f0565b604051610113919061164d565b60405180910390f35b6101246103d1565b60405161013191906116f0565b60405180910390f35b610154600480360381019061014f9190611743565b610460565b60405161016191906117ad565b60405180910390f35b610184600480360381019061017f91906117f0565b61047b565b005b6101a0600480360381019061019b919061182e565b610489565b005b6101bc60048036038101906101b7919061182e565b610588565b005b6101d860048036038101906101d39190611743565b6105a7565b6040516101e591906117ad565b60405180910390f35b6102086004803603810190610203919061187e565b6105b8565b60405161021591906118b8565b60405180910390f35b61022661066e565b60405161023391906116f0565b60405180910390f35b610256600480360381019061025191906117f0565b6106fe565b005b610272600480360381019061026d91906118fb565b61070c565b005b61028e60048036038101906102899190611a65565b610722565b005b6102aa60048036038101906102a59190611743565b610747565b6040516102b791906116f0565b60405180910390f35b6102da60048036038101906102d59190611ae5565b6107ad565b6040516102e7919061164d565b60405180910390f35b5f7f80ac58cd000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806103ba57507f5b5e139f000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b806103ca57506103c98261083b565b5b9050919050565b60605f80546103df90611b50565b80601f016020809104026020016040519081016040528092919081815260200182805461040b90611b50565b80156104565780601f1061042d57610100808354040283529160200191610456565b820191905f5260205f20905b81548152906001019060200180831161043957829003601f168201915b5050505050905090565b5f61046a826108a4565b506104748261092a565b9050919050565b6104858282610963565b5050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036104f9575f6040517f64a0ae920000000000000000000000000000000000000000000000000000000081526004016104f091906117ad565b60405180910390fd5b5f61050c8383610507610979565b610980565b90508373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610582578382826040517f64283d7b00000000000000000000000000000000000000000000000000000000815260040161057993929190611b80565b60405180910390fd5b50505050565b6105a283838360405180602001604052805f815250610722565b505050565b5f6105b182610b8b565b9050919050565b5f8073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610629575f6040517f89c62b6400000000000000000000000000000000000000000000000000000000815260040161062091906117ad565b60405180910390fd5b60035f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b60606001805461067d90611b50565b80601f01602080910402602001604051908101604052809291908181526020018280546106a990611b50565b80156106f45780601f106106cb576101008083540402835291602001916106f4565b820191905f5260205f20905b8154815290600101906020018083116106d757829003601f168201915b5050505050905090565b6107088282610b9c565b5050565b61071e610717610979565b8383610bb9565b5050565b61072d848484610489565b610741610738610979565b85858585610d22565b50505050565b6060610752826108a4565b505f61075c610ece565b90505f81511161077a5760405180602001604052805f8152506107a5565b8061078484610ee4565b604051602001610795929190611bef565b6040516020818303038152906040525b915050919050565b5f60055f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16905092915050565b5f7f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916149050919050565b5f806108af83610fae565b90505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361092157826040517f7e27328900000000000000000000000000000000000000000000000000000000815260040161091891906118b8565b60405180910390fd5b80915050919050565b5f60045f8381526020019081526020015f205f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b6109758282610970610979565b610fe7565b5050565b5f33905090565b5f8061098b84610fae565b90505f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16146109cc576109cb818486610ff9565b5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610a5757610a0b5f855f806110bc565b600160035f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825403925050819055505b5f73ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1614610ad657600160035f8773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8460025f8681526020019081526020015f205f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550838573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a4809150509392505050565b5f610b95826108a4565b9050919050565b610bb5828260405180602001604052805f81525061127b565b5050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610c2957816040517f5b08ba18000000000000000000000000000000000000000000000000000000008152600401610c2091906117ad565b60405180910390fd5b8060055f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3183604051610d15919061164d565b60405180910390a3505050565b5f8373ffffffffffffffffffffffffffffffffffffffff163b1115610ec7578273ffffffffffffffffffffffffffffffffffffffff1663150b7a02868685856040518563ffffffff1660e01b8152600401610d809493929190611c64565b6020604051808303815f875af1925050508015610dbb57506040513d601f19601f82011682018060405250810190610db89190611cc2565b60015b610e3c573d805f8114610de9576040519150601f19603f3d011682016040523d82523d5f602084013e610dee565b606091505b505f815103610e3457836040517f64a0ae92000000000000000000000000000000000000000000000000000000008152600401610e2b91906117ad565b60405180910390fd5b805181602001fd5b63150b7a0260e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614610ec557836040517f64a0ae92000000000000000000000000000000000000000000000000000000008152600401610ebc91906117ad565b60405180910390fd5b505b5050505050565b606060405180602001604052805f815250905090565b60605f6001610ef28461129e565b0190505f8167ffffffffffffffff811115610f1057610f0f611941565b5b6040519080825280601f01601f191660200182016040528015610f425781602001600182028036833780820191505090505b5090505f82602001820190505b600115610fa3578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581610f9857610f97611ced565b5b0494505f8503610f4f575b819350505050919050565b5f60025f8381526020019081526020015f205f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b610ff483838360016110bc565b505050565b6110048383836113ef565b6110b7575f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361107857806040517f7e27328900000000000000000000000000000000000000000000000000000000815260040161106f91906118b8565b60405180910390fd5b81816040517f177e802f0000000000000000000000000000000000000000000000000000000081526004016110ae929190611d1a565b60405180910390fd5b505050565b80806110f457505f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614155b15611226575f611103846108a4565b90505f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415801561116d57508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614155b8015611180575061117e81846107ad565b155b156111c257826040517fa9fbf51f0000000000000000000000000000000000000000000000000000000081526004016111b991906117ad565b60405180910390fd5b811561122457838573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45b505b8360045f8581526020019081526020015f205f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050505050565b61128583836114af565b611299611290610979565b5f858585610d22565b505050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106112fa577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816112f0576112ef611ced565b5b0492506040810190505b6d04ee2d6d415b85acef81000000008310611337576d04ee2d6d415b85acef8100000000838161132d5761132c611ced565b5b0492506020810190505b662386f26fc10000831061136657662386f26fc10000838161135c5761135b611ced565b5b0492506010810190505b6305f5e100831061138f576305f5e100838161138557611384611ced565b5b0492506008810190505b61271083106113b45761271083816113aa576113a9611ced565b5b0492506004810190505b606483106113d757606483816113cd576113cc611ced565b5b0492506002810190505b600a83106113e6576001810190505b80915050919050565b5f8073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141580156114a657508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161480611467575061146684846107ad565b5b806114a557508273ffffffffffffffffffffffffffffffffffffffff1661148d8361092a565b73ffffffffffffffffffffffffffffffffffffffff16145b5b90509392505050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361151f575f6040517f64a0ae9200000000000000000000000000000000000000000000000000000000815260040161151691906117ad565b60405180910390fd5b5f61152b83835f610980565b90505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161461159d575f6040517f73c6ac6e00000000000000000000000000000000000000000000000000000000815260040161159491906117ad565b60405180910390fd5b505050565b5f604051905090565b5f80fd5b5f80fd5b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6115e7816115b3565b81146115f1575f80fd5b50565b5f81359050611602816115de565b92915050565b5f6020828403121561161d5761161c6115ab565b5b5f61162a848285016115f4565b91505092915050565b5f8115159050919050565b61164781611633565b82525050565b5f6020820190506116605f83018461163e565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f5b8381101561169d578082015181840152602081019050611682565b5f8484015250505050565b5f601f19601f8301169050919050565b5f6116c282611666565b6116cc8185611670565b93506116dc818560208601611680565b6116e5816116a8565b840191505092915050565b5f6020820190508181035f83015261170881846116b8565b905092915050565b5f819050919050565b61172281611710565b811461172c575f80fd5b50565b5f8135905061173d81611719565b92915050565b5f60208284031215611758576117576115ab565b5b5f6117658482850161172f565b91505092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6117978261176e565b9050919050565b6117a78161178d565b82525050565b5f6020820190506117c05f83018461179e565b92915050565b6117cf8161178d565b81146117d9575f80fd5b50565b5f813590506117ea816117c6565b92915050565b5f8060408385031215611806576118056115ab565b5b5f611813858286016117dc565b92505060206118248582860161172f565b9150509250929050565b5f805f60608486031215611845576118446115ab565b5b5f611852868287016117dc565b9350506020611863868287016117dc565b92505060406118748682870161172f565b9150509250925092565b5f60208284031215611893576118926115ab565b5b5f6118a0848285016117dc565b91505092915050565b6118b281611710565b82525050565b5f6020820190506118cb5f8301846118a9565b92915050565b6118da81611633565b81146118e4575f80fd5b50565b5f813590506118f5816118d1565b92915050565b5f8060408385031215611911576119106115ab565b5b5f61191e858286016117dc565b925050602061192f858286016118e7565b9150509250929050565b5f80fd5b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b611977826116a8565b810181811067ffffffffffffffff8211171561199657611995611941565b5b80604052505050565b5f6119a86115a2565b90506119b4828261196e565b919050565b5f67ffffffffffffffff8211156119d3576119d2611941565b5b6119dc826116a8565b9050602081019050919050565b828183375f83830152505050565b5f611a09611a04846119b9565b61199f565b905082815260208101848484011115611a2557611a2461193d565b5b611a308482856119e9565b509392505050565b5f82601f830112611a4c57611a4b611939565b5b8135611a5c8482602086016119f7565b91505092915050565b5f805f8060808587031215611a7d57611a7c6115ab565b5b5f611a8a878288016117dc565b9450506020611a9b878288016117dc565b9350506040611aac8782880161172f565b925050606085013567ffffffffffffffff811115611acd57611acc6115af565b5b611ad987828801611a38565b91505092959194509250565b5f8060408385031215611afb57611afa6115ab565b5b5f611b08858286016117dc565b9250506020611b19858286016117dc565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680611b6757607f821691505b602082108103611b7a57611b79611b23565b5b50919050565b5f606082019050611b935f83018661179e565b611ba060208301856118a9565b611bad604083018461179e565b949350505050565b5f81905092915050565b5f611bc982611666565b611bd38185611bb5565b9350611be3818560208601611680565b80840191505092915050565b5f611bfa8285611bbf565b9150611c068284611bbf565b91508190509392505050565b5f81519050919050565b5f82825260208201905092915050565b5f611c3682611c12565b611c408185611c1c565b9350611c50818560208601611680565b611c59816116a8565b840191505092915050565b5f608082019050611c775f83018761179e565b611c84602083018661179e565b611c9160408301856118a9565b8181036060830152611ca38184611c2c565b905095945050505050565b5f81519050611cbc816115de565b92915050565b5f60208284031215611cd757611cd66115ab565b5b5f611ce484828501611cae565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f604082019050611d2d5f83018561179e565b611d3a60208301846118a9565b939250505056fea264697066735822122076bd71be3fdee3ce4ce4a172354a2fae2f744c0c2690c688693e6e1cf07dea0a64736f6c63430008180033\")]\n    // SPDX-License-Identifier: MIT\n    // Compatible with OpenZeppelin Contracts ^5.0.0\n    contract ERC721Mock is ERC721 {\n        constructor() ERC721(\"ERC721Mock\", \"MTK\") {}\n\n        function safeMint(address to, uint256 tokenId) public {\n            _safeMint(to, tokenId);\n        }\n\n        function ownerOf(uint256 tokenId) public view override returns (address) {\n            return super.ownerOf(tokenId);\n        }\n\n        function approve(address to, uint256 tokenId) public override  {\n            super.approve(to, tokenId);\n        }\n\n        function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public override {\n            super.safeTransferFrom(from, to, tokenId, data);\n        }\n\n        function balanceOf(address owner) public view override returns (uint256) {\n            return super.balanceOf(owner);\n        }\n    }\n}\n\npub async fn deploy(wallet: \u0026Wallet) -\u003e eyre::Result\u003cAddress\u003e {\n    // Deploy the contract.\n    let contract = ERC721Mock::deploy(wallet).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","erc721-wrapper","tests","mock","mod.rs"],"content":"pub mod erc721;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","merkle-proofs","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse alloy_primitives::B256;\nuse openzeppelin_crypto::{\n    merkle::{self, Verifier},\n    KeccakBuilder,\n};\nuse stylus_sdk::{alloy_sol_types::sol, prelude::*};\n\nsol! {\n    error MerkleProofInvalidMultiProofLength();\n    error MerkleProofInvalidRootChild();\n    error MerkleProofInvalidTotalHashes();\n    error MerkleProofNoLeaves();\n}\n\n#[derive(SolidityError)]\nenum VerifierError {\n    InvalidProofLength(MerkleProofInvalidMultiProofLength),\n    InvalidRootChild(MerkleProofInvalidRootChild),\n    InvalidTotalHashes(MerkleProofInvalidTotalHashes),\n    NoLeaves(MerkleProofNoLeaves),\n}\n\nimpl core::convert::From\u003cmerkle::MultiProofError\u003e for VerifierError {\n    fn from(value: merkle::MultiProofError) -\u003e Self {\n        match value {\n            merkle::MultiProofError::InvalidProofLength =\u003e {\n                VerifierError::InvalidProofLength(\n                    MerkleProofInvalidMultiProofLength {},\n                )\n            }\n            merkle::MultiProofError::InvalidRootChild =\u003e {\n                VerifierError::InvalidRootChild(MerkleProofInvalidRootChild {})\n            }\n            merkle::MultiProofError::InvalidTotalHashes =\u003e {\n                VerifierError::InvalidTotalHashes(\n                    MerkleProofInvalidTotalHashes {},\n                )\n            }\n            merkle::MultiProofError::NoLeaves =\u003e {\n                VerifierError::NoLeaves(MerkleProofNoLeaves {})\n            }\n        }\n    }\n}\n\n#[entrypoint]\n#[storage]\nstruct VerifierContract;\n\n#[public]\nimpl VerifierContract {\n    fn verify(\u0026self, proof: Vec\u003cB256\u003e, root: B256, leaf: B256) -\u003e bool {\n        let proof: Vec\u003c[u8; 32]\u003e = proof.into_iter().map(|m| *m).collect();\n        Verifier::\u003cKeccakBuilder\u003e::verify(\u0026proof, *root, *leaf)\n    }\n\n    fn verify_multi_proof(\n        \u0026self,\n        proof: Vec\u003cB256\u003e,\n        proof_flags: Vec\u003cbool\u003e,\n        root: B256,\n        leaves: Vec\u003cB256\u003e,\n    ) -\u003e Result\u003cbool, VerifierError\u003e {\n        let proof: Vec\u003c[u8; 32]\u003e = proof.into_iter().map(|m| *m).collect();\n        let leaves: Vec\u003c[u8; 32]\u003e = leaves.into_iter().map(|m| *m).collect();\n        Ok(Verifier::\u003cKeccakBuilder\u003e::verify_multi_proof(\n            \u0026proof,\n            \u0026proof_flags,\n            *root,\n            \u0026leaves,\n        )?)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","merkle-proofs","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    merkle_proofs_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ownable","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse alloy_primitives::{Address, U256};\nuse openzeppelin_stylus::{\n    access::ownable::{self, IOwnable, Ownable},\n    token::erc20::{self, Erc20, IErc20},\n};\nuse stylus_sdk::prelude::*;\n\n#[derive(SolidityError, Debug)]\nenum Error {\n    InsufficientBalance(erc20::ERC20InsufficientBalance),\n    InvalidSender(erc20::ERC20InvalidSender),\n    InvalidReceiver(erc20::ERC20InvalidReceiver),\n    InsufficientAllowance(erc20::ERC20InsufficientAllowance),\n    InvalidSpender(erc20::ERC20InvalidSpender),\n    InvalidApprover(erc20::ERC20InvalidApprover),\n    UnauthorizedAccount(ownable::OwnableUnauthorizedAccount),\n    InvalidOwner(ownable::OwnableInvalidOwner),\n}\n\nimpl From\u003cerc20::Error\u003e for Error {\n    fn from(value: erc20::Error) -\u003e Self {\n        match value {\n            erc20::Error::InsufficientBalance(e) =\u003e {\n                Error::InsufficientBalance(e)\n            }\n            erc20::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc20::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc20::Error::InsufficientAllowance(e) =\u003e {\n                Error::InsufficientAllowance(e)\n            }\n            erc20::Error::InvalidSpender(e) =\u003e Error::InvalidSpender(e),\n            erc20::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n        }\n    }\n}\n\nimpl From\u003cownable::Error\u003e for Error {\n    fn from(value: ownable::Error) -\u003e Self {\n        match value {\n            ownable::Error::UnauthorizedAccount(e) =\u003e {\n                Error::UnauthorizedAccount(e)\n            }\n            ownable::Error::InvalidOwner(e) =\u003e Error::InvalidOwner(e),\n        }\n    }\n}\n\n#[entrypoint]\n#[storage]\nstruct OwnableExample {\n    erc20: Erc20,\n    ownable: Ownable,\n}\n\n#[public]\n#[implements(IErc20\u003cError = Error\u003e, IOwnable\u003cError = Error\u003e)]\nimpl OwnableExample {\n    #[constructor]\n    fn constructor(\u0026mut self, initial_owner: Address) -\u003e Result\u003c(), Error\u003e {\n        Ok(self.ownable.constructor(initial_owner)?)\n    }\n}\n\n#[public]\nimpl IErc20 for OwnableExample {\n    type Error = Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.erc20.total_supply()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.erc20.balance_of(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.ownable.only_owner()?;\n        Ok(self.erc20.transfer(to, value)?)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.erc20.allowance(owner, spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.approve(spender, value)?)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer_from(from, to, value)?)\n    }\n}\n\n#[public]\nimpl IOwnable for OwnableExample {\n    type Error = Error;\n\n    fn owner(\u0026self) -\u003e Address {\n        self.ownable.owner()\n    }\n\n    fn transfer_ownership(\n        \u0026mut self,\n        new_owner: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.ownable.transfer_ownership(new_owner)?)\n    }\n\n    fn renounce_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.ownable.renounce_ownership()?)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ownable","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    ownable_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ownable","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n   contract Ownable {\n        error OwnableUnauthorizedAccount(address account);\n        error OwnableInvalidOwner(address owner);\n\n        #[derive(Debug, PartialEq)]\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        function owner() public view virtual returns (address owner);\n        function renounceOwnership() public virtual onlyOwner;\n        function transferOwnership(address newOwner) public virtual;\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ownable","tests","ownable.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::{Ownable, Ownable::OwnershipTransferred};\nuse alloy::primitives::Address;\nuse e2e::{\n    constructor, receipt, send, Account, Constructor,\n    ContractInitializationError, EventExt, Revert,\n};\nuse eyre::Result;\n\nmod abi;\n\nfn ctr(owner: Address) -\u003e Constructor {\n    constructor!(owner)\n}\n\n// ============================================================================\n// Integration Tests: Ownable\n// ============================================================================\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let receipt =\n        alice.as_deployer().with_constructor(ctr(alice_addr)).deploy().await?;\n    let contract = Ownable::new(receipt.contract_address, \u0026alice.wallet);\n\n    assert!(receipt.emits(OwnershipTransferred {\n        previousOwner: Address::ZERO,\n        newOwner: alice_addr,\n    }));\n\n    let Ownable::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, alice_addr);\n    Ok(())\n}\n\n#[e2e::test]\nasync fn rejects_zero_address_initial_owner(alice: Account) -\u003e Result\u003c()\u003e {\n    let err = alice\n        .as_deployer()\n        .with_constructor(ctr(Address::ZERO))\n        .deploy()\n        .await\n        .expect_err(\"should not deploy due to `OwnableInvalidOwner`\");\n\n    // TODO: assert the actual `OwnableInvalidOwner` error was returned once\n    // StylusDeployer is able to return the exact revert reason from\n    // constructors.\n    // assert!(err.reverted_with(Ownable::OwnableInvalidOwner { owner:\n    // Address::ZERO }));\n    assert!(err.downcast_ref::\u003cContractInitializationError\u003e().is_some());\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfers_ownership(alice: Account, bob: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable::new(contract_addr, \u0026alice.wallet);\n\n    let receipt = receipt!(contract.transferOwnership(bob_addr))?;\n    assert!(receipt.emits(OwnershipTransferred {\n        previousOwner: alice_addr,\n        newOwner: bob_addr,\n    }));\n\n    let Ownable::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, bob_addr);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn prevents_non_owners_from_transferring(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(bob_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable::new(contract_addr, \u0026alice.wallet);\n\n    let err = send!(contract.transferOwnership(bob_addr))\n        .expect_err(\"should not transfer when not owned\");\n    err.reverted_with(Ownable::OwnableUnauthorizedAccount {\n        account: alice_addr,\n    });\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn guards_against_stuck_state(alice: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable::new(contract_addr, \u0026alice.wallet);\n\n    let err = send!(contract.transferOwnership(Address::ZERO))\n        .expect_err(\"should not transfer to Address::ZERO\");\n    err.reverted_with(Ownable::OwnableInvalidOwner { owner: Address::ZERO });\n\n    let Ownable::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, alice_addr);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn loses_ownership_after_renouncement(alice: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable::new(contract_addr, \u0026alice.wallet);\n\n    let receipt = receipt!(contract.renounceOwnership())?;\n    assert!(receipt.emits(OwnershipTransferred {\n        previousOwner: alice_addr,\n        newOwner: Address::ZERO,\n    }));\n\n    let Ownable::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, Address::ZERO);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn prevents_non_owners_from_renouncement(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable::new(contract_addr, \u0026bob.wallet);\n\n    let err = send!(contract.renounceOwnership())\n        .expect_err(\"should prevent non-owner from renouncing\");\n    err.reverted_with(Ownable::OwnableUnauthorizedAccount {\n        account: bob_addr,\n    });\n\n    let Ownable::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, alice_addr);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ownable-two-step","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse alloy_primitives::{Address, U256};\nuse openzeppelin_stylus::{\n    access::{\n        ownable,\n        ownable_two_step::{IOwnable2Step, Ownable2Step},\n    },\n    token::erc20::{self, Erc20, IErc20},\n};\nuse stylus_sdk::prelude::*;\n\n#[derive(SolidityError, Debug)]\nenum Error {\n    InsufficientBalance(erc20::ERC20InsufficientBalance),\n    InvalidSender(erc20::ERC20InvalidSender),\n    InvalidReceiver(erc20::ERC20InvalidReceiver),\n    InsufficientAllowance(erc20::ERC20InsufficientAllowance),\n    InvalidSpender(erc20::ERC20InvalidSpender),\n    InvalidApprover(erc20::ERC20InvalidApprover),\n    UnauthorizedAccount(ownable::OwnableUnauthorizedAccount),\n    InvalidOwner(ownable::OwnableInvalidOwner),\n}\n\nimpl From\u003cerc20::Error\u003e for Error {\n    fn from(value: erc20::Error) -\u003e Self {\n        match value {\n            erc20::Error::InsufficientBalance(e) =\u003e {\n                Error::InsufficientBalance(e)\n            }\n            erc20::Error::InvalidSender(e) =\u003e Error::InvalidSender(e),\n            erc20::Error::InvalidReceiver(e) =\u003e Error::InvalidReceiver(e),\n            erc20::Error::InsufficientAllowance(e) =\u003e {\n                Error::InsufficientAllowance(e)\n            }\n            erc20::Error::InvalidSpender(e) =\u003e Error::InvalidSpender(e),\n            erc20::Error::InvalidApprover(e) =\u003e Error::InvalidApprover(e),\n        }\n    }\n}\n\nimpl From\u003cownable::Error\u003e for Error {\n    fn from(value: ownable::Error) -\u003e Self {\n        match value {\n            ownable::Error::UnauthorizedAccount(e) =\u003e {\n                Error::UnauthorizedAccount(e)\n            }\n            ownable::Error::InvalidOwner(e) =\u003e Error::InvalidOwner(e),\n        }\n    }\n}\n\n#[entrypoint]\n#[storage]\nstruct Ownable2StepExample {\n    erc20: Erc20,\n    ownable: Ownable2Step,\n}\n\n#[public]\n#[implements(IErc20\u003cError = Error\u003e, IOwnable2Step\u003cError = Error\u003e)]\nimpl Ownable2StepExample {\n    #[constructor]\n    fn constructor(\u0026mut self, initial_owner: Address) -\u003e Result\u003c(), Error\u003e {\n        Ok(self.ownable.constructor(initial_owner)?)\n    }\n}\n\n#[public]\nimpl IErc20 for Ownable2StepExample {\n    type Error = Error;\n\n    fn total_supply(\u0026self) -\u003e U256 {\n        self.erc20.total_supply()\n    }\n\n    fn balance_of(\u0026self, account: Address) -\u003e U256 {\n        self.erc20.balance_of(account)\n    }\n\n    fn transfer(\n        \u0026mut self,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        self.ownable.only_owner()?;\n        Ok(self.erc20.transfer(to, value)?)\n    }\n\n    fn allowance(\u0026self, owner: Address, spender: Address) -\u003e U256 {\n        self.erc20.allowance(owner, spender)\n    }\n\n    fn approve(\n        \u0026mut self,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.approve(spender, value)?)\n    }\n\n    fn transfer_from(\n        \u0026mut self,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        Ok(self.erc20.transfer_from(from, to, value)?)\n    }\n}\n\n#[public]\nimpl IOwnable2Step for Ownable2StepExample {\n    type Error = Error;\n\n    fn owner(\u0026self) -\u003e Address {\n        self.ownable.owner()\n    }\n\n    fn pending_owner(\u0026self) -\u003e Address {\n        self.ownable.pending_owner()\n    }\n\n    fn transfer_ownership(\n        \u0026mut self,\n        new_owner: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.ownable.transfer_ownership(new_owner)?)\n    }\n\n    fn accept_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.ownable.accept_ownership()?)\n    }\n\n    fn renounce_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(self.ownable.renounce_ownership()?)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ownable-two-step","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    ownable_two_step_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ownable-two-step","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n   contract Ownable2Step {\n        error OwnableUnauthorizedAccount(address account);\n        error OwnableInvalidOwner(address owner);\n\n        #[derive(Debug, PartialEq)]\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n        #[derive(Debug, PartialEq)]\n        event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n        function owner() public view virtual returns (address owner);\n        function pendingOwner() public view returns (address pendingOwner);\n        function renounceOwnership() public virtual onlyOwner;\n        function transferOwnership(address newOwner) public virtual;\n        function acceptOwnership() public virtual;\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","ownable-two-step","tests","ownable_two_step.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::{\n    Ownable2Step,\n    Ownable2Step::{OwnershipTransferStarted, OwnershipTransferred},\n};\nuse alloy::primitives::Address;\nuse e2e::{\n    constructor, receipt, send, Account, Constructor,\n    ContractInitializationError, EventExt, Revert,\n};\nuse eyre::Result;\n\nmod abi;\n\nfn ctr(owner: Address) -\u003e Constructor {\n    constructor!(owner)\n}\n\n// ============================================================================\n// Integration Tests: Ownable2Step\n// ============================================================================\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let receipt =\n        alice.as_deployer().with_constructor(ctr(alice_addr)).deploy().await?;\n    let contract = Ownable2Step::new(receipt.contract_address, \u0026alice.wallet);\n\n    assert!(receipt.emits(OwnershipTransferred {\n        previousOwner: Address::ZERO,\n        newOwner: alice_addr,\n    }));\n\n    let Ownable2Step::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, alice_addr);\n\n    let Ownable2Step::pendingOwnerReturn { pendingOwner } =\n        contract.pendingOwner().call().await?;\n    assert_eq!(pendingOwner, Address::ZERO);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn construct_reverts_when_owner_is_zero_address(\n    alice: Account,\n) -\u003e Result\u003c()\u003e {\n    let err = alice\n        .as_deployer()\n        .with_constructor(ctr(Address::ZERO))\n        .deploy()\n        .await\n        .expect_err(\"should not deploy due to `OwnableInvalidOwner`\");\n\n    // TODO: assert the actual `OwnableInvalidOwner` error was returned once\n    // StylusDeployer is able to return the exact revert reason from\n    // constructors. assert!(err.\n    // reverted_with(Ownable2Step::OwnableInvalidOwner {     owner:\n    // Address::ZERO }));\n\n    assert!(err.downcast_ref::\u003cContractInitializationError\u003e().is_some());\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfer_ownership_initiates_transfer(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable2Step::new(contract_addr, \u0026alice.wallet);\n\n    let receipt = receipt!(contract.transferOwnership(bob_addr))?;\n    assert!(receipt.emits(OwnershipTransferStarted {\n        previousOwner: alice_addr,\n        newOwner: bob_addr,\n    }));\n\n    // Current owner is still Alice\n    let Ownable2Step::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, alice_addr);\n\n    // Pending owner is Bob\n    let Ownable2Step::pendingOwnerReturn { pendingOwner } =\n        contract.pendingOwner().call().await?;\n    assert_eq!(pendingOwner, bob_addr);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfer_ownership_reverts_when_not_owner(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(bob_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable2Step::new(contract_addr, \u0026alice.wallet);\n\n    let err = send!(contract.transferOwnership(bob_addr))\n        .expect_err(\"should not transfer when not owned\");\n    err.reverted_with(Ownable2Step::OwnableUnauthorizedAccount {\n        account: alice_addr,\n    });\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn accept_ownership(alice: Account, bob: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable2Step::new(contract_addr, \u0026alice.wallet);\n    receipt!(contract.transferOwnership(bob_addr))?;\n\n    // Connect as Bob and accept ownership\n    let contract = Ownable2Step::new(contract_addr, \u0026bob.wallet);\n    let receipt = receipt!(contract.acceptOwnership())?;\n    assert!(receipt.emits(OwnershipTransferred {\n        previousOwner: alice_addr,\n        newOwner: bob_addr,\n    }));\n\n    let Ownable2Step::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, bob_addr);\n\n    let Ownable2Step::pendingOwnerReturn { pendingOwner } =\n        contract.pendingOwner().call().await?;\n    assert_eq!(pendingOwner, Address::ZERO);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn transfer_ownership_cancel_transfer(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable2Step::new(contract_addr, \u0026alice.wallet);\n    receipt!(contract.transferOwnership(bob_addr))?;\n\n    let receipt = receipt!(contract.transferOwnership(Address::ZERO))?;\n    assert!(receipt.emits(OwnershipTransferStarted {\n        previousOwner: alice_addr,\n        newOwner: Address::ZERO,\n    }));\n\n    let Ownable2Step::pendingOwnerReturn { pendingOwner } =\n        contract.pendingOwner().call().await?;\n    assert_eq!(pendingOwner, Address::ZERO);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn overwrite_previous_transfer_ownership(\n    alice: Account,\n    bob: Account,\n    charlie: Account,\n) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let charlie_addr = charlie.address();\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n\n    let contract = Ownable2Step::new(contract_addr, \u0026alice.wallet);\n\n    let receipt = receipt!(contract.transferOwnership(bob_addr))?;\n    assert!(receipt.emits(OwnershipTransferStarted {\n        previousOwner: alice_addr,\n        newOwner: bob_addr,\n    }));\n\n    let receipt = receipt!(contract.transferOwnership(charlie_addr))?;\n    assert!(receipt.emits(OwnershipTransferStarted {\n        previousOwner: alice_addr,\n        newOwner: charlie_addr,\n    }));\n\n    let Ownable2Step::pendingOwnerReturn { pendingOwner } =\n        contract.pendingOwner().call().await?;\n    assert_eq!(pendingOwner, charlie_addr);\n\n    // Connect as Bob and try to accept ownership\n    let contract = Ownable2Step::new(contract_addr, \u0026bob.wallet);\n    let err = send!(contract.acceptOwnership())\n        .expect_err(\"should not accept when not pending owner\");\n\n    err.reverted_with(Ownable2Step::OwnableUnauthorizedAccount {\n        account: bob_addr,\n    });\n\n    // Connect as Charlie and accept ownership\n    let contract = Ownable2Step::new(contract_addr, \u0026charlie.wallet);\n    let receipt = receipt!(contract.acceptOwnership())?;\n    assert!(receipt.emits(OwnershipTransferred {\n        previousOwner: alice_addr,\n        newOwner: charlie_addr,\n    }));\n\n    let Ownable2Step::pendingOwnerReturn { pendingOwner } =\n        contract.pendingOwner().call().await?;\n    assert_eq!(pendingOwner, Address::ZERO);\n\n    let Ownable2Step::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, charlie_addr);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn accept_ownership_reverts_when_not_pending_owner(\n    alice: Account,\n    bob: Account,\n    charlie: Account,\n) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let charlie_addr = charlie.address();\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable2Step::new(contract_addr, \u0026alice.wallet);\n    receipt!(contract.transferOwnership(bob_addr))?;\n\n    // Connect as Charlie and attempt to accept ownership\n    let contract = Ownable2Step::new(contract_addr, \u0026charlie.wallet);\n    let err = send!(contract.acceptOwnership())\n        .expect_err(\"should not accept when not pending owner\");\n    err.reverted_with(Ownable2Step::OwnableUnauthorizedAccount {\n        account: charlie_addr,\n    });\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn renounce_ownership(alice: Account) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable2Step::new(contract_addr, \u0026alice.wallet);\n\n    let receipt = receipt!(contract.renounceOwnership())?;\n    assert!(receipt.emits(OwnershipTransferred {\n        previousOwner: alice_addr,\n        newOwner: Address::ZERO,\n    }));\n\n    let Ownable2Step::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, Address::ZERO);\n\n    // Pending owner is set to zero\n    let Ownable2Step::pendingOwnerReturn { pendingOwner } =\n        contract.pendingOwner().call().await?;\n    assert_eq!(pendingOwner, Address::ZERO);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn renounce_ownership_reverts_when_not_owner(\n    alice: Account,\n    bob: Account,\n) -\u003e Result\u003c()\u003e {\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice_addr))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = Ownable2Step::new(contract_addr, \u0026bob.wallet);\n\n    let err = send!(contract.renounceOwnership())\n        .expect_err(\"should prevent non-owner from renouncing\");\n    err.reverted_with(Ownable2Step::OwnableUnauthorizedAccount {\n        account: bob_addr,\n    });\n\n    let Ownable2Step::ownerReturn { owner } = contract.owner().call().await?;\n    assert_eq!(owner, alice_addr);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","pedersen","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse openzeppelin_crypto::{\n    arithmetic::{uint::U256, BigInteger},\n    field::prime::PrimeField,\n    pedersen::{\n        instance::starknet::{StarknetCurveConfig, StarknetPedersenParams},\n        Pedersen,\n    },\n};\nuse stylus_sdk::prelude::*;\n\n#[entrypoint]\n#[storage]\nstruct PedersenExample;\n\n#[public]\nimpl PedersenExample {\n    fn hash(\n        \u0026mut self,\n        inputs: [alloy_primitives::U256; 2],\n    ) -\u003e alloy_primitives::U256 {\n        let hasher =\n            Pedersen::\u003cStarknetPedersenParams, StarknetCurveConfig\u003e::new();\n\n        let inputs: Vec\u003cU256\u003e = inputs\n            .iter()\n            .map(|x| U256::from_bytes_le(\u0026x.to_le_bytes_vec()))\n            .collect();\n\n        let hash = hasher.hash(inputs[0].into(), inputs[1].into());\n        let hash = hash.expect(\"Failed to hash\").into_bigint().into_bytes_le();\n\n        alloy_primitives::U256::from_le_slice(\u0026hash)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","pedersen","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    pedersen_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","pedersen","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n   contract PedersenExample {\n        #[derive(Debug)]\n        function hash(uint[2] memory inputs) external view returns (uint hash);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","pedersen","tests","pedersen.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse e2e::Account;\nuse eyre::Result;\nuse openzeppelin_crypto::arithmetic::{\n    uint::{from_str_hex, U256},\n    BigInteger,\n};\n\nuse crate::abi::PedersenExample;\n\nmod abi;\n\n// ============================================================================\n// Integration Tests: Pedersen\n// ============================================================================\n\nfn to_alloy_u256(value: \u0026U256) -\u003e alloy_primitives::U256 {\n    alloy_primitives::U256::from_le_slice(\u0026value.into_bytes_le())\n}\n\n#[e2e::test]\nasync fn pedersen_works(alice: Account) -\u003e Result\u003c()\u003e {\n    let input_1 = to_alloy_u256(\u0026from_str_hex(\n        \"3d937c035c878245caf64531a5756109c53068da139362728feb561405371cb\",\n    ));\n    let input_2 = to_alloy_u256(\u0026from_str_hex(\n        \"208a0a10250e382e1e4bbe2880906c2791bf6275695e02fbbc6aeff9cd8b31a\",\n    ));\n\n    let expected = to_alloy_u256(\u0026from_str_hex(\n        \"30e480bed5fe53fa909cc0f8c4d99b8f9f2c016be4c41e13a4848797979c662\",\n    ));\n\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = PedersenExample::new(contract_addr, \u0026alice.wallet);\n\n    let PedersenExample::hashReturn { hash } =\n        contract.hash([input_1, input_2]).call().await?;\n\n    assert_eq!(hash, expected);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","poseidon","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse alloc::vec::Vec;\n\nuse alloy_primitives::U256;\nuse openzeppelin_crypto::{\n    arithmetic::{uint::Uint, BigInteger},\n    field::{instance::FpBN256, prime::PrimeField},\n    poseidon2::{instance::bn256::BN256Params, Poseidon2},\n};\nuse stylus_sdk::prelude::*;\n\n#[entrypoint]\n#[storage]\nstruct PoseidonExample;\n\n#[public]\nimpl PoseidonExample {\n    fn hash(\u0026mut self, inputs: [U256; 2]) -\u003e U256 {\n        let mut hasher = Poseidon2::\u003cBN256Params, FpBN256\u003e::new();\n\n        for input in inputs.iter() {\n            let fp = FpBN256::from_bigint(Uint::from_bytes_le(\n                \u0026input.to_le_bytes_vec(),\n            ));\n            hasher.absorb(\u0026fp);\n        }\n\n        let hash = hasher.squeeze();\n        let hash = hash.into_bigint().into_bytes_le();\n\n        U256::from_le_slice(\u0026hash)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","poseidon","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    poseidon_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","poseidon","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n   contract PoseidonExample {\n        #[derive(Debug)]\n        function hash(uint[2] memory inputs) external view returns (uint hash);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","poseidon","tests","poseidon.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse alloy_primitives::{hex, uint, U256};\nuse e2e::Account;\nuse eyre::Result;\n\nuse crate::abi::PoseidonExample;\n\nmod abi;\n\n// ============================================================================\n// Integration Tests: Poseidon\n// ============================================================================\n\n#[e2e::test]\nasync fn poseidon_works(alice: Account) -\u003e Result\u003c()\u003e {\n    let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n    let contract = PoseidonExample::new(contract_addr, \u0026alice.wallet);\n\n    let PoseidonExample::hashReturn { hash } =\n        contract.hash([uint!(123_U256), uint!(123456_U256)]).call().await?;\n\n    let expected = U256::from_be_slice(\u0026hex!(\n        \"16f70722695a5829a59319fbf746df957a513fdf72b070a67bb72db08070e5de\"\n    ));\n\n    assert_eq!(hash, expected);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse openzeppelin_stylus::token::erc20::utils::safe_erc20::{\n    self, ISafeErc20, SafeErc20,\n};\nuse stylus_sdk::{\n    alloy_primitives::{Address, U256},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct SafeErc20Example {\n    safe_erc20: SafeErc20,\n}\n\n#[public]\n#[implements(ISafeErc20\u003cError = safe_erc20::Error\u003e)]\nimpl SafeErc20Example {}\n\n#[public]\nimpl ISafeErc20 for SafeErc20Example {\n    type Error = safe_erc20::Error;\n\n    fn safe_transfer(\n        \u0026mut self,\n        token: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.safe_erc20.safe_transfer(token, to, value)\n    }\n\n    fn safe_transfer_from(\n        \u0026mut self,\n        token: Address,\n        from: Address,\n        to: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.safe_erc20.safe_transfer_from(token, from, to, value)\n    }\n\n    fn safe_increase_allowance(\n        \u0026mut self,\n        token: Address,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.safe_erc20.safe_increase_allowance(token, spender, value)\n    }\n\n    fn safe_decrease_allowance(\n        \u0026mut self,\n        token: Address,\n        spender: Address,\n        requested_decrease: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.safe_erc20.safe_decrease_allowance(\n            token,\n            spender,\n            requested_decrease,\n        )\n    }\n\n    fn force_approve(\n        \u0026mut self,\n        token: Address,\n        spender: Address,\n        value: U256,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.safe_erc20.force_approve(token, spender, value)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    safe_erc20_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n    #[sol(rpc)]\n    contract SafeErc20 {\n        function safeTransfer(address token, address to, uint256 value) external;\n        function safeTransferFrom(address token, address from, address to, uint256 value) external;\n        function safeIncreaseAllowance(address token, address spender, uint256 value) external;\n        function safeDecreaseAllowance(address token, address spender, uint256 requestedDecrease) external;\n        function forceApprove(address token, address spender, uint256 value) external;\n\n        error SafeErc20FailedOperation(address token);\n        error SafeErc20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n    }\n\n    contract Erc20 {\n        error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n        #[derive(Debug, PartialEq)]\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        #[derive(Debug, PartialEq)]\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n    }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","mock","erc20.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.21+commit.d9974bed\n    #[sol(rpc, bytecode=\"608060405234801562000010575f80fd5b506040518060400160405280600981526020017f45524332304d6f636b00000000000000000000000000000000000000000000008152506040518060400160405280600381526020017f4d544b000000000000000000000000000000000000000000000000000000000081525081600390816200008e91906200030d565b508060049081620000a091906200030d565b505050620003f1565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806200012557607f821691505b6020821081036200013b576200013a620000e0565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026200019f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000162565b620001ab868362000162565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f620001f5620001ef620001e984620001c3565b620001cc565b620001c3565b9050919050565b5f819050919050565b6200021083620001d5565b620002286200021f82620001fc565b8484546200016e565b825550505050565b5f90565b6200023e62000230565b6200024b81848462000205565b505050565b5b818110156200027257620002665f8262000234565b60018101905062000251565b5050565b601f821115620002c1576200028b8162000141565b620002968462000153565b81016020851015620002a6578190505b620002be620002b58562000153565b83018262000250565b50505b505050565b5f82821c905092915050565b5f620002e35f1984600802620002c6565b1980831691505092915050565b5f620002fd8383620002d2565b9150826002028217905092915050565b6200031882620000a9565b67ffffffffffffffff811115620003345762000333620000b3565b5b6200034082546200010d565b6200034d82828562000276565b5f60209050601f83116001811462000383575f84156200036e578287015190505b6200037a8582620002f0565b865550620003e9565b601f198416620003938662000141565b5f5b82811015620003bc5784890151825560018201915060208501945060208101905062000395565b86831015620003dc5784890151620003d8601f891682620002d2565b8355505b6001600288020188555050505b505050505050565b610f4580620003ff5f395ff3fe608060405234801561000f575f80fd5b50600436106100a7575f3560e01c806340c10f191161006f57806340c10f191461016557806370a08231146101815780638483acfe146101b157806395d89b41146101cd578063a9059cbb146101eb578063dd62ed3e1461021b576100a7565b806306fdde03146100ab578063095ea7b3146100c957806318160ddd146100f957806323b872dd14610117578063313ce56714610147575b5f80fd5b6100b361024b565b6040516100c09190610bbe565b60405180910390f35b6100e360048036038101906100de9190610c6f565b6102db565b6040516100f09190610cc7565b60405180910390f35b6101016102ee565b60405161010e9190610cef565b60405180910390f35b610131600480360381019061012c9190610d08565b6102f7565b60405161013e9190610cc7565b60405180910390f35b61014f61030c565b60405161015c9190610d73565b60405180910390f35b61017f600480360381019061017a9190610c6f565b610314565b005b61019b60048036038101906101969190610d8c565b610322565b6040516101a89190610cef565b60405180910390f35b6101cb60048036038101906101c69190610d08565b610333565b005b6101d5610343565b6040516101e29190610bbe565b60405180910390f35b61020560048036038101906102009190610c6f565b6103d3565b6040516102129190610cc7565b60405180910390f35b61023560048036038101906102309190610db7565b6103e6565b6040516102429190610cef565b60405180910390f35b60606003805461025a90610e22565b80601f016020809104026020016040519081016040528092919081815260200182805461028690610e22565b80156102d15780601f106102a8576101008083540402835291602001916102d1565b820191905f5260205f20905b8154815290600101906020018083116102b457829003601f168201915b5050505050905090565b5f6102e683836103f9565b905092915050565b5f600254905090565b5f61030384848461041b565b90509392505050565b5f6012905090565b61031e8282610449565b5050565b5f61032c826104c8565b9050919050565b61033e83838361050d565b505050565b60606004805461035290610e22565b80601f016020809104026020016040519081016040528092919081815260200182805461037e90610e22565b80156103c95780601f106103a0576101008083540402835291602001916103c9565b820191905f5260205f20905b8154815290600101906020018083116103ac57829003601f168201915b5050505050905090565b5f6103de838361051f565b905092915050565b5f6103f18383610541565b905092915050565b5f806104036105c3565b905061041081858561050d565b600191505092915050565b5f806104256105c3565b90506104328582856105ca565b61043d85858561065c565b60019150509392505050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036104b9575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016104b09190610e61565b60405180910390fd5b6104c45f838361074c565b5050565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b61051a8383836001610965565b505050565b5f806105296105c3565b905061053681858561065c565b600191505092915050565b5f60015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f33905090565b5f6105d584846103e6565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146106565781811015610647578281836040517ffb8f41b200000000000000000000000000000000000000000000000000000000815260040161063e93929190610e7a565b60405180910390fd5b61065584848484035f610965565b5b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036106cc575f6040517f96c6fd1e0000000000000000000000000000000000000000000000000000000081526004016106c39190610e61565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361073c575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016107339190610e61565b60405180910390fd5b61074783838361074c565b505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361079c578060025f8282546107909190610edc565b9250508190555061086a565b5f805f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905081811015610825578381836040517fe450d38c00000000000000000000000000000000000000000000000000000000815260040161081c93929190610e7a565b60405180910390fd5b8181035f808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036108b1578060025f82825403925050819055506108fb565b805f808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516109589190610cef565b60405180910390a3505050565b5f73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16036109d5575f6040517fe602df050000000000000000000000000000000000000000000000000000000081526004016109cc9190610e61565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610a45575f6040517f94280d62000000000000000000000000000000000000000000000000000000008152600401610a3c9190610e61565b60405180910390fd5b8160015f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055508015610b2e578273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92584604051610b259190610cef565b60405180910390a35b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015610b6b578082015181840152602081019050610b50565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610b9082610b34565b610b9a8185610b3e565b9350610baa818560208601610b4e565b610bb381610b76565b840191505092915050565b5f6020820190508181035f830152610bd68184610b86565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610c0b82610be2565b9050919050565b610c1b81610c01565b8114610c25575f80fd5b50565b5f81359050610c3681610c12565b92915050565b5f819050919050565b610c4e81610c3c565b8114610c58575f80fd5b50565b5f81359050610c6981610c45565b92915050565b5f8060408385031215610c8557610c84610bde565b5b5f610c9285828601610c28565b9250506020610ca385828601610c5b565b9150509250929050565b5f8115159050919050565b610cc181610cad565b82525050565b5f602082019050610cda5f830184610cb8565b92915050565b610ce981610c3c565b82525050565b5f602082019050610d025f830184610ce0565b92915050565b5f805f60608486031215610d1f57610d1e610bde565b5b5f610d2c86828701610c28565b9350506020610d3d86828701610c28565b9250506040610d4e86828701610c5b565b9150509250925092565b5f60ff82169050919050565b610d6d81610d58565b82525050565b5f602082019050610d865f830184610d64565b92915050565b5f60208284031215610da157610da0610bde565b5b5f610dae84828501610c28565b91505092915050565b5f8060408385031215610dcd57610dcc610bde565b5b5f610dda85828601610c28565b9250506020610deb85828601610c28565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610e3957607f821691505b602082108103610e4c57610e4b610df5565b5b50919050565b610e5b81610c01565b82525050565b5f602082019050610e745f830184610e52565b92915050565b5f606082019050610e8d5f830186610e52565b610e9a6020830185610ce0565b610ea76040830184610ce0565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610ee682610c3c565b9150610ef183610c3c565b9250828201905080821115610f0957610f08610eaf565b5b9291505056fea2646970667358221220383e898342e74543d1bfb6186eff00b4ae7a39d4ecde6190742c5e9f2a7a2e9364736f6c63430008150033\")]\n    // SPDX-License-Identifier: MIT\n    contract ERC20Mock is ERC20 {\n        constructor() ERC20(\"ERC20Mock\", \"MTK\") {}\n\n        function approve(address spender, uint256 value) public override returns (bool) {\n            return super.approve(spender, value);\n        }\n\n        function regular_approve(address owner, address spender, uint256 amount) public {\n            super._approve(owner, spender, amount);\n        }\n\n        function balanceOf(address account) public override view returns (uint256) {\n            return super.balanceOf(account);\n        }\n\n        function mint(address account, uint256 value) public {\n            super._mint(account, value);\n        }\n\n        function transfer(address to, uint256 amount) public override returns (bool) {\n            return super.transfer(to, amount);\n        }\n\n        function transferFrom(address from, address to, uint256 value) public override returns (bool) {\n            return super.transferFrom(from, to, value);\n        }\n\n        function allowance(address owner, address spender) public view override returns (uint256) {\n            return super.allowance(owner, spender);\n        }\n    }\n}\n\npub async fn deploy(wallet: \u0026Wallet) -\u003e eyre::Result\u003cAddress\u003e {\n    // Deploy the contract.\n    let contract = ERC20Mock::deploy(wallet).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","mock","erc20_force_approve.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.21+commit.d9974bed\n    #[sol(rpc, bytecode=\"608060405234801562000010575f80fd5b506040518060400160405280601581526020017f4552433230466f726365417070726f76654d6f636b00000000000000000000008152506040518060400160405280600381526020017f46414d000000000000000000000000000000000000000000000000000000000081525081600390816200008e91906200030d565b508060049081620000a091906200030d565b505050620003f1565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806200012557607f821691505b6020821081036200013b576200013a620000e0565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026200019f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000162565b620001ab868362000162565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f620001f5620001ef620001e984620001c3565b620001cc565b620001c3565b9050919050565b5f819050919050565b6200021083620001d5565b620002286200021f82620001fc565b8484546200016e565b825550505050565b5f90565b6200023e62000230565b6200024b81848462000205565b505050565b5b818110156200027257620002665f8262000234565b60018101905062000251565b5050565b601f821115620002c1576200028b8162000141565b620002968462000153565b81016020851015620002a6578190505b620002be620002b58562000153565b83018262000250565b50505b505050565b5f82821c905092915050565b5f620002e35f1984600802620002c6565b1980831691505092915050565b5f620002fd8383620002d2565b9150826002028217905092915050565b6200031882620000a9565b67ffffffffffffffff811115620003345762000333620000b3565b5b6200034082546200010d565b6200034d82828562000276565b5f60209050601f83116001811462000383575f84156200036e578287015190505b6200037a8582620002f0565b865550620003e9565b601f198416620003938662000141565b5f5b82811015620003bc5784890151825560018201915060208501945060208101905062000395565b86831015620003dc5784890151620003d8601f891682620002d2565b8355505b6001600288020188555050505b505050505050565b610f1580620003ff5f395ff3fe608060405234801561000f575f80fd5b506004361061009c575f3560e01c806370a082311161006457806370a082311461015a5780638483acfe1461018a57806395d89b41146101a6578063a9059cbb146101c4578063dd62ed3e146101f45761009c565b806306fdde03146100a0578063095ea7b3146100be57806318160ddd146100ee57806323b872dd1461010c578063313ce5671461013c575b5f80fd5b6100a8610224565b6040516100b59190610b26565b60405180910390f35b6100d860048036038101906100d39190610bd7565b6102b4565b6040516100e59190610c2f565b60405180910390f35b6100f661031c565b6040516101039190610c57565b60405180910390f35b61012660048036038101906101219190610c70565b610325565b6040516101339190610c2f565b60405180910390f35b610144610353565b6040516101519190610cdb565b60405180910390f35b610174600480360381019061016f9190610cf4565b61035b565b6040516101819190610c57565b60405180910390f35b6101a4600480360381019061019f9190610c70565b6103a0565b005b6101ae6103b0565b6040516101bb9190610b26565b60405180910390f35b6101de60048036038101906101d99190610bd7565b610440565b6040516101eb9190610c2f565b60405180910390f35b61020e60048036038101906102099190610d1f565b610462565b60405161021b9190610c57565b60405180910390f35b60606003805461023390610d8a565b80601f016020809104026020016040519081016040528092919081815260200182805461025f90610d8a565b80156102aa5780601f10610281576101008083540402835291602001916102aa565b820191905f5260205f20905b81548152906001019060200180831161028d57829003601f168201915b5050505050905090565b5f808214806102cb57505f6102c93385610462565b145b61030a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030190610e04565b60405180910390fd5b6103148383610475565b905092915050565b5f600254905090565b5f8061032f610497565b905061033c85828561049e565b610347858585610530565b60019150509392505050565b5f6012905090565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b6103ab838383610620565b505050565b6060600480546103bf90610d8a565b80601f01602080910402602001604051908101604052809291908181526020018280546103eb90610d8a565b80156104365780601f1061040d57610100808354040283529160200191610436565b820191905f5260205f20905b81548152906001019060200180831161041957829003601f168201915b5050505050905090565b5f8061044a610497565b9050610457818585610530565b600191505092915050565b5f61046d8383610632565b905092915050565b5f8061047f610497565b905061048c818585610620565b600191505092915050565b5f33905090565b5f6104a98484610462565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811461052a578181101561051b578281836040517ffb8f41b200000000000000000000000000000000000000000000000000000000815260040161051293929190610e31565b60405180910390fd5b61052984848484035f6106b4565b5b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036105a0575f6040517f96c6fd1e0000000000000000000000000000000000000000000000000000000081526004016105979190610e66565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610610575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016106079190610e66565b60405180910390fd5b61061b838383610883565b505050565b61062d83838360016106b4565b505050565b5f60015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603610724575f6040517fe602df0500000000000000000000000000000000000000000000000000000000815260040161071b9190610e66565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610794575f6040517f94280d6200000000000000000000000000000000000000000000000000000000815260040161078b9190610e66565b60405180910390fd5b8160015f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550801561087d578273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040516108749190610c57565b60405180910390a35b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036108d3578060025f8282546108c79190610eac565b925050819055506109a1565b5f805f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205490508181101561095c578381836040517fe450d38c00000000000000000000000000000000000000000000000000000000815260040161095393929190610e31565b60405180910390fd5b8181035f808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036109e8578060025f8282540392505081905550610a32565b805f808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83604051610a8f9190610c57565b60405180910390a3505050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015610ad3578082015181840152602081019050610ab8565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610af882610a9c565b610b028185610aa6565b9350610b12818560208601610ab6565b610b1b81610ade565b840191505092915050565b5f6020820190508181035f830152610b3e8184610aee565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610b7382610b4a565b9050919050565b610b8381610b69565b8114610b8d575f80fd5b50565b5f81359050610b9e81610b7a565b92915050565b5f819050919050565b610bb681610ba4565b8114610bc0575f80fd5b50565b5f81359050610bd181610bad565b92915050565b5f8060408385031215610bed57610bec610b46565b5b5f610bfa85828601610b90565b9250506020610c0b85828601610bc3565b9150509250929050565b5f8115159050919050565b610c2981610c15565b82525050565b5f602082019050610c425f830184610c20565b92915050565b610c5181610ba4565b82525050565b5f602082019050610c6a5f830184610c48565b92915050565b5f805f60608486031215610c8757610c86610b46565b5b5f610c9486828701610b90565b9350506020610ca586828701610b90565b9250506040610cb686828701610bc3565b9150509250925092565b5f60ff82169050919050565b610cd581610cc0565b82525050565b5f602082019050610cee5f830184610ccc565b92915050565b5f60208284031215610d0957610d08610b46565b5b5f610d1684828501610b90565b91505092915050565b5f8060408385031215610d3557610d34610b46565b5b5f610d4285828601610b90565b9250506020610d5385828601610b90565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610da157607f821691505b602082108103610db457610db3610d5d565b5b50919050565b7f5553445420617070726f76616c206661696c75726500000000000000000000005f82015250565b5f610dee601583610aa6565b9150610df982610dba565b602082019050919050565b5f6020820190508181035f830152610e1b81610de2565b9050919050565b610e2b81610b69565b82525050565b5f606082019050610e445f830186610e22565b610e516020830185610c48565b610e5e6040830184610c48565b949350505050565b5f602082019050610e795f830184610e22565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610eb682610ba4565b9150610ec183610ba4565b9250828201905080821115610ed957610ed8610e7f565b5b9291505056fea26469706673582212204360bd31161a5a21172e203aecf5b49d953f1b1c8a64d9d0e539c9c81467f7b064736f6c63430008150033\")]\n    // SPDX-License-Identifier: MIT\n    contract ERC20ForceApproveMock is ERC20 {\n        constructor() ERC20(\"ERC20ForceApproveMock\", \"FAM\") {}\n\n        function approve(address spender, uint256 amount) public virtual override returns (bool) {\n            require(amount == 0 || allowance(msg.sender, spender) == 0, \"USDT approval failure\");\n            return super.approve(spender, amount);\n        }\n\n        function regular_approve(address owner, address spender, uint256 amount) public {\n            super._approve(owner, spender, amount);\n        }\n\n        function allowance(address owner, address spender) public view override returns (uint256) {\n            return super.allowance(owner, spender);\n        }\n    }\n}\n\npub async fn deploy(wallet: \u0026Wallet) -\u003e eyre::Result\u003cAddress\u003e {\n    // Deploy the contract.\n    let contract = ERC20ForceApproveMock::deploy(wallet).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","mock","erc20_no_return.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.21+commit.d9974bed\n    #[sol(rpc, bytecode=\"608060405234801562000010575f80fd5b506040518060400160405280601181526020017f45524332304e6f52657475726e4d6f636b0000000000000000000000000000008152506040518060400160405280600381526020017f4e524d000000000000000000000000000000000000000000000000000000000081525081600390816200008e91906200030d565b508060049081620000a091906200030d565b505050620003f1565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806200012557607f821691505b6020821081036200013b576200013a620000e0565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026200019f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000162565b620001ab868362000162565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f620001f5620001ef620001e984620001c3565b620001cc565b620001c3565b9050919050565b5f819050919050565b6200021083620001d5565b620002286200021f82620001fc565b8484546200016e565b825550505050565b5f90565b6200023e62000230565b6200024b81848462000205565b505050565b5b818110156200027257620002665f8262000234565b60018101905062000251565b5050565b601f821115620002c1576200028b8162000141565b620002968462000153565b81016020851015620002a6578190505b620002be620002b58562000153565b83018262000250565b50505b505050565b5f82821c905092915050565b5f620002e35f1984600802620002c6565b1980831691505092915050565b5f620002fd8383620002d2565b9150826002028217905092915050565b6200031882620000a9565b67ffffffffffffffff811115620003345762000333620000b3565b5b6200034082546200010d565b6200034d82828562000276565b5f60209050601f83116001811462000383575f84156200036e578287015190505b6200037a8582620002f0565b865550620003e9565b601f198416620003938662000141565b5f5b82811015620003bc5784890151825560018201915060208501945060208101905062000395565b86831015620003dc5784890151620003d8601f891682620002d2565b8355505b6001600288020188555050505b505050505050565b610f3880620003ff5f395ff3fe608060405234801561000f575f80fd5b50600436106100a7575f3560e01c806340c10f191161006f57806340c10f191461016557806370a08231146101815780638483acfe146101b157806395d89b41146101cd578063a9059cbb146101eb578063dd62ed3e1461021b576100a7565b806306fdde03146100ab578063095ea7b3146100c957806318160ddd146100f957806323b872dd14610117578063313ce56714610147575b5f80fd5b6100b361024b565b6040516100c09190610bb1565b60405180910390f35b6100e360048036038101906100de9190610c62565b6102db565b6040516100f09190610cba565b60405180910390f35b6101016102ea565b60405161010e9190610ce2565b60405180910390f35b610131600480360381019061012c9190610cfb565b6102f3565b60405161013e9190610cba565b60405180910390f35b61014f610303565b60405161015c9190610d66565b60405180910390f35b61017f600480360381019061017a9190610c62565b61030b565b005b61019b60048036038101906101969190610d7f565b610319565b6040516101a89190610ce2565b60405180910390f35b6101cb60048036038101906101c69190610cfb565b61032a565b005b6101d561033a565b6040516101e29190610bb1565b60405180910390f35b61020560048036038101906102009190610c62565b6103ca565b6040516102129190610cba565b60405180910390f35b61023560048036038101906102309190610daa565b6103d9565b6040516102429190610ce2565b60405180910390f35b60606003805461025a90610e15565b80601f016020809104026020016040519081016040528092919081815260200182805461028690610e15565b80156102d15780601f106102a8576101008083540402835291602001916102d1565b820191905f5260205f20905b8154815290600101906020018083116102b457829003601f168201915b5050505050905090565b5f6102e683836103ec565b5f80f35b5f600254905090565b5f6102ff84848461040e565b5f80f35b5f6012905090565b610315828261043c565b5050565b5f610323826104bb565b9050919050565b610335838383610500565b505050565b60606004805461034990610e15565b80601f016020809104026020016040519081016040528092919081815260200182805461037590610e15565b80156103c05780601f10610397576101008083540402835291602001916103c0565b820191905f5260205f20905b8154815290600101906020018083116103a357829003601f168201915b5050505050905090565b5f6103d58383610512565b5f80f35b5f6103e48383610534565b905092915050565b5f806103f66105b6565b9050610403818585610500565b600191505092915050565b5f806104186105b6565b90506104258582856105bd565b61043085858561064f565b60019150509392505050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036104ac575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016104a39190610e54565b60405180910390fd5b6104b75f838361073f565b5050565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b61050d8383836001610958565b505050565b5f8061051c6105b6565b905061052981858561064f565b600191505092915050565b5f60015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f33905090565b5f6105c884846103d9565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610649578181101561063a578281836040517ffb8f41b200000000000000000000000000000000000000000000000000000000815260040161063193929190610e6d565b60405180910390fd5b61064884848484035f610958565b5b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036106bf575f6040517f96c6fd1e0000000000000000000000000000000000000000000000000000000081526004016106b69190610e54565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361072f575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016107269190610e54565b60405180910390fd5b61073a83838361073f565b505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361078f578060025f8282546107839190610ecf565b9250508190555061085d565b5f805f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905081811015610818578381836040517fe450d38c00000000000000000000000000000000000000000000000000000000815260040161080f93929190610e6d565b60405180910390fd5b8181035f808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036108a4578060025f82825403925050819055506108ee565b805f808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8360405161094b9190610ce2565b60405180910390a3505050565b5f73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16036109c8575f6040517fe602df050000000000000000000000000000000000000000000000000000000081526004016109bf9190610e54565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610a38575f6040517f94280d62000000000000000000000000000000000000000000000000000000008152600401610a2f9190610e54565b60405180910390fd5b8160015f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055508015610b21578273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92584604051610b189190610ce2565b60405180910390a35b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015610b5e578082015181840152602081019050610b43565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610b8382610b27565b610b8d8185610b31565b9350610b9d818560208601610b41565b610ba681610b69565b840191505092915050565b5f6020820190508181035f830152610bc98184610b79565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610bfe82610bd5565b9050919050565b610c0e81610bf4565b8114610c18575f80fd5b50565b5f81359050610c2981610c05565b92915050565b5f819050919050565b610c4181610c2f565b8114610c4b575f80fd5b50565b5f81359050610c5c81610c38565b92915050565b5f8060408385031215610c7857610c77610bd1565b5b5f610c8585828601610c1b565b9250506020610c9685828601610c4e565b9150509250929050565b5f8115159050919050565b610cb481610ca0565b82525050565b5f602082019050610ccd5f830184610cab565b92915050565b610cdc81610c2f565b82525050565b5f602082019050610cf55f830184610cd3565b92915050565b5f805f60608486031215610d1257610d11610bd1565b5b5f610d1f86828701610c1b565b9350506020610d3086828701610c1b565b9250506040610d4186828701610c4e565b9150509250925092565b5f60ff82169050919050565b610d6081610d4b565b82525050565b5f602082019050610d795f830184610d57565b92915050565b5f60208284031215610d9457610d93610bd1565b5b5f610da184828501610c1b565b91505092915050565b5f8060408385031215610dc057610dbf610bd1565b5b5f610dcd85828601610c1b565b9250506020610dde85828601610c1b565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610e2c57607f821691505b602082108103610e3f57610e3e610de8565b5b50919050565b610e4e81610bf4565b82525050565b5f602082019050610e675f830184610e45565b92915050565b5f606082019050610e805f830186610e45565b610e8d6020830185610cd3565b610e9a6040830184610cd3565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610ed982610c2f565b9150610ee483610c2f565b9250828201905080821115610efc57610efb610ea2565b5b9291505056fea2646970667358221220e66fa5f170a573315c29c69b9be493f577016746885cba3ad5a88b793a2bebac64736f6c63430008150033\")]\n    // SPDX-License-Identifier: MIT\n    contract ERC20NoReturnMock is ERC20 {\n        constructor() ERC20(\"ERC20NoReturnMock\", \"NRM\") {}\n\n        function transfer(address to, uint256 amount) public override returns (bool) {\n            super.transfer(to, amount);\n            assembly {\n                return(0, 0)\n            }\n        }\n\n        function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n            super.transferFrom(from, to, amount);\n            assembly {\n                return(0, 0)\n            }\n        }\n\n        function approve(address spender, uint256 amount) public override returns (bool) {\n            super.approve(spender, amount);\n            assembly {\n                return(0, 0)\n            }\n        }\n\n        function regular_approve(address owner, address spender, uint256 amount) public {\n            super._approve(owner, spender, amount);\n        }\n\n        function balanceOf(address account) public override view returns (uint256) {\n            return super.balanceOf(account);\n        }\n\n        function mint(address account, uint256 value) public {\n            super._mint(account, value);\n        }\n\n        function allowance(address owner, address spender) public view override returns (uint256) {\n            return super.allowance(owner, spender);\n        }\n    }\n}\n\npub async fn deploy(wallet: \u0026Wallet) -\u003e eyre::Result\u003cAddress\u003e {\n    // Deploy the contract.\n    let contract = ERC20NoReturnMock::deploy(wallet).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","mock","erc20_return_false.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.21+commit.d9974bed\n    #[sol(rpc, bytecode=\"608060405234801562000010575f80fd5b506040518060400160405280601481526020017f455243323052657475726e46616c73654d6f636b0000000000000000000000008152506040518060400160405280600381526020017f52464d000000000000000000000000000000000000000000000000000000000081525081600390816200008e91906200030d565b508060049081620000a091906200030d565b505050620003f1565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806200012557607f821691505b6020821081036200013b576200013a620000e0565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026200019f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000162565b620001ab868362000162565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f620001f5620001ef620001e984620001c3565b620001cc565b620001c3565b9050919050565b5f819050919050565b6200021083620001d5565b620002286200021f82620001fc565b8484546200016e565b825550505050565b5f90565b6200023e62000230565b6200024b81848462000205565b505050565b5b818110156200027257620002665f8262000234565b60018101905062000251565b5050565b601f821115620002c1576200028b8162000141565b620002968462000153565b81016020851015620002a6578190505b620002be620002b58562000153565b83018262000250565b50505b505050565b5f82821c905092915050565b5f620002e35f1984600802620002c6565b1980831691505092915050565b5f620002fd8383620002d2565b9150826002028217905092915050565b6200031882620000a9565b67ffffffffffffffff811115620003345762000333620000b3565b5b6200034082546200010d565b6200034d82828562000276565b5f60209050601f83116001811462000383575f84156200036e578287015190505b6200037a8582620002f0565b865550620003e9565b601f198416620003938662000141565b5f5b82811015620003bc5784890151825560018201915060208501945060208101905062000395565b86831015620003dc5784890151620003d8601f891682620002d2565b8355505b6001600288020188555050505b505050505050565b610b0d80620003ff5f395ff3fe608060405234801561000f575f80fd5b506004361061009c575f3560e01c806340c10f191161006457806340c10f191461015a57806370a082311461017657806395d89b41146101a6578063a9059cbb146101c4578063dd62ed3e146101f45761009c565b806306fdde03146100a0578063095ea7b3146100be57806318160ddd146100ee57806323b872dd1461010c578063313ce5671461013c575b5f80fd5b6100a8610224565b6040516100b59190610786565b60405180910390f35b6100d860048036038101906100d39190610837565b6102b4565b6040516100e5919061088f565b60405180910390f35b6100f66102bb565b60405161010391906108b7565b60405180910390f35b610126600480360381019061012191906108d0565b6102c4565b604051610133919061088f565b60405180910390f35b6101446102cc565b604051610151919061093b565b60405180910390f35b610174600480360381019061016f9190610837565b6102d4565b005b610190600480360381019061018b9190610954565b6102e2565b60405161019d91906108b7565b60405180910390f35b6101ae6102f3565b6040516101bb9190610786565b60405180910390f35b6101de60048036038101906101d99190610837565b610383565b6040516101eb919061088f565b60405180910390f35b61020e6004803603810190610209919061097f565b61038a565b60405161021b91906108b7565b60405180910390f35b606060038054610233906109ea565b80601f016020809104026020016040519081016040528092919081815260200182805461025f906109ea565b80156102aa5780601f10610281576101008083540402835291602001916102aa565b820191905f5260205f20905b81548152906001019060200180831161028d57829003601f168201915b5050505050905090565b5f92915050565b5f600254905090565b5f9392505050565b5f6012905090565b6102de828261039d565b5050565b5f6102ec8261041c565b9050919050565b606060048054610302906109ea565b80601f016020809104026020016040519081016040528092919081815260200182805461032e906109ea565b80156103795780601f1061035057610100808354040283529160200191610379565b820191905f5260205f20905b81548152906001019060200180831161035c57829003601f168201915b5050505050905090565b5f92915050565b5f6103958383610461565b905092915050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361040d575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016104049190610a29565b60405180910390fd5b6104185f83836104e3565b5050565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b5f60015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610533578060025f8282546105279190610a6f565b92505081905550610601565b5f805f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050818110156105bc578381836040517fe450d38c0000000000000000000000000000000000000000000000000000000081526004016105b393929190610aa2565b60405180910390fd5b8181035f808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610648578060025f8282540392505081905550610692565b805f808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516106ef91906108b7565b60405180910390a3505050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015610733578082015181840152602081019050610718565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610758826106fc565b6107628185610706565b9350610772818560208601610716565b61077b8161073e565b840191505092915050565b5f6020820190508181035f83015261079e818461074e565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6107d3826107aa565b9050919050565b6107e3816107c9565b81146107ed575f80fd5b50565b5f813590506107fe816107da565b92915050565b5f819050919050565b61081681610804565b8114610820575f80fd5b50565b5f813590506108318161080d565b92915050565b5f806040838503121561084d5761084c6107a6565b5b5f61085a858286016107f0565b925050602061086b85828601610823565b9150509250929050565b5f8115159050919050565b61088981610875565b82525050565b5f6020820190506108a25f830184610880565b92915050565b6108b181610804565b82525050565b5f6020820190506108ca5f8301846108a8565b92915050565b5f805f606084860312156108e7576108e66107a6565b5b5f6108f4868287016107f0565b9350506020610905868287016107f0565b925050604061091686828701610823565b9150509250925092565b5f60ff82169050919050565b61093581610920565b82525050565b5f60208201905061094e5f83018461092c565b92915050565b5f60208284031215610969576109686107a6565b5b5f610976848285016107f0565b91505092915050565b5f8060408385031215610995576109946107a6565b5b5f6109a2858286016107f0565b92505060206109b3858286016107f0565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610a0157607f821691505b602082108103610a1457610a136109bd565b5b50919050565b610a23816107c9565b82525050565b5f602082019050610a3c5f830184610a1a565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610a7982610804565b9150610a8483610804565b9250828201905080821115610a9c57610a9b610a42565b5b92915050565b5f606082019050610ab55f830186610a1a565b610ac260208301856108a8565b610acf60408301846108a8565b94935050505056fea26469706673582212204aac6dd6254b82f37f30add0ed2937474eced0bafc505b611f66b99ebe39999e64736f6c63430008150033\")]\n    // SPDX-License-Identifier: MIT\n    contract ERC20ReturnFalseMock is ERC20 {\n        constructor() ERC20(\"ERC20ReturnFalseMock\", \"RFM\") {}\n\n        function approve(address, uint256) public override returns (bool) {\n            return false;\n        }\n\n        function transfer(address, uint256) public override returns (bool) {\n            return false;\n        }\n\n        function transferFrom(address, address, uint256) public override returns (bool) {\n            return false;\n        }\n\n        function balanceOf(address account) public override view returns (uint256) {\n            return super.balanceOf(account);\n        }\n\n        function mint(address account, uint256 value) public {\n            super._mint(account, value);\n        }\n\n        function allowance(address owner, address spender) public view override returns (uint256) {\n            return super.allowance(owner, spender);\n        }\n    }\n}\n\npub async fn deploy(wallet: \u0026Wallet) -\u003e eyre::Result\u003cAddress\u003e {\n    // Deploy the contract.\n    let contract = ERC20ReturnFalseMock::deploy(wallet).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","mock","mod.rs"],"content":"pub mod erc20;\npub mod erc20_force_approve;\npub mod erc20_no_return;\npub mod erc20_return_false;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","safe_erc20_address_with_no_code.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::SafeErc20;\nuse alloy::primitives::{uint, U256};\nuse e2e::{send, Account, Revert};\n\nmod abi;\nmod mock;\n\n#[e2e::test]\nasync fn reverts_on_transfer(\n    alice: Account,\n    bob: Account,\n    has_no_code: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n    let has_no_code_addr = has_no_code.address();\n\n    let value = uint!(1_U256);\n\n    let err =\n        send!(safe_erc20_alice.safeTransfer(has_no_code_addr, bob_addr, value))\n            .expect_err(\"should not be able to invoke 'transfer' on EOA\");\n    assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n        token: has_no_code_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn reverts_on_transfer_from(\n    alice: Account,\n    bob: Account,\n    has_no_code: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n    let has_no_code_addr = has_no_code.address();\n\n    let value = uint!(1_U256);\n\n    let err = send!(safe_erc20_alice.safeTransferFrom(\n        has_no_code_addr,\n        alice_addr,\n        bob_addr,\n        value\n    ))\n    .expect_err(\"should not be able to invoke 'transferFrom' on EOA\");\n    assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n        token: has_no_code_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn reverts_on_increase_allowance(\n    alice: Account,\n    bob: Account,\n    has_no_code: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n    let has_no_code_addr = has_no_code.address();\n\n    let value = uint!(1_U256);\n\n    let err = send!(safe_erc20_alice.safeIncreaseAllowance(\n        has_no_code_addr,\n        bob_addr,\n        value\n    ))\n    .expect_err(\"should not be able to invoke 'increaseAllowance' on EOA\");\n    assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n        token: has_no_code_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn reverts_on_decrease_allowance(\n    alice: Account,\n    bob: Account,\n    has_no_code: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n    let has_no_code_addr = has_no_code.address();\n\n    let requested_decrease = uint!(1_U256);\n\n    let err = send!(safe_erc20_alice.safeDecreaseAllowance(\n        has_no_code_addr,\n        bob_addr,\n        requested_decrease\n    ))\n    .expect_err(\"should not be able to invoke 'decreaseAllowance' on EOA\");\n    assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n        token: has_no_code_addr\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn reverts_on_force_approve(\n    alice: Account,\n    bob: Account,\n    has_no_code: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n    let has_no_code_addr = has_no_code.address();\n\n    let err = send!(safe_erc20_alice.forceApprove(\n        has_no_code_addr,\n        bob_addr,\n        U256::ZERO\n    ))\n    .expect_err(\"should not be able to invoke 'forceApprove' on EOA\");\n    assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n        token: has_no_code_addr\n    }));\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","safe_erc20_erc20.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::{Erc20, SafeErc20};\nuse alloy::primitives::uint;\nuse alloy_primitives::U256;\nuse e2e::{receipt, send, watch, Account, EventExt, Panic, PanicCode, Revert};\nuse mock::{erc20, erc20::ERC20Mock};\n\nmod abi;\nmod mock;\n\nmod transfers {\n    use super::*;\n\n    #[e2e::test]\n    async fn does_not_revert_on_transfer(\n        alice: Account,\n        bob: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let safe_erc20_addr =\n            alice.as_deployer().deploy().await?.contract_address;\n        let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n        let bob_addr = bob.address();\n\n        let balance = uint!(10_U256);\n        let value = uint!(1_U256);\n\n        let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n        let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n        watch!(erc20_alice.mint(safe_erc20_addr, balance))?;\n\n        let initial_safe_erc20_balance =\n            erc20_alice.balanceOf(safe_erc20_addr).call().await?._0;\n        let initial_bob_balance =\n            erc20_alice.balanceOf(bob_addr).call().await?._0;\n        assert_eq!(initial_safe_erc20_balance, balance);\n        assert_eq!(initial_bob_balance, U256::ZERO);\n\n        let receipt = receipt!(safe_erc20_alice.safeTransfer(\n            erc20_address,\n            bob_addr,\n            value\n        ))?;\n\n        assert!(receipt.emits(Erc20::Transfer {\n            from: safe_erc20_addr,\n            to: bob_addr,\n            value\n        }));\n\n        let safe_erc20_balance =\n            erc20_alice.balanceOf(safe_erc20_addr).call().await?._0;\n        let bob_balance = erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        assert_eq!(initial_safe_erc20_balance - value, safe_erc20_balance);\n        assert_eq!(initial_bob_balance + value, bob_balance);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_on_transfer_with_internal_error(\n        alice: Account,\n        bob: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let safe_erc20_addr =\n            alice.as_deployer().deploy().await?.contract_address;\n        let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n        let bob_addr = bob.address();\n\n        let value = uint!(1_U256);\n\n        let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n        let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n        let initial_safe_erc20_balance =\n            erc20_alice.balanceOf(safe_erc20_addr).call().await?._0;\n        let initial_bob_balance =\n            erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        let err = send!(safe_erc20_alice.safeTransfer(\n            erc20_address,\n            bob_addr,\n            value\n        ))\n        .expect_err(\"should not transfer when insufficient balance\");\n\n        assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n            token: erc20_address\n        }));\n\n        let safe_erc20_balance =\n            erc20_alice.balanceOf(safe_erc20_addr).call().await?._0;\n        let bob_balance = erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        assert_eq!(initial_safe_erc20_balance, safe_erc20_balance);\n        assert_eq!(initial_bob_balance, bob_balance);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn does_not_revert_on_transfer_from(\n        alice: Account,\n        bob: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let safe_erc20_addr =\n            alice.as_deployer().deploy().await?.contract_address;\n        let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n        let alice_addr = alice.address();\n        let bob_addr = bob.address();\n\n        let balance = uint!(10_U256);\n        let value = uint!(1_U256);\n\n        let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n        let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n        watch!(erc20_alice.mint(alice_addr, balance))?;\n        watch!(erc20_alice.approve(safe_erc20_addr, value))?;\n\n        let initial_alice_balance =\n            erc20_alice.balanceOf(alice_addr).call().await?._0;\n        let initial_bob_balance =\n            erc20_alice.balanceOf(bob_addr).call().await?._0;\n        assert_eq!(initial_alice_balance, balance);\n        assert_eq!(initial_bob_balance, U256::ZERO);\n\n        let receipt = receipt!(safe_erc20_alice.safeTransferFrom(\n            erc20_address,\n            alice_addr,\n            bob_addr,\n            value\n        ))?;\n\n        assert!(receipt.emits(Erc20::Transfer {\n            from: alice_addr,\n            to: bob_addr,\n            value\n        }));\n\n        let alice_balance = erc20_alice.balanceOf(alice_addr).call().await?._0;\n        let bob_balance = erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        assert_eq!(initial_alice_balance - value, alice_balance);\n        assert_eq!(initial_bob_balance + value, bob_balance);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_on_transfer_from_internal_error(\n        alice: Account,\n        bob: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let safe_erc20_addr =\n            alice.as_deployer().deploy().await?.contract_address;\n        let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n        let alice_addr = alice.address();\n        let bob_addr = bob.address();\n\n        let value = uint!(1_U256);\n\n        let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n        let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n        watch!(erc20_alice.approve(safe_erc20_addr, value))?;\n\n        let initial_alice_balance =\n            erc20_alice.balanceOf(alice_addr).call().await?._0;\n        let initial_bob_balance =\n            erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        let err = send!(safe_erc20_alice.safeTransferFrom(\n            erc20_address,\n            alice_addr,\n            bob_addr,\n            value\n        ))\n        .expect_err(\"should not transfer when insufficient balance\");\n\n        assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n            token: erc20_address\n        }));\n\n        let alice_balance = erc20_alice.balanceOf(alice_addr).call().await?._0;\n        let bob_balance = erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        assert_eq!(initial_alice_balance, alice_balance);\n        assert_eq!(initial_bob_balance, bob_balance);\n\n        Ok(())\n    }\n}\n\nmod approvals {\n    mod with_zero_allowance {\n        use super::super::*;\n\n        #[e2e::test]\n        async fn does_not_revert_when_force_approving_a_non_zero_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n            let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            let value = uint!(100_U256);\n\n            let receipt = receipt!(safe_erc20_alice.forceApprove(\n                erc20_address,\n                spender_addr,\n                value\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, value);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn does_not_revert_when_force_approving_a_zero_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n            let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            let receipt = receipt!(safe_erc20_alice.forceApprove(\n                erc20_address,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value: U256::ZERO,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, U256::ZERO);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn does_not_revert_when_increasing_the_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n            let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            let value = uint!(10_U256);\n\n            let receipt = receipt!(safe_erc20_alice.safeIncreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, value);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn panics_when_increasing_the_allowance_overflow(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n            let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                U256::MAX\n            ))?;\n\n            let value = uint!(1_U256);\n\n            let err = send!(safe_erc20_alice.safeIncreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))\n            .expect_err(\"should not exceed U256::MAX\");\n\n            assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn reverts_when_decreasing_the_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n            let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            let value = uint!(10_U256);\n\n            let err = send!(safe_erc20_alice.safeDecreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))\n            .expect_err(\"should not be able to succeed on 'decreaseAllowance'\");\n            assert!(err.reverted_with(\n                SafeErc20::SafeErc20FailedDecreaseAllowance {\n                    spender: spender_addr,\n                    currentAllowance: U256::ZERO,\n                    requestedDecrease: value\n                }\n            ));\n\n            Ok(())\n        }\n    }\n\n    mod with_non_zero_allowance {\n        use super::super::*;\n\n        #[e2e::test]\n        async fn does_not_revert_when_force_approving_a_non_zero_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n            let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n            let allowance = uint!(100_U256);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                allowance\n            ))?;\n\n            let value = uint!(20_U256);\n\n            let receipt = receipt!(safe_erc20_alice.forceApprove(\n                erc20_address,\n                spender_addr,\n                value\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, value);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn does_not_revert_when_force_approving_a_zero_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n            let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n            let allowance = uint!(100_U256);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                allowance\n            ))?;\n\n            let receipt = receipt!(safe_erc20_alice.forceApprove(\n                erc20_address,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value: U256::ZERO,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, U256::ZERO);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn does_not_revert_when_increasing_the_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n            let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n            let allowance = uint!(100_U256);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                allowance\n            ))?;\n\n            let value = uint!(10_U256);\n\n            let receipt = receipt!(safe_erc20_alice.safeIncreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value: allowance + value,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, allowance + value);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn does_not_revert_when_decreasing_the_allowance_to_a_positive_value(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n            let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n            let allowance = uint!(100_U256);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                allowance\n            ))?;\n\n            let value = uint!(50_U256);\n\n            let receipt = receipt!(safe_erc20_alice.safeDecreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value: allowance - value,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, allowance - value);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn reverts_when_decreasing_the_allowance_to_a_negative_value(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20::deploy(\u0026alice.wallet).await?;\n            let erc20_alice = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n            let allowance = uint!(100_U256);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                allowance\n            ))?;\n\n            let value = uint!(200_U256);\n\n            let err = send!(safe_erc20_alice.safeDecreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))\n            .expect_err(\"should not be able to succeed on 'decreaseAllowance'\");\n            assert!(err.reverted_with(\n                SafeErc20::SafeErc20FailedDecreaseAllowance {\n                    spender: spender_addr,\n                    currentAllowance: allowance,\n                    requestedDecrease: value\n                }\n            ));\n\n            Ok(())\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","safe_erc20_erc20_that_always_returns_false.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::SafeErc20;\nuse alloy::primitives::U256;\nuse e2e::{send, Account, Revert};\nuse mock::erc20_return_false;\n\nmod abi;\nmod mock;\n\n#[e2e::test]\nasync fn reverts_on_transfer(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n\n    let erc20_address = erc20_return_false::deploy(\u0026alice.wallet).await?;\n\n    let err = send!(safe_erc20_alice.safeTransfer(\n        erc20_address,\n        bob_addr,\n        U256::ZERO\n    ))\n    .expect_err(\"should not be able to succeed on 'transfer'\");\n    assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n        token: erc20_address\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn reverts_on_transfer_from(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let alice_addr = alice.address();\n    let bob_addr = bob.address();\n\n    let erc20_address = erc20_return_false::deploy(\u0026alice.wallet).await?;\n\n    let err = send!(safe_erc20_alice.safeTransferFrom(\n        erc20_address,\n        alice_addr,\n        bob_addr,\n        U256::ZERO\n    ))\n    .expect_err(\"should not be able to succeed on 'transferFrom'\");\n    assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n        token: erc20_address\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn reverts_on_increase_allowance(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n\n    let erc20_address = erc20_return_false::deploy(\u0026alice.wallet).await?;\n\n    let err = send!(safe_erc20_alice.safeIncreaseAllowance(\n        erc20_address,\n        bob_addr,\n        U256::ZERO\n    ))\n    .expect_err(\"should not be able to succeed on 'increaseAllowance'\");\n    assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n        token: erc20_address\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn reverts_on_decrease_allowance(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n\n    let erc20_address = erc20_return_false::deploy(\u0026alice.wallet).await?;\n\n    let err = send!(safe_erc20_alice.safeDecreaseAllowance(\n        erc20_address,\n        bob_addr,\n        U256::ZERO\n    ))\n    .expect_err(\"should not be able to succeed on 'decreaseAllowance'\");\n    assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n        token: erc20_address\n    }));\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn reverts_on_force_approve(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n\n    let erc20_address = erc20_return_false::deploy(\u0026alice.wallet).await?;\n\n    let err = send!(safe_erc20_alice.forceApprove(\n        erc20_address,\n        bob_addr,\n        U256::ZERO\n    ))\n    .expect_err(\"should not be able to succeed on 'forceApprove'\");\n    assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n        token: erc20_address\n    }));\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","safe_erc20_erc20_that_does_not_return.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::{Erc20, SafeErc20};\nuse alloy::primitives::uint;\nuse alloy_primitives::U256;\nuse e2e::{receipt, send, watch, Account, EventExt, Panic, PanicCode, Revert};\nuse mock::{erc20_no_return, erc20_no_return::ERC20NoReturnMock};\n\nmod abi;\nmod mock;\n\nmod transfers {\n    use super::*;\n\n    #[e2e::test]\n    async fn does_not_revert_on_transfer(\n        alice: Account,\n        bob: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let safe_erc20_addr =\n            alice.as_deployer().deploy().await?.contract_address;\n        let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n        let bob_addr = bob.address();\n\n        let balance = uint!(10_U256);\n        let value = uint!(1_U256);\n\n        let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n        let erc20_alice = ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n        watch!(erc20_alice.mint(safe_erc20_addr, balance))?;\n\n        let initial_safe_erc20_balance =\n            erc20_alice.balanceOf(safe_erc20_addr).call().await?._0;\n        let initial_bob_balance =\n            erc20_alice.balanceOf(bob_addr).call().await?._0;\n        assert_eq!(initial_safe_erc20_balance, balance);\n        assert_eq!(initial_bob_balance, U256::ZERO);\n\n        let receipt = receipt!(safe_erc20_alice.safeTransfer(\n            erc20_address,\n            bob_addr,\n            value\n        ))?;\n\n        assert!(receipt.emits(Erc20::Transfer {\n            from: safe_erc20_addr,\n            to: bob_addr,\n            value,\n        }));\n\n        let safe_erc20_balance =\n            erc20_alice.balanceOf(safe_erc20_addr).call().await?._0;\n        let bob_balance = erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        assert_eq!(initial_safe_erc20_balance - value, safe_erc20_balance);\n        assert_eq!(initial_bob_balance + value, bob_balance);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_on_transfer_with_internal_error(\n        alice: Account,\n        bob: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let safe_erc20_addr =\n            alice.as_deployer().deploy().await?.contract_address;\n        let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n        let bob_addr = bob.address();\n\n        let value = uint!(1_U256);\n\n        let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n        let erc20_alice = ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n        let initial_safe_erc20_balance =\n            erc20_alice.balanceOf(safe_erc20_addr).call().await?._0;\n        let initial_bob_balance =\n            erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        let err = send!(safe_erc20_alice.safeTransfer(\n            erc20_address,\n            bob_addr,\n            value\n        ))\n        .expect_err(\"should not transfer when insufficient balance\");\n        assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n            token: erc20_address\n        }));\n\n        let safe_erc20_balance =\n            erc20_alice.balanceOf(safe_erc20_addr).call().await?._0;\n        let bob_balance = erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        assert_eq!(initial_safe_erc20_balance, safe_erc20_balance);\n        assert_eq!(initial_bob_balance, bob_balance);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn does_not_revert_on_transfer_from(\n        alice: Account,\n        bob: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let safe_erc20_addr =\n            alice.as_deployer().deploy().await?.contract_address;\n        let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n        let alice_addr = alice.address();\n        let bob_addr = bob.address();\n\n        let balance = uint!(10_U256);\n        let value = uint!(1_U256);\n\n        let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n        let erc20_alice = ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n        watch!(erc20_alice.mint(alice_addr, balance))?;\n        watch!(erc20_alice.approve(safe_erc20_addr, value))?;\n\n        let initial_alice_balance =\n            erc20_alice.balanceOf(alice_addr).call().await?._0;\n        let initial_bob_balance =\n            erc20_alice.balanceOf(bob_addr).call().await?._0;\n        assert_eq!(initial_alice_balance, balance);\n        assert_eq!(initial_bob_balance, U256::ZERO);\n\n        let receipt = receipt!(safe_erc20_alice.safeTransferFrom(\n            erc20_address,\n            alice_addr,\n            bob_addr,\n            value\n        ))?;\n\n        assert!(receipt.emits(Erc20::Transfer {\n            from: alice_addr,\n            to: bob_addr,\n            value,\n        }));\n\n        let alice_balance = erc20_alice.balanceOf(alice_addr).call().await?._0;\n        let bob_balance = erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        assert_eq!(initial_alice_balance - value, alice_balance);\n        assert_eq!(initial_bob_balance + value, bob_balance);\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn reverts_on_transfer_from_internal_error(\n        alice: Account,\n        bob: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let safe_erc20_addr =\n            alice.as_deployer().deploy().await?.contract_address;\n        let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n        let alice_addr = alice.address();\n        let bob_addr = bob.address();\n\n        let value = uint!(1_U256);\n\n        let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n        let erc20_alice = ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n        watch!(erc20_alice.approve(safe_erc20_addr, value))?;\n\n        let initial_alice_balance =\n            erc20_alice.balanceOf(alice_addr).call().await?._0;\n        let initial_bob_balance =\n            erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        let err = send!(safe_erc20_alice.safeTransferFrom(\n            erc20_address,\n            alice_addr,\n            bob_addr,\n            value\n        ))\n        .expect_err(\"should not transfer when insufficient balance\");\n        assert!(err.reverted_with(SafeErc20::SafeErc20FailedOperation {\n            token: erc20_address\n        }));\n\n        let alice_balance = erc20_alice.balanceOf(alice_addr).call().await?._0;\n        let bob_balance = erc20_alice.balanceOf(bob_addr).call().await?._0;\n\n        assert_eq!(initial_alice_balance, alice_balance);\n        assert_eq!(initial_bob_balance, bob_balance);\n\n        Ok(())\n    }\n}\n\nmod approvals {\n    mod with_zero_allowance {\n        use super::super::*;\n\n        #[e2e::test]\n        async fn does_not_revert_when_force_approving_a_non_zero_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n            let erc20_alice =\n                ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            let value = uint!(100_U256);\n\n            let receipt = receipt!(safe_erc20_alice.forceApprove(\n                erc20_address,\n                spender_addr,\n                value\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, value);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn does_not_revert_when_force_approving_a_zero_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n            let erc20_alice =\n                ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            let receipt = receipt!(safe_erc20_alice.forceApprove(\n                erc20_address,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value: U256::ZERO,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, U256::ZERO);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn does_not_revert_when_increasing_the_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n            let erc20_alice =\n                ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            let value = uint!(10_U256);\n\n            let receipt = receipt!(safe_erc20_alice.safeIncreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, value);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn panics_when_increasing_the_allowance_overflow(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n            let erc20_alice =\n                ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                U256::MAX\n            ))?;\n\n            let value = uint!(1_U256);\n\n            let err = send!(safe_erc20_alice.safeIncreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))\n            .expect_err(\"should exceed U256::MAX\");\n\n            assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn reverts_when_decreasing_the_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n            let erc20_alice =\n                ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            let value = uint!(10_U256);\n\n            let err = send!(safe_erc20_alice.safeDecreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))\n            .expect_err(\"should not be able to succeed on 'decreaseAllowance'\");\n            assert!(err.reverted_with(\n                SafeErc20::SafeErc20FailedDecreaseAllowance {\n                    spender: spender_addr,\n                    currentAllowance: U256::ZERO,\n                    requestedDecrease: value\n                }\n            ));\n\n            Ok(())\n        }\n    }\n\n    mod with_non_zero_allowance {\n        use super::super::*;\n\n        #[e2e::test]\n        async fn does_not_revert_when_force_approving_a_non_zero_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n            let erc20_alice =\n                ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n            let allowance = uint!(100_U256);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                allowance\n            ))?;\n\n            let value = uint!(20_U256);\n\n            let receipt = receipt!(safe_erc20_alice.forceApprove(\n                erc20_address,\n                spender_addr,\n                value\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, value);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn does_not_revert_when_force_approving_a_zero_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n            let erc20_alice =\n                ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n            let allowance = uint!(100_U256);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                allowance\n            ))?;\n\n            let receipt = receipt!(safe_erc20_alice.forceApprove(\n                erc20_address,\n                spender_addr,\n                U256::ZERO\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value: U256::ZERO,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, U256::ZERO);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn does_not_revert_when_increasing_the_allowance(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n            let erc20_alice =\n                ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n            let allowance = uint!(100_U256);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                allowance\n            ))?;\n\n            let value = uint!(10_U256);\n\n            let receipt = receipt!(safe_erc20_alice.safeIncreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value: allowance + value,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, allowance + value);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn does_not_revert_when_decreasing_the_allowance_to_a_positive_value(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n            let erc20_alice =\n                ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n            let allowance = uint!(100_U256);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                allowance\n            ))?;\n\n            let value = uint!(50_U256);\n\n            let receipt = receipt!(safe_erc20_alice.safeDecreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))?;\n\n            assert!(receipt.emits(Erc20::Approval {\n                owner: safe_erc20_addr,\n                spender: spender_addr,\n                value: allowance - value,\n            }));\n\n            let spender_allowance = erc20_alice\n                .allowance(safe_erc20_addr, spender_addr)\n                .call()\n                .await?\n                ._0;\n            assert_eq!(spender_allowance, allowance - value);\n\n            Ok(())\n        }\n\n        #[e2e::test]\n        async fn reverts_when_decreasing_the_allowance_to_a_negative_value(\n            alice: Account,\n        ) -\u003e eyre::Result\u003c()\u003e {\n            let safe_erc20_addr =\n                alice.as_deployer().deploy().await?.contract_address;\n            let safe_erc20_alice =\n                SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n            let spender_addr = alice.address();\n\n            let erc20_address = erc20_no_return::deploy(\u0026alice.wallet).await?;\n            let erc20_alice =\n                ERC20NoReturnMock::new(erc20_address, \u0026alice.wallet);\n\n            let allowance = uint!(100_U256);\n\n            watch!(erc20_alice.regular_approve(\n                safe_erc20_addr,\n                spender_addr,\n                allowance\n            ))?;\n\n            let value = uint!(200_U256);\n\n            let err = send!(safe_erc20_alice.safeDecreaseAllowance(\n                erc20_address,\n                spender_addr,\n                value\n            ))\n            .expect_err(\"should not be able to succeed on 'decreaseAllowance'\");\n            assert!(err.reverted_with(\n                SafeErc20::SafeErc20FailedDecreaseAllowance {\n                    spender: spender_addr,\n                    currentAllowance: allowance,\n                    requestedDecrease: value\n                }\n            ));\n\n            Ok(())\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","safe-erc20","tests","safe_erc20_usdt_approval_behavior.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::{Erc20, SafeErc20};\nuse alloy::primitives::uint;\nuse e2e::{receipt, watch, Account, EventExt};\nuse mock::{erc20_force_approve, erc20_force_approve::ERC20ForceApproveMock};\n\nmod abi;\nmod mock;\n\n#[e2e::test]\nasync fn safe_increase_allowance_works(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n\n    let erc20_address = erc20_force_approve::deploy(\u0026alice.wallet).await?;\n    let erc20_alice = ERC20ForceApproveMock::new(erc20_address, \u0026alice.wallet);\n\n    let init_approval = uint!(100_U256);\n    let value = uint!(10_U256);\n\n    watch!(erc20_alice.regular_approve(\n        safe_erc20_addr,\n        bob_addr,\n        init_approval\n    ))?;\n\n    let initial_bob_allowance =\n        erc20_alice.allowance(safe_erc20_addr, bob_addr).call().await?._0;\n    assert_eq!(initial_bob_allowance, init_approval);\n\n    let receipt = receipt!(safe_erc20_alice.safeIncreaseAllowance(\n        erc20_address,\n        bob_addr,\n        value\n    ))?;\n\n    assert!(receipt.emits(Erc20::Approval {\n        owner: safe_erc20_addr,\n        spender: bob_addr,\n        value: init_approval + value,\n    }));\n\n    let bob_allowance =\n        erc20_alice.allowance(safe_erc20_addr, bob_addr).call().await?._0;\n    assert_eq!(bob_allowance, init_approval + value);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn safe_decrease_allowance_works(\n    alice: Account,\n    bob: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n\n    let erc20_address = erc20_force_approve::deploy(\u0026alice.wallet).await?;\n    let erc20_alice = ERC20ForceApproveMock::new(erc20_address, \u0026alice.wallet);\n\n    let init_approval = uint!(100_U256);\n    let value = uint!(10_U256);\n\n    watch!(erc20_alice.regular_approve(\n        safe_erc20_addr,\n        bob_addr,\n        init_approval\n    ))?;\n\n    let initial_bob_allowance =\n        erc20_alice.allowance(safe_erc20_addr, bob_addr).call().await?._0;\n    assert_eq!(initial_bob_allowance, init_approval);\n\n    let receipt = receipt!(safe_erc20_alice.safeDecreaseAllowance(\n        erc20_address,\n        bob_addr,\n        value\n    ))?;\n\n    assert!(receipt.emits(Erc20::Approval {\n        owner: safe_erc20_addr,\n        spender: bob_addr,\n        value: init_approval - value,\n    }));\n\n    let bob_allowance =\n        erc20_alice.allowance(safe_erc20_addr, bob_addr).call().await?._0;\n    assert_eq!(bob_allowance, init_approval - value);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn force_approve_works(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n    let safe_erc20_addr = alice.as_deployer().deploy().await?.contract_address;\n    let safe_erc20_alice = SafeErc20::new(safe_erc20_addr, \u0026alice.wallet);\n    let bob_addr = bob.address();\n\n    let erc20_address = erc20_force_approve::deploy(\u0026alice.wallet).await?;\n    let erc20_alice = ERC20ForceApproveMock::new(erc20_address, \u0026alice.wallet);\n\n    let init_approval = uint!(100_U256);\n    let updated_approval = uint!(10_U256);\n\n    watch!(erc20_alice.regular_approve(\n        safe_erc20_addr,\n        bob_addr,\n        init_approval\n    ))?;\n\n    let initial_bob_allowance =\n        erc20_alice.allowance(safe_erc20_addr, bob_addr).call().await?._0;\n    assert_eq!(initial_bob_allowance, init_approval);\n\n    let receipt = receipt!(safe_erc20_alice.forceApprove(\n        erc20_address,\n        bob_addr,\n        updated_approval\n    ))?;\n\n    assert!(receipt.emits(Erc20::Approval {\n        owner: safe_erc20_addr,\n        spender: bob_addr,\n        value: updated_approval,\n    }));\n\n    let bob_allowance =\n        erc20_alice.allowance(safe_erc20_addr, bob_addr).call().await?._0;\n    assert_eq!(bob_allowance, updated_approval);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","vesting-wallet","src","lib.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\nextern crate alloc;\n\nuse openzeppelin_stylus::finance::vesting_wallet::{\n    self, IVestingWallet, VestingWallet,\n};\nuse stylus_sdk::{\n    alloy_primitives::{Address, U256, U64},\n    prelude::*,\n};\n\n#[entrypoint]\n#[storage]\nstruct VestingWalletExample {\n    vesting_wallet: VestingWallet,\n}\n\n#[public]\n#[implements(IVestingWallet\u003cError = vesting_wallet::Error\u003e)]\nimpl VestingWalletExample {\n    #[constructor]\n    pub fn constructor(\n        \u0026mut self,\n        beneficiary: Address,\n        start_timestamp: U64,\n        duration_seconds: U64,\n    ) -\u003e Result\u003c(), vesting_wallet::Error\u003e {\n        self.vesting_wallet.constructor(\n            beneficiary,\n            start_timestamp,\n            duration_seconds,\n        )\n    }\n\n    #[receive]\n    fn receive(\u0026mut self) -\u003e Result\u003c(), Vec\u003cu8\u003e\u003e {\n        self.vesting_wallet.receive()\n    }\n}\n\n#[public]\nimpl IVestingWallet for VestingWalletExample {\n    type Error = vesting_wallet::Error;\n\n    fn owner(\u0026self) -\u003e Address {\n        self.vesting_wallet.owner()\n    }\n\n    fn transfer_ownership(\n        \u0026mut self,\n        new_owner: Address,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.vesting_wallet.transfer_ownership(new_owner)\n    }\n\n    fn renounce_ownership(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        self.vesting_wallet.renounce_ownership()\n    }\n\n    fn start(\u0026self) -\u003e U256 {\n        self.vesting_wallet.start()\n    }\n\n    fn duration(\u0026self) -\u003e U256 {\n        self.vesting_wallet.duration()\n    }\n\n    fn end(\u0026self) -\u003e U256 {\n        self.vesting_wallet.end()\n    }\n\n    #[selector(name = \"released\")]\n    fn released_eth(\u0026self) -\u003e U256 {\n        self.vesting_wallet.released_eth()\n    }\n\n    #[selector(name = \"released\")]\n    fn released_erc20(\u0026self, token: Address) -\u003e U256 {\n        self.vesting_wallet.released_erc20(token)\n    }\n\n    #[selector(name = \"releasable\")]\n    fn releasable_eth(\u0026self) -\u003e U256 {\n        self.vesting_wallet.releasable_eth()\n    }\n\n    #[selector(name = \"releasable\")]\n    fn releasable_erc20(\n        \u0026mut self,\n        token: Address,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.vesting_wallet.releasable_erc20(token)\n    }\n\n    #[selector(name = \"release\")]\n    fn release_eth(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        self.vesting_wallet.release_eth()\n    }\n\n    #[selector(name = \"release\")]\n    fn release_erc20(\u0026mut self, token: Address) -\u003e Result\u003c(), Self::Error\u003e {\n        self.vesting_wallet.release_erc20(token)\n    }\n\n    #[selector(name = \"vestedAmount\")]\n    fn vested_amount_eth(\u0026self, timestamp: u64) -\u003e U256 {\n        self.vesting_wallet.vested_amount_eth(timestamp)\n    }\n\n    #[selector(name = \"vestedAmount\")]\n    fn vested_amount_erc20(\n        \u0026mut self,\n        token: Address,\n        timestamp: u64,\n    ) -\u003e Result\u003cU256, Self::Error\u003e {\n        self.vesting_wallet.vested_amount_erc20(token, timestamp)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","vesting-wallet","src","main.rs"],"content":"#![cfg_attr(not(any(test, feature = \"export-abi\")), no_main)]\n\n#[cfg(not(any(test, feature = \"export-abi\")))]\n#[no_mangle]\npub extern \"C\" fn main() {}\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    vesting_wallet_example::print_from_args();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","vesting-wallet","tests","abi","mod.rs"],"content":"#![allow(dead_code)]\nuse alloy::sol;\n\nsol!(\n     #[sol(rpc)]\n     contract VestingWallet {\n          function owner() public view virtual returns (address owner);\n          function start() external view returns (uint256 start);\n          function duration() external view returns (uint256 duration);\n          function end() external view returns (uint256 end);\n          function released() external view returns (uint256 released);\n          function released(address token) external view returns (uint256 released);\n          function releasable() external view returns (uint256 releasable);\n          function releasable(address token) external view returns (uint256 releasable);\n          function release() external;\n          function release(address token) external;\n          function vestedAmount(uint64 timestamp) external view returns (uint256 vestedAmount);\n          function vestedAmount(address token, uint64 timestamp) external view returns (uint256 vestedAmount);\n\n          error OwnableUnauthorizedAccount(address account);\n          error OwnableInvalidOwner(address owner);\n          error ReleaseEtherFailed();\n          error SafeErc20FailedOperation(address token);\n          error InvalidToken(address token);\n\n          #[derive(Debug, PartialEq)]\n          event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n          #[derive(Debug, PartialEq)]\n          event EtherReleased(uint256 amount);\n          #[derive(Debug, PartialEq)]\n          event ERC20Released(address indexed token, uint256 amount);\n   }\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","vesting-wallet","tests","mock","erc20.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.21+commit.d9974bed\n    #[sol(rpc, bytecode=\"608060405234801562000010575f80fd5b506040518060400160405280600981526020017f45524332304d6f636b00000000000000000000000000000000000000000000008152506040518060400160405280600381526020017f4d544b000000000000000000000000000000000000000000000000000000000081525081600390816200008e91906200030d565b508060049081620000a091906200030d565b505050620003f1565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806200012557607f821691505b6020821081036200013b576200013a620000e0565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026200019f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000162565b620001ab868362000162565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f620001f5620001ef620001e984620001c3565b620001cc565b620001c3565b9050919050565b5f819050919050565b6200021083620001d5565b620002286200021f82620001fc565b8484546200016e565b825550505050565b5f90565b6200023e62000230565b6200024b81848462000205565b505050565b5b818110156200027257620002665f8262000234565b60018101905062000251565b5050565b601f821115620002c1576200028b8162000141565b620002968462000153565b81016020851015620002a6578190505b620002be620002b58562000153565b83018262000250565b50505b505050565b5f82821c905092915050565b5f620002e35f1984600802620002c6565b1980831691505092915050565b5f620002fd8383620002d2565b9150826002028217905092915050565b6200031882620000a9565b67ffffffffffffffff811115620003345762000333620000b3565b5b6200034082546200010d565b6200034d82828562000276565b5f60209050601f83116001811462000383575f84156200036e578287015190505b6200037a8582620002f0565b865550620003e9565b601f198416620003938662000141565b5f5b82811015620003bc5784890151825560018201915060208501945060208101905062000395565b86831015620003dc5784890151620003d8601f891682620002d2565b8355505b6001600288020188555050505b505050505050565b610ec080620003ff5f395ff3fe608060405234801561000f575f80fd5b506004361061009c575f3560e01c806340c10f191161006457806340c10f191461015a57806370a082311461017657806395d89b41146101a6578063a9059cbb146101c4578063dd62ed3e146101f45761009c565b806306fdde03146100a0578063095ea7b3146100be57806318160ddd146100ee57806323b872dd1461010c578063313ce5671461013c575b5f80fd5b6100a8610224565b6040516100b59190610b39565b60405180910390f35b6100d860048036038101906100d39190610bea565b6102b4565b6040516100e59190610c42565b60405180910390f35b6100f66102d6565b6040516101039190610c6a565b60405180910390f35b61012660048036038101906101219190610c83565b6102df565b6040516101339190610c42565b60405180910390f35b61014461030d565b6040516101519190610cee565b60405180910390f35b610174600480360381019061016f9190610bea565b610315565b005b610190600480360381019061018b9190610d07565b610323565b60405161019d9190610c6a565b60405180910390f35b6101ae610334565b6040516101bb9190610b39565b60405180910390f35b6101de60048036038101906101d99190610bea565b6103c4565b6040516101eb9190610c42565b60405180910390f35b61020e60048036038101906102099190610d32565b6103e6565b60405161021b9190610c6a565b60405180910390f35b60606003805461023390610d9d565b80601f016020809104026020016040519081016040528092919081815260200182805461025f90610d9d565b80156102aa5780601f10610281576101008083540402835291602001916102aa565b820191905f5260205f20905b81548152906001019060200180831161028d57829003601f168201915b5050505050905090565b5f806102be610468565b90506102cb81858561046f565b600191505092915050565b5f600254905090565b5f806102e9610468565b90506102f6858285610481565b610301858585610513565b60019150509392505050565b5f6012905090565b61031f8282610603565b5050565b5f61032d82610682565b9050919050565b60606004805461034390610d9d565b80601f016020809104026020016040519081016040528092919081815260200182805461036f90610d9d565b80156103ba5780601f10610391576101008083540402835291602001916103ba565b820191905f5260205f20905b81548152906001019060200180831161039d57829003601f168201915b5050505050905090565b5f806103ce610468565b90506103db818585610513565b600191505092915050565b5f60015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f33905090565b61047c83838360016106c7565b505050565b5f61048c84846103e6565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811461050d57818110156104fe578281836040517ffb8f41b20000000000000000000000000000000000000000000000000000000081526004016104f593929190610ddc565b60405180910390fd5b61050c84848484035f6106c7565b5b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610583575f6040517f96c6fd1e00000000000000000000000000000000000000000000000000000000815260040161057a9190610e11565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036105f3575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016105ea9190610e11565b60405180910390fd5b6105fe838383610896565b505050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610673575f6040517fec442f0500000000000000000000000000000000000000000000000000000000815260040161066a9190610e11565b60405180910390fd5b61067e5f8383610896565b5050565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b5f73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603610737575f6040517fe602df0500000000000000000000000000000000000000000000000000000000815260040161072e9190610e11565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036107a7575f6040517f94280d6200000000000000000000000000000000000000000000000000000000815260040161079e9190610e11565b60405180910390fd5b8160015f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055508015610890578273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040516108879190610c6a565b60405180910390a35b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036108e6578060025f8282546108da9190610e57565b925050819055506109b4565b5f805f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205490508181101561096f578381836040517fe450d38c00000000000000000000000000000000000000000000000000000000815260040161096693929190610ddc565b60405180910390fd5b8181035f808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036109fb578060025f8282540392505081905550610a45565b805f808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83604051610aa29190610c6a565b60405180910390a3505050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015610ae6578082015181840152602081019050610acb565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610b0b82610aaf565b610b158185610ab9565b9350610b25818560208601610ac9565b610b2e81610af1565b840191505092915050565b5f6020820190508181035f830152610b518184610b01565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610b8682610b5d565b9050919050565b610b9681610b7c565b8114610ba0575f80fd5b50565b5f81359050610bb181610b8d565b92915050565b5f819050919050565b610bc981610bb7565b8114610bd3575f80fd5b50565b5f81359050610be481610bc0565b92915050565b5f8060408385031215610c0057610bff610b59565b5b5f610c0d85828601610ba3565b9250506020610c1e85828601610bd6565b9150509250929050565b5f8115159050919050565b610c3c81610c28565b82525050565b5f602082019050610c555f830184610c33565b92915050565b610c6481610bb7565b82525050565b5f602082019050610c7d5f830184610c5b565b92915050565b5f805f60608486031215610c9a57610c99610b59565b5b5f610ca786828701610ba3565b9350506020610cb886828701610ba3565b9250506040610cc986828701610bd6565b9150509250925092565b5f60ff82169050919050565b610ce881610cd3565b82525050565b5f602082019050610d015f830184610cdf565b92915050565b5f60208284031215610d1c57610d1b610b59565b5b5f610d2984828501610ba3565b91505092915050565b5f8060408385031215610d4857610d47610b59565b5b5f610d5585828601610ba3565b9250506020610d6685828601610ba3565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610db457607f821691505b602082108103610dc757610dc6610d70565b5b50919050565b610dd681610b7c565b82525050565b5f606082019050610def5f830186610dcd565b610dfc6020830185610c5b565b610e096040830184610c5b565b949350505050565b5f602082019050610e245f830184610dcd565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610e6182610bb7565b9150610e6c83610bb7565b9250828201905080821115610e8457610e83610e2a565b5b9291505056fea2646970667358221220aae0e1f0f9317957e6b898e81a54f655e91a33a9848dbdd292ef970a0904968264736f6c63430008150033\")]\n    // SPDX-License-Identifier: MIT\n    contract ERC20Mock is ERC20 {\n        constructor() ERC20(\"ERC20Mock\", \"MTK\") {}\n\n        function balanceOf(address account) public override view returns (uint256 balance) {\n            return super.balanceOf(account);\n        }\n\n        function mint(address account, uint256 value) public {\n            super._mint(account, value);\n        }\n    }\n}\n\npub async fn deploy(wallet: \u0026Wallet) -\u003e eyre::Result\u003cAddress\u003e {\n    // Deploy the contract.\n    let contract = ERC20Mock::deploy(wallet).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","vesting-wallet","tests","mock","erc20_return_false.rs"],"content":"#![allow(dead_code)]\n#![cfg(feature = \"e2e\")]\nuse alloy::{primitives::Address, sol};\nuse e2e::Wallet;\n\nsol! {\n    #[allow(missing_docs)]\n    // Built with Remix IDE; solc v0.8.21+commit.d9974bed\n    #[sol(rpc, bytecode=\"608060405234801562000010575f80fd5b506040518060400160405280601481526020017f455243323052657475726e46616c73654d6f636b0000000000000000000000008152506040518060400160405280600381526020017f52464d000000000000000000000000000000000000000000000000000000000081525081600390816200008e91906200030d565b508060049081620000a091906200030d565b505050620003f1565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806200012557607f821691505b6020821081036200013b576200013a620000e0565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026200019f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000162565b620001ab868362000162565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f620001f5620001ef620001e984620001c3565b620001cc565b620001c3565b9050919050565b5f819050919050565b6200021083620001d5565b620002286200021f82620001fc565b8484546200016e565b825550505050565b5f90565b6200023e62000230565b6200024b81848462000205565b505050565b5b818110156200027257620002665f8262000234565b60018101905062000251565b5050565b601f821115620002c1576200028b8162000141565b620002968462000153565b81016020851015620002a6578190505b620002be620002b58562000153565b83018262000250565b50505b505050565b5f82821c905092915050565b5f620002e35f1984600802620002c6565b1980831691505092915050565b5f620002fd8383620002d2565b9150826002028217905092915050565b6200031882620000a9565b67ffffffffffffffff811115620003345762000333620000b3565b5b6200034082546200010d565b6200034d82828562000276565b5f60209050601f83116001811462000383575f84156200036e578287015190505b6200037a8582620002f0565b865550620003e9565b601f198416620003938662000141565b5f5b82811015620003bc5784890151825560018201915060208501945060208101905062000395565b86831015620003dc5784890151620003d8601f891682620002d2565b8355505b6001600288020188555050505b505050505050565b610b0d80620003ff5f395ff3fe608060405234801561000f575f80fd5b506004361061009c575f3560e01c806340c10f191161006457806340c10f191461015a57806370a082311461017657806395d89b41146101a6578063a9059cbb146101c4578063dd62ed3e146101f45761009c565b806306fdde03146100a0578063095ea7b3146100be57806318160ddd146100ee57806323b872dd1461010c578063313ce5671461013c575b5f80fd5b6100a8610224565b6040516100b59190610786565b60405180910390f35b6100d860048036038101906100d39190610837565b6102b4565b6040516100e5919061088f565b60405180910390f35b6100f66102bb565b60405161010391906108b7565b60405180910390f35b610126600480360381019061012191906108d0565b6102c4565b604051610133919061088f565b60405180910390f35b6101446102cc565b604051610151919061093b565b60405180910390f35b610174600480360381019061016f9190610837565b6102d4565b005b610190600480360381019061018b9190610954565b6102e2565b60405161019d91906108b7565b60405180910390f35b6101ae6102f3565b6040516101bb9190610786565b60405180910390f35b6101de60048036038101906101d99190610837565b610383565b6040516101eb919061088f565b60405180910390f35b61020e6004803603810190610209919061097f565b61038a565b60405161021b91906108b7565b60405180910390f35b606060038054610233906109ea565b80601f016020809104026020016040519081016040528092919081815260200182805461025f906109ea565b80156102aa5780601f10610281576101008083540402835291602001916102aa565b820191905f5260205f20905b81548152906001019060200180831161028d57829003601f168201915b5050505050905090565b5f92915050565b5f600254905090565b5f9392505050565b5f6012905090565b6102de828261039d565b5050565b5f6102ec8261041c565b9050919050565b606060048054610302906109ea565b80601f016020809104026020016040519081016040528092919081815260200182805461032e906109ea565b80156103795780601f1061035057610100808354040283529160200191610379565b820191905f5260205f20905b81548152906001019060200180831161035c57829003601f168201915b5050505050905090565b5f92915050565b5f6103958383610461565b905092915050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361040d575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016104049190610a29565b60405180910390fd5b6104185f83836104e3565b5050565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b5f60015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610533578060025f8282546105279190610a6f565b92505081905550610601565b5f805f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050818110156105bc578381836040517fe450d38c0000000000000000000000000000000000000000000000000000000081526004016105b393929190610aa2565b60405180910390fd5b8181035f808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610648578060025f8282540392505081905550610692565b805f808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516106ef91906108b7565b60405180910390a3505050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015610733578082015181840152602081019050610718565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610758826106fc565b6107628185610706565b9350610772818560208601610716565b61077b8161073e565b840191505092915050565b5f6020820190508181035f83015261079e818461074e565b905092915050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6107d3826107aa565b9050919050565b6107e3816107c9565b81146107ed575f80fd5b50565b5f813590506107fe816107da565b92915050565b5f819050919050565b61081681610804565b8114610820575f80fd5b50565b5f813590506108318161080d565b92915050565b5f806040838503121561084d5761084c6107a6565b5b5f61085a858286016107f0565b925050602061086b85828601610823565b9150509250929050565b5f8115159050919050565b61088981610875565b82525050565b5f6020820190506108a25f830184610880565b92915050565b6108b181610804565b82525050565b5f6020820190506108ca5f8301846108a8565b92915050565b5f805f606084860312156108e7576108e66107a6565b5b5f6108f4868287016107f0565b9350506020610905868287016107f0565b925050604061091686828701610823565b9150509250925092565b5f60ff82169050919050565b61093581610920565b82525050565b5f60208201905061094e5f83018461092c565b92915050565b5f60208284031215610969576109686107a6565b5b5f610976848285016107f0565b91505092915050565b5f8060408385031215610995576109946107a6565b5b5f6109a2858286016107f0565b92505060206109b3858286016107f0565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610a0157607f821691505b602082108103610a1457610a136109bd565b5b50919050565b610a23816107c9565b82525050565b5f602082019050610a3c5f830184610a1a565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610a7982610804565b9150610a8483610804565b9250828201905080821115610a9c57610a9b610a42565b5b92915050565b5f606082019050610ab55f830186610a1a565b610ac260208301856108a8565b610acf60408301846108a8565b94935050505056fea26469706673582212204aac6dd6254b82f37f30add0ed2937474eced0bafc505b611f66b99ebe39999e64736f6c63430008150033\")]\n    // SPDX-License-Identifier: MIT\n    contract ERC20ReturnFalseMock is ERC20 {\n        constructor() ERC20(\"ERC20ReturnFalseMock\", \"RFM\") {}\n\n        function approve(address, uint256) public override returns (bool) {\n            return false;\n        }\n\n        function transfer(address, uint256) public override returns (bool) {\n            return false;\n        }\n\n        function transferFrom(address, address, uint256) public override returns (bool) {\n            return false;\n        }\n\n        function balanceOf(address account) public override view returns (uint256) {\n            return super.balanceOf(account);\n        }\n\n        function mint(address account, uint256 value) public {\n            super._mint(account, value);\n        }\n\n        function allowance(address owner, address spender) public view override returns (uint256) {\n            return super.allowance(owner, spender);\n        }\n    }\n}\n\npub async fn deploy(wallet: \u0026Wallet) -\u003e eyre::Result\u003cAddress\u003e {\n    // Deploy the contract.\n    let contract = ERC20ReturnFalseMock::deploy(wallet).await?;\n    Ok(*contract.address())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","vesting-wallet","tests","mock","mod.rs"],"content":"pub mod erc20;\npub mod erc20_return_false;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","examples","vesting-wallet","tests","vesting-wallet.rs"],"content":"#![cfg(feature = \"e2e\")]\n\nuse abi::VestingWallet;\nuse alloy::{\n    eips::BlockId,\n    network::TransactionBuilder,\n    primitives::{Address, U256},\n    providers::Provider,\n    rpc::types::{BlockTransactionsKind, TransactionRequest},\n};\nuse e2e::{\n    constructor, receipt, send, watch, Account, Constructor,\n    ContractInitializationError, EventExt, Panic, PanicCode, Revert,\n};\nuse mock::{erc20, erc20::ERC20Mock};\n\nmod abi;\nmod mock;\n\nconst BALANCE: u64 = 1000;\nconst DURATION: u64 = 365 * 86400; // 1 year\n\nfn ctr(\n    beneficiary: Address,\n    start_timestamp: u64,\n    duration_seconds: u64,\n) -\u003e Constructor {\n    constructor!(beneficiary, start_timestamp, duration_seconds)\n}\n\nasync fn block_timestamp(account: \u0026Account) -\u003e eyre::Result\u003cu64\u003e {\n    let timestamp = account\n        .wallet\n        .get_block(BlockId::latest(), BlockTransactionsKind::Hashes)\n        .await?\n        .expect(\"latest block should exist\")\n        .header\n        .timestamp;\n\n    Ok(timestamp)\n}\n\n/// Since the block timestamp can theoretically change between the initial fetch\n/// (to calculate the `start` timestamp) and the final release of vested funds\n/// in the test, it is best we assert that the released amount is within\n/// some predefined range.\n/// The reason why the timestamp can change is that we perform many mutations\n/// on-chain, from deploying and activating contracts, sending initial ETH/ERC20\n/// to the contract and then finally releasing the funds.\nfn assert_in_delta(expected: U256, actual: U256) {\n    let diff = expected.abs_diff(actual);\n    let delta = U256::from(1);\n    assert!(diff \u003c= delta, \"Your result of {actual} should be within {delta} of the expected result {expected}\");\n}\n\n#[e2e::test]\nasync fn constructs(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n    let start_timestamp = block_timestamp(\u0026alice).await?;\n    let contract_addr = alice\n        .as_deployer()\n        .with_constructor(ctr(alice.address(), start_timestamp, DURATION))\n        .deploy()\n        .await?\n        .contract_address;\n    let contract = VestingWallet::new(contract_addr, \u0026alice.wallet);\n\n    let owner = contract.owner().call().await?.owner;\n    let start = contract.start().call().await?.start;\n    let duration = contract.duration().call().await?.duration;\n    let end = contract.end().call().await?.end;\n\n    assert_eq!(alice.address(), owner);\n    assert_eq!(U256::from(start_timestamp), start);\n    assert_eq!(U256::from(DURATION), duration);\n    assert_eq!(U256::from(start_timestamp + DURATION), end);\n\n    Ok(())\n}\n\n#[e2e::test]\nasync fn rejects_zero_address_for_beneficiary(\n    alice: Account,\n) -\u003e eyre::Result\u003c()\u003e {\n    let start = block_timestamp(\u0026alice).await?;\n    let err = alice\n        .as_deployer()\n        .with_constructor(ctr(Address::ZERO, start, DURATION))\n        .deploy()\n        .await\n        .expect_err(\"should not deploy due to `OwnableInvalidOwner`\");\n\n    // TODO: assert the actual `OwnableInvalidOwner` error was returned once\n    // StylusDeployer is able to return the exact revert reason from\n    // constructors. assert!(err.\n    // reverted_with(VestingWallet::OwnableInvalidOwner {     owner:\n    // Address::ZERO }));\n\n    assert!(err.downcast_ref::\u003cContractInitializationError\u003e().is_some());\n\n    Ok(())\n}\n\nmod ether_vesting {\n    use super::*;\n\n    async fn deploy(\n        account: \u0026Account,\n        start: u64,\n        duration: u64,\n        allocation: u64,\n    ) -\u003e eyre::Result\u003cAddress\u003e {\n        let contract_addr = account\n            .as_deployer()\n            .with_constructor(ctr(account.address(), start, duration))\n            .deploy()\n            .await?\n            .contract_address;\n\n        let tx = TransactionRequest::default()\n            .with_from(account.address())\n            .with_to(contract_addr)\n            .with_value(U256::from(allocation));\n\n        account.wallet.send_transaction(tx).await?.watch().await?;\n\n        Ok(contract_addr)\n    }\n\n    async fn run_check_release(\n        alice: Account,\n        time_passed: u64,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let timestamp = block_timestamp(\u0026alice).await?;\n        let start = timestamp - time_passed;\n        let expected_amount = U256::from(std::cmp::min(\n            BALANCE,\n            BALANCE * time_passed / DURATION,\n        ));\n        let contract_addr = deploy(\u0026alice, start, DURATION, BALANCE).await?;\n        let contract = VestingWallet::new(contract_addr, \u0026alice.wallet);\n\n        let old_alice_balance =\n            alice.wallet.get_balance(alice.address()).await?;\n        let old_contract_balance =\n            alice.wallet.get_balance(contract_addr).await?;\n\n        let released = contract.released_0().call().await?.released;\n        let releasable = contract.releasable_0().call().await?.releasable;\n        assert_eq!(U256::ZERO, released);\n        assert_in_delta(expected_amount, releasable);\n\n        let receipt = receipt!(contract.release_0())?;\n\n        let alice_balance = alice.wallet.get_balance(alice.address()).await?;\n        let contract_balance = alice.wallet.get_balance(contract_addr).await?;\n        let released = contract.released_0().call().await?.released;\n        let releasable = contract.releasable_0().call().await?.releasable;\n        assert_in_delta(expected_amount, released);\n        assert_in_delta(U256::ZERO, releasable);\n        assert_in_delta(\n            old_alice_balance + released\n                - U256::from(receipt.gas_used * receipt.effective_gas_price),\n            alice_balance,\n        );\n        assert_in_delta(old_contract_balance - released, contract_balance);\n\n        assert!(\n            receipt.emits(VestingWallet::EtherReleased { amount: released })\n        );\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn check_release_0_percent(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n        run_check_release(alice, 0).await\n    }\n\n    #[e2e::test]\n    async fn check_release_25_percent(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n        run_check_release(alice, DURATION / 4).await\n    }\n\n    #[e2e::test]\n    async fn check_release_50_percent(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n        run_check_release(alice, DURATION / 2).await\n    }\n\n    #[e2e::test]\n    async fn check_release_100_percent(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n        run_check_release(alice, DURATION).await\n    }\n\n    #[e2e::test]\n    async fn check_release_100_percent_vesting_in_the_past(\n        alice: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        run_check_release(alice, DURATION * 4 / 3).await\n    }\n\n    #[e2e::test]\n    async fn check_vested_amount(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n        let start = block_timestamp(\u0026alice).await?;\n        let contract_addr = deploy(\u0026alice, start, DURATION, BALANCE).await?;\n\n        let contract = VestingWallet::new(contract_addr, \u0026alice.wallet);\n\n        for i in 0..64 {\n            let timestamp = i * DURATION / 60 + start;\n            let expected_amount = U256::from(std::cmp::min(\n                BALANCE,\n                BALANCE * (timestamp - start) / DURATION,\n            ));\n\n            let vested_amount =\n                contract.vestedAmount_0(timestamp).call().await?.vestedAmount;\n            assert_eq!(\n                expected_amount, vested_amount,\n                \"\\n---\\ni: {i}\\nstart: {start}\\ntimestamp: {timestamp}\\n---\\n\"\n            );\n        }\n\n        Ok(())\n    }\n}\n\nmod erc20_vesting {\n    use super::*;\n\n    async fn deploy(\n        account: \u0026Account,\n        start: u64,\n        duration: u64,\n    ) -\u003e eyre::Result\u003cAddress\u003e {\n        let contract_addr = account\n            .as_deployer()\n            .with_constructor(ctr(account.address(), start, duration))\n            .deploy()\n            .await?\n            .contract_address;\n        Ok(contract_addr)\n    }\n\n    async fn deploy_erc20(\n        account: \u0026Account,\n        mint_to: Address,\n        allocation: U256,\n    ) -\u003e eyre::Result\u003cAddress\u003e {\n        let erc20_address = erc20::deploy(\u0026account.wallet).await?;\n        let erc20 = ERC20Mock::new(erc20_address, \u0026account.wallet);\n        watch!(erc20.mint(mint_to, allocation))?;\n        Ok(erc20_address)\n    }\n\n    async fn deploy_erc20_return_false(\n        account: \u0026Account,\n        mint_to: Address,\n        allocation: u64,\n    ) -\u003e eyre::Result\u003cAddress\u003e {\n        use mock::{\n            erc20_return_false, erc20_return_false::ERC20ReturnFalseMock,\n        };\n\n        let erc20_address = erc20_return_false::deploy(\u0026account.wallet).await?;\n        let erc20 = ERC20ReturnFalseMock::new(erc20_address, \u0026account.wallet);\n        watch!(erc20.mint(mint_to, U256::from(allocation)))?;\n        Ok(erc20_address)\n    }\n\n    async fn run_check_release(\n        alice: Account,\n        time_passed: u64,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let timestamp = block_timestamp(\u0026alice).await?;\n        let start = timestamp - time_passed;\n        let expected_amount = U256::from(std::cmp::min(\n            BALANCE,\n            BALANCE * time_passed / DURATION,\n        ));\n        let contract_addr = deploy(\u0026alice, start, DURATION).await?;\n        let erc20_address =\n            deploy_erc20(\u0026alice, contract_addr, U256::from(BALANCE)).await?;\n\n        let contract = VestingWallet::new(contract_addr, \u0026alice.wallet);\n        let erc20 = ERC20Mock::new(erc20_address, \u0026alice.wallet);\n\n        let old_alice_balance =\n            erc20.balanceOf(alice.address()).call().await?.balance;\n        let old_contract_balance =\n            erc20.balanceOf(contract_addr).call().await?.balance;\n\n        let released =\n            contract.released_1(erc20_address).call().await?.released;\n        let releasable =\n            contract.releasable_1(erc20_address).call().await?.releasable;\n        assert_eq!(U256::ZERO, released);\n        assert_in_delta(expected_amount, releasable);\n\n        let receipt = receipt!(contract.release_1(erc20_address))?;\n\n        let alice_balance =\n            erc20.balanceOf(alice.address()).call().await?.balance;\n        let contract_balance =\n            erc20.balanceOf(contract_addr).call().await?.balance;\n        let released =\n            contract.released_1(erc20_address).call().await?.released;\n        let releasable =\n            contract.releasable_1(erc20_address).call().await?.releasable;\n        assert_in_delta(expected_amount, released);\n        assert_in_delta(U256::ZERO, releasable);\n        assert_in_delta(old_alice_balance + released, alice_balance);\n        assert_in_delta(old_contract_balance - released, contract_balance);\n\n        assert!(receipt.emits(VestingWallet::ERC20Released {\n            token: erc20_address,\n            amount: released\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn check_release_0_percent(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n        run_check_release(alice, 0).await\n    }\n\n    #[e2e::test]\n    async fn check_release_25_percent(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n        run_check_release(alice, DURATION / 4).await\n    }\n\n    #[e2e::test]\n    async fn check_release_50_percent(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n        run_check_release(alice, DURATION / 2).await\n    }\n\n    #[e2e::test]\n    async fn check_release_100_percent(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n        run_check_release(alice, DURATION).await\n    }\n\n    #[e2e::test]\n    async fn check_release_100_percent_vesting_in_the_past(\n        alice: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        run_check_release(alice, DURATION * 4 / 3).await\n    }\n\n    #[e2e::test]\n    async fn check_vested_amount(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n        let start = block_timestamp(\u0026alice).await?;\n        let contract_addr = deploy(\u0026alice, start, DURATION).await?;\n        let erc20_address =\n            deploy_erc20(\u0026alice, contract_addr, U256::from(BALANCE)).await?;\n\n        let contract = VestingWallet::new(contract_addr, \u0026alice.wallet);\n\n        for i in 0..64 {\n            let timestamp = i * DURATION / 60 + start;\n            let expected_amount = U256::from(std::cmp::min(\n                BALANCE,\n                BALANCE * (timestamp - start) / DURATION,\n            ));\n\n            let vested_amount = contract\n                .vestedAmount_1(erc20_address, timestamp)\n                .call()\n                .await?\n                .vestedAmount;\n            assert_eq!(\n                expected_amount, vested_amount,\n                \"\\n---\\ni: {i}\\nstart: {start}\\ntimestamp: {timestamp}\\n---\\n\"\n            );\n        }\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn releasable_erc20_reverts_on_invalid_token(\n        alice: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let start = block_timestamp(\u0026alice).await?;\n        let contract_addr = deploy(\u0026alice, start, DURATION).await?;\n\n        let contract = VestingWallet::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.releasable_1(Address::ZERO))\n            .expect_err(\"should not get releasable amount for invalid token\");\n\n        assert!(err.reverted_with(VestingWallet::InvalidToken {\n            token: Address::ZERO\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn release_erc20_reverts_on_invalid_token(\n        alice: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let start = block_timestamp(\u0026alice).await?;\n        let contract_addr = deploy(\u0026alice, start, DURATION).await?;\n\n        let contract = VestingWallet::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.release_1(Address::ZERO))\n            .expect_err(\"should not release for invalid token\");\n\n        assert!(err.reverted_with(VestingWallet::InvalidToken {\n            token: Address::ZERO\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn release_erc20_reverts_on_failed_transfer(\n        alice: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let start = block_timestamp(\u0026alice).await?;\n        let contract_addr = deploy(\u0026alice, start, DURATION).await?;\n        let erc20_address =\n            deploy_erc20_return_false(\u0026alice, contract_addr, BALANCE).await?;\n\n        let contract = VestingWallet::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.release_1(erc20_address))\n            .expect_err(\"should not release when transfer fails\");\n\n        assert!(err.reverted_with(VestingWallet::SafeErc20FailedOperation {\n            token: erc20_address\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn vested_amount_erc20_reverts_on_invalid_token(\n        alice: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let start = block_timestamp(\u0026alice).await?;\n        let contract_addr = deploy(\u0026alice, start, DURATION).await?;\n\n        let contract = VestingWallet::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.vestedAmount_1(Address::ZERO, start))\n            .expect_err(\"should not get vested amount for invalid token\");\n\n        assert!(err.reverted_with(VestingWallet::InvalidToken {\n            token: Address::ZERO\n        }));\n\n        Ok(())\n    }\n\n    #[e2e::test]\n    async fn vested_amount_reverts_on_scaled_allocation_overflow(\n        alice: Account,\n    ) -\u003e eyre::Result\u003c()\u003e {\n        let start = block_timestamp(\u0026alice).await?;\n        let timestamp = DURATION / 2 + start;\n        let contract_addr = deploy(\u0026alice, start, DURATION).await?;\n        let erc20_address =\n            deploy_erc20(\u0026alice, contract_addr, U256::MAX).await?;\n\n        let contract = VestingWallet::new(contract_addr, \u0026alice.wallet);\n\n        let err = send!(contract.vestedAmount_1(erc20_address, timestamp))\n            .expect_err(\"should exceed `U256::MAX`\");\n\n        assert!(err.panicked_with(PanicCode::ArithmeticOverflow));\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","fuzz","fuzz_targets","keccak.rs"],"content":"#![no_main]\nuse libfuzzer_sys::fuzz_target;\nuse openzeppelin_crypto::{\n    hash::{BuildHasher, Hasher},\n    keccak::KeccakBuilder,\n};\n\nfuzz_target!(|data: \u0026[u8]| {\n    let mut hasher = KeccakBuilder.build_hasher();\n    hasher.update(data);\n    _ = hasher.finalize();\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","fuzz","fuzz_targets","merkle.rs"],"content":"#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse openzeppelin_crypto::merkle::Verifier;\nuse test_fuzz::Input;\n\nfuzz_target!(|input: Input| {\n    let Input { root, leaves, proof, proof_flags } = input;\n\n    let multi_verif =\n        Verifier::verify_multi_proof(\u0026proof, \u0026proof_flags, root, \u0026leaves);\n\n    // If we have a single leaf, also test the regular verification\n    if leaves.len() == 1 {\n        let single_verif = Verifier::verify(\u0026proof, root, leaves[0]);\n\n        // ensure the results match if no errors occurred\n        if let Ok(multi_verif) = multi_verif {\n            assert_eq!(single_verif, multi_verif);\n        }\n\n        // the reason we don't make any assumptions in case of multi-proof\n        // errors is that it is possible that fuzzer generates invalid\n        // proof_flags for valid merkle tree, returning an error\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","fuzz","src","lib.rs"],"content":"use libfuzzer_sys::arbitrary::{\n    Arbitrary, Result as ArbitraryResult, Unstructured,\n};\n\ntype Bytes32 = [u8; 32];\n\nconst MAX_LEAVES: usize = 64;\n\n#[derive(Debug)]\npub struct Input {\n    pub root: Bytes32,\n    pub leaves: Vec\u003cBytes32\u003e,\n    pub proof: Vec\u003cBytes32\u003e,\n    pub proof_flags: Vec\u003cbool\u003e,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for Input {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e ArbitraryResult\u003cSelf\u003e {\n        let root = u.arbitrary()?;\n        let proof: Vec\u003cBytes32\u003e = u.arbitrary()?;\n\n        // leaves.len() + proof.len() \u003e= 1\n        let min_leaves = if proof.is_empty() { 1 } else { 0 };\n        // ensure we don't go overboard with number of leaves\n        let num_leaves = u.int_in_range(min_leaves..=MAX_LEAVES)?;\n        let mut leaves = Vec::with_capacity(num_leaves);\n        for _ in 0..num_leaves {\n            leaves.push(u.arbitrary()?);\n        }\n\n        // ensure we pass the proof flag length check\n        let proof_flag_len = leaves.len() + proof.len() - 1;\n        let mut proof_flags = Vec::with_capacity(proof_flag_len);\n        for _ in 0..proof_flag_len {\n            proof_flags.push(u.arbitrary()?);\n        }\n\n        Ok(Input { root, leaves, proof, proof_flags })\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","fuzz","src","merkle","corpus.rs"],"content":"use std::{fs, io::Write, path::Path};\n\nuse alloy_primitives::hex;\nuse test_fuzz::Input;\n\n/// Simple struct to represent our test cases\nstruct TestCase {\n    name: \u0026'static str,\n    input: Input,\n}\n\n/// Writes a binary corpus file for libFuzzer\nfn write_corpus_file(dir_path: \u0026str, case: \u0026TestCase) -\u003e std::io::Result\u003c()\u003e {\n    let dir = Path::new(dir_path);\n    if !dir.exists() {\n        fs::create_dir_all(dir)?;\n    }\n\n    let file_path = dir.join(format!(\"seed_{}\", case.name));\n    let mut file = fs::File::create(file_path)?;\n\n    // Fuzzer will reconstruct the Input struct from the data, so we need to\n    // write the data in the order in which it would be listed if it were\n    // flattened\n    let Input { root, leaves, proof, proof_flags } = \u0026case.input;\n\n    // Write the root length\n    file.write_all(\u0026root.len().to_le_bytes())?;\n    // Write the root\n    file.write_all(root)?;\n\n    // Write the number of leaves\n    let num_leaves = leaves.len();\n    file.write_all(\u0026num_leaves.to_le_bytes())?;\n\n    // Write each leaf\n    for leaf in leaves {\n        file.write_all(leaf)?;\n    }\n\n    // Write the number of multi-proof hashes\n    let num_proof_hashes = proof.len();\n    file.write_all(\u0026num_proof_hashes.to_le_bytes())?;\n\n    // Write each proof hash\n    for proof_hash in proof {\n        file.write_all(proof_hash)?;\n    }\n\n    // Write the number of proof flags\n    let num_flags = proof_flags.len();\n    file.write_all(\u0026num_flags.to_le_bytes())?;\n\n    // Write each flag as a byte\n    for \u0026flag in proof_flags {\n        let flag_byte = if flag { 1u8 } else { 0u8 };\n        file.write_all(\u0026[flag_byte])?;\n    }\n\n    Ok(())\n}\n\nfn main() -\u003e std::io::Result\u003c()\u003e {\n    let corpus_dir = \"corpus/merkle\";\n\n    let test_cases = vec![\n        TestCase {\n            name: \"3_leaves_valid\",\n            input: Input {\n                root: hex!(\"6deb52b5da8fd108f79fab00341f38d2587896634c646ee52e49f845680a70c8\"),\n                leaves: vec![\n                    hex!(\"19ba6c6333e0e9a15bf67523e0676e2f23eb8e574092552d5e888c64a4bb3681\"),\n                    hex!(\"c62a8cfa41edc0ef6f6ae27a2985b7d39c7fea770787d7e104696c6e81f64848\"),\n                    hex!(\"eba909cf4bb90c6922771d7f126ad0fd11dfde93f3937a196274e1ac20fd2f5b\"),\n                ],\n                proof: vec![\n                    hex!(\"9a4f64e953595df82d1b4f570d34c4f4f0cfaf729a61e9d60e83e579e1aa283e\"),\n                    hex!(\"8076923e76cf01a7c048400a2304c9a9c23bbbdac3a98ea3946340fdafbba34f\"),\n                ],\n                proof_flags: vec![false, true, false, true],\n            },\n        },\n        TestCase {\n            name: \"minimum_valid_case\",\n            input: Input {\n                root: [0u8; 32],\n                leaves: vec![[0u8; 32]],\n                proof: vec![],\n                proof_flags: vec![],\n            },\n        },\n        TestCase {\n            name: \"empty_flags_valid\",\n            input: Input {\n                root: [0u8; 32],\n                leaves: vec![[1u8; 32]],\n                proof: vec![[2u8; 32]],\n                proof_flags: vec![],\n            },\n        },\n        TestCase {\n            name: \"3_leaves_invalid\",\n            input: Input {\n                root: hex!(\"6deb52b5da8fd108f79fab00341f38d2587896634c646ee52e49f845680a70c8\"),\n                leaves: vec![\n                    hex!(\"34e6ce3d0d73f6bff2ee1e865833d58e283570976d70b05f45c989ef651ef742\"),\n                    hex!(\"aa28358fb75b314c899e16d7975e029d18b4457fd8fd831f2e6c17ffd17a1d7e\"),\n                    hex!(\"e0fd7e6916ff95d933525adae392a17e247819ebecc2e63202dfec7005c60560\"),\n                ],\n                proof: vec![],\n                proof_flags: vec![true, true],\n            },\n        },\n        TestCase {\n            name: \"empty_leaves_valid\",\n            input: Input {\n                root: hex!(\"8f7234e8cfe39c08ca84a3a3e3274f574af26fd15165fe29e09cbab742daccd9\"),\n                leaves: vec![],\n                proof: vec![\n                    hex!(\"8f7234e8cfe39c08ca84a3a3e3274f574af26fd15165fe29e09cbab742daccd9\"), // same as root\n                ],\n                proof_flags: vec![],\n            },\n        },\n        // Merkle tree that contains a zero leaf at depth 1\n        //\n        // Taken from https://github.com/advisories/GHSA-wprv-93r4-jj2p\n        //\n        // ```js\n        // const { MerkleTree } = require('merkletreejs'); // v0.2.32\n        // const keccak256 = require('keccak256'); // v1.0.6\n        //\n        // const leaves = [keccak256('real leaf'), Buffer.alloc(32, 0)];\n        // const merkleTree = new MerkleTree(leaves, keccak256, { sortPairs: true });\n        // const root = merkleTree.getRoot();\n        // ```\n        TestCase {\n            name: \"manipulated_multi_proof\",\n            input: Input {\n                root: hex!(\"f2d552e1e4c59d4f0fa2b80859febc9e4bdc915dff37c56c858550d8b64659a5\"),\n                // malicious leaves\n                leaves: vec![\n                    hex!(\"1f23ad5fc0ee6ccbe2f3d30df856758f05ad9d03408a51a99c1c9f0854309db2\"),\n                    hex!(\"4e7e8301f5d206748d1c4f822e3564ddb1124f86591a839f58dfc2f007983b61\"),\n                    hex!(\"613994f4e324d0667c07857cd5d147994bc917da5d07ee63fc3f0a1fe8a18e34\"),\n                ],\n                // [leaves[0], leaves[0]]\n                proof: vec![\n                    hex!(\"5e941ddd8f313c0b39f92562c0eca709c3d91360965d396aaef584b3fa76889a\"),\n                    hex!(\"5e941ddd8f313c0b39f92562c0eca709c3d91360965d396aaef584b3fa76889a\"),\n                ],\n                proof_flags: vec![true, true, false],\n            },\n        },\n        // ```js\n        // const merkleTree = StandardMerkleTree.of(toElements('abcd'), ['string']);\n        //\n        // const root = merkleTree.root;\n        // const hashA = merkleTree.leafHash(['a']);\n        // const hashB = merkleTree.leafHash(['b']);\n        // const hashCD = hashPair(\n        //   ethers.toBeArray(merkleTree.leafHash(['c'])),\n        //   ethers.toBeArray(merkleTree.leafHash(['d'])),\n        // );\n        // const hashE = merkleTree.leafHash(['e']); // incorrect (not part of the tree)\n        // const fill = ethers.randomBytes(32);\n        // ```\n        TestCase {\n            name: \"invalid_leaf\",\n            input: Input {\n                root: hex!(\"8f7234e8cfe39c08ca84a3a3e3274f574af26fd15165fe29e09cbab742daccd9\"),\n                // malicious leaves\n                leaves: vec![\n                    hex!(\"9a4f64e953595df82d1b4f570d34c4f4f0cfaf729a61e9d60e83e579e1aa283e\"), // hashE\n                    hex!(\"9c15a6a0eaeed500fd9eed4cbeab71f797cefcc67bfd46683e4d2e6ff7f06d1c\"), // hashA\n                ],\n                // [hashB, fill, hashCD]\n                proof: vec![\n                    hex!(\"19ba6c6333e0e9a15bf67523e0676e2f23eb8e574092552d5e888c64a4bb3681\"),\n                    hex!(\"1111111111111111111111111111111111111111111111111111111111111111\"),\n                    hex!(\"03707d7802a71ca56a8ad8028da98c4f1dbec55b31b4a25d536b5309cc20eda9\"),\n                ],\n                proof_flags: vec![false, false, false, false],\n            },\n        },\n    ];\n\n    // Write each test case to a file\n    for case in test_cases {\n        write_corpus_file(corpus_dir, \u0026case)?;\n        println!(\"Created corpus file: seed_{}\", case.name);\n    }\n\n    println!(\"Corpus generation complete!\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","arithmetic","limb.rs"],"content":"//! This module contains low-level arithmetic functions for\n//! big integer's limbs.\n\n// Actually cast truncations are a part of the logic here.\n#![allow(clippy::cast_possible_truncation)]\n#![allow(clippy::cast_lossless)]\n\nuse num_traits::ConstOne;\n\n/// A single limb of a big integer represented by 64-bits.\npub type Limb = u64;\n\n/// Array of [`Limb`]s.\npub type Limbs\u003cconst N: usize\u003e = [Limb; N];\n\n/// A wide limb represented by 128-bits.\n///\n/// Twice larger than [`Limb`].\npub type WideLimb = u128;\n\n/// Multiply two [`Limb`]'s and return widened result.\n#[inline(always)]\n#[must_use]\npub const fn widening_mul(a: Limb, b: Limb) -\u003e WideLimb {\n    #[cfg(not(target_family = \"wasm\"))]\n    {\n        a as WideLimb * b as WideLimb\n    }\n    #[cfg(target_family = \"wasm\")]\n    {\n        widening_mul_wasm(a, b)\n    }\n}\n\n/// Multiply two [`Limb`]'s and return widened result.\n///\n/// This function is optimized for wasm target, due to inefficiency of\n/// 128-bit multiplication in WebAssembly.\n#[inline(always)]\n#[doc(hidden)]\n#[allow(dead_code)]\nconst fn widening_mul_wasm(a: Limb, b: Limb) -\u003e WideLimb {\n    let a_lo = a as u32 as Limb;\n    let a_hi = a \u003e\u003e 32;\n    let b_lo = b as u32 as Limb;\n    let b_hi = b \u003e\u003e 32;\n\n    let lolo = (a_lo * b_lo) as WideLimb;\n    let lohi = ((a_lo * b_hi) as WideLimb) \u003c\u003c 32;\n    let hilo = ((a_hi * b_lo) as WideLimb) \u003c\u003c 32;\n    let hihi = ((a_hi * b_hi) as WideLimb) \u003c\u003c 64;\n    (lolo | hihi) + (lohi + hilo)\n}\n\n/// Calculate `a + b * c`, returning the lower 64 bits of the result and setting\n/// `carry` to the upper 64 bits.\n#[inline(always)]\n#[must_use]\npub const fn mac(a: Limb, b: Limb, c: Limb) -\u003e (Limb, Limb) {\n    let a = a as WideLimb;\n    let tmp = a + widening_mul(b, c);\n    let carry = (tmp \u003e\u003e Limb::BITS) as Limb;\n    (tmp as Limb, carry)\n}\n\n/// Calculate `a + (b * c) + carry`, returning the least significant digit\n/// and setting carry to the most significant digit.\n#[inline(always)]\n#[must_use]\npub const fn carrying_mac(\n    a: Limb,\n    b: Limb,\n    c: Limb,\n    carry: Limb,\n) -\u003e (Limb, Limb) {\n    let a = a as WideLimb;\n    let carry = carry as WideLimb;\n    let tmp = a + widening_mul(b, c) + carry;\n    let carry = (tmp \u003e\u003e Limb::BITS) as Limb;\n    (tmp as Limb, carry)\n}\n\n/// Calculate `a = a + b + carry` and return the result and carry.\n#[inline(always)]\n#[must_use]\npub const fn adc(a: Limb, b: Limb, carry: bool) -\u003e (Limb, bool) {\n    let a = a as WideLimb;\n    let b = b as WideLimb;\n    let carry = carry as WideLimb;\n    let tmp = a + b + carry;\n    let carry = (tmp \u003e\u003e Limb::BITS) != 0;\n    (tmp as Limb, carry)\n}\n\n/// Sets a = a + b + carry, and returns the new carry.\n#[inline(always)]\npub fn adc_assign(a: \u0026mut Limb, b: Limb, carry: bool) -\u003e bool {\n    let tmp = *a as WideLimb + b as WideLimb + carry as WideLimb;\n    *a = tmp as Limb;\n    let carry = tmp \u003e\u003e Limb::BITS;\n    carry != 0\n}\n\n/// Calculate `a = a - b - borrow` and return the result and borrow.\n#[inline(always)]\n#[must_use]\npub const fn sbb(a: Limb, b: Limb, borrow: bool) -\u003e (Limb, bool) {\n    let a = a as WideLimb;\n    let b = b as WideLimb;\n    let borrow = borrow as WideLimb;\n    // Protects from overflow, when `a \u003c b + borrow`.\n    let overflow_protection = WideLimb::ONE \u003c\u003c Limb::BITS;\n    let tmp = overflow_protection + a - b - borrow;\n    let borrow = tmp \u003e\u003e Limb::BITS == 0;\n    // overflow_protection will be truncated on cast.\n    (tmp as Limb, borrow)\n}\n\n/// Sets a = a - b - borrow, and returns the borrow.\n#[inline(always)]\npub fn sbb_assign(a: \u0026mut Limb, b: Limb, borrow: bool) -\u003e bool {\n    let (sub, borrow1) = a.overflowing_sub(b);\n    let (sub, borrow2) = sub.overflowing_sub(borrow as Limb);\n    *a = sub;\n    borrow1 | borrow2\n}\n\n#[cfg(test)]\nmod tests {\n    use proptest::prelude::*;\n\n    use super::*;\n\n    #[test]\n    fn check_widening_mul() {\n        proptest!(|(a: Limb, b: Limb)|{\n            let std_mul_result = widening_mul(a, b);\n            let wasm_mul_result = widening_mul_wasm(a, b);\n            prop_assert_eq!(std_mul_result, wasm_mul_result);\n        });\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":48},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","arithmetic","mod.rs"],"content":"//! This module provides a generic interface, constant functions and common\n//! arithmetics for big integers.\n\npub mod limb;\npub mod uint;\n\nuse core::{\n    fmt::{Debug, Display},\n    ops::{\n        BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Shl,\n        ShlAssign, Shr, ShrAssign,\n    },\n};\n\nuse limb::Limb;\nuse zeroize::Zeroize;\n\nuse crate::bits::BitIteratorBE;\n\n/// Defines a big integer with a constant length.\npub trait BigInteger:\n    'static\n    + Copy\n    + Clone\n    + Debug\n    + Default\n    + Display\n    + Eq\n    + Ord\n    + Send\n    + Sized\n    + Sync\n    + Zeroize\n    + From\u003cu128\u003e\n    + From\u003cu64\u003e\n    + From\u003cu32\u003e\n    + From\u003cu16\u003e\n    + From\u003cu8\u003e\n    + BitXorAssign\u003cSelf\u003e\n    + for\u003c'a\u003e BitXorAssign\u003c\u0026'a Self\u003e\n    + BitXor\u003cSelf, Output = Self\u003e\n    + for\u003c'a\u003e BitXor\u003c\u0026'a Self, Output = Self\u003e\n    + BitAndAssign\u003cSelf\u003e\n    + for\u003c'a\u003e BitAndAssign\u003c\u0026'a Self\u003e\n    + BitAnd\u003cSelf, Output = Self\u003e\n    + for\u003c'a\u003e BitAnd\u003c\u0026'a Self, Output = Self\u003e\n    + BitOrAssign\u003cSelf\u003e\n    + for\u003c'a\u003e BitOrAssign\u003c\u0026'a Self\u003e\n    + BitOr\u003cSelf, Output = Self\u003e\n    + for\u003c'a\u003e BitOr\u003c\u0026'a Self, Output = Self\u003e\n    + Shr\u003cu32, Output = Self\u003e\n    + ShrAssign\u003cu32\u003e\n    + Shl\u003cu32, Output = Self\u003e\n    + ShlAssign\u003cu32\u003e\n    + BitIteratorBE\n{\n    /// Number of `usize` limbs representing `Self`.\n    const NUM_LIMBS: usize;\n\n    /// Number of bits in the integer.\n    const BITS: usize = Self::LIMB_BITS * Self::NUM_LIMBS;\n\n    /// Number of bits in a limb.\n    const LIMB_BITS: usize;\n\n    /// The largest value that can be represented by this integer type.\n    const MAX: Self;\n\n    /// The multiplicative identity element of Self, 1.\n    const ONE: Self;\n\n    /// The additive identity element of Self, 0.\n    const ZERO: Self;\n\n    /// Returns true if this number is odd.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use openzeppelin_crypto::arithmetic::{BigInteger, uint::U64};\n    ///\n    /// let mut one = U64::from(1u64);\n    /// assert!(one.is_odd());\n    /// ```\n    fn is_odd(\u0026self) -\u003e bool;\n\n    /// Returns true if this number is even.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use openzeppelin_crypto::arithmetic::{BigInteger, uint::U64};\n    ///\n    /// let mut two = U64::from(2u64);\n    /// assert!(two.is_even());\n    /// ```\n    fn is_even(\u0026self) -\u003e bool;\n\n    /// Returns true if this number is zero.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use openzeppelin_crypto::arithmetic::{BigInteger, uint::U64};\n    ///\n    /// let mut zero = U64::from(0u64);\n    /// assert!(zero.is_zero());\n    /// ```\n    fn is_zero(\u0026self) -\u003e bool;\n\n    /// Return the minimum number of bits needed to encode this number.\n    ///\n    /// One bit is necessary to encode zero.\n    ///\n    /// # Examples\n    /// ```\n    /// use openzeppelin_crypto::arithmetic::{BigInteger, uint::U64};\n    ///\n    /// let zero = U64::from(0u64);\n    /// assert_eq!(zero.num_bits(), 1);\n    /// let one = U64::from(1u64);\n    /// assert_eq!(one.num_bits(), 1);\n    /// let max = U64::from(u64::MAX);\n    /// assert_eq!(max.num_bits(), 64);\n    /// let u32_max = U64::from(u32::MAX as u64);\n    /// assert_eq!(u32_max.num_bits(), 32);\n    /// ```\n    fn num_bits(\u0026self) -\u003e usize;\n\n    /// Find the `i`-th bit of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use openzeppelin_crypto::arithmetic::{BigInteger, uint::U64};\n    ///\n    /// let mut one = U64::from(1u64);\n    /// assert!(one.get_bit(0));\n    /// assert!(!one.get_bit(1));\n    /// ```\n    fn get_bit(\u0026self, i: usize) -\u003e bool;\n\n    /// Create bigint from little-endian bytes.\n    ///\n    /// # Panics\n    ///\n    /// * If the number of bytes is not equal to `Self::BYTES`.\n    fn from_bytes_le(bytes: \u0026[u8]) -\u003e Self;\n\n    /// Convert bigint to little-endian bytes.\n    fn into_bytes_le(self) -\u003e alloc::vec::Vec\u003cu8\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","arithmetic","uint.rs"],"content":"//! This module contains the [`Uint`] unsigned big integer used for\n//! cryptographic applications, altogether with its exact implementations\n//! [`U64`] for 64 bits, [`U128`] for 128 bits, and so on.\n\nuse alloc::vec::Vec;\nuse core::{\n    borrow::Borrow,\n    cmp::Ordering,\n    fmt::{Debug, Display, Result, UpperHex},\n    ops::{\n        BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not,\n        Shl, ShlAssign, Shr, ShrAssign,\n    },\n};\n\nuse num_traits::ConstZero;\nuse zeroize::Zeroize;\n\nuse crate::{\n    arithmetic::{\n        limb,\n        limb::{Limb, Limbs},\n        BigInteger,\n    },\n    bits::BitIteratorBE,\n    ct_for, ct_for_unroll6, ct_rev_for,\n};\n\n/// Stack-allocated big unsigned integer.\n///\n/// Generic over number `N` of [`Limb`]s.\n#[derive(Copy, Clone, PartialEq, Eq, Hash, Zeroize)]\npub struct Uint\u003cconst N: usize\u003e {\n    pub(crate) limbs: Limbs\u003cN\u003e,\n}\n\nimpl\u003cconst N: usize\u003e Default for Uint\u003cN\u003e {\n    fn default() -\u003e Self {\n        Self { limbs: [Limb::ZERO; N] }\n    }\n}\n\n/// Declare [`Uint`] types for different bit sizes.\nmacro_rules! declare_num {\n    ($num:ident, $bits:expr) =\u003e {\n        #[doc = \"Unsigned integer with \"]\n        #[doc = stringify!($bits)]\n        #[doc = \"bits size.\"]\n        pub type $num = $crate::arithmetic::uint::Uint\u003c\n            { usize::div_ceil($bits, $crate::arithmetic::Limb::BITS as usize) },\n        \u003e;\n    };\n}\n\ndeclare_num!(U64, 64);\ndeclare_num!(U128, 128);\ndeclare_num!(U192, 192);\ndeclare_num!(U256, 256);\ndeclare_num!(U384, 384);\ndeclare_num!(U448, 448);\ndeclare_num!(U512, 512);\ndeclare_num!(U576, 576);\ndeclare_num!(U640, 640);\ndeclare_num!(U704, 704);\ndeclare_num!(U768, 768);\ndeclare_num!(U832, 832);\n\nimpl\u003cconst N: usize\u003e Uint\u003cN\u003e {\n    /// Create a new [`Uint`] from the provided `limbs` (constant).\n    #[must_use]\n    pub const fn new(limbs: [Limb; N]) -\u003e Self {\n        Self { limbs }\n    }\n\n    /// Returns reference to the inner [`Limbs`] array (constant).\n    #[must_use]\n    pub const fn as_limbs(\u0026self) -\u003e \u0026Limbs\u003cN\u003e {\n        \u0026self.limbs\n    }\n\n    /// Returns inner [`Limbs`] array (constant).\n    #[must_use]\n    pub const fn into_limbs(self) -\u003e Limbs\u003cN\u003e {\n        self.limbs\n    }\n\n    /// Returns true if this number is odd (constant).\n    #[doc(hidden)]\n    #[inline]\n    #[must_use]\n    pub const fn ct_is_odd(\u0026self) -\u003e bool {\n        self.limbs[0] \u0026 1 == 1\n    }\n\n    /// Returns true if this number is even (constant).\n    #[doc(hidden)]\n    #[inline]\n    #[must_use]\n    pub const fn ct_is_even(\u0026self) -\u003e bool {\n        self.limbs[0] \u0026 1 == 0\n    }\n\n    /// Checks `self` is greater or equal then `rhs` (constant).\n    #[must_use]\n    #[inline(always)]\n    pub const fn ct_ge(\u0026self, rhs: \u0026Self) -\u003e bool {\n        let mut result = true;\n        ct_for_unroll6!((i in 0..N) {\n            let a = self.limbs[i];\n            let b = rhs.limbs[i];\n            if a \u003e b {\n                result = true;\n            } else if a \u003c b {\n                result = false;\n            }\n        });\n        result\n    }\n\n    /// Checks `self` is greater then `rhs` (constant).\n    #[must_use]\n    #[inline(always)]\n    pub const fn ct_gt(\u0026self, rhs: \u0026Self) -\u003e bool {\n        let mut result = false;\n        ct_for_unroll6!((i in 0..N) {\n            let a = self.limbs[i];\n            let b = rhs.limbs[i];\n            if a \u003e b {\n                result = true;\n            } else if a \u003c b {\n                result = false;\n            }\n        });\n        result\n    }\n\n    /// Checks `self` is less or equal then `rhs` (constant).\n    #[must_use]\n    #[inline(always)]\n    pub const fn ct_le(\u0026self, rhs: \u0026Self) -\u003e bool {\n        let mut result = true;\n        ct_for_unroll6!((i in 0..N) {\n            let a = self.limbs[i];\n            let b = rhs.limbs[i];\n            if a \u003c b {\n                result = true;\n            } else if a \u003e b {\n                result = false;\n            }\n        });\n        result\n    }\n\n    /// Checks `self` is less then `rhs` (constant).\n    #[must_use]\n    #[inline(always)]\n    pub const fn ct_lt(\u0026self, rhs: \u0026Self) -\u003e bool {\n        let mut result = false;\n        ct_for_unroll6!((i in 0..N) {\n            let a = self.limbs[i];\n            let b = rhs.limbs[i];\n            if a \u003c b {\n                result = true;\n            } else if a \u003e b {\n                result = false;\n            }\n        });\n        result\n    }\n\n    /// Checks `self` is zero (constant).\n    #[must_use]\n    #[inline(always)]\n    pub const fn ct_is_zero(\u0026self) -\u003e bool {\n        self.ct_eq(\u0026Self::ZERO)\n    }\n\n    /// Checks if `self` is equal to `rhs` (constant).\n    #[must_use]\n    #[inline(always)]\n    pub const fn ct_eq(\u0026self, rhs: \u0026Self) -\u003e bool {\n        ct_for!((i in 0..N) {\n            if self.limbs[i] != rhs.limbs[i] {\n                return false;\n            }\n        });\n        true\n    }\n\n    /// Checks if `self` is not equal to `rhs` (constant).\n    #[must_use]\n    #[inline(always)]\n    pub const fn ct_ne(\u0026self, rhs: \u0026Self) -\u003e bool {\n        !self.ct_eq(rhs)\n    }\n\n    /// Return the minimum number of bits needed to encode this number.\n    ///\n    /// One bit is necessary to encode zero.\n    #[doc(hidden)]\n    #[must_use]\n    pub const fn ct_num_bits(\u0026self) -\u003e usize {\n        // One bit is necessary to encode zero.\n        if self.ct_is_zero() {\n            return 1;\n        }\n\n        // Total number of bits.\n        let mut num_bits = Self::BITS;\n\n        // Start with the last (highest) limb.\n        ct_rev_for!((index in 0..N) {\n            // Subtract leading zeroes, from the total number of limbs.\n            let leading = self.limbs[index].leading_zeros() as usize;\n            num_bits -= leading;\n\n            // If the limb is not empty, stop processing other limbs.\n            if leading != 64 {\n                break;\n            }\n        });\n\n        // And return the result.\n        num_bits\n    }\n\n    /// Find the `i`-th bit of `self`.\n    #[must_use]\n    pub const fn ct_get_bit(\u0026self, i: usize) -\u003e bool {\n        // If `i` is more than total bits, return `false`.\n        if i \u003e= Self::BITS {\n            return false;\n        }\n\n        // Otherwise find `limb` and `bit` indices and get the bit.\n        let bits_in_limb = Limb::BITS as usize;\n        let limb = i / bits_in_limb;\n        let bit = i - bits_in_limb * limb;\n        let mask = 1 \u003c\u003c bit;\n        (self.limbs[limb] \u0026 mask) != 0\n    }\n\n    /// Multiplies `self` by `2` in-place, returning whether overflow occurred.\n    #[inline(always)]\n    #[allow(unused)]\n    pub fn checked_mul2_assign(\u0026mut self) -\u003e bool {\n        let mut last = 0;\n        ct_for_unroll6!((i in 0..N) {\n            let a = \u0026mut self.limbs[i];\n            let tmp = *a \u003e\u003e 63;\n            *a \u003c\u003c= 1;\n            *a |= last;\n            last = tmp;\n        });\n        last != 0\n    }\n\n    /// Multiplies `self` by `2`, returning the result and whether overflow\n    /// occurred (constant).\n    const fn ct_checked_mul2(mut self) -\u003e (Self, bool) {\n        let mut last = 0;\n        ct_for!((i in 0..N) {\n            let a = self.limbs[i];\n            let tmp = a \u003e\u003e 63;\n            self.limbs[i] \u003c\u003c= 1;\n            self.limbs[i] |= last;\n            last = tmp;\n        });\n        (self, last != 0)\n    }\n\n    /// Divide `self` by `2` in-place.\n    pub fn div2_assign(\u0026mut self) {\n        let mut t = 0;\n        for a in self.limbs.iter_mut().rev() {\n            let t2 = *a \u003c\u003c 63;\n            *a \u003e\u003e= 1;\n            *a |= t;\n            t = t2;\n        }\n    }\n\n    /// Subtract `rhs` from `self`, returning the result and whether overflow\n    /// occurred (constant).\n    #[inline(always)]\n    #[must_use]\n    pub const fn ct_checked_sub(mut self, rhs: \u0026Self) -\u003e (Self, bool) {\n        let mut borrow = false;\n\n        ct_for_unroll6!((i in 0..N) {\n            (self.limbs[i], borrow) = limb::sbb(self.limbs[i], rhs.limbs[i], borrow);\n        });\n\n        (self, borrow)\n    }\n\n    /// Subtract `rhs` from `self`, returning the result wrapping around the\n    /// lower boundary (constant).\n    #[inline(always)]\n    #[must_use]\n    pub const fn ct_wrapping_sub(\u0026self, rhs: \u0026Self) -\u003e Self {\n        self.ct_checked_sub(rhs).0\n    }\n\n    /// Add `rhs` to `self`, returning the result and whether overflow occurred\n    /// (constant).\n    #[inline]\n    #[must_use]\n    pub const fn ct_checked_add(mut self, rhs: \u0026Self) -\u003e (Self, bool) {\n        let mut carry = false;\n\n        ct_for!((i in 0..N) {\n            (self.limbs[i], carry) = limb::adc(self.limbs[i], rhs.limbs[i], carry);\n        });\n\n        (self, carry)\n    }\n\n    /// Add `rhs` to `self` in-place, returning whether overflow occurred.\n    #[inline(always)]\n    pub fn checked_add_assign(\u0026mut self, rhs: \u0026Self) -\u003e bool {\n        let mut carry = false;\n\n        ct_for_unroll6!((i in 0..N) {\n            carry = limb::adc_assign(\u0026mut self.limbs[i], rhs.limbs[i], carry);\n        });\n\n        carry\n    }\n\n    /// Subtract `rhs` from `self` in-place, returning whether overflow\n    /// occurred.\n    #[inline(always)]\n    pub fn checked_sub_assign(\u0026mut self, rhs: \u0026Self) -\u003e bool {\n        let mut borrow = false;\n\n        ct_for_unroll6!((i in 0..N) {\n            borrow =\n                limb::sbb_assign(\u0026mut self.limbs[i], rhs.limbs[i], borrow);\n        });\n\n        borrow\n    }\n\n    /// Compute \"wide\" multiplication, with a product twice the size of the\n    /// input.\n    ///\n    /// Returns a tuple containing the `(lo, hi)` components of the product.\n    ///\n    /// Basic multiplication algorithm described in [wiki].\n    /// It is fast enough for runtime use when optimized with loop \"unrolls\",\n    /// like [`ct_for_unroll6`].\n    ///\n    /// [wiki]: https://en.wikipedia.org/wiki/Multiplication_algorithm\n    #[inline(always)]\n    #[must_use]\n    pub const fn ct_widening_mul(\u0026self, rhs: \u0026Self) -\u003e (Self, Self) {\n        let (mut lo, mut hi) = ([0u64; N], [0u64; N]);\n        // For each digit of the first number,\n        ct_for_unroll6!((i in 0..N) {\n            let mut carry = 0;\n            // perform multiplication of each digit from the second.\n            ct_for_unroll6!((j in 0..N) {\n                // And if the multiplication result is too big,\n                let k = i + j;\n                if k \u003e= N {\n                    // it should go to the high (hi) part.\n                    (hi[k - N], carry) = limb::carrying_mac(\n                        hi[k - N],\n                        self.limbs[i],\n                        rhs.limbs[j],\n                        carry\n                    );\n                } else {\n                    (lo[k], carry) = limb::carrying_mac(\n                        lo[k],\n                        self.limbs[i],\n                        rhs.limbs[j],\n                        carry\n                    );\n                }\n            });\n            // Set the last carry to the next limb.\n            hi[i] = carry;\n        });\n\n        (Self::new(lo), Self::new(hi))\n    }\n\n    /// Multiply two numbers and panic on overflow.\n    #[must_use]\n    pub const fn ct_mul(\u0026self, rhs: \u0026Self) -\u003e Self {\n        let (low, high) = self.ct_widening_mul(rhs);\n        assert!(high.ct_eq(\u0026Uint::\u003cN\u003e::ZERO), \"overflow on multiplication\");\n        low\n    }\n\n    /// Add two numbers and panic on overflow.\n    #[must_use]\n    pub const fn ct_add(\u0026self, rhs: \u0026Self) -\u003e Self {\n        let (low, carry) = self.ct_adc(rhs, false);\n        assert!(!carry, \"overflow on addition\");\n        low\n    }\n\n    /// Add two numbers wrapping around the upper boundary.\n    #[must_use]\n    pub const fn ct_wrapping_add(\u0026self, rhs: \u0026Self) -\u003e Self {\n        let (low, _) = self.ct_adc(rhs, false);\n        low\n    }\n\n    /// Computes `a + b + carry`, returning the result along with the new carry.\n    #[inline(always)]\n    #[must_use]\n    pub const fn ct_adc(\u0026self, rhs: \u0026Uint\u003cN\u003e, mut carry: bool) -\u003e (Self, bool) {\n        let mut limbs = [Limb::ZERO; N];\n\n        ct_for!((i in 0..N) {\n            (limbs[i], carry) = limb::adc(self.limbs[i], rhs.limbs[i], carry);\n        });\n\n        (Self { limbs }, carry)\n    }\n\n    /// Create a new [`Uint`] from the provided little endian bytes.\n    #[must_use]\n    pub const fn ct_from_le_slice(bytes: \u0026[u8]) -\u003e Self {\n        const LIMB_BYTES: usize = Limb::BITS as usize / 8;\n        assert!(\n            bytes.len() == LIMB_BYTES * N,\n            \"bytes are not the expected size\"\n        );\n\n        let mut res = [Limb::ZERO; N];\n        let mut buf = [0u8; LIMB_BYTES];\n\n        ct_for!((i in 0..N) {\n            ct_for!((j in 0..LIMB_BYTES) {\n                buf[j] = bytes[i * LIMB_BYTES + j];\n            });\n            res[i] = Limb::from_le_bytes(buf);\n        });\n\n        Self::new(res)\n    }\n}\n\n// ----------- From Impls -----------\n\n/// Constant implementation from primitives.\nmacro_rules! impl_ct_from_primitive {\n    ($int:ty, $func_name:ident) =\u003e {\n        impl\u003cconst N: usize\u003e Uint\u003cN\u003e {\n            #[doc = \"Create a [`Uint`] from\"]\n            #[doc = stringify!($int)]\n            #[doc = \"integer (constant).\"]\n            #[must_use]\n            #[allow(clippy::cast_lossless)]\n            pub const fn $func_name(val: $int) -\u003e Self {\n                assert!(N \u003e= 1, \"number of limbs must be greater than zero\");\n                let mut repr = Self::ZERO;\n                repr.limbs[0] = val as Limb;\n                repr\n            }\n        }\n    };\n}\nimpl_ct_from_primitive!(u8, from_u8);\nimpl_ct_from_primitive!(u16, from_u16);\nimpl_ct_from_primitive!(u32, from_u32);\nimpl_ct_from_primitive!(u64, from_u64);\nimpl_ct_from_primitive!(usize, from_usize);\n\n// Logic for `u128` conversion is different from `u8`..`u64`, due to the size of\n// the `Limb`.\nimpl\u003cconst N: usize\u003e Uint\u003cN\u003e {\n    /// Create a [`Uint`] from a `u128` integer (constant).\n    #[must_use]\n    #[allow(clippy::cast_possible_truncation)]\n    #[allow(clippy::cast_lossless)]\n    pub const fn from_u128(val: u128) -\u003e Self {\n        assert!(N \u003e= 1, \"number of limbs must be greater than zero\");\n\n        let lo = val as Limb;\n        let hi = (val \u003e\u003e 64) as Limb;\n\n        // If there are at least 2 limbs,\n        if N \u003e= 2 {\n            // we can fit `lo` and `hi`,\n            let mut res = Self::ZERO;\n            res.limbs[0] = lo;\n            res.limbs[1] = hi;\n            res\n        } else if hi == Limb::ZERO {\n            // or if `hi` is zero, we can fit `lo`\n            let mut res = Self::ZERO;\n            res.limbs[0] = lo;\n            res\n        } else {\n            // otherwise, we panic.\n            panic!(\"u128 is too large to fit\");\n        }\n    }\n}\n\n/// From traits implementation for primitives.\nmacro_rules! impl_from_primitive {\n    ($int:ty, $func_name:ident) =\u003e {\n        impl\u003cconst N: usize\u003e From\u003c$int\u003e for Uint\u003cN\u003e {\n            #[inline]\n            fn from(val: $int) -\u003e Uint\u003cN\u003e {\n                Uint::\u003cN\u003e::$func_name(val)\n            }\n        }\n    };\n}\n\nimpl_from_primitive!(u8, from_u8);\nimpl_from_primitive!(u16, from_u16);\nimpl_from_primitive!(u32, from_u32);\nimpl_from_primitive!(u64, from_u64);\nimpl_from_primitive!(usize, from_usize);\nimpl_from_primitive!(u128, from_u128);\n\n// ----------- Traits Impls -----------\n\nimpl\u003cconst N: usize\u003e UpperHex for Uint\u003cN\u003e {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e Result {\n        // Concatenate hex representation of limbs in reversed order without\n        // allocations.\n        // By the end, it will produce actual hex of `Uint`.\n        for limb in self.limbs.iter().rev() {\n            write!(f, \"{limb:016X}\")?;\n        }\n        Ok(())\n    }\n}\n\nimpl\u003cconst N: usize\u003e Display for Uint\u003cN\u003e {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e Result {\n        // Use upper hex by default.\n        write!(f, \"{self:X}\")\n    }\n}\n\nimpl\u003cconst N: usize\u003e Debug for Uint\u003cN\u003e {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e Result {\n        write!(f, \"{self}\")\n    }\n}\n\nimpl\u003cconst N: usize\u003e Ord for Uint\u003cN\u003e {\n    #[inline]\n    fn cmp(\u0026self, rhs: \u0026Self) -\u003e Ordering {\n        let mut result = Ordering::Equal;\n        ct_for_unroll6!((i in 0..N) {\n            let a = \u0026self.limbs[i];\n            let b = \u0026rhs.limbs[i];\n            match a.cmp(b) {\n                Ordering::Equal =\u003e {}\n                order =\u003e {result = order},\n            }\n        });\n\n        result\n    }\n}\n\nimpl\u003cconst N: usize\u003e PartialOrd for Uint\u003cN\u003e {\n    #[inline]\n    fn partial_cmp(\u0026self, rhs: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(rhs))\n    }\n}\n\nimpl\u003cconst N: usize\u003e AsMut\u003c[u64]\u003e for Uint\u003cN\u003e {\n    #[inline]\n    fn as_mut(\u0026mut self) -\u003e \u0026mut [u64] {\n        \u0026mut self.limbs\n    }\n}\n\nimpl\u003cconst N: usize\u003e AsRef\u003c[u64]\u003e for Uint\u003cN\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026[u64] {\n        \u0026self.limbs\n    }\n}\n\nimpl\u003cB: Borrow\u003cSelf\u003e, const N: usize\u003e BitXorAssign\u003cB\u003e for Uint\u003cN\u003e {\n    fn bitxor_assign(\u0026mut self, rhs: B) {\n        for i in 0..N {\n            self.limbs[i] ^= rhs.borrow().limbs[i];\n        }\n    }\n}\n\nimpl\u003cB: Borrow\u003cSelf\u003e, const N: usize\u003e BitXor\u003cB\u003e for Uint\u003cN\u003e {\n    type Output = Self;\n\n    fn bitxor(mut self, rhs: B) -\u003e Self::Output {\n        self ^= rhs;\n        self\n    }\n}\n\nimpl\u003cB: Borrow\u003cSelf\u003e, const N: usize\u003e BitAndAssign\u003cB\u003e for Uint\u003cN\u003e {\n    fn bitand_assign(\u0026mut self, rhs: B) {\n        for i in 0..N {\n            self.limbs[i] \u0026= rhs.borrow().limbs[i];\n        }\n    }\n}\n\nimpl\u003cB: Borrow\u003cSelf\u003e, const N: usize\u003e BitAnd\u003cB\u003e for Uint\u003cN\u003e {\n    type Output = Self;\n\n    fn bitand(mut self, rhs: B) -\u003e Self::Output {\n        self \u0026= rhs;\n        self\n    }\n}\n\nimpl\u003cB: Borrow\u003cSelf\u003e, const N: usize\u003e BitOrAssign\u003cB\u003e for Uint\u003cN\u003e {\n    fn bitor_assign(\u0026mut self, rhs: B) {\n        for i in 0..N {\n            self.limbs[i] |= rhs.borrow().limbs[i];\n        }\n    }\n}\n\nimpl\u003cB: Borrow\u003cSelf\u003e, const N: usize\u003e BitOr\u003cB\u003e for Uint\u003cN\u003e {\n    type Output = Self;\n\n    fn bitor(mut self, rhs: B) -\u003e Self::Output {\n        self |= rhs;\n        self\n    }\n}\n\nimpl\u003cconst N: usize\u003e Not for Uint\u003cN\u003e {\n    type Output = Self;\n\n    fn not(self) -\u003e Self::Output {\n        let mut result = Self::ZERO;\n        for i in 0..N {\n            result.limbs[i] = !self.limbs[i];\n        }\n        result\n    }\n}\n\nimpl\u003cconst N: usize\u003e Shr\u003cu32\u003e for Uint\u003cN\u003e {\n    type Output = Self;\n\n    fn shr(mut self, rhs: u32) -\u003e Self::Output {\n        self \u003e\u003e= rhs;\n        self\n    }\n}\n\nimpl\u003cconst N: usize\u003e ShrAssign\u003cu32\u003e for Uint\u003cN\u003e {\n    #[allow(clippy::similar_names)]\n    #[allow(clippy::cast_possible_truncation)]\n    fn shr_assign(\u0026mut self, rhs: u32) {\n        let shift = rhs as usize;\n        let bits = Limb::BITS as usize;\n\n        assert!(N * bits \u003e shift, \"attempt to shift right with overflow\");\n\n        // Limb shift will probably affect changes between two adjacent limbs.\n        // Compute indexes of both limbs that can be changed during a single\n        // iteration.\n        let index2_shift = shift / bits;\n        let index1_shift = index2_shift + 1;\n\n        // The following shifts can overflow.\n        // Overflow should be interpreted with zero output.\n        let limb_right_shift = (shift % bits) as u32;\n        let limb_left_shift = (bits - shift % bits) as u32;\n\n        // Shift bits in limbs array in-place.\n        // Start from the lowest order limb.\n        for index in 0..N {\n            // Take limb from index leaving 0.\n            let current_limb = core::mem::take(\u0026mut self.limbs[index]);\n\n            if index1_shift \u003c= index {\n                let index1 = index - index1_shift;\n                // Possible to copy the first part of limb with bit AND\n                // operation, since the previous limbs were left zero.\n                self.limbs[index1] |= current_limb\n                    .checked_shl(limb_left_shift)\n                    .unwrap_or_default();\n            }\n\n            if index2_shift \u003c= index {\n                let index2 = index - index2_shift;\n                // Possible to copy the second part of limb with bit AND\n                // operation, since the previous limbs were left zero.\n                self.limbs[index2] |= current_limb\n                    .checked_shr(limb_right_shift)\n                    .unwrap_or_default();\n            }\n        }\n    }\n}\n\nimpl\u003cconst N: usize\u003e Shl\u003cu32\u003e for Uint\u003cN\u003e {\n    type Output = Self;\n\n    fn shl(mut self, rhs: u32) -\u003e Self::Output {\n        self \u003c\u003c= rhs;\n        self\n    }\n}\n\nimpl\u003cconst N: usize\u003e ShlAssign\u003cu32\u003e for Uint\u003cN\u003e {\n    #[allow(clippy::similar_names)]\n    #[allow(clippy::cast_possible_truncation)]\n    fn shl_assign(\u0026mut self, rhs: u32) {\n        let shift = rhs as usize;\n        let bits = Limb::BITS as usize;\n\n        assert!(N * bits \u003e shift, \"attempt to shift left with overflow\");\n\n        // Limb shift will probably affect changes between two adjacent limbs.\n        // Compute indexes of both limbs that can be changed during a single\n        // iteration.\n        let index1_shift = shift / bits;\n        let index2_shift = index1_shift + 1;\n\n        // The following shifts can overflow.\n        // Overflow should be interpreted with zero output.\n        let limb_left_shift = (shift % bits) as u32;\n        let limb_right_shift = (bits - shift % bits) as u32;\n\n        // Shift bits in limbs array in-place.\n        // Start from the highest order limb.\n        for index in (0..N).rev() {\n            // Take limb from index leaving 0.\n            let current_limb = core::mem::take(\u0026mut self.limbs[index]);\n\n            let index1 = index + index1_shift;\n            if index1 \u003c N {\n                // Possible to copy the first part of limb with bit AND\n                // operation, since the previous limbs were left zero.\n                self.limbs[index1] |= current_limb\n                    .checked_shl(limb_left_shift)\n                    .unwrap_or_default();\n            }\n\n            let index2 = index + index2_shift;\n            if index2 \u003c N {\n                // Possible to copy the second part of limb with bit AND\n                // operation, since the previous limbs were left zero.\n                self.limbs[index2] |= current_limb\n                    .checked_shr(limb_right_shift)\n                    .unwrap_or_default();\n            }\n        }\n    }\n}\n\nimpl\u003cconst N: usize\u003e BigInteger for Uint\u003cN\u003e {\n    const LIMB_BITS: usize = Limb::BITS as usize;\n    const MAX: Self = Self { limbs: [u64::MAX; N] };\n    const NUM_LIMBS: usize = N;\n    const ONE: Self = {\n        let mut one = Self::ZERO;\n        one.limbs[0] = 1;\n        one\n    };\n    const ZERO: Self = Self { limbs: [0u64; N] };\n\n    fn is_odd(\u0026self) -\u003e bool {\n        self.ct_is_odd()\n    }\n\n    fn is_even(\u0026self) -\u003e bool {\n        self.ct_is_even()\n    }\n\n    fn is_zero(\u0026self) -\u003e bool {\n        self.ct_is_zero()\n    }\n\n    fn num_bits(\u0026self) -\u003e usize {\n        self.ct_num_bits()\n    }\n\n    fn get_bit(\u0026self, i: usize) -\u003e bool {\n        self.ct_get_bit(i)\n    }\n\n    fn from_bytes_le(bytes: \u0026[u8]) -\u003e Self {\n        Self::ct_from_le_slice(bytes)\n    }\n\n    fn into_bytes_le(self) -\u003e Vec\u003cu8\u003e {\n        self.limbs.iter().flat_map(|\u0026limb| limb.to_le_bytes()).collect()\n    }\n}\n\nimpl\u003cconst N: usize\u003e BitIteratorBE for Uint\u003cN\u003e {\n    fn bit_be_iter(self) -\u003e impl Iterator\u003cItem = bool\u003e {\n        self.into_limbs().into_iter().rev().flat_map(Limb::bit_be_iter)\n    }\n}\n\nimpl BitIteratorBE for \u0026[Limb] {\n    fn bit_be_iter(self) -\u003e impl Iterator\u003cItem = bool\u003e {\n        self.iter().rev().copied().flat_map(Limb::bit_be_iter)\n    }\n}\n\n/// Parse a number from a string in a given radix.\n///\n/// This implementation can be slow on big numbers and possibly fail constant\n/// compilation by timeout.\n///\n/// I.e., convert string encoded integer `s` to base-`radix` number.\n#[must_use]\npub const fn from_str_radix\u003cconst LIMBS: usize\u003e(\n    s: \u0026str,\n    radix: u32,\n) -\u003e Uint\u003cLIMBS\u003e {\n    let bytes = s.as_bytes();\n    assert!(!bytes.is_empty(), \"empty string\");\n\n    // The lowest order number is at the end of the string.\n    // Begin parsing from the last index of the string.\n    let mut index = bytes.len() - 1;\n\n    let mut uint = Uint::from_u32(0);\n    let mut order = Uint::from_u32(1);\n    let uint_radix = Uint::from_u32(radix);\n\n    loop {\n        let digit = Uint::from_u32(parse_digit(bytes[index], radix));\n\n        // Add a digit multiplied by order.\n        uint = uint.ct_add(\u0026digit.ct_mul(\u0026order));\n\n        // If we reached the beginning of the string, return the number.\n        if index == 0 {\n            return uint;\n        }\n\n        // Increase the order of magnitude.\n        order = uint_radix.ct_mul(\u0026order);\n\n        // Move to the next digit.\n        index -= 1;\n    }\n}\n\n/// Parse a number from a hex string.\n///\n/// This implementation performs faster than [`from_str_radix`], since it\n/// assumes the radix is already `16`.\n///\n/// If the string number is shorter, then [`Uint`] can store, returns a [`Uint`]\n/// with leading zeroes.\n///\n/// # Panics\n///\n/// * If hex encoded number is too large to fit in [`Uint`].\n#[must_use]\npub const fn from_str_hex\u003cconst LIMBS: usize\u003e(s: \u0026str) -\u003e Uint\u003cLIMBS\u003e {\n    let bytes = s.as_bytes();\n    assert!(!bytes.is_empty(), \"empty string\");\n\n    // The lowest order number is at the end of the string.\n    // Begin parsing from the last index of the string.\n    let mut index = bytes.len() - 1;\n\n    // The lowest order limb is at the beginning of the `num` array.\n    // Begin indexing from `0`.\n    let mut num = [Limb::ZERO; LIMBS];\n    let mut num_index = 0;\n\n    let digit_radix = 16;\n    let digit_size = 4; // Size of a hex digit in bits (2^4 = 16).\n    let digits_in_limb = Limb::BITS / digit_size;\n\n    loop {\n        let digit = parse_digit(bytes[index], digit_radix) as Limb;\n\n        let limb_index = (num_index / digits_in_limb) as usize;\n        assert!(limb_index \u003c num.len(), \"hex number is too large\");\n\n        // Since a base-16 digit can be represented with the same bits, we can\n        // copy these bits.\n        num[limb_index] |= digit \u003c\u003c ((num_index % digits_in_limb) * digit_size);\n\n        // If we reached the beginning of the string, return the number.\n        if index == 0 {\n            return Uint::new(num);\n        }\n\n        // Move to the next digit.\n        index -= 1;\n        num_index += 1;\n    }\n}\n\n// Try to parse a digit from utf-8 byte.\nconst fn parse_digit(utf8_digit: u8, digit_radix: u32) -\u003e u32 {\n    let ch = parse_utf8_byte(utf8_digit);\n    match ch.to_digit(digit_radix) {\n        None =\u003e {\n            panic!(\"invalid digit\");\n        }\n        Some(digit) =\u003e digit,\n    }\n}\n\n/// Parse a single UTF-8 byte into a char.\n///\n/// Converts bytes to characters during compile-time string evaluation.\n/// Only handles ASCII bytes (0x00-0x7F).\n///\n/// # Arguments\n///\n/// * `byte` - Byte to convert.\n///\n/// # Panics\n///\n/// * If the byte is non-ASCII (\u003e= 0x80).\npub(crate) const fn parse_utf8_byte(byte: u8) -\u003e char {\n    match byte {\n        0x00..=0x7F =\u003e byte as char,\n        _ =\u003e panic!(\"non-ASCII character found\"),\n    }\n}\n\n/// This macro converts a string base-10 number to a big integer.\n#[macro_export]\nmacro_rules! from_num {\n    ($num:literal) =\u003e {\n        $crate::arithmetic::uint::from_str_radix($num, 10)\n    };\n}\n\n/// This macro converts a string hex number to a big integer.\n#[macro_export]\nmacro_rules! from_hex {\n    ($num:literal) =\u003e {\n        $crate::arithmetic::uint::from_str_hex($num)\n    };\n}\n\n/// Integer that uses twice more limbs than `Uint` for the same `N` parameter.\n#[derive(Copy, Clone, PartialEq, Eq, Hash, Zeroize)]\npub struct WideUint\u003cconst N: usize\u003e {\n    low: Uint\u003cN\u003e,\n    high: Uint\u003cN\u003e,\n}\n\nimpl\u003cconst N: usize\u003e WideUint\u003cN\u003e {\n    /// Construct new [`WideUint`] from `low` and `high` parts.\n    #[must_use]\n    pub const fn new(low: Uint\u003cN\u003e, high: Uint\u003cN\u003e) -\u003e Self {\n        Self { low, high }\n    }\n\n    /// Compute the remainder of division `self` by `rhs` (constant).\n    ///\n    /// Basic division algorithm based on [wiki].\n    /// Fine to be used for constant evaluation, but slow in runtime.\n    ///\n    /// [wiki]: https://en.wikipedia.org/wiki/Division_algorithm\n    #[must_use]\n    pub const fn ct_rem(\u0026self, rhs: \u0026Uint\u003cN\u003e) -\u003e Uint\u003cN\u003e {\n        assert!(!rhs.ct_is_zero(), \"should not divide by zero\");\n\n        let mut remainder = Uint::\u003cN\u003e::ZERO;\n        let num_bits = self.ct_num_bits();\n\n        // Start from the last bit.\n        ct_rev_for!((index in 0..num_bits) {\n            // Shift the remainder to the left by 1,\n            let (result, carry) = remainder.ct_checked_mul2();\n            remainder = result;\n\n            // and set the first bit to remainder from the dividend.\n            remainder.limbs[0] |= self.ct_get_bit(index) as Limb;\n\n            // If the remainder overflows, subtract the divisor.\n            if remainder.ct_ge(rhs) || carry {\n                (remainder, _) = remainder.ct_checked_sub(rhs);\n            }\n        });\n\n        remainder\n    }\n\n    /// Find the number of bits in the binary decomposition of `self`.\n    ///\n    /// One bit is necessary to encode zero.\n    #[must_use]\n    pub const fn ct_num_bits(\u0026self) -\u003e usize {\n        if self.high.ct_is_zero() {\n            self.low.ct_num_bits()\n        } else {\n            self.high.ct_num_bits() + Uint::\u003cN\u003e::BITS\n        }\n    }\n\n    /// Compute the `i`-th bit of `self`.\n    #[must_use]\n    pub const fn ct_get_bit(\u0026self, i: usize) -\u003e bool {\n        if i \u003e= Uint::\u003cN\u003e::BITS {\n            self.high.ct_get_bit(i - Uint::\u003cN\u003e::BITS)\n        } else {\n            self.low.ct_get_bit(i)\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use proptest::prelude::*;\n\n    use crate::{\n        arithmetic::{\n            uint::{from_str_hex, from_str_radix, Uint, WideUint, U256},\n            BigInteger, Limb,\n        },\n        bits::BitIteratorBE,\n    };\n\n    #[test]\n    fn convert_from_str_radix() {\n        let uint_from_base10: Uint\u003c4\u003e = from_str_radix(\n            \"28948022309329048855892746252171976963363056481941647379679742748393362948097\",\n            10,\n        );\n        #[allow(clippy::unreadable_literal)]\n        let expected = Uint::\u003c4\u003e::new([\n            10108024940646105089u64,\n            2469829653919213789u64,\n            0u64,\n            4611686018427387904u64,\n        ]);\n        assert_eq!(uint_from_base10, expected);\n\n        let uint_from_base10: Uint\u003c1\u003e =\n            from_str_radix(\"18446744069414584321\", 10);\n        let uint_from_binary: Uint\u003c1\u003e = from_str_radix(\n            \"1111111111111111111111111111111100000000000000000000000000000001\",\n            2,\n        );\n        assert_eq!(uint_from_base10, uint_from_binary);\n    }\n\n    #[test]\n    fn convert_from_str_hex() {\n        // Test different implementations of hex parsing on random hex inputs.\n        proptest!(|(hex in \"[0-9a-fA-F]{1,64}\")| {\n            let uint_from_hex: Uint\u003c4\u003e = from_str_hex(\u0026hex);\n            let expected: Uint\u003c4\u003e = from_str_radix(\u0026hex, 16);\n            prop_assert_eq!(uint_from_hex, expected);\n        });\n    }\n\n    #[test]\n    #[should_panic = \"hex number is too large\"]\n    fn from_str_hex_should_panic_on_overflow() {\n        let _ = from_str_hex::\u003c4\u003e(\n            \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0\",\n        );\n    }\n\n    #[test]\n    fn parse_and_display_hex() {\n        // Test parsing from upper hex against displaying in upper hex.\n        proptest!(|(upper_hex in \"[0-9A-F]{64}\")| {\n            let uint_from_hex: Uint\u003c4\u003e = from_str_hex(\u0026upper_hex);\n            let hex_from_uint = format!(\"{uint_from_hex:X}\");\n            prop_assert_eq!(hex_from_uint, upper_hex);\n        });\n    }\n\n    #[test]\n    fn uint_bit_iterator_be() {\n        let words: [Limb; 4] = [0b1100, 0, 0, 0];\n        let num = Uint::\u003c4\u003e::new(words);\n        let bits: Vec\u003cbool\u003e = num.bit_be_trimmed_iter().collect();\n\n        assert_eq!(bits.len(), 4);\n        assert_eq!(bits, vec![true, true, false, false]);\n    }\n\n    #[test]\n    fn num_bits() {\n        let words: [Limb; 4] = [0b1100, 0, 0, 0];\n        let num = Uint::\u003c4\u003e::new(words);\n        assert_eq!(num.num_bits(), 4);\n\n        let words: [Limb; 4] = [0, 0b1100, 0, 0];\n        let num = Uint::\u003c4\u003e::new(words);\n        assert_eq!(num.num_bits(), 64 + 4);\n\n        let words: [Limb; 4] = [0b11, 0b11, 0b11, 0b11];\n        let num = Uint::\u003c4\u003e::new(words);\n        assert_eq!(num.num_bits(), 64 + 64 + 64 + 2);\n    }\n\n    #[test]\n    fn ct_rem() {\n        let dividend = from_num!(\"43129923721897334698312931\");\n        let divisor = from_num!(\"375923422\");\n        let result =\n            WideUint::\u003c4\u003e::new(dividend, Uint::\u003c4\u003e::ZERO).ct_rem(\u0026divisor);\n        assert_eq!(result, from_num!(\"216456157\"));\n    }\n\n    #[test]\n    #[should_panic = \"should not divide by zero\"]\n    fn ct_rem_zero() {\n        let zero = Uint::\u003c4\u003e::ZERO;\n        let divisor = from_num!(\"375923422\");\n        let result = WideUint::\u003c4\u003e::new(zero, zero).ct_rem(\u0026divisor);\n        assert_eq!(result, zero);\n\n        let dividend = from_num!(\"43129923721897334698312931\");\n        let divisor = zero;\n        let _ = WideUint::\u003c4\u003e::new(dividend, zero).ct_rem(\u0026divisor);\n    }\n\n    #[test]\n    fn ct_ge_le_gt_lt_eq_ne() {\n        let a: Uint\u003c4\u003e = Uint::new([0, 0, 0, 5]);\n        let b: Uint\u003c4\u003e = Uint::new([4, 0, 0, 0]);\n        assert!(a.ct_ge(\u0026b));\n        assert!(a.ct_gt(\u0026b));\n        assert!(!a.ct_le(\u0026b));\n        assert!(!a.ct_lt(\u0026b));\n        assert!(!a.ct_eq(\u0026b));\n        assert!(a.ct_ne(\u0026b));\n\n        let a: Uint\u003c4\u003e = Uint::new([0, 0, 0, 5]);\n        let b: Uint\u003c4\u003e = Uint::new([0, 0, 0, 6]);\n        assert!(!a.ct_ge(\u0026b));\n        assert!(!a.ct_gt(\u0026b));\n        assert!(a.ct_le(\u0026b));\n        assert!(a.ct_lt(\u0026b));\n        assert!(!a.ct_eq(\u0026b));\n        assert!(a.ct_ne(\u0026b));\n\n        let a: Uint\u003c4\u003e = Uint::new([0, 0, 1, 2]);\n        let b: Uint\u003c4\u003e = Uint::new([0, 0, 1, 2]);\n        assert!(a.ct_ge(\u0026b));\n        assert!(!a.ct_gt(\u0026b));\n        assert!(a.ct_le(\u0026b));\n        assert!(!a.ct_lt(\u0026b));\n        assert!(a.ct_eq(\u0026b));\n        assert!(!a.ct_ne(\u0026b));\n    }\n\n    #[test]\n    fn shl() {\n        // The first limb is the lowest order part of the number.\n        let num = Uint::\u003c4\u003e::new([0b1100000000, 0, 0, 0]);\n\n        let expected = Uint::\u003c4\u003e::new([0, 0b11000000, 0, 0]);\n        assert_eq!(num \u003c\u003c 62, expected);\n\n        let expected = Uint::\u003c4\u003e::new([0, 0, 0b110000, 0]);\n        assert_eq!(num \u003c\u003c (60 + 64), expected);\n\n        let expected = Uint::\u003c4\u003e::new([0, 0, 0, 0b1100]);\n        assert_eq!(num \u003c\u003c (58 + 64 + 64), expected);\n\n        // edge case to make shift the number into all zeroes\n        let expected = Uint::\u003c4\u003e::new([0, 0, 0, 0]);\n        assert_eq!(num \u003c\u003c (56 + 64 + 64 + 64), expected);\n    }\n\n    #[test]\n    #[should_panic = \"attempt to shift left with overflow\"]\n    fn shl_overflow_should_panic() {\n        let num = Uint::\u003c4\u003e::ONE;\n        let _ = num \u003c\u003c (64 * 4);\n    }\n\n    #[test]\n    fn shr() {\n        // The last limb is the highest order part of the number.\n        let num = Uint::\u003c4\u003e::new([0, 0, 0, 0b11]);\n\n        let expected = Uint::\u003c4\u003e::new([0, 0, 0b1100, 0]);\n        assert_eq!(num \u003e\u003e 62, expected);\n\n        let expected = Uint::\u003c4\u003e::new([0, 0b110000, 0, 0]);\n        assert_eq!(num \u003e\u003e (60 + 64), expected);\n\n        let expected = Uint::\u003c4\u003e::new([0b11000000, 0, 0, 0]);\n        assert_eq!(num \u003e\u003e (58 + 64 + 64), expected);\n\n        // edge case to make shift the number into all zeroes\n        let expected = Uint::\u003c4\u003e::new([0, 0, 0, 0]);\n        assert_eq!(num \u003e\u003e (2 + 64 + 64 + 64), expected);\n    }\n\n    #[test]\n    #[should_panic = \"attempt to shift right with overflow\"]\n    fn shr_overflow_should_panic() {\n        let num = Uint::\u003c4\u003e::ONE;\n        let _ = num \u003e\u003e (64 * 4);\n    }\n\n    #[test]\n    fn shr_shl_edge_case() {\n        let num = Uint::\u003c4\u003e::ONE;\n        assert_eq!(num \u003e\u003e 0, num);\n        assert_eq!(num \u003c\u003c 0, num);\n\n        let num = Uint::\u003c4\u003e::new([\n            0xffffffffffffffff,\n            0xffffffffffffffff,\n            0,\n            0xffffffffffffffff,\n        ]);\n\n        assert_eq!(\n            num \u003e\u003e 64,\n            Uint::\u003c4\u003e::new([0xffffffffffffffff, 0, 0xffffffffffffffff, 0])\n        );\n\n        assert_eq!(\n            num \u003c\u003c 64,\n            Uint::\u003c4\u003e::new([0, 0xffffffffffffffff, 0xffffffffffffffff, 0])\n        );\n    }\n\n    #[test]\n    fn test_process_single_element_masks_correctly() {\n        let low_part_bits = 248;\n        let low_part_mask: U256 = from_str_hex(\n            \"00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n        );\n        let element: U256 = from_str_hex(\n            \"01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n        );\n        let high_part = element \u003e\u003e low_part_bits;\n        let low_part = element \u0026 low_part_mask;\n        assert_eq!(high_part, U256::ONE);\n        assert_eq!(low_part, low_part_mask);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":344},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","bits.rs"],"content":"//! Bit manipulation utilities.\n\n/// Iterates over bits in big-endian order.\npub trait BitIteratorBE: Sized {\n    /// Returns an iterator over the bits of the integer, starting from the most\n    /// significant bit.\n    fn bit_be_iter(self) -\u003e impl Iterator\u003cItem = bool\u003e;\n\n    /// Returns an iterator over the bits of the integer, starting from the most\n    /// significant bit, and without leading zeroes.\n    fn bit_be_trimmed_iter(self) -\u003e impl Iterator\u003cItem = bool\u003e {\n        self.bit_be_iter().skip_while(|\u0026b| !b)\n    }\n}\n\nmacro_rules! impl_bit_iter_be {\n    ($int:ty) =\u003e {\n        impl BitIteratorBE for $int {\n            fn bit_be_iter(self) -\u003e impl Iterator\u003cItem = bool\u003e {\n                (0..\u003c$int\u003e::BITS).rev().map(move |i| self \u0026 (1 \u003c\u003c i) != 0)\n            }\n        }\n    };\n}\n\nimpl_bit_iter_be!(u8);\nimpl_bit_iter_be!(u16);\nimpl_bit_iter_be!(u32);\nimpl_bit_iter_be!(u64);\nimpl_bit_iter_be!(u128);\nimpl_bit_iter_be!(usize);\n\n#[cfg(test)]\nmod tests {\n    use num_traits::ConstOne;\n    use proptest::prelude::*;\n\n    use super::*;\n\n    #[test]\n    fn known_pattern() {\n        let value = 0b1100u64;\n        let full = value.bit_be_iter().collect::\u003cVec\u003c_\u003e\u003e();\n        let expected = [false; 60]\n            .iter()\n            .chain(\u0026[true, true, false, false])\n            .copied()\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(full, expected);\n\n        let trimmed = value.bit_be_trimmed_iter().collect::\u003cVec\u003c_\u003e\u003e();\n        let expected = vec![true, true, false, false];\n        assert_eq!(trimmed, expected);\n    }\n\n    macro_rules! trimmed_is_subset_of_full {\n        ($ty:ident) =\u003e {{\n            proptest!(|(value: $ty)| {\n                let full: Vec\u003cbool\u003e = value.bit_be_iter().collect();\n                let trimmed: Vec\u003cbool\u003e = value.bit_be_trimmed_iter().collect();\n                let start_idx = value.leading_zeros() as usize;\n                prop_assert_eq!(\u0026full[start_idx..], trimmed);\n            });\n        }};\n    }\n\n    #[test]\n    fn trimmed_is_subset_of_full() {\n        trimmed_is_subset_of_full!(u8);\n        trimmed_is_subset_of_full!(u16);\n        trimmed_is_subset_of_full!(u32);\n        trimmed_is_subset_of_full!(u64);\n        trimmed_is_subset_of_full!(u128);\n        trimmed_is_subset_of_full!(usize);\n    }\n\n    macro_rules! edge_case {\n        ($ty:ident) =\u003e {{\n            assert_eq!($ty::MIN.bit_be_trimmed_iter().count(), 0);\n            assert_eq!($ty::MIN.bit_be_iter().count(), $ty::BITS as usize);\n            assert_eq!(\n                $ty::MAX.bit_be_trimmed_iter().count(),\n                $ty::BITS as usize\n            );\n            assert_eq!($ty::MAX.bit_be_iter().count(), $ty::BITS as usize);\n            assert_eq!($ty::ONE.bit_be_trimmed_iter().count(), usize::ONE);\n        }};\n    }\n\n    #[test]\n    fn edge_cases() {\n        edge_case!(u8);\n        edge_case!(u16);\n        edge_case!(u32);\n        edge_case!(u64);\n        edge_case!(u128);\n        edge_case!(usize);\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","const_helpers.rs"],"content":"//! This module contains helpers for functions with constant context, like\n//! [`ct_for`] - constant time `for` cycle, as well as its optimized versions\n//! like [`ct_for_unroll6`], that performs [loop unroll] optimization and can be\n//! used both from compile time and runtime.\n//!\n//! Beware of using an optimized version everywhere, since it can bloat\n//! binary (WASM) size easily.\n//! Measure impact first.\n//!\n//! [loop unroll]: https://en.wikipedia.org/wiki/Loop_unrolling\n\n/// Allows writing `for` cycle in constant context.\n#[macro_export]\nmacro_rules! ct_for {\n    (($i:ident in $start:tt.. $end:tt) $code:expr) =\u003e {{\n        let mut $i = $start;\n        loop {\n            $crate::cycle!($i, $end, $code);\n        }\n    }};\n}\n\n/// Allows writing reversed `for` cycle in constant context.\n///\n/// Start (`$start`) index is not inclusive.\n///\n/// ```rust,ignore\n/// // This loop:\n/// ct_rev_for!((i in 0..10) {\n///\n/// });\n/// // is similar to the following loop:\n/// for i in (0..10).rev() {\n///\n/// }\n/// // Will start from 9 till 0 inclusive.\n/// ```\n#[macro_export]\nmacro_rules! ct_rev_for {\n    (($i:ident in $end:tt.. $start:tt) $code:expr) =\u003e {{\n        let mut $i = $start;\n        loop {\n            $crate::rev_cycle!($i, $end, $code);\n        }\n    }};\n}\n\n/// Allows writing `for` cycle in constant context, with 2 stages loop unroll\n/// optimization.\n#[macro_export]\nmacro_rules! ct_for_unroll2 {\n    (($i:ident in $start:tt.. $end:tt) $code:expr) =\u003e {{\n        let mut $i = $start;\n        loop {\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n        }\n    }};\n}\n\n/// Allows writing `for` cycle in constant context, with 4 stages loop unroll\n/// optimization.\n#[macro_export]\nmacro_rules! ct_for_unroll4 {\n    (($i:ident in $start:tt.. $end:tt) $code:expr) =\u003e {{\n        let mut $i = $start;\n        loop {\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n        }\n    }};\n}\n\n/// Allows writing `for` cycle in constant context, with 6 stages loop unroll\n/// optimization.\n#[macro_export]\nmacro_rules! ct_for_unroll6 {\n    (($i:ident in $start:tt.. $end:tt) $code:expr) =\u003e {{\n        let mut $i = $start;\n        loop {\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n        }\n    }};\n}\n\n/// Allows writing reversed `for` cycle in constant context, with 6 stages loop\n/// unroll optimization.\n///\n/// Start (`$start`) index is not inclusive.\n#[macro_export]\nmacro_rules! ct_rev_for_unroll6 {\n    (($i:ident in $end:tt.. $start:tt) $code:expr) =\u003e {{\n        let mut $i = $start;\n        loop {\n            $crate::rev_cycle!($i, $end, $code);\n            $crate::rev_cycle!($i, $end, $code);\n            $crate::rev_cycle!($i, $end, $code);\n            $crate::rev_cycle!($i, $end, $code);\n            $crate::rev_cycle!($i, $end, $code);\n            $crate::rev_cycle!($i, $end, $code);\n        }\n    }};\n}\n\n/// Allows writing `for` cycle in constant context, with 8 stages loop unroll\n/// optimization.\n#[macro_export]\nmacro_rules! ct_for_unroll8 {\n    (($i:ident in $start:tt.. $end:tt) $code:expr) =\u003e {{\n        let mut $i = $start;\n        loop {\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n            $crate::cycle!($i, $end, $code);\n        }\n    }};\n}\n\n/// Single cycle step in the loop.\n#[macro_export]\nmacro_rules! cycle {\n    ($i:ident, $end:tt, $code:expr) =\u003e {{\n        if $i \u003c $end {\n            $code\n        } else {\n            break;\n        }\n        $i += 1;\n    }};\n}\n\n/// Single cycle step back in the loop.\n#[macro_export]\nmacro_rules! rev_cycle {\n    ($i:ident, $end:tt, $code:expr) =\u003e {{\n        if $end \u003c $i {\n            $i -= 1;\n            $code\n        } else {\n            break;\n        }\n    }};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","curve","helpers.rs"],"content":"//! Helper macros for implementing common traits for curve types.\n\n/// Implements additive operations by deferring to an implementation on \u0026Self.\n#[macro_export]\nmacro_rules! impl_additive_ops_from_ref {\n    ($type:ident, $params:ident) =\u003e {\n        #[allow(unused_qualifications)]\n        impl\u003cP: $params\u003e core::ops::Add\u003cSelf\u003e for $type\u003cP\u003e {\n            type Output = Self;\n\n            #[inline]\n            fn add(self, other: Self) -\u003e Self {\n                let mut result = self;\n                result += \u0026other;\n                result\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003c'a, P: $params\u003e core::ops::Add\u003c\u0026'a mut Self\u003e for $type\u003cP\u003e {\n            type Output = Self;\n\n            #[inline]\n            fn add(self, other: \u0026'a mut Self) -\u003e Self {\n                let mut result = self;\n                result += \u0026*other;\n                result\n            }\n        }\n\n        impl\u003c'b, P: $params\u003e core::ops::Add\u003c$type\u003cP\u003e\u003e for \u0026'b $type\u003cP\u003e {\n            type Output = $type\u003cP\u003e;\n\n            #[inline]\n            fn add(self, mut other: $type\u003cP\u003e) -\u003e $type\u003cP\u003e {\n                other += self;\n                other\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003c'a, 'b, P: $params\u003e core::ops::Add\u003c\u0026'a $type\u003cP\u003e\u003e for \u0026'b $type\u003cP\u003e {\n            type Output = $type\u003cP\u003e;\n\n            #[inline]\n            fn add(self, other: \u0026'a $type\u003cP\u003e) -\u003e $type\u003cP\u003e {\n                let mut result = *self;\n                result += \u0026*other;\n                result\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003c'a, 'b, P: $params\u003e core::ops::Add\u003c\u0026'a mut $type\u003cP\u003e\u003e\n            for \u0026'b $type\u003cP\u003e\n        {\n            type Output = $type\u003cP\u003e;\n\n            #[inline]\n            fn add(self, other: \u0026'a mut $type\u003cP\u003e) -\u003e $type\u003cP\u003e {\n                let mut result = *self;\n                result += \u0026*other;\n                result\n            }\n        }\n\n        impl\u003c'b, P: $params\u003e core::ops::Sub\u003c$type\u003cP\u003e\u003e for \u0026'b $type\u003cP\u003e {\n            type Output = $type\u003cP\u003e;\n\n            #[inline]\n            fn sub(self, other: $type\u003cP\u003e) -\u003e $type\u003cP\u003e {\n                let mut result = *self;\n                result -= \u0026other;\n                result\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003c'a, 'b, P: $params\u003e core::ops::Sub\u003c\u0026'a $type\u003cP\u003e\u003e for \u0026'b $type\u003cP\u003e {\n            type Output = $type\u003cP\u003e;\n\n            #[inline]\n            fn sub(self, other: \u0026'a $type\u003cP\u003e) -\u003e $type\u003cP\u003e {\n                let mut result = *self;\n                result -= \u0026*other;\n                result\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003c'a, 'b, P: $params\u003e core::ops::Sub\u003c\u0026'a mut $type\u003cP\u003e\u003e\n            for \u0026'b $type\u003cP\u003e\n        {\n            type Output = $type\u003cP\u003e;\n\n            #[inline]\n            fn sub(self, other: \u0026'a mut $type\u003cP\u003e) -\u003e $type\u003cP\u003e {\n                let mut result = *self;\n                result -= \u0026*other;\n                result\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003cP: $params\u003e core::ops::Sub\u003cSelf\u003e for $type\u003cP\u003e {\n            type Output = Self;\n\n            #[inline]\n            fn sub(self, other: Self) -\u003e Self {\n                let mut result = self;\n                result -= \u0026other;\n                result\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003c'a, P: $params\u003e core::ops::Sub\u003c\u0026'a mut Self\u003e for $type\u003cP\u003e {\n            type Output = Self;\n\n            #[inline]\n            fn sub(self, other: \u0026'a mut Self) -\u003e Self {\n                let mut result = self;\n                result -= \u0026*other;\n                result\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003cP: $params\u003e core::iter::Sum\u003cSelf\u003e for $type\u003cP\u003e {\n            fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\n                iter.fold(Self::zero(), core::ops::Add::add)\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003c'a, P: $params\u003e core::iter::Sum\u003c\u0026'a Self\u003e for $type\u003cP\u003e {\n            fn sum\u003cI: Iterator\u003cItem = \u0026'a Self\u003e\u003e(iter: I) -\u003e Self {\n                iter.fold(Self::zero(), core::ops::Add::add)\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003cP: $params\u003e core::ops::AddAssign\u003cSelf\u003e for $type\u003cP\u003e {\n            fn add_assign(\u0026mut self, other: Self) {\n                *self += \u0026other\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003cP: $params\u003e core::ops::SubAssign\u003cSelf\u003e for $type\u003cP\u003e {\n            fn sub_assign(\u0026mut self, other: Self) {\n                *self -= \u0026other\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003c'a, P: $params\u003e core::ops::AddAssign\u003c\u0026'a mut Self\u003e for $type\u003cP\u003e {\n            fn add_assign(\u0026mut self, other: \u0026'a mut Self) {\n                *self += \u0026*other\n            }\n        }\n\n        #[allow(unused_qualifications)]\n        impl\u003c'a, P: $params\u003e core::ops::SubAssign\u003c\u0026'a mut Self\u003e for $type\u003cP\u003e {\n            fn sub_assign(\u0026mut self, other: \u0026'a mut Self) {\n                *self -= \u0026*other\n            }\n        }\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","curve","mod.rs"],"content":"//! This module provides common operations to work with elliptic curves.\n//!\n//! Abstractions and api in this module are similar to Arkworks Algebra [ark-ec\n//! library].\n//!\n//! [ark-ec library]: https://github.com/arkworks-rs/algebra/tree/master/ec\n\nuse alloc::vec::Vec;\nuse core::{\n    fmt::{Debug, Display},\n    hash::Hash,\n    ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n};\n\nuse num_traits::Zero;\nuse zeroize::Zeroize;\n\nuse crate::{\n    bits::BitIteratorBE,\n    field::{group::AdditiveGroup, prime::PrimeField, Field},\n};\n\nmod helpers;\npub mod sw;\n\n/// Elliptic curves can be represented via different \"models\" with varying\n/// efficiency properties.\n///\n/// [`CurveConfig`] bundles together the types that are common\n/// to all models of the given curve, namely the [`Self::BaseField`] over which\n/// the curve is defined, and the [`Self::ScalarField`] defined by the\n/// appropriate prime-order subgroup of the curve.\npub trait CurveConfig: Send + Sync + Sized + 'static {\n    /// Base field that the curve is defined over.\n    type BaseField: Field;\n    /// Finite prime field corresponding to an appropriate prime-order subgroup\n    /// of the curve group.\n    type ScalarField: PrimeField;\n\n    /// The cofactor of this curve, represented as a sequence of little-endian\n    /// limbs.\n    const COFACTOR: \u0026'static [u64];\n\n    /// The inverse of the cofactor.\n    const COFACTOR_INV: Self::ScalarField;\n\n    /// Returns `true` if the cofactor is one.\n    fn cofactor_is_one() -\u003e bool {\n        let mut iter = Self::COFACTOR.iter();\n        matches!(iter.next(), Some(1)) \u0026\u0026 iter.all(Zero::is_zero)\n    }\n}\n\n/// Represents (elements of) a group of prime order `r`.\npub trait PrimeGroup: AdditiveGroup\u003cScalar = Self::ScalarField\u003e {\n    /// The scalar field `F_r`, where `r` is the order of this group.\n    type ScalarField: PrimeField;\n\n    /// Returns a fixed generator of this group.\n    #[must_use]\n    fn generator() -\u003e Self;\n\n    /// Performs scalar multiplication of this element.\n    #[must_use]\n    fn mul_bigint(\u0026self, other: impl BitIteratorBE) -\u003e Self;\n\n    /// Computes `other * self`, where `other` is a *big-endian*\n    /// bit representation of some integer.\n    #[must_use]\n    fn mul_bits_be(\u0026self, other: impl Iterator\u003cItem = bool\u003e) -\u003e Self {\n        let mut res = Self::zero();\n        for b in other.skip_while(|b| !b) {\n            // skip leading zeros\n            res.double_in_place();\n            if b {\n                res += self;\n            }\n        }\n        res\n    }\n}\n\n/// An opaque representation of an elliptic curve group element that is suitable\n/// for efficient group arithmetic.\n///\n/// The point is guaranteed to be in the correct prime order subgroup.\npub trait CurveGroup:\n    PrimeGroup\n    + Add\u003cSelf::Affine, Output = Self\u003e\n    + AddAssign\u003cSelf::Affine\u003e\n    + Sub\u003cSelf::Affine, Output = Self\u003e\n    + SubAssign\u003cSelf::Affine\u003e\n    + From\u003cSelf::Affine\u003e\n    + Into\u003cSelf::Affine\u003e\n    + core::iter::Sum\u003cSelf::Affine\u003e\n    + for\u003c'a\u003e core::iter::Sum\u003c\u0026'a Self::Affine\u003e\n{\n    /// Associated configuration for this curve.\n    type Config: CurveConfig\u003c\n        ScalarField = Self::ScalarField,\n        BaseField = Self::BaseField,\n    \u003e;\n\n    /// The field over which this curve is defined.\n    type BaseField: Field;\n\n    /// The affine representation of this element.\n    type Affine: AffineRepr\u003c\n            Config = Self::Config,\n            Group = Self,\n            ScalarField = Self::ScalarField,\n            BaseField = Self::BaseField,\n        \u003e + From\u003cSelf\u003e\n        + Into\u003cSelf\u003e;\n\n    /// Type representing an element of the full elliptic curve group, not just\n    /// the prime order subgroup.\n    type FullGroup;\n\n    /// Normalizes a slice of group elements into affine.\n    #[must_use]\n    fn normalize_batch(v: \u0026[Self]) -\u003e Vec\u003cSelf::Affine\u003e;\n\n    /// Converts `self` into the affine representation.\n    fn into_affine(self) -\u003e Self::Affine {\n        self.into()\n    }\n}\n\n/// The canonical representation of an elliptic curve group element.\n/// This should represent the affine coordinates of the point corresponding\n/// to this group element.\n///\n/// The point is guaranteed to be in the correct prime order subgroup.\npub trait AffineRepr:\n    Eq\n    + 'static\n    + Sized\n    + Copy\n    + Clone\n    + Default\n    + Send\n    + Sync\n    + Hash\n    + Debug\n    + Display\n    + Zeroize\n    + Neg\n    + From\u003c\u003cSelf as AffineRepr\u003e::Group\u003e\n    + Into\u003c\u003cSelf as AffineRepr\u003e::Group\u003e\n    + Add\u003cSelf, Output = Self::Group\u003e\n    + for\u003c'a\u003e Add\u003c\u0026'a Self, Output = Self::Group\u003e\n    + Add\u003cSelf::Group, Output = Self::Group\u003e\n    + for\u003c'a\u003e Add\u003c\u0026'a Self::Group, Output = Self::Group\u003e\n    + Sub\u003cSelf, Output = Self::Group\u003e\n    + for\u003c'a\u003e Sub\u003c\u0026'a Self, Output = Self::Group\u003e\n    + Sub\u003cSelf::Group, Output = Self::Group\u003e\n    + for\u003c'a\u003e Sub\u003c\u0026'a Self::Group, Output = Self::Group\u003e\n    + Mul\u003cSelf::ScalarField, Output = Self::Group\u003e\n    + for\u003c'a\u003e Mul\u003c\u0026'a Self::ScalarField, Output = Self::Group\u003e\n{\n    /// Associated configuration for this curve.\n    type Config: CurveConfig\u003c\n        ScalarField = Self::ScalarField,\n        BaseField = Self::BaseField,\n    \u003e;\n\n    /// Finite prime field corresponding to an appropriate prime-order subgroup\n    /// of the curve group.\n    type ScalarField: PrimeField;\n\n    /// Base field that the curve is defined over.\n    type BaseField: Field;\n\n    /// The projective representation of points on this curve.\n    type Group: CurveGroup\u003c\n            Config = Self::Config,\n            Affine = Self,\n            ScalarField = Self::ScalarField,\n            BaseField = Self::BaseField,\n        \u003e + From\u003cSelf\u003e\n        + Into\u003cSelf\u003e\n        + MulAssign\u003cSelf::ScalarField\u003e; // needed due to https://github.com/rust-lang/rust/issues/69640\n\n    /// Returns the x and y coordinates of this affine point.\n    fn xy(\u0026self) -\u003e Option\u003c(Self::BaseField, Self::BaseField)\u003e;\n\n    /// Returns the x coordinate of this affine point.\n    fn x(\u0026self) -\u003e Option\u003cSelf::BaseField\u003e {\n        self.xy().map(|(x, _)| x)\n    }\n\n    /// Returns the y coordinate of this affine point.\n    fn y(\u0026self) -\u003e Option\u003cSelf::BaseField\u003e {\n        self.xy().map(|(_, y)| y)\n    }\n\n    /// Returns the point at infinity.\n    fn zero() -\u003e Self;\n\n    /// Is `self` the point at infinity?\n    fn is_zero(\u0026self) -\u003e bool {\n        self.xy().is_none()\n    }\n\n    /// Returns a fixed generator of unknown exponent.\n    #[must_use]\n    fn generator() -\u003e Self;\n\n    /// Converts self into the projective representation.\n    fn into_group(self) -\u003e Self::Group {\n        self.into()\n    }\n\n    /// Performs scalar multiplication of this element with mixed addition.\n    #[must_use]\n    fn mul_bigint(\u0026self, by: impl BitIteratorBE) -\u003e Self::Group;\n\n    /// Performs cofactor clearing.\n    /// The default method is simply to multiply by the cofactor.\n    /// For some curve families more efficient methods exist.\n    #[must_use]\n    fn clear_cofactor(\u0026self) -\u003e Self;\n\n    /// Multiplies this element by the cofactor and output the\n    /// resulting projective element.\n    #[must_use]\n    fn mul_by_cofactor_to_group(\u0026self) -\u003e Self::Group;\n\n    /// Multiplies this element by the cofactor.\n    #[must_use]\n    fn mul_by_cofactor(\u0026self) -\u003e Self {\n        self.mul_by_cofactor_to_group().into()\n    }\n\n    /// Multiplies this element by the inverse of the cofactor in\n    /// `Self::ScalarField`.\n    #[must_use]\n    fn mul_by_cofactor_inv(\u0026self) -\u003e Self {\n        self.mul_bigint(Self::Config::COFACTOR_INV.into_bigint()).into()\n    }\n}\n\n/// Efficiently computes inverses of non-zero elements in the slice.\n///\n/// Uses Montgomery's trick to compute multiple inverses with fewer field\n/// operations. Zero elements remain unchanged.\n///\n/// # Arguments\n///\n/// * `v` - Mutable slice of field elements for in-place inversion.\npub fn batch_inversion\u003cF: Field\u003e(v: \u0026mut [F]) {\n    batch_inversion_and_mul(v, \u0026F::one());\n}\n\n/// Efficiently computes `coeff * v_i^(-1)` for each non-zero element.\n///\n/// Optimizes batch inversion by multiplying each result by a coefficient.\n/// Implements Montgomery's trick in two passes to minimize field inversions.\n/// Zero elements remain unchanged.\n///\n/// # Arguments\n///\n/// * `v` - Mutable slice for in-place computation.\n/// * `coeff` - Coefficient to multiply each inverse by.\nfn batch_inversion_and_mul\u003cF: Field\u003e(v: \u0026mut [F], coeff: \u0026F) {\n    // Montgomery's Trick and Fast Implementation of Masked AES\n    // Genelle, Prouff and Quisquater\n    // Section 3.2\n    // but with an optimization to multiply every element in the returned vector\n    // by coeff.\n\n    // First pass: compute [a, ab, abc, ...]\n    let mut tmp = F::one();\n    let prod: Vec\u003c_\u003e = v\n        .iter()\n        .filter(|f| !f.is_zero())\n        .map(|f| {\n            tmp *= f;\n            tmp\n        })\n        .collect();\n\n    // Invert `tmp`.\n    tmp = tmp.inverse().expect(\"should not be zero\");\n\n    // Multiply product by coeff, so coeff will scale all inverses.\n    tmp *= coeff;\n\n    // Second pass: iterate backwards to compute inverses\n    for (f, s) in v\n        .iter_mut()\n        // Backwards\n        .rev()\n        // Ignore normalized elements\n        .filter(|f| !f.is_zero())\n        // Backwards, skip last element, fill in one for last term.\n        .zip(prod.into_iter().rev().skip(1).chain(Some(F::one())))\n    {\n        // tmp := tmp * f; f := tmp * s = 1/f\n        let new_tmp = tmp * *f;\n        *f = tmp * s;\n        tmp = new_tmp;\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","curve","sw","affine.rs"],"content":"//! Affine coordinates for a point on a Short Weierstrass curve\n//! ([Affine Space]).\n//!\n//! [Affine Space]: https://en.wikipedia.org/wiki/Affine_space\n\nuse core::{\n    borrow::Borrow,\n    fmt::{Debug, Display, Formatter},\n    ops::{Add, Mul, Neg, Sub},\n};\n\nuse educe::Educe;\nuse num_traits::{One, Zero};\nuse zeroize::Zeroize;\n\nuse super::{Projective, SWCurveConfig};\nuse crate::{\n    bits::BitIteratorBE,\n    curve::AffineRepr,\n    field::{group::AdditiveGroup, prime::PrimeField, Field},\n};\n\n/// Affine coordinates for a point on an elliptic curve in short Weierstrass\n/// form, over the base field `P::BaseField`.\n#[derive(Educe)]\n#[educe(Copy, Clone, PartialEq, Eq, Hash)]\n#[must_use]\npub struct Affine\u003cP: SWCurveConfig\u003e {\n    #[doc(hidden)]\n    pub x: P::BaseField,\n    #[doc(hidden)]\n    pub y: P::BaseField,\n    #[doc(hidden)]\n    pub infinity: bool,\n}\n\nimpl\u003cP: SWCurveConfig\u003e PartialEq\u003cProjective\u003cP\u003e\u003e for Affine\u003cP\u003e {\n    fn eq(\u0026self, other: \u0026Projective\u003cP\u003e) -\u003e bool {\n        self.into_group() == *other\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Display for Affine\u003cP\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        if self.infinity {\n            write!(f, \"infinity\")\n        } else {\n            write!(f, \"({}, {})\", self.x, self.y)\n        }\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Debug for Affine\u003cP\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        if self.infinity {\n            write!(f, \"infinity\")\n        } else {\n            write!(f, \"({}, {})\", self.x, self.y)\n        }\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Affine\u003cP\u003e {\n    /// Constructs a group element from `x` and `y` coordinates.\n    /// Performs checks to ensure that the point is on the curve and is in the\n    /// right subgroup.\n    ///\n    /// # Panics\n    ///\n    /// * If point is not on curve.\n    /// * If point is not in the prime-order subgroup.\n    pub fn new(x: P::BaseField, y: P::BaseField) -\u003e Self {\n        let point = Self { x, y, infinity: false };\n        assert!(point.is_on_curve());\n        assert!(point.is_in_correct_subgroup_assuming_on_curve());\n        point\n    }\n\n    /// Constructs a group element from `x` and `y` coordinates.\n    ///\n    /// # Warning\n    ///\n    /// Does *not* perform any checks to ensure the point is in the curve or\n    /// is in the right subgroup.\n    pub const fn new_unchecked(x: P::BaseField, y: P::BaseField) -\u003e Self {\n        Self { x, y, infinity: false }\n    }\n\n    /// Additive identity element of the curve group.\n    pub const fn identity() -\u003e Self {\n        Self { x: P::BaseField::ZERO, y: P::BaseField::ZERO, infinity: true }\n    }\n\n    /// Checks if `self` is a valid point on the curve.\n    pub fn is_on_curve(\u0026self) -\u003e bool {\n        if self.infinity {\n            return true;\n        }\n\n        let mut x3b = P::add_b(self.x.square() * self.x);\n        // Optimise addition with zero.\n        if !P::COEFF_A.is_zero() {\n            x3b += P::mul_by_a(self.x);\n        }\n        self.y.square() == x3b\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Affine\u003cP\u003e {\n    /// Checks if `self` is in the subgroup having order that equaling that of\n    /// `P::ScalarField`.\n    // DISCUSS Maybe these function names are too verbose?\n    pub fn is_in_correct_subgroup_assuming_on_curve(\u0026self) -\u003e bool {\n        P::is_in_correct_subgroup_assuming_on_curve(self)\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Zeroize for Affine\u003cP\u003e {\n    // The phantom data does not contain element-specific data\n    // and thus does not need to be zeroized.\n    fn zeroize(\u0026mut self) {\n        self.x.zeroize();\n        self.y.zeroize();\n        self.infinity.zeroize();\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e AffineRepr for Affine\u003cP\u003e {\n    type BaseField = P::BaseField;\n    type Config = P;\n    type Group = Projective\u003cP\u003e;\n    type ScalarField = P::ScalarField;\n\n    fn xy(\u0026self) -\u003e Option\u003c(Self::BaseField, Self::BaseField)\u003e {\n        (!self.infinity).then_some((self.x, self.y))\n    }\n\n    #[inline]\n    fn generator() -\u003e Self {\n        P::GENERATOR\n    }\n\n    fn zero() -\u003e Self {\n        Self { x: P::BaseField::ZERO, y: P::BaseField::ZERO, infinity: true }\n    }\n\n    fn mul_bigint(\u0026self, by: impl BitIteratorBE) -\u003e Self::Group {\n        P::mul_affine(self, by)\n    }\n\n    /// Multiplies this element by the cofactor and output the\n    /// resulting projective element.\n    fn mul_by_cofactor_to_group(\u0026self) -\u003e Self::Group {\n        P::mul_affine(self, Self::Config::COFACTOR)\n    }\n\n    /// Performs cofactor clearing.\n    /// The default method is simply to multiply by the cofactor.\n    /// Some curves can implement a more efficient algorithm.\n    fn clear_cofactor(\u0026self) -\u003e Self {\n        P::clear_cofactor(self)\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Neg for Affine\u003cP\u003e {\n    type Output = Self;\n\n    /// If `self.is_zero()`, returns `self` (`== Self::zero()`).\n    /// Else, returns `(x, -y)`, where `self = (x, y)`.\n    #[inline]\n    fn neg(mut self) -\u003e Self {\n        self.y.neg_in_place();\n        self\n    }\n}\n\nimpl\u003cP: SWCurveConfig, T: Borrow\u003cSelf\u003e\u003e Add\u003cT\u003e for Affine\u003cP\u003e {\n    type Output = Projective\u003cP\u003e;\n\n    fn add(self, other: T) -\u003e Projective\u003cP\u003e {\n        let mut copy = self.into_group();\n        copy += other.borrow();\n        copy\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Add\u003cProjective\u003cP\u003e\u003e for Affine\u003cP\u003e {\n    type Output = Projective\u003cP\u003e;\n\n    fn add(self, other: Projective\u003cP\u003e) -\u003e Projective\u003cP\u003e {\n        other + self\n    }\n}\n\nimpl\u003c'a, P: SWCurveConfig\u003e Add\u003c\u0026'a Projective\u003cP\u003e\u003e for Affine\u003cP\u003e {\n    type Output = Projective\u003cP\u003e;\n\n    fn add(self, other: \u0026'a Projective\u003cP\u003e) -\u003e Projective\u003cP\u003e {\n        *other + self\n    }\n}\n\nimpl\u003cP: SWCurveConfig, T: Borrow\u003cSelf\u003e\u003e Sub\u003cT\u003e for Affine\u003cP\u003e {\n    type Output = Projective\u003cP\u003e;\n\n    fn sub(self, other: T) -\u003e Projective\u003cP\u003e {\n        let mut copy = self.into_group();\n        copy -= other.borrow();\n        copy\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Sub\u003cProjective\u003cP\u003e\u003e for Affine\u003cP\u003e {\n    type Output = Projective\u003cP\u003e;\n\n    fn sub(self, other: Projective\u003cP\u003e) -\u003e Projective\u003cP\u003e {\n        self + (-other)\n    }\n}\n\nimpl\u003c'a, P: SWCurveConfig\u003e Sub\u003c\u0026'a Projective\u003cP\u003e\u003e for Affine\u003cP\u003e {\n    type Output = Projective\u003cP\u003e;\n\n    fn sub(self, other: \u0026'a Projective\u003cP\u003e) -\u003e Projective\u003cP\u003e {\n        self + (-*other)\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Default for Affine\u003cP\u003e {\n    #[inline]\n    fn default() -\u003e Self {\n        Self::identity()\n    }\n}\n\nimpl\u003cP: SWCurveConfig, T: Borrow\u003cP::ScalarField\u003e\u003e Mul\u003cT\u003e for Affine\u003cP\u003e {\n    type Output = Projective\u003cP\u003e;\n\n    #[inline]\n    fn mul(self, other: T) -\u003e Self::Output {\n        self.mul_bigint(other.borrow().into_bigint())\n    }\n}\n\n// The projective point X, Y, Z is represented in the affine\n// coordinates as X/Z^2, Y/Z^3.\nimpl\u003cP: SWCurveConfig\u003e From\u003cProjective\u003cP\u003e\u003e for Affine\u003cP\u003e {\n    #[inline]\n    fn from(p: Projective\u003cP\u003e) -\u003e Affine\u003cP\u003e {\n        if p.is_zero() {\n            Affine::identity()\n        } else if p.z.is_one() {\n            // If Z is one, the point is already normalized.\n            Affine::new_unchecked(p.x, p.y)\n        } else {\n            // Z is nonzero, so it must have an inverse in a field.\n            let zinv = p.z.inverse().unwrap();\n            let zinv_squared = zinv.square();\n\n            // X/Z^2\n            let x = p.x * zinv_squared;\n\n            // Y/Z^3\n            let y = p.y * zinv_squared * zinv;\n\n            Affine::new_unchecked(x, y)\n        }\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":74},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","curve","sw","mod.rs"],"content":"//! This module contains definitions for the [Short Weierstrass model] of the\n//! curve.\n//!\n//! [Short Weierstrass model]: https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html\n\nuse num_traits::Zero;\n\nmod affine;\npub use affine::*;\n\nmod projective;\npub use projective::*;\n\nuse crate::{\n    bits::BitIteratorBE,\n    curve::AffineRepr,\n    field::{group::AdditiveGroup, prime::PrimeField},\n};\n\n/// Constants and convenience functions that collectively define the\n/// [Short Weierstrass model] of the curve.\n///\n/// In this model, the curve equation is `y² = x³ + a * x + b`, for constants\n/// `a` and `b`.\n///\n/// [Short Weierstrass model]: https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html\npub trait SWCurveConfig: super::CurveConfig {\n    /// Coefficient `a` of the curve equation.\n    const COEFF_A: Self::BaseField;\n    /// Coefficient `b` of the curve equation.\n    const COEFF_B: Self::BaseField;\n    /// Generator of the prime-order subgroup.\n    const GENERATOR: Affine\u003cSelf\u003e;\n\n    /// Helper method for computing `elem * Self::COEFF_A`.\n    ///\n    /// The default implementation should be overridden only if\n    /// the product can be computed faster than standard field multiplication\n    /// (eg: via doubling if `COEFF_A == 2`, or if `COEFF_A.is_zero()`).\n    #[inline(always)]\n    fn mul_by_a(elem: Self::BaseField) -\u003e Self::BaseField {\n        if Self::COEFF_A.is_zero() {\n            Self::BaseField::ZERO\n        } else {\n            elem * Self::COEFF_A\n        }\n    }\n\n    /// Helper method for computing `elem + Self::COEFF_B`.\n    ///\n    /// The default implementation should be overridden only if\n    /// the sum can be computed faster than standard field addition (eg: via\n    /// doubling).\n    #[inline(always)]\n    fn add_b(elem: Self::BaseField) -\u003e Self::BaseField {\n        if Self::COEFF_B.is_zero() {\n            elem\n        } else {\n            elem + Self::COEFF_B\n        }\n    }\n\n    /// Check if the provided curve point is in the prime-order subgroup.\n    ///\n    /// The default implementation multiplies `item` by the order `r` of the\n    /// prime-order subgroup, and checks if the result is zero. If the\n    /// curve's cofactor is one, this check automatically returns true.\n    /// Implementors can choose to override this default impl\n    /// if the given curve has faster methods\n    /// for performing this check (for example, via leveraging curve\n    /// isomorphisms).\n    fn is_in_correct_subgroup_assuming_on_curve(item: \u0026Affine\u003cSelf\u003e) -\u003e bool {\n        Self::cofactor_is_one()\n            || Self::mul_affine(item, Self::ScalarField::characteristic())\n                .is_zero()\n    }\n\n    /// Performs cofactor clearing.\n    /// The default method is simply to multiply by the cofactor.\n    /// Some curves can implement a more efficient algorithm.\n    fn clear_cofactor(item: \u0026Affine\u003cSelf\u003e) -\u003e Affine\u003cSelf\u003e {\n        item.mul_by_cofactor()\n    }\n\n    /// Default implementation of group multiplication for projective\n    /// coordinates\n    fn mul_projective(\n        base: \u0026Projective\u003cSelf\u003e,\n        scalar: impl BitIteratorBE,\n    ) -\u003e Projective\u003cSelf\u003e {\n        sw_double_and_add_projective(base, scalar)\n    }\n\n    /// Default implementation of group multiplication for affine\n    /// coordinates.\n    fn mul_affine(\n        base: \u0026Affine\u003cSelf\u003e,\n        scalar: impl BitIteratorBE,\n    ) -\u003e Projective\u003cSelf\u003e {\n        sw_double_and_add_affine(base, scalar)\n    }\n}\n\n/// Standard double-and-add method for multiplication by a scalar.\n#[inline(always)]\npub fn sw_double_and_add_affine\u003cP: SWCurveConfig\u003e(\n    base: \u0026Affine\u003cP\u003e,\n    scalar: impl BitIteratorBE,\n) -\u003e Projective\u003cP\u003e {\n    let mut res = Projective::zero();\n    for b in scalar.bit_be_trimmed_iter() {\n        res.double_in_place();\n        if b {\n            res += base;\n        }\n    }\n\n    res\n}\n\n/// Standard double-and-add method for multiplication by a scalar.\n#[inline(always)]\npub fn sw_double_and_add_projective\u003cP: SWCurveConfig\u003e(\n    base: \u0026Projective\u003cP\u003e,\n    scalar: impl BitIteratorBE,\n) -\u003e Projective\u003cP\u003e {\n    let mut res = Projective::zero();\n    for b in scalar.bit_be_trimmed_iter() {\n        res.double_in_place();\n        if b {\n            res += base;\n        }\n    }\n\n    res\n}\n\n#[cfg(test)]\nmod test {\n    use num_traits::Zero;\n\n    use crate::{\n        arithmetic::uint::U256,\n        curve::{sw::SWCurveConfig, AffineRepr, CurveConfig, CurveGroup},\n        field::{\n            fp::{Fp256, FpParams, LIMBS_256},\n            group::AdditiveGroup,\n        },\n        fp_from_hex, fp_from_num, from_num,\n    };\n\n    type Affine = super::Affine\u003cConfig\u003e;\n    type Projective = super::Projective\u003cConfig\u003e;\n\n    #[derive(Clone, Default, PartialEq, Eq)]\n    struct Config;\n\n    type Fq = Fp256\u003cFqParam\u003e;\n    struct FqParam;\n\n    impl FpParams\u003cLIMBS_256\u003e for FqParam {\n        const GENERATOR: Fp256\u003cSelf\u003e = fp_from_num!(\"3\");\n        const MODULUS: U256 = from_num!(\"115792089237316195423570985008687907853269984665640564039457584007908834671663\");\n    }\n\n    type Fr = Fp256\u003cFrParam\u003e;\n    struct FrParam;\n\n    impl FpParams\u003cLIMBS_256\u003e for FrParam {\n        const GENERATOR: Fp256\u003cSelf\u003e = fp_from_num!(\"7\");\n        const MODULUS: U256 = from_num!(\"115792089237316195423570985008687907852837564279074904382605163141518161494337\");\n    }\n\n    impl CurveConfig for Config {\n        type BaseField = Fq;\n        type ScalarField = Fr;\n\n        const COFACTOR: \u0026'static [u64] = \u0026[0x1, 0x0];\n        const COFACTOR_INV: Fr = Fr::ONE;\n    }\n\n    impl SWCurveConfig for Config {\n        const COEFF_A: Fq = Fq::ZERO;\n        const COEFF_B: Fq = fp_from_num!(\"7\");\n        const GENERATOR: Affine =\n            Affine::new_unchecked(G_GENERATOR_X, G_GENERATOR_Y);\n    }\n\n    const G_GENERATOR_X: Fq =\n        fp_from_num!(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\");\n\n    const G_GENERATOR_Y: Fq =\n        fp_from_num!(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\");\n\n    #[test]\n    fn scalar_mul() {\n        assert!(Affine::generator().mul_bigint(0u32).into_affine().infinity);\n\n        let result: Vec\u003c_\u003e = (1u32..25)\n            .map(|k| Affine::generator().mul_bigint(k).into_affine())\n            .collect();\n\n        let expected =\n            [\n                (fp_from_hex!(\"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\"), fp_from_hex!(\"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\")),\n                (fp_from_hex!(\"C6047F9441ED7D6D3045406E95C07CD85C778E4B8CEF3CA7ABAC09B95C709EE5\"), fp_from_hex!(\"1AE168FEA63DC339A3C58419466CEAEEF7F632653266D0E1236431A950CFE52A\")),\n                (fp_from_hex!(\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\"), fp_from_hex!(\"388F7B0F632DE8140FE337E62A37F3566500A99934C2231B6CB9FD7584B8E672\")),\n                (fp_from_hex!(\"E493DBF1C10D80F3581E4904930B1404CC6C13900EE0758474FA94ABE8C4CD13\"), fp_from_hex!(\"51ED993EA0D455B75642E2098EA51448D967AE33BFBDFE40CFE97BDC47739922\")),\n                (fp_from_hex!(\"2F8BDE4D1A07209355B4A7250A5C5128E88B84BDDC619AB7CBA8D569B240EFE4\"), fp_from_hex!(\"D8AC222636E5E3D6D4DBA9DDA6C9C426F788271BAB0D6840DCA87D3AA6AC62D6\")),\n                (fp_from_hex!(\"FFF97BD5755EEEA420453A14355235D382F6472F8568A18B2F057A1460297556\"), fp_from_hex!(\"AE12777AACFBB620F3BE96017F45C560DE80F0F6518FE4A03C870C36B075F297\")),\n                (fp_from_hex!(\"5CBDF0646E5DB4EAA398F365F2EA7A0E3D419B7E0330E39CE92BDDEDCAC4F9BC\"), fp_from_hex!(\"6AEBCA40BA255960A3178D6D861A54DBA813D0B813FDE7B5A5082628087264DA\")),\n                (fp_from_hex!(\"2F01E5E15CCA351DAFF3843FB70F3C2F0A1BDD05E5AF888A67784EF3E10A2A01\"), fp_from_hex!(\"5C4DA8A741539949293D082A132D13B4C2E213D6BA5B7617B5DA2CB76CBDE904\")),\n                (fp_from_hex!(\"ACD484E2F0C7F65309AD178A9F559ABDE09796974C57E714C35F110DFC27CCBE\"), fp_from_hex!(\"CC338921B0A7D9FD64380971763B61E9ADD888A4375F8E0F05CC262AC64F9C37\")),\n                (fp_from_hex!(\"A0434D9E47F3C86235477C7B1AE6AE5D3442D49B1943C2B752A68E2A47E247C7\"), fp_from_hex!(\"893ABA425419BC27A3B6C7E693A24C696F794C2ED877A1593CBEE53B037368D7\")),\n                (fp_from_hex!(\"774AE7F858A9411E5EF4246B70C65AAC5649980BE5C17891BBEC17895DA008CB\"), fp_from_hex!(\"D984A032EB6B5E190243DD56D7B7B365372DB1E2DFF9D6A8301D74C9C953C61B\")),\n                (fp_from_hex!(\"D01115D548E7561B15C38F004D734633687CF4419620095BC5B0F47070AFE85A\"), fp_from_hex!(\"A9F34FFDC815E0D7A8B64537E17BD81579238C5DD9A86D526B051B13F4062327\")),\n                (fp_from_hex!(\"F28773C2D975288BC7D1D205C3748651B075FBC6610E58CDDEEDDF8F19405AA8\"), fp_from_hex!(\"AB0902E8D880A89758212EB65CDAF473A1A06DA521FA91F29B5CB52DB03ED81\")),\n                (fp_from_hex!(\"499FDF9E895E719CFD64E67F07D38E3226AA7B63678949E6E49B241A60E823E4\"), fp_from_hex!(\"CAC2F6C4B54E855190F044E4A7B3D464464279C27A3F95BCC65F40D403A13F5B\")),\n                (fp_from_hex!(\"D7924D4F7D43EA965A465AE3095FF41131E5946F3C85F79E44ADBCF8E27E080E\"), fp_from_hex!(\"581E2872A86C72A683842EC228CC6DEFEA40AF2BD896D3A5C504DC9FF6A26B58\")),\n                (fp_from_hex!(\"E60FCE93B59E9EC53011AABC21C23E97B2A31369B87A5AE9C44EE89E2A6DEC0A\"), fp_from_hex!(\"F7E3507399E595929DB99F34F57937101296891E44D23F0BE1F32CCE69616821\")),\n                (fp_from_hex!(\"DEFDEA4CDB677750A420FEE807EACF21EB9898AE79B9768766E4FAA04A2D4A34\"), fp_from_hex!(\"4211AB0694635168E997B0EAD2A93DAECED1F4A04A95C0F6CFB199F69E56EB77\")),\n                (fp_from_hex!(\"5601570CB47F238D2B0286DB4A990FA0F3BA28D1A319F5E7CF55C2A2444DA7CC\"), fp_from_hex!(\"C136C1DC0CBEB930E9E298043589351D81D8E0BC736AE2A1F5192E5E8B061D58\")),\n                (fp_from_hex!(\"2B4EA0A797A443D293EF5CFF444F4979F06ACFEBD7E86D277475656138385B6C\"), fp_from_hex!(\"85E89BC037945D93B343083B5A1C86131A01F60C50269763B570C854E5C09B7A\")),\n                (fp_from_hex!(\"4CE119C96E2FA357200B559B2F7DD5A5F02D5290AFF74B03F3E471B273211C97\"), fp_from_hex!(\"12BA26DCB10EC1625DA61FA10A844C676162948271D96967450288EE9233DC3A\")),\n                (fp_from_hex!(\"352BBF4A4CDD12564F93FA332CE333301D9AD40271F8107181340AEF25BE59D5\"), fp_from_hex!(\"321EB4075348F534D59C18259DDA3E1F4A1B3B2E71B1039C67BD3D8BCF81998C\")),\n                (fp_from_hex!(\"421F5FC9A21065445C96FDB91C0C1E2F2431741C72713B4B99DDCB316F31E9FC\"), fp_from_hex!(\"2B90F16D11DABDB616F6DB7E225D1E14743034B37B223115DB20717AD1CD6781\")),\n                (fp_from_hex!(\"2FA2104D6B38D11B0230010559879124E42AB8DFEFF5FF29DC9CDADD4ECACC3F\"), fp_from_hex!(\"2DE1068295DD865B64569335BD5DD80181D70ECFC882648423BA76B532B7D67\")),\n                (fp_from_hex!(\"FE72C435413D33D48AC09C9161BA8B09683215439D62B7940502BDA8B202E6CE\"), fp_from_hex!(\"6851DE067FF24A68D3AB47E09D72998101DC88E36B4A9D22978ED2FBCF58C5BF\")),\n            ];\n\n        for (result, (expected_x, expected_y)) in result.iter().zip(expected) {\n            assert!(result.is_on_curve());\n            assert_eq!(result.x, expected_x);\n            assert_eq!(result.y, expected_y);\n        }\n    }\n\n    #[test]\n    fn point_add() {\n        let g = Affine::generator();\n        let g_proj: Projective = g.into();\n\n        // Test G + G = 2G\n        let expected_g2 = Affine::new_unchecked(\n            fp_from_hex!(\"C6047F9441ED7D6D3045406E95C07CD85C778E4B8CEF3CA7ABAC09B95C709EE5\"),\n            fp_from_hex!(\"1AE168FEA63DC339A3C58419466CEAEEF7F632653266D0E1236431A950CFE52A\"),\n        );\n        let g2 = g_proj + g;\n        let g2_affine = g2.into_affine();\n        assert_eq!(g2_affine, expected_g2);\n        let g2_affine = g_proj.double().into_affine();\n        assert_eq!(g2_affine, expected_g2);\n\n        // Test G + (-G) = 0\n        let neg_g = -g_proj;\n        let zero = g_proj + neg_g;\n        assert!(zero.is_zero());\n    }\n\n    #[test]\n    fn point_sub() {\n        let g = Affine::generator();\n        let g_proj: Projective = g.into();\n\n        // Test G - G = 0\n        let zero = g_proj - g_proj;\n        assert!(zero.is_zero());\n\n        // Test 2G - G = G\n        let g2: Projective = Affine::new_unchecked(\n                fp_from_hex!(\"C6047F9441ED7D6D3045406E95C07CD85C778E4B8CEF3CA7ABAC09B95C709EE5\"),\n                fp_from_hex!(\"1AE168FEA63DC339A3C58419466CEAEEF7F632653266D0E1236431A950CFE52A\"),\n            ).into();\n        assert_eq!(g2 - g_proj, g_proj);\n    }\n\n    #[test]\n    fn cofactor_is_one() {\n        #[derive(Clone, Default, PartialEq, Eq)]\n        struct NotOneCofactorConfig;\n\n        impl CurveConfig for NotOneCofactorConfig {\n            type BaseField = Fq;\n            type ScalarField = Fr;\n\n            const COFACTOR: \u0026'static [u64] = \u0026[0x0, 0x0, 0x0, 0x1, 0x0];\n            const COFACTOR_INV: Fr = Fr::ONE;\n        }\n\n        assert!(Config::cofactor_is_one());\n        assert!(!NotOneCofactorConfig::cofactor_is_one());\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","curve","sw","projective.rs"],"content":"//! Projective coordinates for a point on a Short Weierstrass curve\n//! ([Homogeneous coordinates]).\n//!\n//! [Homogeneous coordinates]: https://en.wikipedia.org/wiki/Homogeneous_coordinates\n\nuse alloc::vec::Vec;\nuse core::{\n    borrow::Borrow,\n    fmt::{Debug, Display, Formatter},\n    hash::{Hash, Hasher},\n    ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n};\n\nuse educe::Educe;\nuse num_traits::{One, Zero};\nuse zeroize::Zeroize;\n\nuse super::{Affine, SWCurveConfig};\nuse crate::{\n    bits::BitIteratorBE,\n    curve::{batch_inversion, AffineRepr, CurveGroup, PrimeGroup},\n    field::{group::AdditiveGroup, prime::PrimeField, Field},\n    impl_additive_ops_from_ref,\n};\n\n/// Jacobian coordinates for a point on an elliptic curve in short Weierstrass\n/// form, over the base field `P::BaseField`. This struct implements arithmetic\n/// via the Jacobian formulae.\n#[derive(Educe)]\n#[educe(Copy, Clone)]\n#[must_use]\npub struct Projective\u003cP: SWCurveConfig\u003e {\n    /// `X / Z` projection of the affine `X`\n    pub x: P::BaseField,\n    /// `Y / Z` projection of the affine `Y`\n    pub y: P::BaseField,\n    /// Projective multiplicative inverse. Will be `0` only at infinity.\n    pub z: P::BaseField,\n}\n\nimpl\u003cP: SWCurveConfig\u003e Display for Projective\u003cP\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        write!(f, \"{}\", Affine::from(*self))\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Debug for Projective\u003cP\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        if self.is_zero() {\n            write!(f, \"infinity\")\n        } else {\n            write!(f, \"({}, {}, {})\", self.x, self.y, self.z)\n        }\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Eq for Projective\u003cP\u003e {}\nimpl\u003cP: SWCurveConfig\u003e PartialEq for Projective\u003cP\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        if self.is_zero() {\n            return other.is_zero();\n        }\n\n        if other.is_zero() {\n            return false;\n        }\n\n        // The points (X, Y, Z) and (X', Y', Z')\n        // are equal when (X * Z'^2) = (X' * Z^2)\n        // and (Y * Z'^3) = (Y' * Z^3).\n        let z1z1 = self.z.square();\n        let z2z2 = other.z.square();\n\n        if self.x * z2z2 == other.x * z1z1 {\n            self.y * (z2z2 * other.z) == other.y * (z1z1 * self.z)\n        } else {\n            false\n        }\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e PartialEq\u003cAffine\u003cP\u003e\u003e for Projective\u003cP\u003e {\n    fn eq(\u0026self, other: \u0026Affine\u003cP\u003e) -\u003e bool {\n        self == \u0026other.into_group()\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Hash for Projective\u003cP\u003e {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.into_affine().hash(state);\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Default for Projective\u003cP\u003e {\n    #[inline]\n    fn default() -\u003e Self {\n        Self::zero()\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Projective\u003cP\u003e {\n    /// Constructs a new group element without checking whether the coordinates\n    /// specify a point in the subgroup.\n    pub const fn new_unchecked(\n        x: P::BaseField,\n        y: P::BaseField,\n        z: P::BaseField,\n    ) -\u003e Self {\n        Self { x, y, z }\n    }\n\n    /// Constructs a new group element in a way while enforcing that points are\n    /// in the prime-order subgroup.\n    ///\n    /// # Panics\n    ///\n    /// * If point is not on curve.\n    /// * If point is not in the prime-order subgroup.\n    pub fn new(x: P::BaseField, y: P::BaseField, z: P::BaseField) -\u003e Self {\n        let p = Self::new_unchecked(x, y, z).into_affine();\n        assert!(p.is_on_curve());\n        assert!(p.is_in_correct_subgroup_assuming_on_curve());\n        p.into()\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Zeroize for Projective\u003cP\u003e {\n    fn zeroize(\u0026mut self) {\n        self.x.zeroize();\n        self.y.zeroize();\n        self.z.zeroize();\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Zero for Projective\u003cP\u003e {\n    /// Returns the point at infinity, which always has Z = 0.\n    #[inline]\n    fn zero() -\u003e Self {\n        Self::new_unchecked(\n            P::BaseField::one(),\n            P::BaseField::one(),\n            P::BaseField::zero(),\n        )\n    }\n\n    /// Checks whether `self.z.is_zero()`.\n    #[inline]\n    fn is_zero(\u0026self) -\u003e bool {\n        self.z == P::BaseField::ZERO\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e AdditiveGroup for Projective\u003cP\u003e {\n    type Scalar = P::ScalarField;\n\n    const ZERO: Self = Self::new_unchecked(\n        P::BaseField::ONE,\n        P::BaseField::ONE,\n        P::BaseField::ZERO,\n    );\n\n    /// Sets `self = 2 * self`. Note that Jacobian formulae are incomplete, and\n    /// so doubling cannot be computed as `self + self`. Instead, this\n    /// implementation uses the following specialized doubling formulae:\n    ///\n    /// * [`P::A` is zero](http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l)\n    /// * [`P::A` is not zero](https://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-2007-bl)\n    fn double_in_place(\u0026mut self) -\u003e \u0026mut Self {\n        if self.is_zero() {\n            return self;\n        }\n\n        if P::COEFF_A == P::BaseField::ZERO {\n            // A = X1^2\n            let mut a = self.x;\n            a.square_in_place();\n\n            // B = Y1^2\n            let mut b = self.y;\n            b.square_in_place();\n\n            // C = B^2\n            let mut c = b;\n            c.square_in_place();\n\n            // D = 2*((X1+B)^2-A-C)\n            //   = 2 * (X1 + Y1^2)^2 - A - C\n            //   = 2 * 2 * X1 * Y1^2\n            let d = if [1, 2].contains(\u0026P::BaseField::extension_degree()) {\n                let mut d = self.x;\n                d *= \u0026b;\n                d.double_in_place().double_in_place();\n                d\n            } else {\n                let mut d = self.x;\n                d += \u0026b;\n                d.square_in_place();\n                d -= a;\n                d -= c;\n                d.double_in_place();\n                d\n            };\n\n            // E = 3*A\n            let e = a + a.double_in_place();\n\n            // Z3 = 2*Y1*Z1\n            self.z *= \u0026self.y;\n            self.z.double_in_place();\n\n            // F = E^2\n            // X3 = F-2*D\n            self.x = e;\n            self.x.square_in_place();\n            self.x -= \u0026d.double();\n\n            // Y3 = E*(D-X3)-8*C\n            self.y = d;\n            self.y -= \u0026self.x;\n            self.y *= \u0026e;\n            self.y -= c.double_in_place().double_in_place().double_in_place();\n            self\n        } else {\n            // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n            // XX = X1^2\n            let xx = self.x.square();\n\n            // YY = Y1^2\n            let yy = self.y.square();\n\n            // YYYY = YY^2\n            let mut yyyy = yy;\n            yyyy.square_in_place();\n\n            // ZZ = Z1^2\n            let mut zz = self.z;\n            zz.square_in_place();\n\n            // S = 2*((X1+YY)^2-XX-YYYY)\n            let s = ((self.x + yy).square() - xx - yyyy).double();\n\n            // M = 3*XX+a*ZZ^2\n            let mut m = xx;\n            m.double_in_place();\n            m += \u0026xx;\n            m += \u0026P::mul_by_a(zz.square());\n\n            // T = M^2-2*S\n            // X3 = T\n            self.x = m;\n            self.x.square_in_place();\n            self.x -= s.double();\n\n            // Z3 = (Y1+Z1)^2-YY-ZZ\n            // Can be calculated as Z3 = 2*Y1*Z1, and this is faster.\n            self.z *= self.y;\n            self.z.double_in_place();\n\n            // Y3 = M*(S-X3)-8*YYYY\n            self.y = s;\n            self.y -= \u0026self.x;\n            self.y *= \u0026m;\n            self.y -=\n                yyyy.double_in_place().double_in_place().double_in_place();\n\n            self\n        }\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e PrimeGroup for Projective\u003cP\u003e {\n    type ScalarField = P::ScalarField;\n\n    #[inline]\n    fn generator() -\u003e Self {\n        Affine::generator().into()\n    }\n\n    #[inline]\n    fn mul_bigint(\u0026self, other: impl BitIteratorBE) -\u003e Self {\n        P::mul_projective(self, other)\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e CurveGroup for Projective\u003cP\u003e {\n    type Affine = Affine\u003cP\u003e;\n    type BaseField = P::BaseField;\n    type Config = P;\n    type FullGroup = Affine\u003cP\u003e;\n\n    /// Normalizes a slice of projective elements so that\n    /// conversion to affine is inexpensive.\n    ///\n    /// In more detail, this method converts a curve point in Jacobian\n    /// coordinates (x, y, z) into an equivalent representation (x/z^2,\n    /// y/z^3, 1).\n    ///\n    /// For `N = v.len()`, this costs 1 inversion + 6N field multiplications + N\n    /// field squarings.\n    ///\n    /// (Where batch inversion comprises 3N field multiplications + 1 inversion\n    /// of these operations)\n    #[inline]\n    fn normalize_batch(v: \u0026[Self]) -\u003e Vec\u003cSelf::Affine\u003e {\n        let mut z_s = v.iter().map(|g| g.z).collect::\u003cVec\u003c_\u003e\u003e();\n\n        batch_inversion(\u0026mut z_s);\n\n        // Perform affine transformations\n        v.iter()\n            .zip(z_s)\n            .map(|(g, z)| {\n                if g.is_zero() {\n                    Affine::identity()\n                } else {\n                    let z2 = z.square();\n                    let x = g.x * z2;\n                    let y = g.y * z2 * z;\n                    Affine::new_unchecked(x, y)\n                }\n            })\n            .collect()\n    }\n}\n\nimpl\u003cP: SWCurveConfig\u003e Neg for Projective\u003cP\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn neg(mut self) -\u003e Self {\n        self.y = -self.y;\n        self\n    }\n}\n\nimpl\u003cP: SWCurveConfig, T: Borrow\u003cAffine\u003cP\u003e\u003e\u003e AddAssign\u003cT\u003e for Projective\u003cP\u003e {\n    /// Using \u003chttp://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-madd-2007-bl\u003e\n    fn add_assign(\u0026mut self, other: T) {\n        let other = other.borrow();\n        if let Some((other_x, other_y)) = other.xy() {\n            if self.is_zero() {\n                self.x = other_x;\n                self.y = other_y;\n                self.z = P::BaseField::one();\n                return;\n            }\n\n            // Z1Z1 = Z1^2\n            let mut z1z1 = self.z;\n            z1z1.square_in_place();\n\n            // U2 = X2*Z1Z1\n            let mut u2 = other_x;\n            u2 *= \u0026z1z1;\n\n            // S2 = Y2*Z1*Z1Z1\n            let mut s2 = self.z;\n            s2 *= \u0026other_y;\n            s2 *= \u0026z1z1;\n\n            if self.x == u2 {\n                if self.y == s2 {\n                    // The two points are equal, so we double.\n                    self.double_in_place();\n                } else {\n                    // a + (-a) = 0\n                    *self = Self::zero();\n                }\n            } else {\n                // H = U2-X1\n                let mut h = u2;\n                h -= \u0026self.x;\n\n                // HH = H^2\n                let mut hh = h;\n                hh.square_in_place();\n\n                // I = 4*HH\n                let mut i = hh;\n                i.double_in_place().double_in_place();\n\n                // J = -H*I\n                let mut j = h;\n                j.neg_in_place();\n                j *= \u0026i;\n\n                // r = 2*(S2-Y1)\n                let mut r = s2;\n                r -= \u0026self.y;\n                r.double_in_place();\n\n                // V = X1*I\n                let mut v = self.x;\n                v *= \u0026i;\n\n                // X3 = r^2 + J - 2*V\n                self.x = r.square();\n                self.x += \u0026j;\n                self.x -= \u0026v.double();\n\n                // Y3 = r*(V-X3) + 2*Y1*J\n                v -= \u0026self.x;\n                self.y.double_in_place();\n                self.y = P::BaseField::sum_of_products(\u0026[r, self.y], \u0026[v, j]);\n\n                // Z3 = 2 * Z1 * H;\n                // Can alternatively be computed as (Z1+H)^2-Z1Z1-HH, but the\n                // latter is slower.\n                self.z *= \u0026h;\n                self.z.double_in_place();\n            }\n        }\n    }\n}\n\nimpl\u003cP: SWCurveConfig, T: Borrow\u003cAffine\u003cP\u003e\u003e\u003e Add\u003cT\u003e for Projective\u003cP\u003e {\n    type Output = Self;\n\n    fn add(mut self, other: T) -\u003e Self {\n        let other = other.borrow();\n        self += other;\n        self\n    }\n}\n\nimpl\u003cP: SWCurveConfig, T: Borrow\u003cAffine\u003cP\u003e\u003e\u003e SubAssign\u003cT\u003e for Projective\u003cP\u003e {\n    fn sub_assign(\u0026mut self, other: T) {\n        *self += -(*other.borrow());\n    }\n}\n\nimpl\u003cP: SWCurveConfig, T: Borrow\u003cAffine\u003cP\u003e\u003e\u003e Sub\u003cT\u003e for Projective\u003cP\u003e {\n    type Output = Self;\n\n    fn sub(mut self, other: T) -\u003e Self {\n        self -= other.borrow();\n        self\n    }\n}\n\nimpl_additive_ops_from_ref!(Projective, SWCurveConfig);\n\nimpl\u003c'a, P: SWCurveConfig\u003e Add\u003c\u0026'a Self\u003e for Projective\u003cP\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn add(mut self, other: \u0026'a Self) -\u003e Self {\n        self += other;\n        self\n    }\n}\n\nimpl\u003c'a, P: SWCurveConfig\u003e AddAssign\u003c\u0026'a Self\u003e for Projective\u003cP\u003e {\n    fn add_assign(\u0026mut self, other: \u0026'a Self) {\n        if self.is_zero() {\n            *self = *other;\n            return;\n        }\n\n        if other.is_zero() {\n            return;\n        }\n\n        // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl\n        // Works for all curves.\n\n        // Z1Z1 = Z1^2\n        let z1z1 = self.z.square();\n\n        // Z2Z2 = Z2^2\n        let z2z2 = other.z.square();\n\n        // U1 = X1*Z2Z2\n        let mut u1 = self.x;\n        u1 *= \u0026z2z2;\n\n        // U2 = X2*Z1Z1\n        let mut u2 = other.x;\n        u2 *= \u0026z1z1;\n\n        // S1 = Y1*Z2*Z2Z2\n        let mut s1 = self.y;\n        s1 *= \u0026other.z;\n        s1 *= \u0026z2z2;\n\n        // S2 = Y2*Z1*Z1Z1\n        let mut s2 = other.y;\n        s2 *= \u0026self.z;\n        s2 *= \u0026z1z1;\n\n        if u1 == u2 {\n            if s1 == s2 {\n                // The two points are equal, so we double.\n                self.double_in_place();\n            } else {\n                // a + (-a) = 0\n                *self = Self::zero();\n            }\n        } else {\n            // H = U2-U1\n            let mut h = u2;\n            h -= \u0026u1;\n\n            // I = (2*H)^2\n            let mut i = h;\n            i.double_in_place().square_in_place();\n\n            // J = -H*I\n            let mut j = h;\n            j.neg_in_place();\n            j *= \u0026i;\n\n            // r = 2*(S2-S1)\n            let mut r = s2;\n            r -= \u0026s1;\n            r.double_in_place();\n\n            // V = U1*I\n            let mut v = u1;\n            v *= \u0026i;\n\n            // X3 = r^2 + J - 2*V\n            self.x = r;\n            self.x.square_in_place();\n            self.x += \u0026j;\n            self.x -= \u0026(v.double());\n\n            // Y3 = r*(V - X3) + 2*S1*J\n            v -= \u0026self.x;\n            self.y = s1;\n            self.y.double_in_place();\n            self.y = P::BaseField::sum_of_products(\u0026[r, self.y], \u0026[v, j]);\n\n            // Z3 = ((Z1+Z2)^2 - Z1Z1 - Z2Z2)*H\n            // This is equal to Z3 = 2 * Z1 * Z2 * H, and computing it this way\n            // is faster.\n            self.z *= other.z;\n            self.z.double_in_place();\n            self.z *= \u0026h;\n        }\n    }\n}\n\nimpl\u003c'a, P: SWCurveConfig\u003e Sub\u003c\u0026'a Self\u003e for Projective\u003cP\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn sub(mut self, other: \u0026'a Self) -\u003e Self {\n        self -= other;\n        self\n    }\n}\n\nimpl\u003c'a, P: SWCurveConfig\u003e SubAssign\u003c\u0026'a Self\u003e for Projective\u003cP\u003e {\n    fn sub_assign(\u0026mut self, other: \u0026'a Self) {\n        *self += \u0026(-(*other));\n    }\n}\n\nimpl\u003cP: SWCurveConfig, T: Borrow\u003cP::ScalarField\u003e\u003e MulAssign\u003cT\u003e\n    for Projective\u003cP\u003e\n{\n    fn mul_assign(\u0026mut self, other: T) {\n        *self = self.mul_bigint(other.borrow().into_bigint());\n    }\n}\n\nimpl\u003cP: SWCurveConfig, T: Borrow\u003cP::ScalarField\u003e\u003e Mul\u003cT\u003e for Projective\u003cP\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn mul(mut self, other: T) -\u003e Self {\n        self *= other;\n        self\n    }\n}\n\n// The affine point X, Y is represented in the Jacobian\n// coordinates with Z = 1.\nimpl\u003cP: SWCurveConfig\u003e From\u003cAffine\u003cP\u003e\u003e for Projective\u003cP\u003e {\n    #[inline]\n    fn from(p: Affine\u003cP\u003e) -\u003e Projective\u003cP\u003e {\n        p.xy().map_or(Projective::zero(), |(x, y)| Self {\n            x,\n            y,\n            z: P::BaseField::one(),\n        })\n    }\n}\n\nimpl\u003cP: SWCurveConfig, T: Borrow\u003cAffine\u003cP\u003e\u003e\u003e core::iter::Sum\u003cT\u003e\n    for Projective\u003cP\u003e\n{\n    fn sum\u003cI: Iterator\u003cItem = T\u003e\u003e(iter: I) -\u003e Self {\n        iter.fold(Projective::zero(), |sum, x| sum + x.borrow())\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":226},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","field","fp.rs"],"content":"//! This module contains the implementation of a prime field element [`Fp`],\n//! altogether with exact implementations [`Fp64`] for 64-bit, [`Fp128`] for\n//! 128-bit elements and so on.\n//!\n//! Finite field element [`Fp`] wraps a biginteger element in [motgomery form],\n//! which is used for efficient multiplication and division.\n//!\n//! Note that implementation of `Ord` for [`Fp`] compares field elements viewing\n//! them as integers in the range `0, 1, ..., P::MODULUS - 1`.\n//! However, other implementations of `PrimeField` might choose a different\n//! ordering, and as such, users should use this `Ord` for applications where\n//! any ordering suffices (like in a `BTreeMap`), and not in applications\n//! where a particular ordering is required.\n//!\n//! [motgomery form]: https://en.wikipedia.org/wiki/Montgomery_modular_multiplication\nuse alloc::string::ToString;\nuse core::{\n    cmp::Ordering,\n    fmt::{Debug, Display, Formatter},\n    iter::{Product, Sum},\n    marker::PhantomData,\n    ops::{\n        Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign,\n    },\n};\n\nuse educe::Educe;\nuse num_traits::{One, Zero};\n\nuse crate::{\n    arithmetic::{\n        limb,\n        uint::{Uint, WideUint},\n        BigInteger,\n    },\n    ct_for, ct_for_unroll6,\n    field::{group::AdditiveGroup, prime::PrimeField, Field},\n};\n\n/// A trait that specifies the configuration of a prime field.\n/// Also specifies how to perform arithmetic on field elements.\npub trait FpParams\u003cconst N: usize\u003e: Send + Sync + 'static + Sized {\n    /// The modulus of the field.\n    const MODULUS: Uint\u003cN\u003e;\n\n    /// A multiplicative generator of the field.\n    /// [`Self::GENERATOR`] is an element having multiplicative order\n    /// `MODULUS - 1`.\n    const GENERATOR: Fp\u003cSelf, N\u003e;\n\n    /// `MODULUS` has a spare bit in the most significant limb.\n    const HAS_MODULUS_SPARE_BIT: bool = Self::MODULUS.limbs[N - 1] \u003e\u003e 63 == 0;\n\n    /// `INV = -MODULUS^{-1} mod 2^64`\n    const INV: u64 = inv::\u003cSelf, N\u003e();\n\n    /// Let `M` be the power of 2^64 nearest to [`Self::MODULUS`] size.\n    ///\n    /// Then `R = M % MODULUS` or `R = (M - 1) % MODULUS + 1` for convenience of\n    /// multiplication.\n    const R: Uint\u003cN\u003e = WideUint::new(Uint::\u003cN\u003e::MAX, Uint::\u003cN\u003e::ZERO)\n        .ct_rem(\u0026Self::MODULUS)\n        .ct_wrapping_add(\u0026Uint::ONE);\n\n    /// `R2 = R^2 % MODULUS` or `R2 = (R^2 - 1) % MODULUS + 1` for convenience\n    /// of multiplication.\n    const R2: Uint\u003cN\u003e = WideUint::new(Uint::\u003cN\u003e::MAX, Uint::\u003cN\u003e::MAX)\n        .ct_rem(\u0026Self::MODULUS)\n        .ct_wrapping_add(\u0026Uint::ONE);\n\n    /// Set `a += b`.\n    #[inline(always)]\n    fn add_assign(a: \u0026mut Fp\u003cSelf, N\u003e, b: \u0026Fp\u003cSelf, N\u003e) {\n        // This cannot exceed the backing capacity.\n        let c = a.montgomery_form.checked_add_assign(\u0026b.montgomery_form);\n        // However, it may need to be reduced\n        if Self::HAS_MODULUS_SPARE_BIT {\n            *a = a.ct_subtract_modulus();\n        } else {\n            *a = a.ct_carrying_sub_modulus(c);\n        }\n    }\n\n    /// Set `a -= b`.\n    #[inline(always)]\n    fn sub_assign(a: \u0026mut Fp\u003cSelf, N\u003e, b: \u0026Fp\u003cSelf, N\u003e) {\n        // If `other` is larger than `self`, add the modulus to `self` first.\n        if b.montgomery_form \u003e a.montgomery_form {\n            a.montgomery_form.checked_add_assign(\u0026Self::MODULUS);\n        }\n        a.montgomery_form.checked_sub_assign(\u0026b.montgomery_form);\n    }\n\n    /// Set `a = a + a`.\n    #[inline(always)]\n    fn double_in_place(a: \u0026mut Fp\u003cSelf, N\u003e) {\n        // This cannot exceed the backing capacity.\n        let c = a.montgomery_form.checked_mul2_assign();\n        // However, it may need to be reduced.\n        if Self::HAS_MODULUS_SPARE_BIT {\n            *a = a.ct_subtract_modulus();\n        } else {\n            *a = a.ct_carrying_sub_modulus(c);\n        }\n    }\n\n    /// Set `a = -a`;\n    #[inline(always)]\n    fn neg_in_place(a: \u0026mut Fp\u003cSelf, N\u003e) {\n        if !a.is_zero() {\n            let mut tmp = Self::MODULUS;\n            tmp.checked_sub_assign(\u0026a.montgomery_form);\n            a.montgomery_form = tmp;\n        }\n    }\n\n    /// Set `a *= b`.\n    ///\n    /// This modular multiplication algorithm uses Montgomery\n    /// reduction for efficient implementation.\n    #[inline(always)]\n    fn mul_assign(a: \u0026mut Fp\u003cSelf, N\u003e, b: \u0026Fp\u003cSelf, N\u003e) {\n        *a = a.ct_mul(b);\n    }\n\n    /// Set `a *= a`.\n    #[inline(always)]\n    fn square_in_place(a: \u0026mut Fp\u003cSelf, N\u003e) {\n        *a = a.ct_mul(a);\n    }\n\n    /// Compute `a^{-1}` if `a` is not zero.\n    ///\n    /// Guajardo, Kumar, Paar, Pelzl.\n    /// Efficient Software-Implementation of Finite Fields with Applications to\n    /// Cryptography [reference].\n    /// Algorithm 16 (BEA for Inversion in Fp).\n    ///\n    /// [reference]: https://www.sandeep.de/my/papers/2006_ActaApplMath_EfficientSoftFiniteF.pdf\n    #[must_use]\n    #[inline(always)]\n    fn inverse(a: \u0026Fp\u003cSelf, N\u003e) -\u003e Option\u003cFp\u003cSelf, N\u003e\u003e {\n        if a.is_zero() {\n            return None;\n        }\n\n        let one = Uint::ONE;\n\n        let mut u = a.montgomery_form;\n        let mut v = Self::MODULUS;\n        let mut b = Fp::new_unchecked(Self::R2); // Avoids unnecessary reduction step.\n        let mut c = Fp::zero();\n\n        while u != one \u0026\u0026 v != one {\n            while u.is_even() {\n                u.div2_assign();\n\n                if b.montgomery_form.is_even() {\n                    b.montgomery_form.div2_assign();\n                } else {\n                    let carry =\n                        b.montgomery_form.checked_add_assign(\u0026Self::MODULUS);\n                    b.montgomery_form.div2_assign();\n                    if !Self::HAS_MODULUS_SPARE_BIT \u0026\u0026 carry {\n                        b.montgomery_form.limbs[N - 1] |= 1 \u003c\u003c 63;\n                    }\n                }\n            }\n\n            while v.is_even() {\n                v.div2_assign();\n\n                if c.montgomery_form.is_even() {\n                    c.montgomery_form.div2_assign();\n                } else {\n                    let carry =\n                        c.montgomery_form.checked_add_assign(\u0026Self::MODULUS);\n                    c.montgomery_form.div2_assign();\n                    if !Self::HAS_MODULUS_SPARE_BIT \u0026\u0026 carry {\n                        c.montgomery_form.limbs[N - 1] |= 1 \u003c\u003c 63;\n                    }\n                }\n            }\n\n            if v \u003c u {\n                u.checked_sub_assign(\u0026v);\n                b -= \u0026c;\n            } else {\n                v.checked_sub_assign(\u0026u);\n                c -= \u0026b;\n            }\n        }\n\n        if u == one {\n            Some(b)\n        } else {\n            Some(c)\n        }\n    }\n\n    /// Construct a field element from an integer.\n    ///\n    /// By the end element will be converted to a montgomery form and reduced.\n    #[must_use]\n    #[inline(always)]\n    fn from_bigint(num: Uint\u003cN\u003e) -\u003e Fp\u003cSelf, N\u003e {\n        let elem = Fp::new_unchecked(num);\n        if elem.is_zero() {\n            elem\n        } else {\n            elem * Fp::new_unchecked(Self::R2)\n        }\n    }\n\n    /// Convert a field element to an integer less than [`Self::MODULUS`].\n    #[must_use]\n    #[inline(always)]\n    fn into_bigint(elem: Fp\u003cSelf, N\u003e) -\u003e Uint\u003cN\u003e {\n        elem.montgomery_reduction()\n    }\n}\n\n/// Compute `-M^{-1} mod 2^64`.\n#[must_use]\npub const fn inv\u003cT: FpParams\u003cN\u003e, const N: usize\u003e() -\u003e u64 {\n    // We compute this as follows.\n    // First, MODULUS mod 2^64 is just the lower 64 bits of MODULUS.\n    // Hence MODULUS mod 2^64 = MODULUS.0[0] mod 2^64.\n    //\n    // Next, computing the inverse mod 2^64 involves exponentiating by\n    // the multiplicative group order, which is euler_totient(2^64) - 1.\n    // Now, euler_totient(2^64) = 1 \u003c\u003c 63, and so\n    // euler_totient(2^64) - 1 = (1 \u003c\u003c 63) - 1 = 1111111... (63 digits).\n    // We compute this powering via standard square and multiply.\n    let mut inv = 1u64;\n    ct_for!((_i in 0..63) {\n        // Square\n        inv = inv.wrapping_mul(inv);\n        // Multiply\n        inv = inv.wrapping_mul(T::MODULUS.limbs[0]);\n    });\n    inv.wrapping_neg()\n}\n\n/// Represents an element of the prime field `F_p`, where `p == P::MODULUS`.\n///\n/// This type can represent elements in any field of size at most N * 64 bits.\n#[derive(Educe)]\n#[educe(Default, Clone, Copy, PartialEq, Eq, Hash)]\npub struct Fp\u003cP: FpParams\u003cN\u003e, const N: usize\u003e {\n    /// Contains the element in Montgomery form for efficient multiplication.\n    /// To convert an element to a [`Uint`], use [`FpParams::into_bigint`]\n    /// or `into`.\n    montgomery_form: Uint\u003cN\u003e,\n    #[doc(hidden)]\n    phantom: PhantomData\u003cP\u003e,\n}\n\n/// Declare [`Fp`] types for different bit sizes.\nmacro_rules! declare_fp {\n    ($fp:ident, $limbs:ident, $bits:expr) =\u003e {\n        #[doc = \"Finite field with max\"]\n        #[doc = stringify!($bits)]\n        #[doc = \"bits size element.\"]\n        pub type $fp\u003cP\u003e = $crate::field::fp::Fp\u003c\n            P,\n            {\n                usize::div_ceil(\n                    $bits,\n                    $crate::arithmetic::limb::Limb::BITS as usize,\n                )\n            },\n        \u003e;\n\n        #[doc = \"Number of limbs in the field with\"]\n        #[doc = stringify!($bits)]\n        #[doc = \"bits size element.\"]\n        pub const $limbs: usize = usize::div_ceil(\n            $bits,\n            $crate::arithmetic::limb::Limb::BITS as usize,\n        );\n    };\n}\n\ndeclare_fp!(Fp64, LIMBS_64, 64);\ndeclare_fp!(Fp128, LIMBS_128, 128);\ndeclare_fp!(Fp192, LIMBS_192, 192);\ndeclare_fp!(Fp256, LIMBS_256, 256);\ndeclare_fp!(Fp320, LIMBS_320, 320);\ndeclare_fp!(Fp384, LIMBS_384, 384);\ndeclare_fp!(Fp448, LIMBS_448, 448);\ndeclare_fp!(Fp512, LIMBS_512, 512);\ndeclare_fp!(Fp576, LIMBS_576, 576);\ndeclare_fp!(Fp640, LIMBS_640, 640);\ndeclare_fp!(Fp704, LIMBS_704, 704);\ndeclare_fp!(Fp768, LIMBS_768, 768);\ndeclare_fp!(Fp832, LIMBS_832, 832);\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Fp\u003cP, N\u003e {\n    /// A multiplicative generator of the field.\n    /// [`Self::GENERATOR`] is an element having multiplicative order\n    /// `MODULUS - 1`.\n    ///\n    /// Every element of the field should be represented as `GENERATOR^i`\n    pub const GENERATOR: Fp\u003cP, N\u003e = P::GENERATOR;\n    /// Multiplicative identity of the field, i.e., the element `e`\n    /// such that, for all elements `f` of the field, `e * f = f`.\n    pub const ONE: Fp\u003cP, N\u003e = Fp::new_unchecked(P::R);\n    /// Additive identity of the field, i.e., the element `e`\n    /// such that, for all elements `f` of the field, `e + f = f`.\n    pub const ZERO: Fp\u003cP, N\u003e = Fp::new_unchecked(Uint { limbs: [0; N] });\n\n    /// Construct a new field element from [`Uint`].\n    ///\n    /// Unlike [`Self::new`], this method does not perform Montgomery reduction.\n    /// This method should be used only when constructing an element from an\n    /// integer that has already been put in Montgomery form.\n    #[must_use]\n    #[inline(always)]\n    pub const fn new_unchecked(element: Uint\u003cN\u003e) -\u003e Self {\n        Self { montgomery_form: element, phantom: PhantomData }\n    }\n\n    #[doc(hidden)]\n    #[inline(always)]\n    #[must_use]\n    pub const fn is_ge_modulus(\u0026self) -\u003e bool {\n        self.montgomery_form.ct_ge(\u0026P::MODULUS)\n    }\n\n    #[inline(always)]\n    const fn ct_subtract_modulus(mut self) -\u003e Self {\n        if self.is_ge_modulus() {\n            self.montgomery_form =\n                self.montgomery_form.ct_wrapping_sub(\u0026P::MODULUS);\n        }\n        self\n    }\n\n    /// Construct a new field element from its underlying\n    /// [`struct@Uint`] data type.\n    #[inline]\n    #[must_use]\n    pub const fn new(element: Uint\u003cN\u003e) -\u003e Self {\n        let r = Self { montgomery_form: element, phantom: PhantomData };\n        if r.ct_is_zero() {\n            r\n        } else {\n            r.ct_mul(\u0026Fp { montgomery_form: P::R2, phantom: PhantomData })\n        }\n    }\n\n    /// Multiply `self` to `rhs` and return the result (constant).\n    ///\n    /// Implements the Montgomery multiplication algorithm [reference].\n    ///\n    /// [reference]: https://en.wikipedia.org/wiki/Montgomery_modular_multiplication\n    #[inline(always)]\n    const fn ct_mul(\u0026self, rhs: \u0026Self) -\u003e Self {\n        let (carry, result) = self.ct_mul_without_cond_subtract(rhs);\n        if P::HAS_MODULUS_SPARE_BIT {\n            result.ct_subtract_modulus()\n        } else {\n            result.ct_carrying_sub_modulus(carry)\n        }\n    }\n\n    //// Returns true if this number is zero (constant).\n    const fn ct_is_zero(\u0026self) -\u003e bool {\n        self.montgomery_form.ct_is_zero()\n    }\n\n    /// Subtract modulus from `self` with carry and return the result.\n    #[inline(always)]\n    const fn ct_carrying_sub_modulus(mut self, carry: bool) -\u003e Self {\n        if carry || self.is_ge_modulus() {\n            self.montgomery_form =\n                self.montgomery_form.ct_wrapping_sub(\u0026P::MODULUS);\n        }\n        self\n    }\n\n    #[inline(always)]\n    const fn ct_mul_without_cond_subtract(\u0026self, other: \u0026Self) -\u003e (bool, Self) {\n        let (lo, hi) =\n            self.montgomery_form.ct_widening_mul(\u0026other.montgomery_form);\n\n        let (carry, res) = Self::widening_montgomery_reduction(lo, hi);\n        (carry, Self::new_unchecked(res))\n    }\n\n    /// Apply the Montgomery reduction to composite number represented as `lo`\n    /// and `hi`.\n    /// Returns `carry` and the result of the reduction.\n    ///\n    /// Algorithm 14.32 in Handbook of Applied Cryptography [reference].\n    ///\n    /// [reference]: https://cacr.uwaterloo.ca/hac/about/chap14.pdf\n    #[inline(always)]\n    const fn widening_montgomery_reduction(\n        mut lo: Uint\u003cN\u003e,\n        mut hi: Uint\u003cN\u003e,\n    ) -\u003e (bool, Uint\u003cN\u003e) {\n        let mut carry2 = false;\n        ct_for_unroll6!((i in 0..N) {\n            let tmp = lo.limbs[i].wrapping_mul(P::INV);\n\n            let (_, mut carry) = limb::mac(lo.limbs[i], tmp, P::MODULUS.limbs[0]);\n\n            ct_for_unroll6!((j in 1..N) {\n                let k = i + j;\n                if k \u003e= N {\n                    (hi.limbs[k - N], carry) = limb::carrying_mac(\n                        hi.limbs[k - N],\n                        tmp,\n                        P::MODULUS.limbs[j],\n                        carry\n                    );\n                } else {\n                    (lo.limbs[k], carry) = limb::carrying_mac(\n                        lo.limbs[k],\n                        tmp,\n                        P::MODULUS.limbs[j],\n                        carry\n                    );\n                }\n            });\n            (hi.limbs[i], carry2) = limb::adc(hi.limbs[i], carry, carry2);\n        });\n\n        (carry2, hi)\n    }\n\n    /// Apply the Montgomery reduction to `self`.\n    /// Returns the result of the reduction (carry not needed).\n    /// Compare to [`Self::widening_montgomery_reduction`] doesn't use loop\n    /// \"unroll\" optimization, since it is assumed to be called just to\n    /// convert back to normal representation.\n    ///\n    /// Algorithm 14.32 in Handbook of Applied Cryptography [reference].\n    ///\n    /// [reference]: https://cacr.uwaterloo.ca/hac/about/chap14.pdf\n    #[inline(always)]\n    fn montgomery_reduction(self) -\u003e Uint\u003cN\u003e {\n        let mut limbs = self.montgomery_form.limbs;\n        for i in 0..N {\n            let k = limbs[i].wrapping_mul(P::INV);\n\n            let (_, mut carry) = limb::mac(limbs[i], k, Self::MODULUS.limbs[0]);\n            for j in 1..N {\n                (limbs[(j + i) % N], carry) = limb::carrying_mac(\n                    limbs[(j + i) % N],\n                    k,\n                    Self::MODULUS.limbs[j],\n                    carry,\n                );\n            }\n            limbs[i % N] = carry;\n        }\n        Uint::new(limbs)\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Debug for Fp\u003cP, N\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        Debug::fmt(\u0026self.into_bigint(), f)\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Zero for Fp\u003cP, N\u003e {\n    #[inline]\n    fn zero() -\u003e Self {\n        Self::ZERO\n    }\n\n    #[inline]\n    fn is_zero(\u0026self) -\u003e bool {\n        *self == Self::ZERO\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e One for Fp\u003cP, N\u003e {\n    #[inline]\n    fn one() -\u003e Self {\n        Self::ONE\n    }\n\n    #[inline]\n    fn is_one(\u0026self) -\u003e bool {\n        *self == Self::ONE\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e AdditiveGroup for Fp\u003cP, N\u003e {\n    type Scalar = Self;\n\n    const ZERO: Self = Self::ZERO;\n\n    #[inline]\n    fn double(\u0026self) -\u003e Self {\n        let mut temp = *self;\n        temp.double_in_place();\n        temp\n    }\n\n    #[inline]\n    fn double_in_place(\u0026mut self) -\u003e \u0026mut Self {\n        P::double_in_place(self);\n        self\n    }\n\n    #[inline]\n    fn neg_in_place(\u0026mut self) -\u003e \u0026mut Self {\n        P::neg_in_place(self);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Field for Fp\u003cP, N\u003e {\n    const ONE: Self = Fp::new_unchecked(P::R);\n\n    fn extension_degree() -\u003e usize {\n        1\n    }\n\n    #[inline]\n    fn square(\u0026self) -\u003e Self {\n        let mut temp = *self;\n        temp.square_in_place();\n        temp\n    }\n\n    #[inline]\n    fn square_in_place(\u0026mut self) -\u003e \u0026mut Self {\n        P::square_in_place(self);\n        self\n    }\n\n    #[inline]\n    fn inverse(\u0026self) -\u003e Option\u003cSelf\u003e {\n        P::inverse(self)\n    }\n\n    fn inverse_in_place(\u0026mut self) -\u003e Option\u003c\u0026mut Self\u003e {\n        if let Some(inverse) = self.inverse() {\n            *self = inverse;\n            Some(self)\n        } else {\n            None\n        }\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e PrimeField for Fp\u003cP, N\u003e {\n    type BigInt = Uint\u003cN\u003e;\n\n    const MODULUS: Self::BigInt = P::MODULUS;\n    const MODULUS_BIT_SIZE: usize = \u003cUint\u003cN\u003e as BigInteger\u003e::BITS;\n\n    #[inline]\n    fn from_bigint(repr: Self::BigInt) -\u003e Self {\n        P::from_bigint(repr)\n    }\n\n    #[inline]\n    fn into_bigint(self) -\u003e Uint\u003cN\u003e {\n        P::into_bigint(self)\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Ord for Fp\u003cP, N\u003e {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        self.into_bigint().cmp(\u0026other.into_bigint())\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e PartialOrd for Fp\u003cP, N\u003e {\n    #[inline]\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\n/// Auto implements conversion from unsigned integer of type `$int` to [`Fp`].\nmacro_rules! impl_fp_from_unsigned_int {\n    ($int:ty) =\u003e {\n        impl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e From\u003c$int\u003e for Fp\u003cP, N\u003e {\n            fn from(other: $int) -\u003e Self {\n                Fp::from_bigint(Uint::from(other))\n            }\n        }\n    };\n}\n\n/// Auto implements conversion from signed integer of type `$int` to [`Fp`].\nmacro_rules! impl_fp_from_signed_int {\n    ($int:ty) =\u003e {\n        impl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e From\u003c$int\u003e for Fp\u003cP, N\u003e {\n            fn from(other: $int) -\u003e Self {\n                let abs = other.unsigned_abs().into();\n                if other.is_positive() {\n                    abs\n                } else {\n                    -abs\n                }\n            }\n        }\n    };\n}\n\nimpl_fp_from_unsigned_int!(u128);\nimpl_fp_from_unsigned_int!(u64);\nimpl_fp_from_unsigned_int!(u32);\nimpl_fp_from_unsigned_int!(u16);\nimpl_fp_from_unsigned_int!(u8);\n\nimpl_fp_from_signed_int!(i128);\nimpl_fp_from_signed_int!(i64);\nimpl_fp_from_signed_int!(i32);\nimpl_fp_from_signed_int!(i16);\nimpl_fp_from_signed_int!(i8);\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e From\u003cbool\u003e for Fp\u003cP, N\u003e {\n    fn from(other: bool) -\u003e Self {\n        u8::from(other).into()\n    }\n}\n\n/// Auto implements conversion from [`Fp`] to integer of type `$int`.\n///\n/// Conversion is available only for a single limb field elements,\n/// i.e. `N = 1`.\nmacro_rules! impl_int_from_fp {\n    ($int:ty) =\u003e {\n        impl\u003cP: FpParams\u003c1\u003e\u003e From\u003cFp\u003cP, 1\u003e\u003e for $int {\n            fn from(other: Fp\u003cP, 1\u003e) -\u003e Self {\n                let uint = other.into_bigint();\n                let words = uint.as_limbs();\n                \u003c$int\u003e::try_from(words[0]).unwrap_or_else(|_| {\n                    panic!(\"should convert to {}\", stringify!($int))\n                })\n            }\n        }\n    };\n}\n\nimpl_int_from_fp!(u128);\nimpl_int_from_fp!(u64);\nimpl_int_from_fp!(u32);\nimpl_int_from_fp!(u16);\nimpl_int_from_fp!(u8);\nimpl_int_from_fp!(i128);\nimpl_int_from_fp!(i64);\nimpl_int_from_fp!(i32);\nimpl_int_from_fp!(i16);\nimpl_int_from_fp!(i8);\n\n/// Outputs a string containing the value of `self`,\n/// represented as a decimal without leading zeroes.\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Display for Fp\u003cP, N\u003e {\n    #[inline]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        let str = self.into_bigint().to_string();\n        write!(f, \"{str}\")\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Neg for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn neg(mut self) -\u003e Self {\n        P::neg_in_place(\u0026mut self);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Add\u003c\u0026Fp\u003cP, N\u003e\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn add(mut self, other: \u0026Self) -\u003e Self {\n        self.add_assign(other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Sub\u003c\u0026Fp\u003cP, N\u003e\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn sub(mut self, other: \u0026Self) -\u003e Self {\n        self.sub_assign(other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Mul\u003c\u0026Fp\u003cP, N\u003e\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn mul(mut self, other: \u0026Self) -\u003e Self {\n        self.mul_assign(other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Div\u003c\u0026Fp\u003cP, N\u003e\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn div(mut self, other: \u0026Self) -\u003e Self {\n        // Returns `self * other.inverse()` if `other.inverse()` is `Some`, and\n        // panics otherwise.\n        self.mul_assign(\u0026other.inverse().expect(\"should not divide by zero\"));\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Add\u003c\u0026Fp\u003cP, N\u003e\u003e for \u0026Fp\u003cP, N\u003e {\n    type Output = Fp\u003cP, N\u003e;\n\n    #[inline]\n    fn add(self, other: \u0026Fp\u003cP, N\u003e) -\u003e Fp\u003cP, N\u003e {\n        let mut result = *self;\n        result.add_assign(other);\n        result\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Sub\u003c\u0026Fp\u003cP, N\u003e\u003e for \u0026Fp\u003cP, N\u003e {\n    type Output = Fp\u003cP, N\u003e;\n\n    #[inline]\n    fn sub(self, other: \u0026Fp\u003cP, N\u003e) -\u003e Fp\u003cP, N\u003e {\n        let mut result = *self;\n        result.sub_assign(other);\n        result\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Mul\u003c\u0026Fp\u003cP, N\u003e\u003e for \u0026Fp\u003cP, N\u003e {\n    type Output = Fp\u003cP, N\u003e;\n\n    #[inline]\n    fn mul(self, other: \u0026Fp\u003cP, N\u003e) -\u003e Fp\u003cP, N\u003e {\n        let mut result = *self;\n        result.mul_assign(other);\n        result\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Div\u003c\u0026Fp\u003cP, N\u003e\u003e for \u0026Fp\u003cP, N\u003e {\n    type Output = Fp\u003cP, N\u003e;\n\n    #[inline]\n    fn div(self, other: \u0026Fp\u003cP, N\u003e) -\u003e Fp\u003cP, N\u003e {\n        let mut result = *self;\n        result.div_assign(other);\n        result\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e AddAssign\u003c\u0026Self\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn add_assign(\u0026mut self, other: \u0026Self) {\n        P::add_assign(self, other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e SubAssign\u003c\u0026Self\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn sub_assign(\u0026mut self, other: \u0026Self) {\n        P::sub_assign(self, other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Add\u003cSelf\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn add(mut self, other: Self) -\u003e Self {\n        self.add_assign(\u0026other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Add\u003c\u0026mut Self\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn add(mut self, other: \u0026mut Self) -\u003e Self {\n        self.add_assign(\u0026*other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Sub\u003cSelf\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn sub(mut self, other: Self) -\u003e Self {\n        self.sub_assign(\u0026other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Sub\u003c\u0026mut Self\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn sub(mut self, other: \u0026mut Self) -\u003e Self {\n        self.sub_assign(\u0026*other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Sum\u003cSelf\u003e for Fp\u003cP, N\u003e {\n    fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\n        iter.fold(Self::zero(), Add::add)\n    }\n}\n\nimpl\u003c'a, P: FpParams\u003cN\u003e, const N: usize\u003e Sum\u003c\u0026'a Self\u003e for Fp\u003cP, N\u003e {\n    fn sum\u003cI: Iterator\u003cItem = \u0026'a Self\u003e\u003e(iter: I) -\u003e Self {\n        iter.fold(Self::zero(), Add::add)\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e AddAssign\u003cSelf\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn add_assign(\u0026mut self, other: Self) {\n        self.add_assign(\u0026other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e SubAssign\u003cSelf\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn sub_assign(\u0026mut self, other: Self) {\n        self.sub_assign(\u0026other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e AddAssign\u003c\u0026mut Self\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn add_assign(\u0026mut self, other: \u0026mut Self) {\n        self.add_assign(\u0026*other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e SubAssign\u003c\u0026mut Self\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn sub_assign(\u0026mut self, other: \u0026mut Self) {\n        self.sub_assign(\u0026*other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e MulAssign\u003c\u0026Self\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn mul_assign(\u0026mut self, other: \u0026Self) {\n        P::mul_assign(self, other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e DivAssign\u003c\u0026Self\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn div_assign(\u0026mut self, other: \u0026Self) {\n        // Returns `self * other.inverse()` if `other.inverse()` is `Some`, and\n        // panics otherwise.\n        self.mul_assign(\u0026other.inverse().expect(\"should not divide by zero\"));\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Mul\u003cSelf\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn mul(mut self, other: Self) -\u003e Self {\n        self.mul_assign(\u0026other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Div\u003cSelf\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn div(mut self, other: Self) -\u003e Self {\n        use DivAssign;\n        self.div_assign(\u0026other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Mul\u003c\u0026mut Self\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn mul(mut self, other: \u0026mut Self) -\u003e Self {\n        self.mul_assign(\u0026*other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Div\u003c\u0026mut Self\u003e for Fp\u003cP, N\u003e {\n    type Output = Self;\n\n    #[inline]\n    fn div(mut self, other: \u0026mut Self) -\u003e Self {\n        self.div_assign(\u0026*other);\n        self\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e Product\u003cSelf\u003e for Fp\u003cP, N\u003e {\n    fn product\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\n        iter.fold(Self::one(), Mul::mul)\n    }\n}\n\nimpl\u003c'a, P: FpParams\u003cN\u003e, const N: usize\u003e Product\u003c\u0026'a Self\u003e for Fp\u003cP, N\u003e {\n    fn product\u003cI: Iterator\u003cItem = \u0026'a Self\u003e\u003e(iter: I) -\u003e Self {\n        iter.fold(Self::one(), Mul::mul)\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e MulAssign\u003cSelf\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn mul_assign(\u0026mut self, other: Self) {\n        self.mul_assign(\u0026other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e DivAssign\u003c\u0026mut Self\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn div_assign(\u0026mut self, other: \u0026mut Self) {\n        self.div_assign(\u0026*other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e MulAssign\u003c\u0026mut Self\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn mul_assign(\u0026mut self, other: \u0026mut Self) {\n        self.mul_assign(\u0026*other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e DivAssign\u003cSelf\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn div_assign(\u0026mut self, other: Self) {\n        self.div_assign(\u0026other);\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e zeroize::Zeroize for Fp\u003cP, N\u003e {\n    // The phantom data does not contain element-specific data\n    // and thus does not need to be zeroized.\n    fn zeroize(\u0026mut self) {\n        self.montgomery_form.zeroize();\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e From\u003cFp\u003cP, N\u003e\u003e for Uint\u003cN\u003e {\n    #[inline]\n    fn from(fp: Fp\u003cP, N\u003e) -\u003e Self {\n        fp.into_bigint()\n    }\n}\n\nimpl\u003cP: FpParams\u003cN\u003e, const N: usize\u003e From\u003cUint\u003cN\u003e\u003e for Fp\u003cP, N\u003e {\n    #[inline]\n    fn from(int: Uint\u003cN\u003e) -\u003e Self {\n        Self::from_bigint(int)\n    }\n}\n\n/// This macro converts a string base-10 number to a field element.\n#[macro_export]\nmacro_rules! fp_from_num {\n    ($num:literal) =\u003e {\n        $crate::field::fp::Fp::new($crate::arithmetic::uint::from_str_radix(\n            $num, 10,\n        ))\n    };\n}\n\n/// This macro converts a string hex number to a field element.\n#[macro_export]\nmacro_rules! fp_from_hex {\n    ($num:literal) =\u003e {{\n        $crate::field::fp::Fp::new($crate::arithmetic::uint::from_str_hex($num))\n    }};\n}\n\n#[cfg(test)]\nmod tests {\n    use proptest::prelude::*;\n\n    use super::*;\n    use crate::{\n        arithmetic::uint::U64,\n        field::{\n            fp::{Fp64, FpParams, LIMBS_64},\n            group::AdditiveGroup,\n        },\n        fp_from_num, from_num,\n    };\n\n    type Field64 = Fp64\u003cFp64Param\u003e;\n    struct Fp64Param;\n    impl FpParams\u003cLIMBS_64\u003e for Fp64Param {\n        const GENERATOR: Fp64\u003cFp64Param\u003e = fp_from_num!(\"3\");\n        const MODULUS: U64 = from_num!(\"1000003\"); // Prime number\n    }\n\n    const MODULUS: i128 = 1000003; // Prime number\n\n    #[test]\n    fn add() {\n        proptest!(|(a: i64, b: i64)| {\n            let res = Field64::from(a) + Field64::from(b);\n            let res: i128 = res.into();\n            let a = i128::from(a);\n            let b = i128::from(b);\n            prop_assert_eq!(res, (a + b).rem_euclid(MODULUS));\n        });\n    }\n\n    #[test]\n    fn double() {\n        proptest!(|(a: i64)| {\n            let res = Field64::from(a).double();\n            let res: i128 = res.into();\n            let a = i128::from(a);\n            prop_assert_eq!(res, (a + a).rem_euclid(MODULUS));\n        });\n    }\n\n    #[test]\n    fn sub() {\n        proptest!(|(a: i64, b: i64)| {\n            let res = Field64::from(a) - Field64::from(b);\n            let res: i128 = res.into();\n            let a = i128::from(a);\n            let b = i128::from(b);\n            prop_assert_eq!(res, (a - b).rem_euclid(MODULUS));\n        });\n    }\n\n    #[test]\n    fn mul() {\n        proptest!(|(a: i64, b: i64)| {\n            let res = Field64::from(a) * Field64::from(b);\n            let res: i128 = res.into();\n            let a = i128::from(a);\n            let b = i128::from(b);\n            prop_assert_eq!(res, (a * b).rem_euclid(MODULUS));\n        });\n    }\n\n    #[test]\n    fn square() {\n        proptest!(|(a: i64)| {\n            let res = Field64::from(a).square();\n            let res: i128 = res.into();\n            let a = i128::from(a);\n            prop_assert_eq!(res, (a * a).rem_euclid(MODULUS));\n        });\n    }\n\n    prop_compose! {\n        fn non_zero_modulo_i64()(\n            b in 1..i64::MAX\n        ) -\u003e i64 {\n            if i128::from(b) % MODULUS == 0 {\n                b + 1\n            } else {\n                b\n            }\n        }\n    }\n\n    #[test]\n    fn div() {\n        proptest!(|(a: i64, b in non_zero_modulo_i64())| {\n            let res = Field64::from(a) / Field64::from(b);\n            let res: i128 = res.into();\n            let a = i128::from(a);\n            let b = i128::from(b);\n            // a / b = res mod M =\u003e res * b = a mod M\n            prop_assert_eq!((res * b).rem_euclid(MODULUS), a.rem_euclid(MODULUS));\n        });\n    }\n\n    /// Compute a^b in an expensive and iterative way.\n    fn dumb_pow(a: i128, b: i128) -\u003e i128 {\n        (0..b).fold(1, |acc, _| (acc * a).rem_euclid(MODULUS))\n    }\n\n    #[test]\n    fn pow() {\n        proptest!(|(a: i64, b in 0_u32..1000)| {\n            let res = Field64::from(a).pow(b);\n            let res: i128 = res.into();\n            let a = i128::from(a);\n            let b = i128::from(b);\n            prop_assert_eq!(res, dumb_pow(a, b));\n        });\n    }\n\n    #[test]\n    fn neg() {\n        proptest!(|(a: i64)| {\n            let res = -Field64::from(a);\n            let res: i128 = res.into();\n            let a = i128::from(a);\n            prop_assert_eq!(res, (-a).rem_euclid(MODULUS));\n        });\n    }\n\n    #[test]\n    fn one() {\n        proptest!(|(a: i64)| {\n            let res = Field64::one();\n            let res: i128 = res.into();\n            prop_assert_eq!(res, 1);\n\n            let res = Field64::one() * Field64::from(a);\n            let res: i128 = res.into();\n            let a: i128 = a.into();\n            prop_assert_eq!(res, a.rem_euclid(MODULUS));\n        });\n    }\n\n    #[test]\n    fn zero() {\n        proptest!(|(a: i64)| {\n            let res = Field64::zero();\n            let res: i128 = res.into();\n            prop_assert_eq!(res, 0);\n\n            let res = Field64::zero() + Field64::from(a);\n            let res: i128 = res.into();\n            let a: i128 = a.into();\n            prop_assert_eq!(res, a.rem_euclid(MODULUS));\n        });\n    }\n}\n","traces":[{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":274},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","field","group.rs"],"content":"//! This module provides a generic interface for groups with additive notation.\n\nuse core::{\n    fmt::{Debug, Display},\n    hash::Hash,\n    iter::Sum,\n    ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n};\n\nuse num_traits::Zero;\nuse zeroize::Zeroize;\n\nuse crate::field::Field;\n\n/// Defines an abstract group with additive notation.\n/// Support addition and subtraction with itself and multiplication by scalar.\n/// Scalar and group can be different types.\n///\n/// E.g., points on an elliptic curve define an additive group and can be\n/// multiplied by a scalar.\npub trait AdditiveGroup:\n    Eq\n    + 'static\n    + Sized\n    + Copy\n    + Clone\n    + Default\n    + Send\n    + Sync\n    + Hash\n    + Debug\n    + Display\n    + Zeroize\n    + Zero\n    + Neg\u003cOutput = Self\u003e\n    + Add\u003cSelf, Output = Self\u003e\n    + Sub\u003cSelf, Output = Self\u003e\n    + Mul\u003c\u003cSelf as AdditiveGroup\u003e::Scalar, Output = Self\u003e\n    + AddAssign\u003cSelf\u003e\n    + SubAssign\u003cSelf\u003e\n    + MulAssign\u003c\u003cSelf as AdditiveGroup\u003e::Scalar\u003e\n    + for\u003c'a\u003e Add\u003c\u0026'a Self, Output = Self\u003e\n    + for\u003c'a\u003e Sub\u003c\u0026'a Self, Output = Self\u003e\n    + for\u003c'a\u003e Mul\u003c\u0026'a \u003cSelf as AdditiveGroup\u003e::Scalar, Output = Self\u003e\n    + for\u003c'a\u003e AddAssign\u003c\u0026'a Self\u003e\n    + for\u003c'a\u003e SubAssign\u003c\u0026'a Self\u003e\n    + for\u003c'a\u003e MulAssign\u003c\u0026'a \u003cSelf as AdditiveGroup\u003e::Scalar\u003e\n    + for\u003c'a\u003e Add\u003c\u0026'a mut Self, Output = Self\u003e\n    + for\u003c'a\u003e Sub\u003c\u0026'a mut Self, Output = Self\u003e\n    + for\u003c'a\u003e Mul\u003c\u0026'a mut \u003cSelf as AdditiveGroup\u003e::Scalar, Output = Self\u003e\n    + for\u003c'a\u003e AddAssign\u003c\u0026'a mut Self\u003e\n    + for\u003c'a\u003e SubAssign\u003c\u0026'a mut Self\u003e\n    + for\u003c'a\u003e MulAssign\u003c\u0026'a mut \u003cSelf as AdditiveGroup\u003e::Scalar\u003e\n    + Sum\u003cSelf\u003e\n    + for\u003c'a\u003e Sum\u003c\u0026'a Self\u003e\n{\n    /// Scalar associated with the group.\n    type Scalar: Field;\n\n    /// Additive identity of the group.\n    const ZERO: Self;\n\n    /// Doubles `self`.\n    #[must_use]\n    fn double(\u0026self) -\u003e Self {\n        let mut copy = *self;\n        copy.double_in_place();\n        copy\n    }\n\n    /// Doubles `self` in place.\n    fn double_in_place(\u0026mut self) -\u003e \u0026mut Self {\n        self.add_assign(*self);\n        self\n    }\n\n    /// Negates `self` in place.\n    fn neg_in_place(\u0026mut self) -\u003e \u0026mut Self {\n        *self = -(*self);\n        self\n    }\n}\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","field","instance.rs"],"content":"//! This module contains the field instances for some popular curves.\n\n#![allow(missing_docs)]\n\nuse crate::{\n    arithmetic::uint::{U256, U64},\n    field::fp::{Fp256, Fp64, FpParams, LIMBS_256, LIMBS_64},\n    fp_from_num, from_num,\n};\n\npub type FpVesta = Fp256\u003cVestaParam\u003e;\npub struct VestaParam;\nimpl FpParams\u003cLIMBS_256\u003e for VestaParam {\n    const GENERATOR: Fp256\u003cVestaParam\u003e = fp_from_num!(\"5\");\n    const MODULUS: U256 = from_num!(\"28948022309329048855892746252171976963363056481941647379679742748393362948097\");\n}\n\npub type FpBabyBear = Fp64\u003cBabyBearParam\u003e;\npub struct BabyBearParam;\nimpl FpParams\u003cLIMBS_64\u003e for BabyBearParam {\n    const GENERATOR: Fp64\u003cBabyBearParam\u003e = fp_from_num!(\"31\");\n    const MODULUS: U64 = from_num!(\"2013265921\");\n}\n\npub type FpBLS12 = Fp256\u003cBLS12Param\u003e;\npub struct BLS12Param;\nimpl FpParams\u003cLIMBS_256\u003e for BLS12Param {\n    const GENERATOR: Fp256\u003cBLS12Param\u003e = fp_from_num!(\"7\");\n    const MODULUS: U256 = from_num!(\"52435875175126190479447740508185965837690552500527637822603658699938581184513\");\n}\n\npub type FpBN256 = Fp256\u003cBN256Param\u003e;\npub struct BN256Param;\nimpl FpParams\u003cLIMBS_256\u003e for BN256Param {\n    const GENERATOR: Fp256\u003cBN256Param\u003e = fp_from_num!(\"7\");\n    const MODULUS: U256 = from_num!(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n}\n\npub type FpGoldiLocks = Fp64\u003cGoldiLocksParam\u003e;\npub struct GoldiLocksParam;\nimpl FpParams\u003cLIMBS_64\u003e for GoldiLocksParam {\n    const GENERATOR: Fp64\u003cGoldiLocksParam\u003e = fp_from_num!(\"7\");\n    const MODULUS: U64 = from_num!(\"18446744069414584321\");\n}\n\npub type FpPallas = Fp256\u003cPallasParam\u003e;\npub struct PallasParam;\nimpl FpParams\u003cLIMBS_256\u003e for PallasParam {\n    const GENERATOR: Fp256\u003cPallasParam\u003e = fp_from_num!(\"5\");\n    const MODULUS: U256 = from_num!(\"28948022309329048855892746252171976963363056481941560715954676764349967630337\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","field","mod.rs"],"content":"//! This module provides common arithmetics to work with finite fields.\n//! Implementations of some used fields provided in the [`instance`]\n//! module.\n//!\n//! Abstractions and api in this module are similar to Arkworks Algebra [ark-ff\n//! library].\n//!\n//! Here is an example operations over a prime finite field (aka Fp) with a\n//! prime modulus `17` and generator element `3`.\n//!\n//! # Examples\n//!\n//! ```rust\n//! use openzeppelin_crypto::{\n//!     arithmetic::uint::U64,\n//!     field::{\n//!         fp::{Fp64, FpParams, LIMBS_64},\n//!         group::AdditiveGroup,\n//!         Field,\n//!     },\n//!     fp_from_num,\n//!     from_num,\n//! };\n//!\n//! pub type ExampleField = Fp64\u003cFpParam\u003e;\n//! pub struct FpParam;\n//! impl FpParams\u003cLIMBS_64\u003e for FpParam {\n//!     const MODULUS: U64 = from_num!(\"17\");\n//!     const GENERATOR: Fp64\u003cFpParam\u003e = fp_from_num!(\"3\");\n//! }\n//!\n//! # fn main() {\n//! let a = ExampleField::from(9);\n//! let b = ExampleField::from(10);\n//!\n//! assert_eq!(a, ExampleField::from(26));          // 26 =  9 mod 17\n//! assert_eq!(a - b, ExampleField::from(16));      // -1 = 16 mod 17\n//! assert_eq!(a + b, ExampleField::from(2));       // 19 =  2 mod 17\n//! assert_eq!(a * b, ExampleField::from(5));       // 90 =  5 mod 17\n//! assert_eq!(a.square(), ExampleField::from(13)); // 81 = 13 mod 17\n//! assert_eq!(b.double(), ExampleField::from(3));  // 20 =  3 mod 17\n//! assert_eq!(a / b, a * b.inverse().unwrap());    // need to unwrap since `b` could be 0 which is not invertible\n//! # }\n//! ```\n//!\n//! [ark-ff library]: https://github.com/arkworks-rs/algebra/tree/master/ff\nuse core::{\n    fmt::{Debug, Display},\n    hash::Hash,\n    iter::Product,\n    ops::{Div, DivAssign, Neg},\n};\n\nuse group::AdditiveGroup;\nuse num_traits::{One, Zero};\nuse zeroize::Zeroize;\n\nuse crate::bits::BitIteratorBE;\n\npub mod fp;\npub mod group;\npub mod instance;\npub mod prime;\n\n/// Defines an abstract field.\n/// Types implementing [`Field`] support common field operations such as\n/// addition, subtraction, multiplication, and inverses.\npub trait Field:\n    'static\n    + Copy\n    + Clone\n    + Debug\n    + Display\n    + Default\n    + Send\n    + Sync\n    + Eq\n    + Zero\n    + One\n    + Ord\n    + Neg\u003cOutput = Self\u003e\n    + Zeroize\n    + Sized\n    + Hash\n    + AdditiveGroup\u003cScalar = Self\u003e\n    + Div\u003cSelf, Output = Self\u003e\n    + DivAssign\u003cSelf\u003e\n    + for\u003c'a\u003e Div\u003c\u0026'a Self, Output = Self\u003e\n    + for\u003c'a\u003e DivAssign\u003c\u0026'a Self\u003e\n    + for\u003c'a\u003e Div\u003c\u0026'a mut Self, Output = Self\u003e\n    + for\u003c'a\u003e DivAssign\u003c\u0026'a mut Self\u003e\n    + for\u003c'a\u003e Product\u003c\u0026'a Self\u003e\n    + From\u003cu128\u003e\n    + From\u003cu64\u003e\n    + From\u003cu32\u003e\n    + From\u003cu16\u003e\n    + From\u003cu8\u003e\n    + From\u003ci128\u003e\n    + From\u003ci64\u003e\n    + From\u003ci32\u003e\n    + From\u003ci16\u003e\n    + From\u003ci8\u003e\n    + From\u003cbool\u003e\n    + Product\u003cSelf\u003e\n{\n    /// The multiplicative identity of the field.\n    const ONE: Self;\n\n    /// Returns the extension degree of this field.\n    #[must_use]\n    fn extension_degree() -\u003e usize;\n\n    /// Returns `self * self`.\n    #[must_use]\n    fn square(\u0026self) -\u003e Self;\n\n    /// Squares `self` in place.\n    fn square_in_place(\u0026mut self) -\u003e \u0026mut Self;\n\n    /// Computes the multiplicative inverse of `self` if `self` is nonzero.\n    fn inverse(\u0026self) -\u003e Option\u003cSelf\u003e;\n\n    /// If `self.inverse().is_none()`, this just returns `None`. Otherwise, it\n    /// sets `self` to `self.inverse().unwrap()`.\n    fn inverse_in_place(\u0026mut self) -\u003e Option\u003c\u0026mut Self\u003e;\n\n    /// Returns `self^exp`, where `exp` is an integer.\n    ///\n    /// NOTE: Consumers should pass `exp`'s type `S` with the least bit size\n    /// possible.\n    /// e.g. for `pow(12)` u8 type is small enough to represent `12`.\n    #[must_use]\n    fn pow\u003cS: BitIteratorBE\u003e(\u0026self, exp: S) -\u003e Self {\n        // Variant `Option::\u003cSelf\u003e::None` corresponds to `one`.\n        // This approach removes pointless multiplications by one, that\n        // are still expensive.\n        let mut res: Option\u003cSelf\u003e = None;\n\n        for has_bit in exp.bit_be_trimmed_iter() {\n            // If res is not empty, square it.\n            if let Some(res) = \u0026mut res {\n                res.square_in_place();\n            }\n\n            // If bit is set,\n            if has_bit {\n                match res {\n                    None =\u003e {\n                        // and res is empty, set it to self.\n                        res = Some(*self);\n                    }\n                    Some(ref mut res) =\u003e {\n                        // and res is not empty, multiply it by self.\n                        *res *= self;\n                    }\n                }\n            }\n        }\n\n        // If res is empty, return one.\n        res.unwrap_or(Self::ONE)\n    }\n\n    /// Returns `sum([a_i * b_i])`.\n    #[inline]\n    fn sum_of_products\u003cconst T: usize\u003e(a: \u0026[Self; T], b: \u0026[Self; T]) -\u003e Self {\n        let mut sum = Self::zero();\n        for i in 0..a.len() {\n            sum += a[i] * b[i];\n        }\n        sum\n    }\n}\n","traces":[{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","field","prime.rs"],"content":"//! This module provides a generic interface for finite prime fields.\n\nuse crate::{arithmetic::BigInteger, field::Field};\n\n/// Defines an abstract prime field.\n/// I.e., the field of integers of prime module [`Self::MODULUS`].\npub trait PrimeField:\n    Field + From\u003c\u003cSelf as PrimeField\u003e::BigInt\u003e + Into\u003c\u003cSelf as PrimeField\u003e::BigInt\u003e\n{\n    /// A `BigInteger` type that can represent elements of this field.\n    type BigInt: BigInteger;\n\n    /// The modulus `p`.\n    const MODULUS: Self::BigInt;\n\n    /// The size of the modulus in bits.\n    const MODULUS_BIT_SIZE: usize;\n\n    /// Returns the characteristic of the field,\n    /// in little-endian representation.\n    #[must_use]\n    fn characteristic() -\u003e Self::BigInt {\n        Self::MODULUS\n    }\n\n    /// Construct a prime field element from a big integer.\n    fn from_bigint(repr: Self::BigInt) -\u003e Self;\n\n    /// Converts an element of the prime field into an integer less than\n    /// [`Self::MODULUS`].\n    fn into_bigint(self) -\u003e Self::BigInt;\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","hash.rs"],"content":"//! Generic hashing support.\n//!\n//! This module provides a generic way to compute the [hash] of a value. It is\n//! intended to be used as a replacement for [`core::hash`], which we can't use\n//! because [`core::hash::Hasher::finish`] returns a `u64`.\n//!\n//! [hash]: https://en.wikipedia.org/wiki/Hash_function\n\n/// A hashable type.\n///\n/// Types implementing `Hash` are able to be [`Hash::hash`]ed with an instance\n/// of [`Hasher`].\npub trait Hash {\n    /// Feeds this value into the given [`Hasher`].\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H);\n}\n\n/// A trait for hashing an arbitrary stream of bytes.\n///\n/// Instances of `Hasher` usually represent state that is changed while hashing\n/// data.\n///\n/// `Hasher` provides a fairly basic interface for retrieving the generated hash\n/// (with [`Hasher::finalize`]), and absorbing an arbitrary number of bytes\n/// (with [`Hasher::update`]). Most of the time, [`Hasher`] instances are used\n/// in conjunction with the [`Hash`] trait.\npub trait Hasher {\n    /// The output type of this hasher.\n    ///\n    /// For [`core::hash`] types, it's `u64`. For [`tiny_keccak`], it's `[u8]`.\n    /// For this crate, it's `[u8; 32]`.\n    type Output;\n\n    /// Absorb additional input. Can be called multiple times.\n    fn update(\u0026mut self, input: impl AsRef\u003c[u8]\u003e);\n\n    /// Output the hashing algorithm state.\n    fn finalize(self) -\u003e Self::Output;\n}\n\n/// A trait for creating instances of [`Hasher`].\n///\n/// A `BuildHasher` is typically used (e.g., by [`HashMap`]) to create\n/// [`Hasher`]s for each key such that they are hashed independently of one\n/// another, since [`Hasher`]s contain state.\n///\n/// For each instance of `BuildHasher`, the [`Hasher`]s created by\n/// [`build_hasher`] should be identical. That is, if the same stream of bytes\n/// is fed into each hasher, the same output will also be generated.\n///\n/// # Examples\n///\n/// ```rust\n/// use openzeppelin_crypto::KeccakBuilder;\n/// use openzeppelin_crypto::hash::{BuildHasher, Hash, Hasher};\n///\n/// let b = KeccakBuilder;\n/// let mut hasher_1 = b.build_hasher();\n/// let mut hasher_2 = b.build_hasher();\n///\n/// hasher_1.update([1]);\n/// hasher_2.update([1]);\n///\n/// assert_eq!(hasher_1.finalize(), hasher_2.finalize());\n/// ```\n///\n/// [`build_hasher`]: BuildHasher::build_hasher\n/// [`HashMap`]: ../../std/collections/struct.HashMap.html\npub trait BuildHasher {\n    /// Type of the hasher that will be created.\n    type Hasher: Hasher;\n\n    /// Creates a new hasher.\n    ///\n    /// Each call to `build_hasher` on the same instance should produce\n    /// identical [`Hasher`]s.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use openzeppelin_crypto::KeccakBuilder;\n    /// use openzeppelin_crypto::hash::BuildHasher;\n    ///\n    /// let b = KeccakBuilder;\n    /// let hasher = b.build_hasher();\n    /// ```\n    fn build_hasher(\u0026self) -\u003e Self::Hasher;\n\n    /// Calculates the hash of a single value.\n    ///\n    /// This is intended as a convenience for code which *consumes* hashes, such\n    /// as the implementation of a hash table or in unit tests that check\n    /// whether a custom [`Hash`] implementation behaves as expected.\n    ///\n    /// This must not be used in any code which *creates* hashes, such as in an\n    /// implementation of [`Hash`].  The way to create a combined hash of\n    /// multiple values is to call [`Hash::hash`] multiple times using the same\n    /// [`Hasher`], not to call this method repeatedly and combine the results.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use openzeppelin_crypto::KeccakBuilder;\n    /// use openzeppelin_crypto::hash::{BuildHasher, Hash};\n    ///\n    /// let b = KeccakBuilder;\n    /// let hash_1 = b.hash_one([0u8; 32]);\n    /// let hash_2 = b.hash_one([0u8; 32]);\n    /// assert_eq!(hash_1, hash_2);\n    ///\n    /// let hash_1 = b.hash_one([1u8; 32]);\n    /// assert_ne!(hash_1, hash_2);\n    /// ```\n    fn hash_one\u003cHashable\u003e(\n        \u0026self,\n        h: Hashable,\n    ) -\u003e \u003cSelf::Hasher as Hasher\u003e::Output\n    where\n        Hashable: Hash,\n        Self: Sized,\n        Self::Hasher: Hasher,\n    {\n        let mut hasher = self.build_hasher();\n        h.hash(\u0026mut hasher);\n        hasher.finalize()\n    }\n}\n\n/// Hash the pair `(a, b)` with `state`.\n///\n/// Returns the finalized hash output from the hasher.\n///\n/// # Arguments\n///\n/// * `a` - The first value to hash.\n/// * `b` - The second value to hash.\n/// * `state` - The hasher state to use.\n#[inline]\npub fn hash_pair\u003cS, H\u003e(a: \u0026H, b: \u0026H, mut state: S) -\u003e S::Output\nwhere\n    H: Hash + ?Sized,\n    S: Hasher,\n{\n    a.hash(\u0026mut state);\n    b.hash(\u0026mut state);\n    state.finalize()\n}\n\n/// Sort the pair `(a, b)` and hash the result with `state`. Frequently used\n/// when working with merkle proofs.\n#[inline]\npub fn commutative_hash_pair\u003cS, H\u003e(a: \u0026H, b: \u0026H, state: S) -\u003e S::Output\nwhere\n    H: Hash + PartialOrd,\n    S: Hasher,\n{\n    if a \u003e b {\n        hash_pair(b, a, state)\n    } else {\n        hash_pair(a, b, state)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use proptest::prelude::*;\n\n    use super::*;\n    use crate::{test_helpers::non_empty_u8_vec_strategy, KeccakBuilder};\n\n    // Helper impl for testing\n    impl Hash for Vec\u003cu8\u003e {\n        fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n            state.update(self.as_slice());\n        }\n    }\n\n    #[test]\n    fn commutative_hash_is_order_independent() {\n        proptest!(|(a: Vec\u003cu8\u003e, b: Vec\u003cu8\u003e)| {\n            let builder = KeccakBuilder;\n            let hash1 = commutative_hash_pair(\u0026a, \u0026b, builder.build_hasher());\n            let hash2 = commutative_hash_pair(\u0026b, \u0026a, builder.build_hasher());\n            prop_assert_eq!(hash1, hash2);\n        })\n    }\n\n    #[test]\n    fn regular_hash_is_order_dependent() {\n        proptest!(|(a in non_empty_u8_vec_strategy(),\n                    b in non_empty_u8_vec_strategy())| {\n            prop_assume!(a != b);\n            let builder = KeccakBuilder;\n            let hash1 = hash_pair(\u0026a, \u0026b, builder.build_hasher());\n            let hash2 = hash_pair(\u0026b, \u0026a, builder.build_hasher());\n            prop_assert_ne!(hash1, hash2);\n        })\n    }\n\n    #[test]\n    fn hash_pair_deterministic() {\n        proptest!(|(a: Vec\u003cu8\u003e, b: Vec\u003cu8\u003e)| {\n            let builder = KeccakBuilder;\n            let hash1 = hash_pair(\u0026a, \u0026b, builder.build_hasher());\n            let hash2 = hash_pair(\u0026a, \u0026b, builder.build_hasher());\n            prop_assert_eq!(hash1, hash2);\n        })\n    }\n\n    #[test]\n    fn commutative_hash_pair_deterministic() {\n        proptest!(|(a: Vec\u003cu8\u003e, b: Vec\u003cu8\u003e)| {\n            let builder = KeccakBuilder;\n            let hash1 = commutative_hash_pair(\u0026a, \u0026b, builder.build_hasher());\n            let hash2 = commutative_hash_pair(\u0026a, \u0026b, builder.build_hasher());\n            prop_assert_eq!(hash1, hash2);\n        })\n    }\n\n    #[test]\n    fn identical_pairs_hash() {\n        proptest!(|(a: Vec\u003cu8\u003e)| {\n            let builder = KeccakBuilder;\n            let hash1 = hash_pair(\u0026a, \u0026a, builder.build_hasher());\n            let hash2 = commutative_hash_pair(\u0026a, \u0026a, builder.build_hasher());\n            assert_eq!(hash1, hash2);\n        })\n    }\n}\n","traces":[{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","keccak.rs"],"content":"//! An interface to the default hashing algorithm used in this library's [merkle\n//! proofs][crate].\nuse tiny_keccak::{Hasher as TinyHasher, Keccak};\n\nuse crate::hash::{BuildHasher, Hash, Hasher};\n\n/// The default [`Hasher`] builder used in this library's [merkle\n/// proofs][crate].\n///\n/// It instantiates a [`Keccak256`] hasher.\npub struct KeccakBuilder;\n\nimpl BuildHasher for KeccakBuilder {\n    type Hasher = Keccak256;\n\n    #[inline]\n    fn build_hasher(\u0026self) -\u003e Self::Hasher {\n        Keccak256(Keccak::v256())\n    }\n}\n\n/// The default [`Hasher`] used in this library's [merkle proofs][crate].\n///\n/// The underlying implementation is guaranteed to match that of the\n/// `keccak256` algorithm, commonly used in Ethereum.\npub struct Keccak256(Keccak);\n\nimpl Hasher for Keccak256 {\n    type Output = [u8; 32];\n\n    fn update(\u0026mut self, input: impl AsRef\u003c[u8]\u003e) {\n        self.0.update(input.as_ref());\n    }\n\n    fn finalize(self) -\u003e Self::Output {\n        let mut buffer = [0u8; 32];\n        self.0.finalize(\u0026mut buffer);\n        buffer\n    }\n}\n\nimpl Hash for [u8; 32] {\n    #[inline]\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        state.update(self);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use proptest::prelude::*;\n\n    use super::*;\n    use crate::test_helpers::non_empty_u8_vec_strategy;\n\n    #[test]\n    fn single_bit_change_affects_output() {\n        proptest!(|(data in non_empty_u8_vec_strategy())| {\n            let mut modified = data.clone();\n            modified[0] ^= 1;\n\n            let mut hasher1 = KeccakBuilder.build_hasher();\n            let mut hasher2 = KeccakBuilder.build_hasher();\n            hasher1.update(\u0026data);\n            hasher2.update(\u0026modified);\n\n            prop_assert_ne!(hasher1.finalize(), hasher2.finalize());\n        })\n    }\n\n    #[test]\n    fn sequential_updates_match_concatenated() {\n        proptest!(|(data1: Vec\u003cu8\u003e, data2: Vec\u003cu8\u003e)| {\n            let builder = KeccakBuilder;\n\n            let mut hasher1 = builder.build_hasher();\n            hasher1.update(\u0026data1);\n            hasher1.update(\u0026data2);\n            let result1 = hasher1.finalize();\n\n            let mut hasher2 = builder.build_hasher();\n            let mut concatenated = data1.clone();\n            concatenated.extend_from_slice(\u0026data2);\n            hasher2.update(concatenated);\n            let result2 = hasher2.finalize();\n\n            prop_assert_eq!(result1, result2);\n        })\n    }\n\n    #[test]\n    fn split_updates_match_full_update() {\n        proptest!(|(data in non_empty_u8_vec_strategy(), split_point: usize)| {\n            let builder = KeccakBuilder;\n            let split_at = split_point % data.len();\n\n            let mut hasher1 = builder.build_hasher();\n            hasher1.update(\u0026data[..split_at]);\n            hasher1.update(\u0026data[split_at..]);\n            let result1 = hasher1.finalize();\n\n            let mut hasher2 = builder.build_hasher();\n            hasher2.update(\u0026data);\n            let result2 = hasher2.finalize();\n\n            prop_assert_eq!(result1, result2);\n        })\n    }\n\n    #[test]\n    fn multiple_hasher_instances_are_consistent() {\n        proptest!(|(data1: Vec\u003cu8\u003e, data2: Vec\u003cu8\u003e)| {\n            let builder = KeccakBuilder;\n\n            let mut hasher1 = builder.build_hasher();\n            hasher1.update(\u0026data1);\n            hasher1.update(\u0026data2);\n            let result1 = hasher1.finalize();\n\n            let mut hasher2 = builder.build_hasher();\n            hasher2.update(\u0026data1);\n            hasher2.update(\u0026data2);\n            let result2 = hasher2.finalize();\n\n            prop_assert_eq!(result1, result2);\n        })\n    }\n\n    #[test]\n    fn output_is_always_32_bytes() {\n        proptest!(|(data: Vec\u003cu8\u003e)| {\n            let builder = KeccakBuilder;\n            let mut hasher = builder.build_hasher();\n            hasher.update(\u0026data);\n            let result = hasher.finalize();\n            assert_eq!(result.len(), 32);\n        })\n    }\n\n    #[test]\n    fn update_order_dependence() {\n        proptest!(|(data1 in non_empty_u8_vec_strategy(),\n                    data2 in non_empty_u8_vec_strategy())| {\n            prop_assume!(data1 != data2);\n\n            let mut hasher1 = KeccakBuilder.build_hasher();\n            hasher1.update(\u0026data1);\n            hasher1.update(\u0026data2);\n\n            let mut hasher2 = KeccakBuilder.build_hasher();\n            hasher2.update(\u0026data2);\n            hasher2.update(\u0026data1);\n\n            prop_assert_ne!(hasher1.finalize(), hasher2.finalize());\n        })\n    }\n\n    #[test]\n    fn empty_input_order_independence() {\n        proptest!(|(data in non_empty_u8_vec_strategy())| {\n            let empty = vec![];\n\n            let mut hasher1 = KeccakBuilder.build_hasher();\n            hasher1.update(\u0026data);\n            hasher1.update(\u0026empty);\n\n            let mut hasher2 = KeccakBuilder.build_hasher();\n            hasher2.update(\u0026empty);\n            hasher2.update(\u0026data);\n\n            prop_assert_eq!(hasher1.finalize(), hasher2.finalize());\n        })\n    }\n\n    #[test]\n    fn trailing_zero_affects_output() {\n        proptest!(|(data: Vec\u003cu8\u003e)| {\n            let mut hasher1 = KeccakBuilder.build_hasher();\n            hasher1.update(\u0026data);\n\n            let mut padded = data.clone();\n            padded.push(0);\n\n            let mut hasher2 = KeccakBuilder.build_hasher();\n            hasher2.update(\u0026padded);\n\n            prop_assert_ne!(hasher1.finalize(), hasher2.finalize());\n        })\n    }\n\n    #[test]\n    fn leading_zeros_affect_output() {\n        proptest!(|(data in non_empty_u8_vec_strategy())| {\n            let mut hasher1 = KeccakBuilder.build_hasher();\n            hasher1.update(\u0026data);\n            let hash1 = hasher1.finalize();\n\n            let mut padded = vec![0u8; 32];\n            padded.extend(data.iter());\n\n            let mut hasher2 = KeccakBuilder.build_hasher();\n            hasher2.update(\u0026padded);\n            let hash2 = hasher2.finalize();\n\n            prop_assert_ne!(hash1, hash2);\n        })\n    }\n\n    #[test]\n    fn no_trivial_collisions_same_length() {\n        proptest!(|(data in non_empty_u8_vec_strategy())| {\n            let mut hasher1 = KeccakBuilder.build_hasher();\n            hasher1.update(\u0026data);\n\n            let mut modified = data.clone();\n            modified[data.len() - 1] = modified[data.len() - 1].wrapping_add(1);\n\n            let mut hasher2 = KeccakBuilder.build_hasher();\n            hasher2.update(\u0026modified);\n\n            prop_assert_ne!(hasher1.finalize(), hasher2.finalize());\n        })\n    }\n\n    #[test]\n    fn length_extension_attack_resistance() {\n        proptest!(|(data1 in non_empty_u8_vec_strategy(), data2 in non_empty_u8_vec_strategy())| {\n            let mut hasher1 = KeccakBuilder.build_hasher();\n            hasher1.update(\u0026data1);\n            let hash1 = hasher1.finalize();\n\n            let mut hasher2 = KeccakBuilder.build_hasher();\n            hasher2.update(\u0026data1);\n            hasher2.update(\u0026data2);\n            let hash2 = hasher2.finalize();\n\n            let mut hasher3 = KeccakBuilder.build_hasher();\n            hasher3.update(\u0026hash1);\n            hasher3.update(\u0026data2);\n            let hash3 = hasher3.finalize();\n\n            prop_assert_ne!(hash2, hash3);\n        })\n    }\n\n    #[test]\n    fn empty_input() {\n        let builder = KeccakBuilder;\n        let mut hasher = builder.build_hasher();\n        hasher.update(\u0026[]);\n        let result = hasher.finalize();\n        let expected: [u8; 32] = [\n            0xc5, 0xd2, 0x46, 0x01, 0x86, 0xf7, 0x23, 0x3c, 0x92, 0x7e, 0x7d,\n            0xb2, 0xdc, 0xc7, 0x03, 0xc0, 0xe5, 0x00, 0xb6, 0x53, 0xca, 0x82,\n            0x27, 0x3b, 0x7b, 0xfa, 0xd8, 0x04, 0x5d, 0x85, 0xa4, 0x70,\n        ];\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn known_hash() {\n        let builder = KeccakBuilder;\n        let mut hasher = builder.build_hasher();\n        hasher.update(b\"hello\");\n        let result = hasher.finalize();\n        let expected: [u8; 32] = [\n            0x1c, 0x8a, 0xff, 0x95, 0x06, 0x85, 0xc2, 0xed, 0x4b, 0xc3, 0x17,\n            0x4f, 0x34, 0x72, 0x28, 0x7b, 0x56, 0xd9, 0x51, 0x7b, 0x9c, 0x94,\n            0x81, 0x27, 0x31, 0x9a, 0x09, 0xa7, 0xa3, 0x6d, 0xea, 0xc8,\n        ];\n        assert_eq!(result, expected);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","lib.rs"],"content":"/*!\nCommon cryptographic procedures for a blockchain environment.\n\n\u003e Note that `crypto` is still `0.*.*`, so breaking changes\n\u003e [may occur at any time](https://semver.org/#spec-item-4). If you must depend\n\u003e on `crypto`, we recommend pinning to a specific version, i.e., `=0.y.z`.\n\n## Verifying Merkle Proofs\n\n[`merkle.rs`](./src/merkle.rs) provides:\n\n- A `verify` function which can prove that some value is part of a\n  [Merkle tree].\n- A `verify_multi_proof` function which can prove multiple values are part of a\n  [Merkle tree].\n\n[Merkle tree]: https://en.wikipedia.org/wiki/Merkle_tree\n\n*/\n\n#![allow(clippy::module_name_repetitions)]\n#![allow(clippy::inline_always)]\n#![allow(clippy::unreadable_literal)]\n#![allow(clippy::many_single_char_names)]\n#![cfg_attr(not(test), no_std, no_main)]\nextern crate alloc;\nextern crate core;\n\npub mod arithmetic;\npub mod bits;\n#[macro_use]\npub mod field;\nmod const_helpers;\npub mod hash;\npub mod keccak;\npub mod merkle;\npub mod pedersen;\npub mod poseidon2;\n\npub use keccak::KeccakBuilder;\n\npub mod curve;\n#[cfg(test)]\nmod test_helpers;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","merkle.rs"],"content":"//! This module deals with verification of Merkle Tree proofs.\n//!\n//! The tree and the proofs can be generated using `OpenZeppelin`'s\n//! [merkle tree library](https://github.com/OpenZeppelin/merkle-tree). You will\n//! find a quickstart guide in its README.\n//!\n//! WARNING: You should avoid using leaf values that are 64 bytes long\n//! prior to hashing, or use a hash function other than keccak256 for\n//! hashing leaves. This is because the concatenation of a sorted pair\n//! of internal nodes in the Merkle tree could be reinterpreted as a\n//! leaf value. `OpenZeppelin`'s JavaScript library generates Merkle trees\n//! that are safe against this attack out of the box.\nuse alloc::vec::Vec;\nuse core::marker::PhantomData;\n\nuse crate::{\n    hash::{commutative_hash_pair, BuildHasher, Hasher},\n    KeccakBuilder,\n};\n\ntype Bytes32 = [u8; 32];\n\n/// Verify merkle proofs.\npub struct Verifier\u003cB = KeccakBuilder\u003e(PhantomData\u003cB\u003e)\nwhere\n    B: BuildHasher;\n\nimpl Verifier\u003cKeccakBuilder\u003e {\n    /// Verify that `leaf` is part of a Merkle tree defined by `root` by using\n    /// `proof` and the default `keccak256` hashing algorithm.\n    ///\n    /// A new root is rebuilt by traversing up the Merkle tree. The `proof`\n    /// provided must contain sibling hashes on the branch starting from the\n    /// leaf to the root of the tree. Each pair of leaves and each pair of\n    /// pre-images are assumed to be sorted.\n    ///\n    /// A `proof` is valid if and only if the rebuilt hash matches the root\n    /// of the tree.\n    ///\n    /// # Arguments\n    ///\n    /// * `proof` - A slice of hashes that constitute the merkle proof.\n    /// * `root` - The root of the merkle tree, in bytes.\n    /// * `leaf` - The leaf of the merkle tree to proof, in bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use openzeppelin_crypto::merkle::Verifier;\n    /// use hex_literal::hex;\n    ///\n    /// let root  = hex!(\"0000000000000000000000000000000000000000000000000000000000000000\");\n    /// let leaf  = hex!(\"0000000000000000000000000000000000000000000000000000000000000000\");\n    /// let proof = hex!(\"0000000000000000000000000000000000000000000000000000000000000000\");\n    ///\n    /// let verification = Verifier::verify(\u0026[proof], root, leaf);\n    /// assert!(!verification);\n    /// ```\n    #[must_use]\n    pub fn verify(proof: \u0026[Bytes32], root: Bytes32, leaf: Bytes32) -\u003e bool {\n        Verifier::verify_with_builder(proof, root, leaf, \u0026KeccakBuilder)\n    }\n\n    /// Verify multiple `leaves` can be simultaneously proven to be a part of\n    /// a Merkle tree defined by `root` by using a `proof` with `proof_flags`\n    /// and a `hasher`.\n    ///\n    /// The `proof` must contain the sibling hashes one would need to rebuild\n    /// the root starting from `leaves`. `proof_flags` represents whether a\n    /// hash must be computed using a `proof` member. A new root is rebuilt by\n    /// starting from the `leaves` and traversing up the Merkle tree.\n    ///\n    /// The procedure incrementally reconstructs all inner nodes by combining\n    /// a leaf/inner node with either another leaf/inner node or a `proof`\n    /// sibling node, depending on each proof flag being true or false\n    /// respectively, i.e., the `i`-th hash must be computed using the proof if\n    /// `proof_flags[i] == false`.\n    ///\n    /// CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs,\n    /// it is sufficient to ensure that:\n    /// - The tree is complete (but not necessarily perfect).\n    /// - The leaves to be proven are in the opposite order they appear in the\n    ///   tree (i.e., as seen from right to left starting at the deepest layer\n    ///   and continuing at the next layer).\n    ///\n    /// NOTE: This implementation is *not* equivalent to it's Solidity\n    /// counterpart. In Rust, access to uninitialized memory panics, which\n    /// means we don't need to check that the whole proof array has been\n    /// processed. Both implementations will revert for the same inputs, but\n    /// for different reasons. See \u003chttps://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wprv-93r4-jj2p\u003e\n    ///\n    /// # Arguments\n    ///\n    /// * `proof` - A slice of hashes that constitute the merkle proof.\n    /// * `proof_flags` - A slice of booleans that determine whether to hash\n    ///   leaves or the proof.\n    /// * `root` - The root of the merkle tree, in bytes.\n    /// * `leaves` - A slice of hashes that constitute the leaves of the merkle\n    ///   tree to be proven, each leaf in bytes.\n    ///\n    /// # Errors\n    ///\n    /// * [`MultiProofError`] - If the arguments are well-formed, but invalid.\n    ///\n    /// # Panics\n    ///\n    /// * If the proof is malicious (with an out-of-bounds error). See \u003chttps://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wprv-93r4-jj2p\u003e\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use openzeppelin_crypto::merkle::Verifier;\n    /// use hex_literal::hex;\n    ///\n    /// let root   =  hex!(\"6deb52b5da8fd108f79fab00341f38d2587896634c646ee52e49f845680a70c8\");\n    /// let leaves = [hex!(\"19ba6c6333e0e9a15bf67523e0676e2f23eb8e574092552d5e888c64a4bb3681\"),\n    ///               hex!(\"c62a8cfa41edc0ef6f6ae27a2985b7d39c7fea770787d7e104696c6e81f64848\"),\n    ///               hex!(\"eba909cf4bb90c6922771d7f126ad0fd11dfde93f3937a196274e1ac20fd2f5b\")];\n    /// let proof  = [hex!(\"9a4f64e953595df82d1b4f570d34c4f4f0cfaf729a61e9d60e83e579e1aa283e\"),\n    ///               hex!(\"8076923e76cf01a7c048400a2304c9a9c23bbbdac3a98ea3946340fdafbba34f\")];\n    ///\n    /// let proof_flags = [false, true, false, true];\n    ///\n    /// let verification =\n    ///     Verifier::verify_multi_proof(\u0026proof, \u0026proof_flags, root, \u0026leaves);\n    /// assert!(verification.unwrap());\n    /// ```\n    #[must_use]\n    pub fn verify_multi_proof(\n        proof: \u0026[Bytes32],\n        proof_flags: \u0026[bool],\n        root: Bytes32,\n        leaves: \u0026[Bytes32],\n    ) -\u003e Result\u003cbool, MultiProofError\u003e {\n        Verifier::verify_multi_proof_with_builder(\n            proof,\n            proof_flags,\n            root,\n            leaves,\n            \u0026KeccakBuilder,\n        )\n    }\n}\n\nimpl\u003cB\u003e Verifier\u003cB\u003e\nwhere\n    B: BuildHasher,\n    B::Hasher: Hasher\u003cOutput = Bytes32\u003e,\n{\n    /// Verify that `leaf` is part of a Merkle tree defined by `root` by using\n    /// `proof` and a custom hashing algorithm defined by `builder`. See\n    /// [`BuildHasher`] for more information on how to construct a builder.\n    ///\n    /// Merkle tree hashing process must be constructed commutatively when using\n    /// custom hashing algorithms.\n    ///\n    /// WARNING: This is a lower-level function. For most use cases,\n    /// [`Verifier::verify`], which uses `keccak256` as a hashing algorithm,\n    /// should be enough. Using other hashing algorithm may have unexpected\n    /// results.\n    ///\n    /// # Arguments\n    ///\n    /// * `proof` - A slice of hashes that constitute the merkle proof.\n    /// * `root` - The root of the merkle tree, in bytes.\n    /// * `leaf` - The leaf of the merkle tree to proof, in bytes.\n    /// * `builder` - A [`BuildHasher`] that represents a hashing algorithm.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use openzeppelin_crypto::{merkle::Verifier, KeccakBuilder};\n    /// use hex_literal::hex;\n    ///\n    /// let root  = hex!(\"0000000000000000000000000000000000000000000000000000000000000000\");\n    /// let leaf  = hex!(\"0000000000000000000000000000000000000000000000000000000000000000\");\n    /// let proof = hex!(\"0000000000000000000000000000000000000000000000000000000000000000\");\n    ///\n    /// let verification = Verifier::verify_with_builder(\u0026[proof], root, leaf, \u0026KeccakBuilder);\n    /// assert!(!verification);\n    /// ```\n    pub fn verify_with_builder(\n        proof: \u0026[Bytes32],\n        root: Bytes32,\n        mut leaf: Bytes32,\n        builder: \u0026B,\n    ) -\u003e bool {\n        for \u0026hash in proof {\n            leaf = commutative_hash_pair(\u0026leaf, \u0026hash, builder.build_hasher());\n        }\n\n        leaf == root\n    }\n\n    /// Verify multiple `leaves` can be simultaneously proven to be a part of\n    /// a Merkle tree defined by `root` by using a `proof` with `proof_flags`\n    /// and a custom hashing algorithm defined by `builder`. See\n    /// [`BuildHasher`] for more information on how to construct a builder.\n    ///\n    /// Merkle tree hashing process must be constructed commutatively when using\n    /// custom hashing algorithms.\n    ///\n    /// WARNING: This is a lower-level function. For most use cases,\n    /// [`Verifier::verify_multi_proof`], which uses `keccak256` as a hashing\n    /// algorithm, should be enough. Using other hashing algorithm may have\n    /// unexpected results.\n    ///\n    /// The `proof` must contain the sibling hashes one would need to rebuild\n    /// the root starting from `leaves`. `proof_flags` represents whether a\n    /// hash must be computed using a `proof` member. A new root is rebuilt by\n    /// starting from the `leaves` and traversing up the Merkle tree.\n    ///\n    /// The procedure incrementally reconstructs all inner nodes by combining\n    /// a leaf/inner node with either another leaf/inner node or a `proof`\n    /// sibling node, depending on each proof flag being true or false\n    /// respectively, i.e., the `i`-th hash must be computed using the proof if\n    /// `proof_flags[i] == false`.\n    ///\n    /// CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs,\n    /// it is sufficient to ensure that:\n    /// - The tree is complete (but not necessarily perfect).\n    /// - The leaves to be proven are in the opposite order they appear in the\n    ///   tree (i.e., as seen from right to left starting at the deepest layer\n    ///   and continuing at the next layer).\n    ///\n    /// NOTE: This implementation is *not* equivalent to it's Solidity\n    /// counterpart. In Rust, access to uninitialized memory panics, which\n    /// means we don't need to check that the whole proof array has been\n    /// processed. Both implementations will revert for the same inputs, but\n    /// for different reasons. See \u003chttps://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wprv-93r4-jj2p\u003e\n    ///\n    /// # Arguments\n    ///\n    /// * `proof` - A slice of hashes that constitute the merkle proof.\n    /// * `proof_flags` - A slice of booleans that determine whether to hash\n    ///   leaves or the proof.\n    /// * `root` - The root of the merkle tree, in bytes.\n    /// * `leaves` - A slice of hashes that constitute the leaves of the merkle\n    ///   tree to be proven, each leaf in bytes.\n    /// * `builder` - A [`BuildHasher`] that represents a hashing algorithm.\n    ///\n    /// # Errors\n    ///\n    /// * [`MultiProofError`] - If the arguments are well-formed, but invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use openzeppelin_crypto::{merkle::Verifier, KeccakBuilder};\n    /// use hex_literal::hex;\n    ///\n    /// let root   =  hex!(\"6deb52b5da8fd108f79fab00341f38d2587896634c646ee52e49f845680a70c8\");\n    /// let leaves = [hex!(\"19ba6c6333e0e9a15bf67523e0676e2f23eb8e574092552d5e888c64a4bb3681\"),\n    ///               hex!(\"c62a8cfa41edc0ef6f6ae27a2985b7d39c7fea770787d7e104696c6e81f64848\"),\n    ///               hex!(\"eba909cf4bb90c6922771d7f126ad0fd11dfde93f3937a196274e1ac20fd2f5b\")];\n    /// let proof  = [hex!(\"9a4f64e953595df82d1b4f570d34c4f4f0cfaf729a61e9d60e83e579e1aa283e\"),\n    ///               hex!(\"8076923e76cf01a7c048400a2304c9a9c23bbbdac3a98ea3946340fdafbba34f\")];\n    /// let proof_flags = [false, true, false, true];\n    ///\n    /// let verification =\n    ///     Verifier::verify_multi_proof_with_builder(\u0026proof, \u0026proof_flags, root, \u0026leaves, \u0026KeccakBuilder);\n    /// assert!(verification.unwrap());\n    /// ```\n    pub fn verify_multi_proof_with_builder(\n        proof: \u0026[Bytes32],\n        proof_flags: \u0026[bool],\n        root: Bytes32,\n        leaves: \u0026[Bytes32],\n        builder: \u0026B,\n    ) -\u003e Result\u003cbool, MultiProofError\u003e {\n        let total_hashes = proof_flags.len();\n        if leaves.len() + proof.len() != total_hashes + 1 {\n            return Err(MultiProofError::InvalidTotalHashes);\n        }\n        if total_hashes == 0 {\n            // We can safely assume that either `leaves` or `proof` is not empty\n            // given the previous check. We use `unwrap_or_else` to avoid\n            // eagerly evaluating `proof[0]`, which may panic.\n            let rebuilt_root = *leaves.first().unwrap_or_else(|| \u0026proof[0]);\n            return Ok(root == rebuilt_root);\n        }\n\n        // We need at least one leaf for non-trivial trees\n        if leaves.is_empty() {\n            return Err(MultiProofError::NoLeaves);\n        }\n\n        // `hashes` represents a queue of hashes, our \"main queue\".\n        let mut hashes = Vec::with_capacity(total_hashes + leaves.len());\n        // Which initially gets populated with the leaves.\n        hashes.extend(leaves);\n        // The `xxx_pos` values are \"pointers\" to the next value to consume in\n        // each queue. We use them to mimic a queue's pop operation.\n        let mut proof_pos = 0;\n        let mut hashes_pos = 0;\n        // At each step, we compute the next hash using two values:\n        // - A value from the \"main queue\". Consume all the leaves, then all the\n        //   hashes but the root.\n        // - A value from the \"main queue\" (merging branches) or a member of the\n        //   `proof`, depending on `flag`.\n        for \u0026flag in proof_flags {\n            let a = hashes[hashes_pos];\n            hashes_pos += 1;\n\n            let b;\n            if flag {\n                b = hashes\n                    .get(hashes_pos)\n                    .ok_or(MultiProofError::InvalidRootChild)?;\n                hashes_pos += 1;\n            } else {\n                b = proof\n                    .get(proof_pos)\n                    .ok_or(MultiProofError::InvalidProofLength)?;\n                proof_pos += 1;\n            }\n\n            let hash = commutative_hash_pair(\u0026a, b, builder.build_hasher());\n            hashes.push(hash);\n        }\n\n        // We know that `total_hashes \u003e 0`.\n        let rebuilt_root = hashes[total_hashes + leaves.len() - 1];\n        Ok(root == rebuilt_root)\n    }\n}\n\n/// An error that occurred while verifying a multi-proof.\n///\n/// TODO: Once \u003chttps://github.com/rust-lang/rust/issues/103765\u003e is resolved,\n/// we should derive `core::error::Error`.\n#[derive(core::fmt::Debug, PartialEq)]\npub enum MultiProofError {\n    /// The proof length does not match the flags.\n    InvalidProofLength,\n    /// Tried to access uninitialized memory.\n    ///\n    /// This happens when the proof is too long, which makes the verification\n    /// procedure try to access uninitialized memory, which may result in an\n    /// invalid root.\n    ///\n    /// For more information see [this vulnerability].\n    ///\n    /// [this vulnerability]: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wprv-93r4-jj2p\n    InvalidRootChild,\n    /// The number of leaves and proof members does not match the number of\n    /// hashes necessary to complete the verification.\n    InvalidTotalHashes,\n    /// No leaves were provided for a non-trivial tree.\n    NoLeaves,\n}\n\nimpl core::fmt::Display for MultiProofError {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        let msg = match self {\n            MultiProofError::InvalidProofLength =\u003e \"invalid multi-proof length\",\n            MultiProofError::InvalidRootChild =\u003e \"invalid root child generated\",\n            MultiProofError::InvalidTotalHashes =\u003e {\n                \"leaves.len() + proof.len() != total_hashes + 1\"\n            }\n            MultiProofError::NoLeaves =\u003e {\n                \"no leaves were provided for a non-trivial tree\"\n            }\n        };\n\n        write!(f, \"{msg}\")\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    //! NOTE: The values used as input for these tests were all generated using\n    //! \u003chttps://github.com/OpenZeppelin/merkle-tree\u003e.\n    use hex_literal::hex;\n    use proptest::{prelude::*, prop_compose};\n    use rand::{rng, RngCore};\n\n    use super::{Bytes32, KeccakBuilder, MultiProofError, Verifier};\n    use crate::hash::{commutative_hash_pair, BuildHasher};\n\n    /// Shorthand for declaring variables converted from a hex literal to a\n    /// fixed 32-byte slice.\n    macro_rules! bytes {\n        ($($var:ident = $hex:literal);* $(;)?) =\u003e {\n            $(\n                #[allow(non_upper_case_globals)]\n                const $var: Bytes32 = hex!($hex);\n            )*\n        };\n    }\n\n    /// Shorthand for converting from an array of hex literals to an array of\n    /// fixed 32-bytes slices.\n    macro_rules! bytes_array {\n        ($($s:literal),* $(,)?) =\u003e {\n            [\n              $(hex!($s),)*\n            ]\n        };\n    }\n\n    prop_compose! {\n        fn valid_merkle_proof(min_proof_len: usize)(\n            leaf: [u8; 32],\n            proof in prop::collection::vec(any::\u003c[u8; 32]\u003e(), min_proof_len..ProptestConfig::default().max_default_size_range),\n        ) -\u003e (Vec\u003c[u8; 32]\u003e, [u8; 32], [u8; 32]) {\n            let mut current = leaf;\n            for \u0026hash in \u0026proof {\n                current = commutative_hash_pair(\n                    \u0026current,\n                    \u0026hash,\n                    KeccakBuilder.build_hasher(),\n                );\n            }\n            let root = current;\n            (proof, root, leaf)\n        }\n    }\n\n    #[test]\n    fn proof_tampering_invalidates() {\n        proptest!(\n            |((proof, root, leaf) in valid_merkle_proof(0),\n             tamper_idx in 0..32usize)| {\n                if let Some(proof_element) = proof.first() {\n                    let mut tampered_proof = proof.clone();\n                    let mut tampered_element = *proof_element;\n                    tampered_element[tamper_idx] =\n                        tampered_element[tamper_idx].wrapping_add(1);\n                    tampered_proof[0] = tampered_element;\n\n                    prop_assert!(!Verifier::verify(\u0026tampered_proof, root, leaf));\n                }\n            }\n        )\n    }\n\n    #[test]\n    fn proof_length_affects_verification() {\n        proptest!(\n            |((proof, root, leaf) in valid_merkle_proof(0),\n             extra_hash: [u8; 32])| {\n                let longer_proof = \u0026[proof.as_slice(), \u0026[extra_hash]].concat();\n                prop_assert!(!Verifier::verify(longer_proof, root, leaf));\n\n                if !proof.is_empty() {\n                    let shorter_proof = \u0026proof[1..];\n                    prop_assert!(!Verifier::verify(shorter_proof, root, leaf));\n                    let shorter_proof = \u0026proof[..proof.len() - 1];\n                    prop_assert!(!Verifier::verify(shorter_proof, root, leaf));\n                }\n            }\n        )\n    }\n\n    #[test]\n    fn proof_consistency() {\n        proptest!(\n            |(proof: Vec\u003c[u8; 32]\u003e,\n             proof_flags: Vec\u003cbool\u003e,\n             root: [u8; 32],\n             // for regular proof\n             leaf: [u8; 32],\n             // for multi-proof\n             leaves: Vec\u003c[u8; 32]\u003e,)| {\n                let result1 = Verifier::verify(\u0026proof, root, leaf);\n                let result2 = Verifier::verify(\u0026proof, root, leaf);\n                prop_assert_eq!(result1, result2);\n\n                // ensure proof_flags length is always \u003c= proof.len()\n                let proof_flags =\n                proof_flags.into_iter().take(proof.len()).collect::\u003cVec\u003c_\u003e\u003e();\n\n                let result1 = Verifier::verify_multi_proof(\n                    \u0026proof,\n                    \u0026proof_flags,\n                    root,\n                    \u0026leaves,\n                );\n                let result2 = Verifier::verify_multi_proof(\n                    \u0026proof,\n                    \u0026proof_flags,\n                    root,\n                    \u0026leaves,\n                );\n                prop_assert_eq!(result1, result2);\n            }\n        )\n    }\n\n    #[test]\n    fn single_leaf_equals_regular_verify() {\n        proptest!(|((proof, root, leaf) in valid_merkle_proof(0))| {\n            let proof_flags = vec![false; proof.len()];\n            let multi_result = Verifier::verify_multi_proof(\n                \u0026proof,\n                \u0026proof_flags,\n                root,\n                \u0026[leaf],\n            );\n            let regular_result = Verifier::verify(\u0026proof, root, leaf);\n\n            let multi_result = multi_result.unwrap();\n            prop_assert_eq!(multi_result, regular_result);\n        })\n    }\n\n    #[test]\n    fn zero_length_proof_with_matching_leaf_and_root() {\n        let root = [0u8; 32];\n        let leaf = root.clone();\n        assert!(Verifier::verify(\u0026[], root, leaf));\n    }\n\n    #[test]\n    fn multi_proof_empty_flags() {\n        let root = [0u8; 32];\n        let leaves = vec![[1u8; 32]];\n        let proof = vec![[2u8; 32]];\n\n        let result = Verifier::verify_multi_proof(\u0026proof, \u0026[], root, \u0026leaves);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn multi_proof_minimum_valid_case() {\n        let root = [0u8; 32];\n        let leaves = vec![[0u8; 32]];\n        let result = Verifier::verify_multi_proof(\u0026[], \u0026[], root, \u0026leaves);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn verifies_valid_proofs() {\n        // ```js\n        // const merkleTree = StandardMerkleTree.of(\n        //   toElements('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='),\n        //   ['string'],\n        // );\n        //\n        // const root  = merkleTree.root;\n        // const hash  = merkleTree.leafHash(['A']);\n        // const proof = merkleTree.getProof(['A']);\n        // ```\n        bytes! {\n            root   = \"b89eb120147840e813a77109b44063488a346b4ca15686185cf314320560d3f3\";\n            leaf_a = \"6efbf77e320741a027b50f02224545461f97cd83762d5fbfeb894b9eb3287c16\";\n            leaf_b = \"7051e21dd45e25ed8c605a53da6f77de151dcbf47b0e3ced3c5d8b61f4a13dbc\";\n        };\n        let proof = bytes_array! {\n            \"7051e21dd45e25ed8c605a53da6f77de151dcbf47b0e3ced3c5d8b61f4a13dbc\",\n            \"1629d3b5b09b30449d258e35bbd09dd5e8a3abb91425ef810dc27eef995f7490\",\n            \"633d21baee4bbe5ed5c51ac0c68f7946b8f28d2937f0ca7ef5e1ea9dbda52e7a\",\n            \"8a65d3006581737a3bab46d9e4775dbc1821b1ea813d350a13fcd4f15a8942ec\",\n            \"d6c3f3e36cd23ba32443f6a687ecea44ebfe2b8759a62cccf7759ec1fb563c76\",\n            \"276141cd72b9b81c67f7182ff8a550b76eb96de9248a3ec027ac048c79649115\",\n        };\n\n        let verification = Verifier::verify(\u0026proof, root, leaf_a);\n        assert!(verification);\n\n        let builder = KeccakBuilder.build_hasher();\n        let no_such_leaf = commutative_hash_pair(\u0026leaf_a, \u0026leaf_b, builder);\n        let proof = \u0026proof[1..];\n        let verification = Verifier::verify(proof, root, no_such_leaf);\n        assert!(verification);\n    }\n\n    #[test]\n    fn rejects_invalid_proofs() {\n        // ```js\n        // const correctMerkleTree = StandardMerkleTree.of(toElements('abc'), ['string']);\n        // const otherMerkleTree = StandardMerkleTree.of(toElements('def'), ['string']);\n        //\n        // const root = correctMerkleTree.root;\n        // const leaf = correctMerkleTree.leafHash(['a']);\n        // const proof = otherMerkleTree.getProof(['d']);\n        // ```\n        bytes! {\n            root  = \"f2129b5a697531ef818f644564a6552b35c549722385bc52aa7fe46c0b5f46b1\";\n            leaf  = \"9c15a6a0eaeed500fd9eed4cbeab71f797cefcc67bfd46683e4d2e6ff7f06d1c\";\n            proof = \"7b0c6cd04b82bfc0e250030a5d2690c52585e0cc6a4f3bc7909d7723b0236ece\";\n        };\n\n        let verification = Verifier::verify(\u0026[proof], root, leaf);\n        assert!(!verification);\n    }\n\n    #[test]\n    fn rejects_proofs_with_invalid_length() {\n        // ```js\n        // const merkleTree = StandardMerkleTree.of(toElements('abc'), ['string']);\n        //\n        // const root = merkleTree.root;\n        // const leaf = merkleTree.leafHash(['a']);\n        // const proof = merkleTree.getProof(['a']);\n        // ```\n        bytes! {\n            root = \"f2129b5a697531ef818f644564a6552b35c549722385bc52aa7fe46c0b5f46b1\";\n            leaf = \"9c15a6a0eaeed500fd9eed4cbeab71f797cefcc67bfd46683e4d2e6ff7f06d1c\";\n        };\n        let proof = bytes_array! {\n            \"19ba6c6333e0e9a15bf67523e0676e2f23eb8e574092552d5e888c64a4bb3681\",\n            \"9cf5a63718145ba968a01c1d557020181c5b252f665cf7386d370eddb176517b\",\n        };\n\n        let bad_proof = \u0026proof[..1];\n        let verification = Verifier::verify(bad_proof, root, leaf);\n        assert!(!verification);\n    }\n\n    #[test]\n    fn verifies_valid_multi_proof() {\n        // ```js\n        // const merkleTree = StandardMerkleTree.of(toElements('abcdef'), ['string']);\n        //\n        // const root = merkleTree.root;\n        // const { proof, proofFlags, leaves } = merkleTree.getMultiProof(toElements('bdf'));\n        // const hashes = leaves.map(e =\u003e merkleTree.leafHash(e));\n        // ```\n        bytes! {\n            root = \"6deb52b5da8fd108f79fab00341f38d2587896634c646ee52e49f845680a70c8\";\n        };\n        let leaves = bytes_array! {\n            \"19ba6c6333e0e9a15bf67523e0676e2f23eb8e574092552d5e888c64a4bb3681\",\n            \"c62a8cfa41edc0ef6f6ae27a2985b7d39c7fea770787d7e104696c6e81f64848\",\n            \"eba909cf4bb90c6922771d7f126ad0fd11dfde93f3937a196274e1ac20fd2f5b\",\n        };\n        let proof = bytes_array! {\n            \"9a4f64e953595df82d1b4f570d34c4f4f0cfaf729a61e9d60e83e579e1aa283e\",\n            \"8076923e76cf01a7c048400a2304c9a9c23bbbdac3a98ea3946340fdafbba34f\",\n        };\n\n        let proof_flags = [false, true, false, true];\n        let verification =\n            Verifier::verify_multi_proof(\u0026proof, \u0026proof_flags, root, \u0026leaves);\n        assert!(verification.unwrap());\n    }\n\n    #[test]\n    fn rejects_invalid_multi_proof() {\n        // ```js\n        // const merkleTree = StandardMerkleTree.of(toElements('abcdef'), ['string']);\n        // const otherMerkleTree = StandardMerkleTree.of(toElements('ghi'), ['string']);\n        //\n        // const root = merkleTree.root;\n        // const { proof, proofFlags, leaves } = otherMerkleTree.getMultiProof(toElements('ghi'));\n        // const hashes = leaves.map(e =\u003e merkleTree.leafHash(e));\n        // ```\n        bytes! {\n            root = \"6deb52b5da8fd108f79fab00341f38d2587896634c646ee52e49f845680a70c8\";\n        };\n        let leaves = bytes_array! {\n            \"34e6ce3d0d73f6bff2ee1e865833d58e283570976d70b05f45c989ef651ef742\",\n            \"aa28358fb75b314c899e16d7975e029d18b4457fd8fd831f2e6c17ffd17a1d7e\",\n            \"e0fd7e6916ff95d933525adae392a17e247819ebecc2e63202dfec7005c60560\",\n        };\n        let proof = [];\n        let proof_flags = [true, true];\n\n        let verification =\n            Verifier::verify_multi_proof(\u0026proof, \u0026proof_flags, root, \u0026leaves);\n        assert!(!verification.unwrap());\n    }\n\n    #[test]\n    fn multi_proof_invalid_total_hashes_length() {\n        // ```js\n        // const merkleTree = StandardMerkleTree.of(toElements('abcd'), ['string']);\n        //\n        // const root = merkleTree.root;\n        // const hashA = merkleTree.leafHash(['a']);\n        // const hashB = merkleTree.leafHash(['b']);\n        // const hashCD = hashPair(\n        //   ethers.toBeArray(merkleTree.leafHash(['c'])),\n        //   ethers.toBeArray(merkleTree.leafHash(['d'])),\n        // );\n        // const hashE = merkleTree.leafHash(['e']); // incorrect (not part of the tree)\n        // const fill = ethers.randomBytes(32);\n        // ```\n        bytes! {\n            root    = \"8f7234e8cfe39c08ca84a3a3e3274f574af26fd15165fe29e09cbab742daccd9\";\n            hash_a  = \"9c15a6a0eaeed500fd9eed4cbeab71f797cefcc67bfd46683e4d2e6ff7f06d1c\";\n            hash_b  = \"19ba6c6333e0e9a15bf67523e0676e2f23eb8e574092552d5e888c64a4bb3681\";\n            hash_cd = \"03707d7802a71ca56a8ad8028da98c4f1dbec55b31b4a25d536b5309cc20eda9\";\n            hash_e  = \"9a4f64e953595df82d1b4f570d34c4f4f0cfaf729a61e9d60e83e579e1aa283e\";\n        };\n\n        let mut random_bytes = [0u8; 32];\n        rng().fill_bytes(\u0026mut random_bytes);\n\n        let fill = Bytes32::from(random_bytes);\n        let proof = [hash_b, fill, hash_cd];\n        let proof_flags = [false, false, false];\n        let leaves = [hash_a, hash_e];\n\n        let err =\n            Verifier::verify_multi_proof(\u0026proof, \u0026proof_flags, root, \u0026leaves)\n                .unwrap_err();\n        assert!(matches!(err, MultiProofError::InvalidTotalHashes));\n    }\n\n    #[test]\n    fn multi_proof_invalid_proof_length() {\n        // ```js\n        // const merkleTree = StandardMerkleTree.of(toElements('abcd'), ['string']);\n        //\n        // const root = merkleTree.root;\n        // const hashA = merkleTree.leafHash(['a']);\n        // const hashB = merkleTree.leafHash(['b']);\n        // const hashCD = hashPair(\n        //   ethers.toBeArray(merkleTree.leafHash(['c'])),\n        //   ethers.toBeArray(merkleTree.leafHash(['d'])),\n        // );\n        // const hashE = merkleTree.leafHash(['e']); // incorrect (not part of the tree)\n        // const fill = ethers.randomBytes(32);\n        // ```\n        bytes! {\n            root    = \"8f7234e8cfe39c08ca84a3a3e3274f574af26fd15165fe29e09cbab742daccd9\";\n            hash_a  = \"9c15a6a0eaeed500fd9eed4cbeab71f797cefcc67bfd46683e4d2e6ff7f06d1c\";\n            hash_b  = \"19ba6c6333e0e9a15bf67523e0676e2f23eb8e574092552d5e888c64a4bb3681\";\n            hash_cd = \"03707d7802a71ca56a8ad8028da98c4f1dbec55b31b4a25d536b5309cc20eda9\";\n            hash_e  = \"9a4f64e953595df82d1b4f570d34c4f4f0cfaf729a61e9d60e83e579e1aa283e\";\n        };\n\n        let mut random_bytes = [0u8; 32];\n        rng().fill_bytes(\u0026mut random_bytes);\n\n        let fill = Bytes32::from(random_bytes);\n        let proof = [hash_b, fill, hash_cd];\n        let proof_flags = [false, false, false, false];\n        let leaves = [hash_e, hash_a];\n\n        let err =\n            Verifier::verify_multi_proof(\u0026proof, \u0026proof_flags, root, \u0026leaves)\n                .unwrap_err();\n        assert!(matches!(err, MultiProofError::InvalidProofLength));\n    }\n\n    #[test]\n    fn verifies_empty_leaves_multi_proof() {\n        // ```js\n        // const merkleTree = StandardMerkleTree.of(toElements('abcd'), ['string']);\n        //\n        // const root = merkleTree.root;\n        // ```\n        bytes!(root = \"8f7234e8cfe39c08ca84a3a3e3274f574af26fd15165fe29e09cbab742daccd9\");\n        let proof = [root];\n        let proof_flags = [];\n        let leaves = [];\n\n        let verification =\n            Verifier::verify_multi_proof(\u0026proof, \u0026proof_flags, root, \u0026leaves);\n        assert!(verification.unwrap());\n    }\n\n    #[test]\n    /// Errors when processing manipulated proofs with a zero-value node at\n    /// depth 1.\n    fn errors_manipulated_multi_proof() {\n        // Create a merkle tree that contains a zero leaf at depth 1\n        //\n        // Taken from https://github.com/advisories/GHSA-wprv-93r4-jj2p\n        //\n        // ```js\n        // const { MerkleTree } = require('merkletreejs'); // v0.2.32\n        // const keccak256 = require('keccak256'); // v1.0.6\n        //\n        // const leaves = [keccak256('real leaf'), Buffer.alloc(32, 0)];\n        // const merkleTree = new MerkleTree(leaves, keccak256, { sortPairs: true });\n        // const root = merkleTree.getRoot();\n        // ```\n        bytes! {\n            root = \"f2d552e1e4c59d4f0fa2b80859febc9e4bdc915dff37c56c858550d8b64659a5\";\n            leaf = \"5e941ddd8f313c0b39f92562c0eca709c3d91360965d396aaef584b3fa76889a\"; // 'real leaf'\n        };\n        let malicious_leaves = bytes_array! {\n            \"1f23ad5fc0ee6ccbe2f3d30df856758f05ad9d03408a51a99c1c9f0854309db2\",\n            \"4e7e8301f5d206748d1c4f822e3564ddb1124f86591a839f58dfc2f007983b61\",\n            \"613994f4e324d0667c07857cd5d147994bc917da5d07ee63fc3f0a1fe8a18e34\",\n        };\n        let malicious_proof = [leaf, leaf];\n        let malicious_proof_flags = [true, true, false];\n\n        let verification = Verifier::verify_multi_proof(\n            \u0026malicious_proof,\n            \u0026malicious_proof_flags,\n            root,\n            \u0026malicious_leaves,\n        );\n        assert!(verification.is_err());\n    }\n\n    #[test]\n    fn verify_empty_proof_should_mean_leaf_equal_to_root() {\n        // ```js\n        // const merkleTree = StandardMerkleTree.of(toElements('abc'), ['string']);\n        //\n        // const root = merkleTree.root;\n        // const leaf = merkleTree.leafHash(['a']);\n        // const proof = merkleTree.getProof(['a']);\n        // ```\n        bytes! {\n            root = \"f2129b5a697531ef818f644564a6552b35c549722385bc52aa7fe46c0b5f46b1\";\n            leaf = \"9c15a6a0eaeed500fd9eed4cbeab71f797cefcc67bfd46683e4d2e6ff7f06d1c\";\n        };\n        let proof = [];\n\n        // valid if root == leaf\n        assert!(Verifier::verify(\u0026proof, root, root));\n\n        // invalid if root != leaf\n        assert!(!Verifier::verify(\u0026proof, root, leaf));\n    }\n}\n","traces":[{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","pedersen","instance","mod.rs"],"content":"//! This module contains Pedersen Hash instances for some popular curves.\npub mod starknet;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","pedersen","instance","starknet.rs"],"content":"//! This module contains the Pedersen Hash function (and curve) parameters for\n//! [Starknet instance].\n//!\n//! [Starknet instance]: \u003chttps://docs.starkware.co/starkex/crypto/pedersen-hash-function.html\u003e\n\nuse crate::{\n    arithmetic::uint::U256,\n    curve::{\n        sw::{Affine, SWCurveConfig},\n        CurveConfig,\n    },\n    field::fp::{Fp256, FpParams, LIMBS_256},\n    fp_from_num, from_hex, from_num,\n    pedersen::params::PedersenParams,\n};\n\n/// Starknet's Curve Details.\n#[derive(Clone, Default, PartialEq, Eq)]\npub struct StarknetCurveConfig;\n\n/// Base Field for [`StarknetCurveConfig`].\npub type Fq = Fp256\u003cFqParam\u003e;\n/// Base Field parameters for [`StarknetCurveConfig`].\npub struct FqParam;\n\nimpl FpParams\u003cLIMBS_256\u003e for FqParam {\n    // The multiplicative generator of Fp.\n    const GENERATOR: Fp256\u003cSelf\u003e = fp_from_num!(\"3\");\n    // Starknet's base field modulus.\n    const MODULUS: U256 = from_num!(\"3618502788666131213697322783095070105623107215331596699973092056135872020481\");\n}\n\n/// Scalar Field for [`StarknetCurveConfig`].\npub type Fr = Fp256\u003cFrParam\u003e;\n/// Scalar Field parameters for [`StarknetCurveConfig`].\npub struct FrParam;\n\nimpl FpParams\u003cLIMBS_256\u003e for FrParam {\n    // Primitive generator of the multiplicative group of the scalar field.\n    const GENERATOR: Fp256\u003cSelf\u003e = fp_from_num!(\"5\");\n    // The curve's group order (`EC_ORDER`).\n    const MODULUS: U256 = from_num!(\"3618502788666131213697322783095070105526743751716087489154079457884512865583\");\n}\n\nimpl CurveConfig for StarknetCurveConfig {\n    type BaseField = Fq;\n    type ScalarField = Fr;\n\n    const COFACTOR: \u0026'static [u64] = \u0026[0x1];\n    const COFACTOR_INV: Fr = Fr::ONE;\n}\n\n// https://docs.starkware.co/starkex/crypto/stark-curve.html\nconst G_GENERATOR_X: Fq = fp_from_num!(\"874739451078007766457464989774322083649278607533249481151382481072868806602\");\nconst G_GENERATOR_Y: Fq = fp_from_num!(\"152666792071518830868575557812948353041420400780739481342941381225525861407\");\n\nimpl SWCurveConfig for StarknetCurveConfig {\n    const COEFF_A: Fq = fp_from_num!(\"1\");\n    const COEFF_B: Fq = fp_from_num!(\"3141592653589793238462643383279502884197169399375105820974944592307816406665\");\n    const GENERATOR: Affine\u003cStarknetCurveConfig\u003e =\n        Affine::new_unchecked(G_GENERATOR_X, G_GENERATOR_Y);\n}\n#[derive(Clone, Default, PartialEq, Eq)]\n/// Pedersen Hash parameters for Starknet.\npub struct StarknetPedersenParams;\n\nimpl PedersenParams\u003cStarknetCurveConfig\u003e for StarknetPedersenParams {\n    /// Low part bits.\n    const LOW_PART_BITS: u32 = 248;\n    /// Low part mask. (2**248 - 1)\n    const LOW_PART_MASK: U256 = from_hex!(\n        \"00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n    );\n    const N_ELEMENT_BITS_HASH: usize = 252;\n    const P_0: Affine\u003cStarknetCurveConfig\u003e = Affine::new_unchecked(\n\t\t\tfp_from_num!(\"2089986280348253421170679821480865132823066470938446095505822317253594081284\"),\n\t\t\tfp_from_num!(\"1713931329540660377023406109199410414810705867260802078187082345529207694986\")\n\t\t);\n    const P_1: Affine\u003cStarknetCurveConfig\u003e =\n\t\tAffine::new_unchecked(\n            fp_from_num!(\"996781205833008774514500082376783249102396023663454813447423147977397232763\"),\n            fp_from_num!(\"1668503676786377725805489344771023921079126552019160156920634619255970485781\")\n        );\n    const P_2: Affine\u003cStarknetCurveConfig\u003e =\n        Affine::new_unchecked(\n            fp_from_num!(\"2251563274489750535117886426533222435294046428347329203627021249169616184184\"),\n            fp_from_num!(\"1798716007562728905295480679789526322175868328062420237419143593021674992973\")\n        );\n    const P_3: Affine\u003cStarknetCurveConfig\u003e =\n\t\tAffine::new_unchecked(\n            fp_from_num!(\"2138414695194151160943305727036575959195309218611738193261179310511854807447\"),\n            fp_from_num!(\"113410276730064486255102093846540133784865286929052426931474106396135072156\")\n        );\n    const P_4:  Affine\u003cStarknetCurveConfig\u003e =\n\t\tAffine::new_unchecked(\n            fp_from_num!(\"2379962749567351885752724891227938183011949129833673362440656643086021394946\"),\n            fp_from_num!(\"776496453633298175483985398648758586525933812536653089401905292063708816422\")\n        );\n}\n\n#[cfg(test)]\nmod tests {\n    use proptest::proptest;\n\n    use super::*;\n    use crate::{\n        arithmetic::BigInteger,\n        fp_from_hex,\n        pedersen::{\n            instance::starknet::{\n                Fq, StarknetCurveConfig, StarknetPedersenParams,\n            },\n            Pedersen,\n        },\n    };\n\n    #[test]\n    fn correct_bits_hash_length() {\n        assert_eq!(StarknetPedersenParams::N_ELEMENT_BITS_HASH, 252);\n    }\n\n    #[test]\n    fn correct_shift_point() {\n        assert_eq!(StarknetPedersenParams::P_0, Affine::new_unchecked(\n            fp_from_num!(\"2089986280348253421170679821480865132823066470938446095505822317253594081284\"),\n            fp_from_num!(\"1713931329540660377023406109199410414810705867260802078187082345529207694986\")\n        ));\n    }\n\n    #[derive(Debug)]\n    struct StarknetTestCase {\n        x: Fq,\n        y: Fq,\n        expected: Option\u003cFq\u003e,\n    }\n\n    #[test]\n    fn smoke() {\n        // Based on \u003chttps://github.com/starkware-libs/starkware-crypto-utils/blob/master/test/config/signature_test_data.json\u003e.\n        let test_cases = vec![\n                StarknetTestCase {\n                    x: fp_from_hex!(\"3d937c035c878245caf64531a5756109c53068da139362728feb561405371cb\"),\n                    y: fp_from_hex!(\"208a0a10250e382e1e4bbe2880906c2791bf6275695e02fbbc6aeff9cd8b31a\"),\n                    expected: Some(fp_from_hex!(\"30e480bed5fe53fa909cc0f8c4d99b8f9f2c016be4c41e13a4848797979c662\"))\n                },\n                StarknetTestCase {\n                    x: fp_from_hex!(\"58f580910a6ca59b28927c08fe6c43e2e303ca384badc365795fc645d479d45\"),\n                    y: fp_from_hex!(\"78734f65a067be9bdb39de18434d71e79f7b6466a4b66bbd979ab9e7515fe0b\"),\n                    expected: Some(fp_from_hex!(\"68cc0b76cddd1dd4ed2301ada9b7c872b23875d5ff837b3a87993e0d9996b87\")),\n                },\n            ];\n        for test_case in test_cases {\n            let pedersen =\n                Pedersen::\u003cStarknetPedersenParams, StarknetCurveConfig\u003e::new();\n\n            assert_eq!(\n                pedersen.hash(test_case.x, test_case.y),\n                test_case.expected,\n                \"Failed for input x: {:?}, y: {:?}\",\n                test_case.x,\n                test_case.y\n            );\n        }\n    }\n\n    fn from_u256(elem: \u0026alloy_primitives::U256) -\u003e U256 {\n        U256::from_bytes_le(\u0026elem.to_le_bytes_vec())\n    }\n\n    #[test]\n    fn hash() {\n        // Check no panics.\n        proptest!(|(input1: alloy_primitives::U256, input2: alloy_primitives::U256)| {\n            let pedersen =\n                Pedersen::\u003cStarknetPedersenParams, StarknetCurveConfig\u003e::new();\n            let hash = pedersen.hash(from_u256(\u0026input1).into(), from_u256(\u0026input2).into());\n            assert!(hash.is_some());\n        });\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","pedersen","mod.rs"],"content":"//! This module contains Pedersen Hash Function implementation.\n///\n/// Based on the [Starknet] implementation of the Pedersen Hash Function.\n///\n/// [Starknet]: \u003chttps://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/crypto/signature/fast_pedersen_hash.py\u003e\npub mod instance;\npub mod params;\n\nuse crate::{\n    curve::{\n        sw::{Affine, Projective, SWCurveConfig},\n        AffineRepr, CurveConfig, PrimeGroup,\n    },\n    field::prime::PrimeField,\n    pedersen::params::PedersenParams,\n};\n\n/// Pedersen hash.\n#[derive(Clone, Debug)]\npub struct Pedersen\u003cF: PedersenParams\u003cP\u003e, P: SWCurveConfig\u003e\nwhere\n    \u003cP as CurveConfig\u003e::BaseField: PrimeField,\n{\n    params: core::marker::PhantomData\u003cF\u003e,\n    curve: core::marker::PhantomData\u003cP\u003e,\n}\n\nimpl\u003cF: PedersenParams\u003cP\u003e, P: SWCurveConfig\u003e Default for Pedersen\u003cF, P\u003e\nwhere\n    \u003cP as CurveConfig\u003e::BaseField: PrimeField,\n{\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cF: PedersenParams\u003cP\u003e, P: SWCurveConfig\u003e Pedersen\u003cF, P\u003e\nwhere\n    \u003cP as CurveConfig\u003e::BaseField: PrimeField,\n{\n    #[must_use]\n    #[inline]\n    /// Creates a new Pedersen hash instance.\n    pub fn new() -\u003e Self {\n        Self {\n            params: core::marker::PhantomData,\n            curve: core::marker::PhantomData,\n        }\n    }\n\n    fn process_single_element(\n        element: P::BaseField,\n        p1: Projective\u003cP\u003e,\n        p2: Projective\u003cP\u003e,\n    ) -\u003e Projective\u003cP\u003e {\n        let element = element.into_bigint();\n\n        let high_nibble = element \u003e\u003e F::LOW_PART_BITS;\n        let low_part = element \u0026 F::LOW_PART_MASK;\n\n        p1.mul_bigint(low_part) + p2.mul_bigint(high_nibble)\n    }\n\n    /// Computes the Starkware version of the Pedersen hash of x and y.\n    ///\n    /// The hash is defined by:\n    /// [`PedersenParams::P_0`] + `x_low` * [`PedersenParams::P_1`] +\n    /// `x_high` * [`PedersenParams::P_2`] + `y_low` * [`PedersenParams::P_3`] +\n    /// `y_high` * [`PedersenParams::P_4`]\n    ///\n    /// where `x_low` is the 248 low bits of `x`, `x_high` is the 4 high bits of\n    /// `x` and similarly for `y`. [`PedersenParams::P_0`],\n    /// [`PedersenParams::P_1`], [`PedersenParams::P_2`],\n    /// [`PedersenParams::P_3`], [`PedersenParams::P_4`] are constant points\n    /// generated from the digits of pi.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - Pedersen hasher instance.\n    /// * `x` - The x coordinate of the point to hash.\n    /// * `y` - The y coordinate of the point to hash.\n    #[must_use]\n    pub fn hash(\n        \u0026self,\n        x: P::BaseField,\n        y: P::BaseField,\n    ) -\u003e Option\u003cP::BaseField\u003e {\n        let hash: Projective\u003cP\u003e = F::P_0\n            + Self::process_single_element(x, F::P_1.into(), F::P_2.into())\n            + Self::process_single_element(y, F::P_3.into(), F::P_4.into());\n\n        let hash: Affine\u003cP\u003e = hash.into();\n        hash.x()\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","pedersen","params.rs"],"content":"//! Pedersen hash parameters.\n\nuse crate::{\n    curve::{\n        sw::{Affine, SWCurveConfig},\n        CurveConfig,\n    },\n    field::prime::PrimeField,\n};\n\n/// Pedersen hash parameters.\npub trait PedersenParams\u003cP: SWCurveConfig\u003e\nwhere\n    \u003cP as CurveConfig\u003e::BaseField: PrimeField,\n{\n    /// Number of elements in the hash.\n    const N_ELEMENT_BITS_HASH: usize;\n\n    /// Shift point.\n    const P_0: Affine\u003cP\u003e;\n\n    /// Constant point -- `P_1`.\n    const P_1: Affine\u003cP\u003e;\n    /// Constant point -- `P_2`.\n    const P_2: Affine\u003cP\u003e;\n    /// Constant point -- `P_3`.\n    const P_3: Affine\u003cP\u003e;\n    /// Constant point -- `P_4`.\n    const P_4: Affine\u003cP\u003e;\n\n    /// Low bits of a value to hash.\n    const LOW_PART_BITS: u32;\n    /// Low part mask for a value to hash.\n    const LOW_PART_MASK: \u003cP::BaseField as PrimeField\u003e::BigInt;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","poseidon2","instance","babybear.rs"],"content":"//! This module contains the poseidon sponge hash function parameters for\n//! [`FpBabyBear`] field instance.\n\nuse crate::{\n    field::instance::FpBabyBear, fp_from_hex, poseidon2::params::PoseidonParams,\n};\n\n/// Poseidon sponge hash function parameters for [`FpBabyBear`] field instance.\npub struct BabyBear24Params;\n\n#[rustfmt::skip]\nimpl PoseidonParams\u003cFpBabyBear\u003e for BabyBear24Params {\n    const T: usize = 24;\n    const D: u8 = 7;\n    // Capacity 4 will give `4*64 = 256` bits security.\n    const CAPACITY: usize = 4;\n    const ROUNDS_F: usize = 8;\n    const ROUNDS_P: usize = 21;\n    const MAT_INTERNAL_DIAG_M_1: \u0026'static [FpBabyBear] = \u0026[\n        fp_from_hex!(\"409133f0\"),\n        fp_from_hex!(\"1667a8a1\"),\n        fp_from_hex!(\"06a6c7b6\"),\n        fp_from_hex!(\"6f53160e\"),\n        fp_from_hex!(\"273b11d1\"),\n        fp_from_hex!(\"03176c5d\"),\n        fp_from_hex!(\"72f9bbf9\"),\n        fp_from_hex!(\"73ceba91\"),\n        fp_from_hex!(\"5cdef81d\"),\n        fp_from_hex!(\"01393285\"),\n        fp_from_hex!(\"46daee06\"),\n        fp_from_hex!(\"065d7ba6\"),\n        fp_from_hex!(\"52d72d6f\"),\n        fp_from_hex!(\"05dd05e0\"),\n        fp_from_hex!(\"3bab4b63\"),\n        fp_from_hex!(\"6ada3842\"),\n        fp_from_hex!(\"2fc5fbec\"),\n        fp_from_hex!(\"770d61b0\"),\n        fp_from_hex!(\"5715aae9\"),\n        fp_from_hex!(\"03ef0e90\"),\n        fp_from_hex!(\"75b6c770\"),\n        fp_from_hex!(\"242adf5f\"),\n        fp_from_hex!(\"00d0ca4c\"),\n        fp_from_hex!(\"36c0e388\"),\n    ];\n    const ROUND_CONSTANTS: \u0026'static [\u0026'static [FpBabyBear]] = \u0026[\n        \u0026[\n            fp_from_hex!(\"0fa20c37\"),\n            fp_from_hex!(\"0795bb97\"),\n            fp_from_hex!(\"12c60b9c\"),\n            fp_from_hex!(\"0eabd88e\"),\n            fp_from_hex!(\"096485ca\"),\n            fp_from_hex!(\"07093527\"),\n            fp_from_hex!(\"1b1d4e50\"),\n            fp_from_hex!(\"30a01ace\"),\n            fp_from_hex!(\"3bd86f5a\"),\n            fp_from_hex!(\"69af7c28\"),\n            fp_from_hex!(\"3f94775f\"),\n            fp_from_hex!(\"731560e8\"),\n            fp_from_hex!(\"465a0ecd\"),\n            fp_from_hex!(\"574ef807\"),\n            fp_from_hex!(\"62fd4870\"),\n            fp_from_hex!(\"52ccfe44\"),\n            fp_from_hex!(\"14772b14\"),\n            fp_from_hex!(\"4dedf371\"),\n            fp_from_hex!(\"260acd7c\"),\n            fp_from_hex!(\"1f51dc58\"),\n            fp_from_hex!(\"75125532\"),\n            fp_from_hex!(\"686a4d7b\"),\n            fp_from_hex!(\"54bac179\"),\n            fp_from_hex!(\"31947706\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"29799d3b\"),\n            fp_from_hex!(\"6e01ae90\"),\n            fp_from_hex!(\"203a7a64\"),\n            fp_from_hex!(\"4f7e25be\"),\n            fp_from_hex!(\"72503f77\"),\n            fp_from_hex!(\"45bd3b69\"),\n            fp_from_hex!(\"769bd6b4\"),\n            fp_from_hex!(\"5a867f08\"),\n            fp_from_hex!(\"4fdba082\"),\n            fp_from_hex!(\"251c4318\"),\n            fp_from_hex!(\"28f06201\"),\n            fp_from_hex!(\"6788c43a\"),\n            fp_from_hex!(\"4c6d6a99\"),\n            fp_from_hex!(\"357784a8\"),\n            fp_from_hex!(\"2abaf051\"),\n            fp_from_hex!(\"770f7de6\"),\n            fp_from_hex!(\"1794b784\"),\n            fp_from_hex!(\"4796c57a\"),\n            fp_from_hex!(\"724b7a10\"),\n            fp_from_hex!(\"449989a7\"),\n            fp_from_hex!(\"64935cf1\"),\n            fp_from_hex!(\"59e14aac\"),\n            fp_from_hex!(\"0e620bb8\"),\n            fp_from_hex!(\"3af5a33b\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4465cc0e\"),\n            fp_from_hex!(\"019df68f\"),\n            fp_from_hex!(\"4af8d068\"),\n            fp_from_hex!(\"08784f82\"),\n            fp_from_hex!(\"0cefdeae\"),\n            fp_from_hex!(\"6337a467\"),\n            fp_from_hex!(\"32fa7a16\"),\n            fp_from_hex!(\"486f62d6\"),\n            fp_from_hex!(\"386a7480\"),\n            fp_from_hex!(\"20f17c4a\"),\n            fp_from_hex!(\"54e50da8\"),\n            fp_from_hex!(\"2012cf03\"),\n            fp_from_hex!(\"5fe52950\"),\n            fp_from_hex!(\"09afb6cd\"),\n            fp_from_hex!(\"2523044e\"),\n            fp_from_hex!(\"5c54d0ef\"),\n            fp_from_hex!(\"71c01f3c\"),\n            fp_from_hex!(\"60b2c4fb\"),\n            fp_from_hex!(\"4050b379\"),\n            fp_from_hex!(\"5e6a70a5\"),\n            fp_from_hex!(\"418543f5\"),\n            fp_from_hex!(\"71debe56\"),\n            fp_from_hex!(\"1aad2994\"),\n            fp_from_hex!(\"3368a483\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"07a86f3a\"),\n            fp_from_hex!(\"5ea43ff1\"),\n            fp_from_hex!(\"2443780e\"),\n            fp_from_hex!(\"4ce444f7\"),\n            fp_from_hex!(\"146f9882\"),\n            fp_from_hex!(\"3132b089\"),\n            fp_from_hex!(\"197ea856\"),\n            fp_from_hex!(\"667030c3\"),\n            fp_from_hex!(\"2317d5dc\"),\n            fp_from_hex!(\"0c2c48a7\"),\n            fp_from_hex!(\"56b2df66\"),\n            fp_from_hex!(\"67bd81e9\"),\n            fp_from_hex!(\"4fcdfb19\"),\n            fp_from_hex!(\"4baaef32\"),\n            fp_from_hex!(\"0328d30a\"),\n            fp_from_hex!(\"6235760d\"),\n            fp_from_hex!(\"12432912\"),\n            fp_from_hex!(\"0a49e258\"),\n            fp_from_hex!(\"030e1b70\"),\n            fp_from_hex!(\"48caeb03\"),\n            fp_from_hex!(\"49e4d9e9\"),\n            fp_from_hex!(\"1051b5c6\"),\n            fp_from_hex!(\"6a36dbbe\"),\n            fp_from_hex!(\"4cff27a5\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1da78ec2\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"730b0924\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3eb56cf3\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5bd93073\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"37204c97\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"51642d89\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"66e943e8\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1a3e72de\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"70beb1e9\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"30ff3b3f\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4240d1c4\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"12647b8d\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"65d86965\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"49ef4d7c\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"47785697\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"46b3969f\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5c7b7a0e\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"7078fc60\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4f22d482\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"482a9aee\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6beb839d\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n            fp_from_hex!(\"00000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"032959ad\"),\n            fp_from_hex!(\"2b18af6a\"),\n            fp_from_hex!(\"55d3dc8c\"),\n            fp_from_hex!(\"43bd26c8\"),\n            fp_from_hex!(\"0c41595f\"),\n            fp_from_hex!(\"7048d2e2\"),\n            fp_from_hex!(\"00db8983\"),\n            fp_from_hex!(\"2af563d7\"),\n            fp_from_hex!(\"6e84758f\"),\n            fp_from_hex!(\"611d64e1\"),\n            fp_from_hex!(\"1f9977e2\"),\n            fp_from_hex!(\"64163a0a\"),\n            fp_from_hex!(\"5c5fc27b\"),\n            fp_from_hex!(\"02e22561\"),\n            fp_from_hex!(\"3a2d75db\"),\n            fp_from_hex!(\"1ba7b71a\"),\n            fp_from_hex!(\"34343f64\"),\n            fp_from_hex!(\"7406b35d\"),\n            fp_from_hex!(\"19df8299\"),\n            fp_from_hex!(\"6ff4480a\"),\n            fp_from_hex!(\"514a81c8\"),\n            fp_from_hex!(\"57ab52ce\"),\n            fp_from_hex!(\"6ad69f52\"),\n            fp_from_hex!(\"3e0c0e0d\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"48126114\"),\n            fp_from_hex!(\"2a9d62cc\"),\n            fp_from_hex!(\"17441f23\"),\n            fp_from_hex!(\"485762bb\"),\n            fp_from_hex!(\"2f218674\"),\n            fp_from_hex!(\"06fdc64a\"),\n            fp_from_hex!(\"0861b7f2\"),\n            fp_from_hex!(\"3b36eee6\"),\n            fp_from_hex!(\"70a11040\"),\n            fp_from_hex!(\"04b31737\"),\n            fp_from_hex!(\"3722a872\"),\n            fp_from_hex!(\"2a351c63\"),\n            fp_from_hex!(\"623560dc\"),\n            fp_from_hex!(\"62584ab2\"),\n            fp_from_hex!(\"382c7c04\"),\n            fp_from_hex!(\"3bf9edc7\"),\n            fp_from_hex!(\"0e38fe51\"),\n            fp_from_hex!(\"376f3b10\"),\n            fp_from_hex!(\"5381e178\"),\n            fp_from_hex!(\"3afc61c7\"),\n            fp_from_hex!(\"5c1bcb4d\"),\n            fp_from_hex!(\"6643ce1f\"),\n            fp_from_hex!(\"2d0af1c1\"),\n            fp_from_hex!(\"08f583cc\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5d6ff60f\"),\n            fp_from_hex!(\"6324c1e5\"),\n            fp_from_hex!(\"74412fb7\"),\n            fp_from_hex!(\"70c0192e\"),\n            fp_from_hex!(\"0b72f141\"),\n            fp_from_hex!(\"4067a111\"),\n            fp_from_hex!(\"57388c4f\"),\n            fp_from_hex!(\"351009ec\"),\n            fp_from_hex!(\"0974c159\"),\n            fp_from_hex!(\"539a58b3\"),\n            fp_from_hex!(\"038c0cff\"),\n            fp_from_hex!(\"476c0392\"),\n            fp_from_hex!(\"3f7bc15f\"),\n            fp_from_hex!(\"4491dd2c\"),\n            fp_from_hex!(\"4d1fef55\"),\n            fp_from_hex!(\"04936ae3\"),\n            fp_from_hex!(\"58214dd4\"),\n            fp_from_hex!(\"683c6aad\"),\n            fp_from_hex!(\"1b42f16b\"),\n            fp_from_hex!(\"6dc79135\"),\n            fp_from_hex!(\"2d4e71ec\"),\n            fp_from_hex!(\"3e2946ea\"),\n            fp_from_hex!(\"59dce8db\"),\n            fp_from_hex!(\"6cee892a\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"47f07350\"),\n            fp_from_hex!(\"7106ce93\"),\n            fp_from_hex!(\"3bd4a7a9\"),\n            fp_from_hex!(\"2bfe636a\"),\n            fp_from_hex!(\"430011e9\"),\n            fp_from_hex!(\"001cd66a\"),\n            fp_from_hex!(\"307faf5b\"),\n            fp_from_hex!(\"0d9ef3fe\"),\n            fp_from_hex!(\"6d40043a\"),\n            fp_from_hex!(\"2e8f470c\"),\n            fp_from_hex!(\"1b6865e8\"),\n            fp_from_hex!(\"0c0e6c01\"),\n            fp_from_hex!(\"4d41981f\"),\n            fp_from_hex!(\"423b9d3d\"),\n            fp_from_hex!(\"410408cc\"),\n            fp_from_hex!(\"263f0884\"),\n            fp_from_hex!(\"5311bbd0\"),\n            fp_from_hex!(\"4dae58d8\"),\n            fp_from_hex!(\"30401cea\"),\n            fp_from_hex!(\"09afa575\"),\n            fp_from_hex!(\"4b3d5b42\"),\n            fp_from_hex!(\"63ac0b37\"),\n            fp_from_hex!(\"5fe5bb14\"),\n            fp_from_hex!(\"5244e9d4\"),\n        ],\n    ];\n}\n\n#[allow(unused_imports)]\n#[cfg(test)]\nmod tests {\n    use crate::{\n        field::instance::FpBabyBear,\n        fp_from_hex,\n        poseidon2::{instance::babybear::BabyBear24Params, *},\n    };\n\n    type Scalar = FpBabyBear;\n\n    #[test]\n    fn smoke() {\n        let mut poseidon2 = Poseidon2::\u003cBabyBear24Params, _\u003e::new();\n        for i in 1..BabyBear24Params::T {\n            poseidon2.absorb(\u0026Scalar::from(i as u64));\n        }\n        let mut perm = poseidon2\n            .squeeze_batch(BabyBear24Params::T - BabyBear24Params::CAPACITY)\n            .into_iter();\n\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"5F5A91BB\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"1AB970BC\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"641C2977\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"70EE1E1F\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"5002978A\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"309B742F\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"09C59B3E\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"6B554AC2\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"450C070E\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"07EAEA75\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"358E2514\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"387D082C\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"4869C4E2\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"66E56CAE\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"349EAB1A\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"58A416EC\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"5EB14F6A\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"28BD8371\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"56B19FBE\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"01DD53EF\"));\n        assert!(perm.next().is_none());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","poseidon2","instance","bls12.rs"],"content":"//! This module contains the poseidon sponge hash function parameters for\n//! [`FpBLS12`] field instance.\n\nuse crate::{\n    field::instance::FpBLS12, fp_from_hex, poseidon2::params::PoseidonParams,\n};\n\n/// Poseidon sponge hash function parameters for [`FpBLS12`] field instance with\n/// state size of `2`.\npub struct BLS2Params;\n\n#[rustfmt::skip]\nimpl PoseidonParams\u003cFpBLS12\u003e for BLS2Params {\n    const T: usize = 2;\n    const D: u8 = 5;\n    const CAPACITY: usize = 1;\n    const ROUNDS_F: usize = 8;\n    const ROUNDS_P: usize = 56;\n    const MAT_INTERNAL_DIAG_M_1: \u0026'static [FpBLS12] = \u0026[\n        fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000001\"),\n        fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000002\"),\n    ];\n    const ROUND_CONSTANTS: \u0026'static [\u0026'static [FpBLS12]] = \u0026[\n        \u0026[\n            fp_from_hex!(\"6267f5556c88257324c1c8b00d5871b2eba13cc39d72aa10dde6b69bc44c41c7\"),\n            fp_from_hex!(\"30347723511438a085118166c68bf0c4f4ab5c10a2c55adb5cf87cc9e030f60f\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"10db856965e40038eb6427303181e7b7439f1a051aa4630c26cf86d0a0451a4b\"),\n            fp_from_hex!(\"5a3d2dcd541e4faaae7eb143eec847a0f652b6dc1b92e3f39ec23c808b3a5d63\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3b07f0ff7edcf93b1dd0487bc9fab1c6905f9ceee38dcce83efeb3a320398526\"),\n            fp_from_hex!(\"40c73c524b9fd0fab63128175befe07b5c63ccdde9ca10e1a37205c9607fdf8a\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3a933861cf23752376d94dbb24b0f3c61630787928875c07672b68abfb9191e0\"),\n            fp_from_hex!(\"71cc165e208570b2d5ef81db84e3c5e714ea4edfb36fc7fb11ef65a64b2d9755\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6c0dc9eb332b5d968bec8ad68fe24ce34087ea54093f153618434475bce402f8\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0af5bafd335dae5c86967b11d5dcefb986a54c9d60d35eb06dc7a3fd779b3906\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6e12847918f030f2626c150ab69e4be0f13d202ae1f8bc87ea74323e93372e3b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5565d40e21d059a26db241ca125d9316283eadf144b1318e604e253eeae1fe9a\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"608e01b42d3dca09fed9b54eadaaba3e4ce6aefe92b0dc954a0fa4683a9678f2\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"16bbe434b24f94e2c40ed1f4f9bd7d17e5be96c3aec15579b35fd80f0f80de9e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0d1be811a8e73220cab01ce981d475522c3d7dd9e2716c3a2cf4ddd541546890\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5997a3affb18f942868b86f8ee10a68966e90bac7bbd8c65ede7e6e5ef1f6320\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4d92e86d270041061eec80278079fca771499dea5ccdc99682a953bb3a038b8e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"616c8c5ce232b9314f694fc6a968446ea9daf7a4079ce1a75fcc950741d680bb\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"677e31e7846d9131bdc350eaf11a8ff918dd258ddd800444424afab34dfdfe3d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4e7d7f85aefc110b233525ee3e53851aee7d3241e2a132585e0e25005eee0b0e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"06a8b4539488b7dddc48c3a226dbda313f906e106f844196d55013d321244f13\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5091517b6a85783108999f8e6bda3c793bef3f2e9589641d260bdfde8bdef00d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0d2703e5b30f54d7f414e901802d54f8c14cd6355415df6e0f063d16bef9c43a\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"56f69096811148eb38eec143d32565c077b3d1a4a4351f2b458f43b1659d4495\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"622d94d38d1ded428afd062008c5709b43a678f6ba518ec56383e8ffba473504\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2730c607bba7333723a4a44577819b7db82a24574f6d13eee4c856c1ca3de9c7\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"01ac5f59256c5004dc1043c53b23800a3fbab53eb1a83f551056f227b514b9f6\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0790b92523c973f1c95b94937afbb5796d89481e7a56328b44bab5ba81ae42f3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1d63b59d97bc269d13964fb3e8771d0acc749bc83eb2f0372484e266142bb8c0\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1a52d04e5f14a3a05f7a01262df9e68c77fdf7e2bfb56c8b252d2140efdf0914\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5aa9b3b808812b284857e8622843a8717fa5cb49b217017f31d79e8d0f963fc0\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6a3d18fdbeb1d77ec1304539b00e6188786dbbc4435269b4c6281367f42656e3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4743e860df269a85dd76fb99dbe9d840eb669dc859754b3f74805e57ba288b00\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6c32cac3946825f80a434c5ab397fc1a1c6a9bdfaab53175d4cf3d29ddb6cbc6\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"333b0eea5da7ed1e3959d16280a361aa77dd24ecbfb28e1b2583ac4e9894305c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3b503fc333b795ccc0c5bb3ae26b077dc3742cb745ec8821648c5ce7ebd9df18\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4fa5853188d9f728a17532d94bee6fb28fee510380a5d50927c6c5b1ce283444\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5d2ed8a6603a905bac490ebfb9e6c18f0bc9da1bbc2173291b18de6b6186118f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2d830a53584c5556264852f075c78f7f9eb068016ae88af9cda933d6ae52eca7\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0250f4d6780ad29ae60e55f135b9ac80ccc7c81e3add37db276c26f1a2b1b86e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6e3e9595f59220599e23e830728d4a0c4d62515ec1ed10b72446cf4df5b4c308\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2cd3314555d6faf23ee90cdb884f1c4697ebe98e3a450a624c4d896233b93cd5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"584a408d0f370543b8413fee70a060a394e561f504d8679f7bece4bf222e4108\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"499cd53437b9fcbf7479c00fcc21295759074ce9bd1bb1fbd3460237aef4759e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"56a9b567bd0646effd0608d74d537991136098d9a06af6cb3ff8f010efb57578\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6a5fae2b00d968b931441b374e27ba4d03b306bd602d48731677169e75a67e8c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2e1cc28e390e64aa1d60edb99c0aeda7c8c32bdb01ba11abbad5026b46eccb27\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2d4820000675df7c276beac408fe2e851e734a7008ae09bbcb3c96c70024f71b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0c2fe101a2b52b538b902c6b2dc992cb266f7636e05b0c068385b5fa19e97142\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"209b790b78c0e7927c6a178ef2f00b8687fc7bd4f21a9e02578551535002bc95\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2dd0926cf56bbaaec6491513d08a9983f94a910852a7b4ea4bd4222b93e14c10\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4316b39dd7d65b1bb575198104d409b169236a7ade371f7ab176fcbae75a5f0d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"540276d61041b91f6ea3068ec260a9338b6e3da15d934e648c24f35aee04e535\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"37af612900b839977b146324c84772c58a4ccc0f6494cc054571827e74bfd2d3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2af00c93d59ed14c9911e5cb3781d772371e83228e4267bbce11d065c1955338\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"62b48779b0cf7ff2c10fd9b91a6ff7b7a99f935e961a5a94aa38f9d4f71c8b4c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"540bf5bbe01f28563bcbe11a2ce346d8231a2cdd0fe07641f9fa89e5c21978e3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"232b6c847a6d23912cb10ecbe50b53491f67f71e9b87a4a30446f2218017874b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0ab34adbe77b8f1e57a370e4fd626071eea74b3f0b66644a629efaa0e96456c0\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1a83e43ef118c90046b1bdbeab8dd5cdcab632807c2cd0dc9147cbc5b7084be8\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1ec6fa41b41b672d9005468720918130b642567462a3d557a595d4dc6c56f2f9\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"01f81a153199a751a111b8f5212cfc5bf82aacf0287d03e1864f8e5713fe4a17\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2617307587a675f4ecd73a54a7b206162d751cabf3d9fd007bcca4de2c6f0649\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1647be94c515178c7974a245624b642bb1ae6e2d4e1682087e362d7f98bc953f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6e690b956e00b9e339dec49d675586f661f9b081ee3fa7696d73977658aa6fea\"),\n            fp_from_hex!(\"660b85bc22de06d476c47bf084ad436f59874f1d630c0f5c91fbef51d5e738c5\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"32bf3d451b69dde075fc370eaa8c1b77b5c0bc2aab1c7b46da7ef9d1840b0419\"),\n            fp_from_hex!(\"73924b40beaa9c1ce4074c2154d1af4d658c09395a568b99b2fbcc3b5685e810\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"17cbb3ee0adcb9d977e96e9152b36042925244fdd0aa184c7a89a58a2dc40097\"),\n            fp_from_hex!(\"29d76a821e3220775c552f6b5977ab94956e52b8dac36ef88ace050d553766a3\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"62b1a6c06ab26881a1fe57eceac56b5aec0b96da7211557f4e27ec24296d7db6\"),\n            fp_from_hex!(\"0dfc474151e5c605a693a51ae8227cc0a99fdc4524fc2810c6eda9035d04334d\"),\n        ],\n    ];\n}\n\n/// Poseidon sponge hash function parameters for [`FpBLS12`] field instance with\n// /// state size of `3`.\npub struct BLS3Params;\n#[rustfmt::skip]\nimpl PoseidonParams\u003cFpBLS12\u003e for BLS3Params {\n    const T: usize = 3;\n    const D: u8 = 5;\n    const CAPACITY: usize = 1;\n    const ROUNDS_F: usize = 8;\n    const ROUNDS_P: usize = 56;\n    const MAT_INTERNAL_DIAG_M_1: \u0026'static [FpBLS12] = \u0026[\n        fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000001\"),\n        fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000001\"),\n        fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000002\"),\n    ];\n    const ROUND_CONSTANTS: \u0026'static [\u0026'static [FpBLS12]] = \u0026[\n        \u0026[\n            fp_from_hex!(\"6f007a551156b3a449e44936b7c093644a0ed33f33eaccc628e942e836c1a875\"),\n            fp_from_hex!(\"360d7470611e473d353f628f76d110f34e71162f31003b7057538c2596426303\"),\n            fp_from_hex!(\"4b5fec3aa073df44019091f007a44ca996484965f7036dce3e9d0977edcdc0f6\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"67cf1868af6396c0b84cce715e539f849e06cd1c383ac5b06100c76bcc973a11\"),\n            fp_from_hex!(\"555db4d1dced819f5d3de70fde83f1c7d3e8c98968e516a23a771a5c9c8257aa\"),\n            fp_from_hex!(\"2bab94d7ae222d135dc3c6c5febfaa314908ac2f12ebe06fbdb74213bf63188b\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"66f44be5296682c4fa7882799d6dd049b6d7d2c950ccf98cf2e50d6d1ebb77c2\"),\n            fp_from_hex!(\"150c93fef652fb1c2bf03e1a29aa871fef77e7d736766c5d0939d92753cc5dc8\"),\n            fp_from_hex!(\"3270661e68928b3a955d55db56dc57c103cc0a60141e894e14259dce537782b2\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"073f116f04122e25a0b7afe4e2057299b407c370f2b5a1ccce9fb9ffc345afb3\"),\n            fp_from_hex!(\"409fda22558cfe4d3dd8dce24f69e76f8c2aaeb1dd0f09d65e654c71f32aa23f\"),\n            fp_from_hex!(\"2a32ec5c4ee5b1837affd09c1f53f5fd55c9cd2061ae93ca8ebad76fc71554d8\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5848ebeb5923e92555b7124fffba5d6bd571c6f984195eb9cfd3a3e8eb55b1d4\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"270326ee039df19e651e2cfc740628ca634d24fc6e2559f22d8ccbe292efeead\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"27c6642ac633bc66dc100fe7fcfa54918af895bce012f182a068fc37c182e274\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1bdfd8b01401c70ad27f57396989129d710e1fb6ab976a459ca18682e26d7ff9\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"491b9ba6983bcf9f05fe4794adb44a30879bf8289662e1f57d90f672414e8a4a\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"162a14c62f9a89b814b9d6a9c84dd678f4f6fb3f9054d373c832d824261a35ea\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2d193e0f76de586b2af6f79e3127feeaac0a1fc71e2cf0c0f79824667b5b6bec\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"46efd8a9a262d6d8fdc9ca5c04b0982f24ddcc6e9863885a6a732a3906a07b95\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"509717e0c200e3c92d8dca2973b3db45f0788294351ad07ae75cbb780693a798\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"7299b28464a8c94fb9d4df61380f39c0dca9c2c014118789e227252820f01bfc\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"044ca3cc4a85d73b81696ef1104e674f4feff82984990ff85d0bf58dc8a4aa94\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1cbaf2b371dac6a81d0453416d3e235cb8d9e2d4f314f46f6198785f0cd6b9af\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1d5b2777692c205b0e6c49d061b6b5f4293c4ab038fdbbdc343e07610f3fede5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"56ae7c7a5293bdc23e85e1698c81c77f8ad88c4b33a5780437ad047c6edb59ba\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2e9bdbba3dd34bffaa30535bdd749a7e06a9adb0c1e6f962f60e971b8d73b04f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2de11886b18011ca8bd5bae36969299fde40fbe26d047b05035a13661f22418b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2e07de1780b8a70d0d5b4a3f1841dcd82ab9395c449be947bc998884ba96a721\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0f69f1854d20ca0cbbdb63dbd52dad16250440a99d6b8af3825e4c2bb74925ca\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5dc987318e6e59c1afb87b655dd58cc1d22e513a05838cd4585d04b135b957ca\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"48b725758571c9df6c01dc639a85f07297696b1bb678633a29dc91de95ef53f6\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5e565e08c0821099256b56490eaee1d573afd10bb6d17d13ca4e5c611b2a3718\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2eb1b25417fe17670d135dc639fb09a46ce5113507f96de9816c059422dc705e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"115cd0a0643cfb988c24cb44c3fab48aff36c661d26cc42db8b1bdf4953bd82c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"26ca293f7b2c462d066d7378b999868bbb57ddf14e0f958ade801612311d04cd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4147400d8e1aaccf311a6b5b762011ab3e45326e4d4b9de26992816b99c528ac\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6b0db7dccc4ba1b268f6bdcc4d372848d4a72976c268ea30519a2f73e6db4d55\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"17bf1b93c4c7e01a2a830aa162412cd90f160bf9f71e967ff5209d14b24820ca\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4b431cd9efedbc94cf1eca6f9e9c1839d0e66a8bffa8c8464cac81a39d3cf8f1\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"35b41a7ac4f3c571a24f8456369c85dfe03c0354bd8cfd3805c86f2e7dc293c5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3b1480080523c439435927994849bea964e14d3beb2dddde72ac156af435d09e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2cc6810031dc1b0d4950856dc907d57508e286442a2d3eb2271618d874b14c6d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6f4141c8401c5a395ba6790efd71c70c04afea06c3c92826bcabdd5cb5477d51\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"25bdbbeda1bde8c1059618e2afd2ef999e517aa93b78341d91f318c09f0cb566\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"392a4a8758e06ee8b95f33c25dde8ac02a5ed0a27b61926cc6313487073f7f7b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"272a55878a08442b9aa6111f4de009485e6a6fd15db89365e7bbcef02eb5866c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"631ec1d6d28dd9e824ee89a30730aef7ab463acfc9d184b355aa05fd6938eab5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4eb6fda10fd0fbde02c7449bfbddc35bcd8225e7e5c3833a0818a100409dc6f2\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2d5b308b0cf02cdfefa13c4e60e26239a6ebba011694dd129b925b3c5b21e0e2\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"16549fc6af2f3b72dd5d293d72e2e5f244dff42f18b46c56ef38c57c311673ac\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"42332677ff359c5e8db836d9f5fb54822e39bd5e22340bb9ba975ba1a92be382\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"49d7d2c0b449e5179bc5ccc3b44c6075d9849b5610465f09ea725ddc97723a94\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"64c20fb90d7a003831757cc4c6226f6e4985fc9ecb416b9f684ca0351d967904\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"59cff40de83b52b41bc443d7979510d771c940b9758ca820fe73b5c8d5580934\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"53db2731730c39b04edd875fe3b7c882808285cdbc621d7af4f80dd53ebb71b0\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1b10bb7a82afce39fa69c3a2ad52f76d76398265344203119b7126d9b46860df\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"561b6012d666bfe179c4dd7f84cdd1531596d3aac7c5700ceb319f91046a63c9\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0f1e7505ebd91d2fc79c2df7dc98a3bed1b36968ba0405c090d27f6a00b7dfc8\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2f313faf0d3f6187537a7497a3b43f46797fd6e3f18eb1caff457756b819bb20\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3a5cbb6de450b481fa3ca61c0ed15bc55cad11ebf0f7ceb8f0bc3e732ecb26f6\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"681d93411bf8ce63f6716aefbd0e24506454c0348ee38fabeb264702714ccf94\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5178e940f50004312646b436727f0e80a7b8f2e9ee1fdc677c4831a7672777fb\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3dab54bc9bef688dd92086e253b439d651baa6e20f892b62865527cbca915982\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4b3ce75311218f9ae905f84eaa5b2b3818448bbf3972e1aad69de321009015d0\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"06dbfb42b979884de280d31670123f744c24b33b410fefd4368045acf2b71ae3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"068d6b4608aae810c6f039ea1973a63eb8d2de72e3d2c9eca7fc32d22f18b9d3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4c5c254589a92a36084a57d3b1d964278acc7e4fe8f69f2955954f27a79cebef\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6cbac5e1700984ebc32da15b4bb9683faabab55f67ccc4f71d9560b3475a77eb\"),\n            fp_from_hex!(\"4603c403bbfa9a17738a5c6278eaab1c37ec30b0737aa2409fc4898069eb983c\"),\n            fp_from_hex!(\"6894e7e22b2c1d5c70a712a6345ae6b192a9c833a9234c31c56aacd16bc2f100\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5be2cbbc44053ad08afa4d1eabc7f3d231eea799b93f226e905b7d4d65c58ebb\"),\n            fp_from_hex!(\"58e55f287b453a9808624a8c2a353d528da0f7e713a5c6d0d7711e47063fa611\"),\n            fp_from_hex!(\"366ebfafa3ad381c0ee258c9b8fdfccdb868a7d7e1f1f69a2b5dfcc5572555df\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"45766ab728968c642f90d97ccf5504ddc10518a819ebbcc4d09c3f5d784d67ce\"),\n            fp_from_hex!(\"39678f65512f1ee404db3024f41d3f567ef66d89d044d022e6bc229e95bc76b1\"),\n            fp_from_hex!(\"463aed1d2f1f955e3078be5bf7bfc46fc0eb8c51551906a8868f18ffae30cf4f\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"21668f016a8063c0d58b7750a3bc2fe1cf82c25f99dc01a4e534c88fe53d85fe\"),\n            fp_from_hex!(\"39d00994a8a5046a1bc749363e98a768e34dea56439fe1954bef429bc5331608\"),\n            fp_from_hex!(\"4d7f5dcd78ece9a933984de32c0b48fac2bba91f261996b8e9d1021773bd07cc\"),\n        ],\n    ];\n}\n\n/// Poseidon sponge hash function parameters for [`FpBLS12`] field instance with\n// /// state size of `4`.\npub struct BLS4Params;\n#[rustfmt::skip]\nimpl PoseidonParams\u003cFpBLS12\u003e for BLS4Params {\n    const T: usize = 4;\n    const D: u8 = 5;\n    const CAPACITY: usize = 1;\n    const ROUNDS_F: usize = 8;\n    const ROUNDS_P: usize = 56;\n    const MAT_INTERNAL_DIAG_M_1: \u0026'static [FpBLS12] = \u0026[\n        fp_from_hex!(\"07564ad691bf01c8601d68757a561d224f00f313ada673ab83e6255fb4fd5b3d\"),\n        fp_from_hex!(\"6184e3be38549f7c0850cd069b32f6decbfde312dd4b8c18349b1b3776a6eaa4\"),\n        fp_from_hex!(\"419289088178ad742be6f78425c0156b6546a18fd338f0169937dea46cfb64d2\"),\n        fp_from_hex!(\"3244cdec173b71a4659e2529b499362dac10cb2fd17562860c8bb9d0fd45b787\"),\n    ];\n    const ROUND_CONSTANTS: \u0026'static [\u0026'static [FpBLS12]] = \u0026[\n        \u0026[\n            fp_from_hex!(\"1a3bdcbfc11dabfb6ed0dd5f5a9b38191488bce9eecd811c10f9378b32db8c61\"),\n            fp_from_hex!(\"52b733e857912fdd2248dc9638dd79b1ce18b285b27792238b44c2b23c0f5d5f\"),\n            fp_from_hex!(\"47d6df02d73e6c78ced550ec8df1a459ac41f318d8b904a37652b581b2b766b8\"),\n            fp_from_hex!(\"11ec284726dddcf3cbb2b81862c9cd95e9de81ce0317302e1ef432d59b913388\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"19e21d749905904f3e10cd57f7817c2564c06ec1b1e229def2129e79a7a77738\"),\n            fp_from_hex!(\"6eeecf4c83e1ec164217f3c00956d83c3bd845bee2d86b263cf3bf89a345e5e1\"),\n            fp_from_hex!(\"10d5808ab47295f7a950dc72f968398b9c67426a217811b9bd7e97f2a261992f\"),\n            fp_from_hex!(\"25d334fbadcbfd26449c4ce1472f961f7d401a3ddf40a70af5c10ac9176d151b\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3ef8a46ec07ee551ecba60b1601cbf6e3664418331a254729b7c6a5c3d13a6c6\"),\n            fp_from_hex!(\"30d373e298c09d2a6efe661d708fcfa6163dc61ae1eb103d98cf88c63e482125\"),\n            fp_from_hex!(\"18769839949b2dda9ef3f111acd86e10250ffad4c4c4263ea970e4f4726cfad7\"),\n            fp_from_hex!(\"2c941286d1534ff3be3a66f9dd59833e65b1fa67db23511f7b4b2ae3b3d66bc9\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"08b6d9c90b4139ea70497ac8a22b30fb9b76b8ceabf70449d282b57d98c60ddd\"),\n            fp_from_hex!(\"3a8a2dd917222a71ca678b5c0a803a43c62de2f2c9fe37931b5b2a017fe64638\"),\n            fp_from_hex!(\"2dc17308abd0e731b3cffafd296cc3e6e2403dc563baa1c797a68da9754dd207\"),\n            fp_from_hex!(\"1d04e542f54431c23f9d1812392a0c87203144e343c459d3ee640b04e203be6c\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"500760e2ef6bf463fdecbf7b47f4adaa8214c797e59359439d63169e1cdb9dfb\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"61f36faac1c12d756dcc3b5491f2b22565409a4e952b8f8e726ee126c0e1c0e6\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"49e72db524a48243849fea068e58d0c078b0c738cd482a2e2160602657456ccb\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4a74677fff94821e97b20b86063c36d35c6a2908c0a19a9f130edde9c8ceb6b5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"62d27fd5080b44a436e13066ce1c80ddef2af086c2a4806bd99fa02de9726ded\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"15a26c92fc51dd285a61c2c1379f6731377aeb29c62696aa6a9c109c2991f200\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1db900a5e9b2685be9f8f02498123ac71bd7bfa40b6853ab527a8d2512b9aefb\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6ff755d237742498e0b78829cd8358bdb831e96fef08eb192b7e334123080afa\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1595447e5b94a64c8b3681f57068e19ee3696440ef785e35123886311f48cd1e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2b0eabc08eef3abae3304cbb2efc67e7b437bd96b6f7d175daed6da5a2144e8b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3a345ee8e715f3226e52838652219202efb4e6d4f057f904d69d3fbd781e39f5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"49eb2a07b5da81b57b7aa4fab19e691f9a684baef4cfb5afb6f46d23cbf1a9cd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3051663ef7de7674506f2c873409725363849564815b8bd291f00b9c60b4daf0\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"041a632a7bc167f67ca9c3825021a05b13f81f814ee101d37716e12efec3121f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6a5ae006b70bfebc1a485eed2c078654dc0f10514e8c739ca2a7019f42444ce5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0f3dba730b64dda2bc2eaa50ede0fcaa86a37c74c3a17be97a9d969fca21fb37\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6d6c02004f2a4cbb965f9e73799041fafb49f61aee66232f45ae09972af08e86\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"60391f436a32fdb0eeba8578313579c04c48c126f4eb6a0c49e249ff1c1fbf4a\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"570a30710a42539d4440ce9a2cc7d9ac102409a188960d0fbd249fc4352bf3e5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"35cb6ce55352599332471ad8be46ddc0cf598e0e36b8a8fa5fae6f26277b318e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"48a8116b254b171052251f353c93ca3816734e4e0baeea10b4269bbab9a2be55\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"126258211a4bb2035121c7ca129eae719d4ddfefa99921a8befb7a160e0f845f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5bf6985473bc5500f140844f5b66cea85815772cce03596eda60e6c7dcb4ebbd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5af46d3dd02261d893c418582188d328a8a84ff8f6ac6c1997d3aaadf64220d9\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5e3c84925609016da58df82c1f2b51590e3b91e5502dca2eba13d8354916ddbe\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"410e6fb4390379a8b726cfb22a9eaab7232bc4b60eaddb629a4aacfc7dcdbfcf\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2ca5debb9de1c4bbfa0204543dd9757241611cd28b5eac2d7f37baa293fa2618\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4a1554023154a99b4572572ccd5d89fa8745c117a2a85e5786ef6ef39410d611\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2ca75fb22881b238b6c96da6b908f922da8b54f909237051775c64fec8d5920c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"546ea8ad3dffe14c4c96e4d6d8c43c644212fb663486165b34cb26ddd717f341\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6b168ee87f2c532efdb378116dfe462f632a18eccf1e9bcfc740d35e535b2735\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4cf917a780b850292f44502b80865d3664d75213f89e8ae5861dbcb52aa95e76\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"02e8dfe9046d8b951532466bdf1b62571b85e551b34c8bbfb1ccd3216271b73d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4a34d2abd01f09f743cc56a3f87febd60ae5d88e224918d840656da973d9252e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0a3fad26c6318d471fa376fbaf02d341e41e687db6f3da88266de21c7157e940\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"131c9df7176eadb9af3a14f0f53a9b87196ef60bbb89b3630142ff8d9d69137b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5753682a8120106b42241c86deee879263d81fe8e3423e01f567316d9524647e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5ed9725af6a91090027acfc12100733a9dea89771048aa2dfe40daea9546645b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2c7b7a87f31ebd2464be9f211d41719b453939d53ff7be07a2cc21741d48b467\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"118159eb07353fef60e9733077cc82f92a6e2bd361c88d8122e9a292217757e0\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"5b4626e787d4a4b00ba4693fd7900ecaa19624be9f2fee6b9c3b538d4f896b8a\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"18cad22ae06bb0e8d043f7928477219e4d38ac544ce81c4c685267089e4c7003\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0511149594758e789b440ce534b52b6c508ae1881669d1fa4a7e551ef84e4dc4\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"428b8532efa194a7f5cbf4c296786346ddfcfe8f2bab26f25321f5d984dfc307\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"00fd035cc129e91eac66d841e2864989d1ff4853662166143535603bf9460621\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2c167565114475412c76f0df1961eaca9deb17622c9fb6f5ac8a89a29f42df69\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"10cac3ff02125419ac84ff80295589d1124a1e65a94e8d9b63a411317c7f5728\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"7213c2f17aec536d0a5196e877d1626a63d7db5b4e3bd77327eb3617b932aee7\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1b86ee2e45fbcd59fa43edee6630dda5cb3b894eb4701eff5fd53967abad2666\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0b941850091bd16875f408f183fb93d250c538e5ee1e8979e960b5b499b2f070\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"031f75d53bdd5ac603c252925148a74fa5f3bf5d9ffabe64c6e932be904204ec\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"55296a48dd399c65798cdbda11e89f26f998f2d33cf328e87a1c364e05be492b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"191175ec337e64a48785a083559176168bcea3db2822630c48f1d497d03e1e35\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"33200b518e6b1a1e96ba214cad18929e7f5b4e3336e522c5fa1febf69c0818c6\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2f989e24f97dc06c075bb53404e3eaaae32a1b6d89d9e09acdeee65712aa4216\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0de4b77163f1572bbaa325f48bde7a429b6b0f803ade45a0e72cd2bdbd84680c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6af270d408f492402b7271432b6c443abbd1f0e220888d73f47498d59044d7cc\"),\n            fp_from_hex!(\"3d5b5310e7b6be63be8f12594ecd68108f4b3f6266683b13178d0c80d8530c2f\"),\n            fp_from_hex!(\"5f69d748d06e22916088bd21fb472334ddbe5223ff494b6c0dcdf62db69d43ac\"),\n            fp_from_hex!(\"6c1fd7dbb3298da86dfe5d0435b26e0a91fe6ad6aa25b9407d5da544e6b9cd27\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"37172dd49bf14ebca52e1c31b60f31de8213644e330bcf2cc59684606e62537d\"),\n            fp_from_hex!(\"509cf829b68e58861c3d6bce6046ac1b6e9c065378fe9556348c0c1814808e20\"),\n            fp_from_hex!(\"529d5dd132f5cb4b71994ae6b330b7944f0fd8ba319582d2414b9b10768b7448\"),\n            fp_from_hex!(\"5d251391abee228833dbd24be99d163ba9f8c92a2cf73a4e1f8a87e9c4ca97ba\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1abe1d77226f2eff6f1a6bfc6c8d9e00dde1da9d67858e6984e53bc2aceba535\"),\n            fp_from_hex!(\"4ca74ba72baea6d84fa8f2a05e387a1c41a5a1b2f1a479fb11bbf9d5e09bd01a\"),\n            fp_from_hex!(\"232bfa6a3120224814967315ebf3d8c88b2eb0ea8c20c79ce854f90aec7a9b91\"),\n            fp_from_hex!(\"109f5bd722c8cf28ab6a3852970bcb665f398a8dc9d331958dc291d49a1ba9b4\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4a181a5de6c79a05c02533350ab51deee24b8f5b9154c5cf09ba5e25862ae176\"),\n            fp_from_hex!(\"6e063b99c16028df94b1eb719164ae8c8336894791516ca2c37c5a1a394bb0d7\"),\n            fp_from_hex!(\"6bbd2d3a643d301d25a8cf156542165abee3039068fecf501e9d39f313ca2a87\"),\n            fp_from_hex!(\"04690fe1be7c7b8c10c81e63f5e508fe93853c61f0435f81eabc9997fa3b99f3\"),\n        ],\n    ];\n}\n\n#[allow(unused_imports)]\n#[cfg(test)]\nmod tests {\n    use crate::{\n        field::instance::FpBLS12,\n        fp_from_hex,\n        poseidon2::{\n            instance::bls12::{BLS2Params, BLS3Params, BLS4Params},\n            params::PoseidonParams,\n            Poseidon2,\n        },\n    };\n\n    type Scalar = FpBLS12;\n\n    #[test]\n    fn smoke() {\n        let mut poseidon2 = Poseidon2::\u003cBLS2Params, _\u003e::new();\n        for i in 1..BLS2Params::T {\n            poseidon2.absorb(\u0026Scalar::from(i as u64));\n        }\n        let perm = poseidon2.squeeze_batch(1);\n        assert_eq!(\n            perm[0],\n            fp_from_hex!(\n                \"1f0e305ee21c9366d5793b80251405032a3fee32b9dd0b5f4578262891b043b4\"\n            )\n        );\n\n        let mut poseidon2 = Poseidon2::\u003cBLS3Params, _\u003e::new();\n        for i in 1..BLS3Params::T {\n            poseidon2.absorb(\u0026Scalar::from(i as u64));\n        }\n        let perm = poseidon2.squeeze_batch(2);\n        assert_eq!(\n            perm[0],\n            fp_from_hex!(\n                \"4c5793c87d51bdc2c08a32108437dc0000bd0275868f09ebc5f36919af5b3891\"\n            )\n        );\n        assert_eq!(\n            perm[1],\n            fp_from_hex!(\n                \"1fc8ed171e67902ca49863159fe5ba6325318843d13976143b8125f08b50dc6b\"\n            )\n        );\n\n        let mut poseidon2 = Poseidon2::\u003cBLS4Params, _\u003e::new();\n        for i in 1..BLS4Params::T {\n            poseidon2.absorb(\u0026Scalar::from(i as u64));\n        }\n        let perm = poseidon2.squeeze_batch(3);\n        assert_eq!(\n            perm[0],\n            fp_from_hex!(\n                \"0e56f2b6fad25075aa93560185b70e2b180ed7e269159c507c288b6747a0db2d\"\n            )\n        );\n        assert_eq!(\n            perm[1],\n            fp_from_hex!(\n                \"6d8196f28da6006bb89b3df94600acdc03d0ba7c2b0f3f4409a54c1db6bf30d0\"\n            )\n        );\n        assert_eq!(\n            perm[2],\n            fp_from_hex!(\n                \"07cfb49540ee456cce38b8a7d1a930a57ffc6660737f6589ef184c5e15334e36\"\n            )\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","poseidon2","instance","bn256.rs"],"content":"//! This module contains the poseidon sponge hash function parameters for\n//! [`FpBN256`] field instance.\n\nuse crate::{\n    field::instance::FpBN256, fp_from_hex, poseidon2::params::PoseidonParams,\n};\n\n/// Poseidon sponge hash function parameters for [`FpBN256`] field instance.\npub struct BN256Params;\n\n#[rustfmt::skip]\nimpl PoseidonParams\u003cFpBN256\u003e for BN256Params {\n    const T: usize = 3;\n    const D: u8 = 5;\n    const CAPACITY: usize = 1;\n    const ROUNDS_F: usize = 8;\n    const ROUNDS_P: usize = 56;\n    const MAT_INTERNAL_DIAG_M_1: \u0026'static [FpBN256] = \u0026[\n        fp_from_hex!(\n            \"0000000000000000000000000000000000000000000000000000000000000001\"\n        ),\n        fp_from_hex!(\n            \"0000000000000000000000000000000000000000000000000000000000000001\"\n        ),\n        fp_from_hex!(\n            \"0000000000000000000000000000000000000000000000000000000000000002\"\n        ),\n    ];\n    const ROUND_CONSTANTS: \u0026'static [\u0026'static [FpBN256]] = \u0026[\n        \u0026[\n            fp_from_hex!(\"1d066a255517b7fd8bddd3a93f7804ef7f8fcde48bb4c37a59a09a1a97052816\"),\n            fp_from_hex!(\"29daefb55f6f2dc6ac3f089cebcc6120b7c6fef31367b68eb7238547d32c1610\"),\n            fp_from_hex!(\"1f2cb1624a78ee001ecbd88ad959d7012572d76f08ec5c4f9e8b7ad7b0b4e1d1\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0aad2e79f15735f2bd77c0ed3d14aa27b11f092a53bbc6e1db0672ded84f31e5\"),\n            fp_from_hex!(\"2252624f8617738cd6f661dd4094375f37028a98f1dece66091ccf1595b43f28\"),\n            fp_from_hex!(\"1a24913a928b38485a65a84a291da1ff91c20626524b2b87d49f4f2c9018d735\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"22fc468f1759b74d7bfc427b5f11ebb10a41515ddff497b14fd6dae1508fc47a\"),\n            fp_from_hex!(\"1059ca787f1f89ed9cd026e9c9ca107ae61956ff0b4121d5efd65515617f6e4d\"),\n            fp_from_hex!(\"02be9473358461d8f61f3536d877de982123011f0bf6f155a45cbbfae8b981ce\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0ec96c8e32962d462778a749c82ed623aba9b669ac5b8736a1ff3a441a5084a4\"),\n            fp_from_hex!(\"292f906e073677405442d9553c45fa3f5a47a7cdb8c99f9648fb2e4d814df57e\"),\n            fp_from_hex!(\"274982444157b86726c11b9a0f5e39a5cc611160a394ea460c63f0b2ffe5657e\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1a1d063e54b1e764b63e1855bff015b8cedd192f47308731499573f23597d4b5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"26abc66f3fdf8e68839d10956259063708235dccc1aa3793b91b002c5b257c37\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0c7c64a9d887385381a578cfed5aed370754427aabca92a70b3c2b12ff4d7be8\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1cf5998769e9fab79e17f0b6d08b2d1eba2ebac30dc386b0edd383831354b495\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0f5e3a8566be31b7564ca60461e9e08b19828764a9669bc17aba0b97e66b0109\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"18df6a9d19ea90d895e60e4db0794a01f359a53a180b7d4b42bf3d7a531c976e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"04f7bf2c5c0538ac6e4b782c3c6e601ad0ea1d3a3b9d25ef4e324055fa3123dc\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"29c76ce22255206e3c40058523748531e770c0584aa2328ce55d54628b89ebe6\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"198d425a45b78e85c053659ab4347f5d65b1b8e9c6108dbe00e0e945dbc5ff15\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"25ee27ab6296cd5e6af3cc79c598a1daa7ff7f6878b3c49d49d3a9a90c3fdf74\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"138ea8e0af41a1e024561001c0b6eb1505845d7d0c55b1b2c0f88687a96d1381\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"306197fb3fab671ef6e7c2cba2eefd0e42851b5b9811f2ca4013370a01d95687\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1a0c7d52dc32a4432b66f0b4894d4f1a21db7565e5b4250486419eaf00e8f620\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2b46b418de80915f3ff86a8e5c8bdfccebfbe5f55163cd6caa52997da2c54a9f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"12d3e0dc0085873701f8b777b9673af9613a1af5db48e05bfb46e312b5829f64\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"263390cf74dc3a8870f5002ed21d089ffb2bf768230f648dba338a5cb19b3a1f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0a14f33a5fe668a60ac884b4ca607ad0f8abb5af40f96f1d7d543db52b003dcd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"28ead9c586513eab1a5e86509d68b2da27be3a4f01171a1dd847df829bc683b9\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1c6ab1c328c3c6430972031f1bdb2ac9888f0ea1abe71cffea16cda6e1a7416c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1fc7e71bc0b819792b2500239f7f8de04f6decd608cb98a932346015c5b42c94\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"03e107eb3a42b2ece380e0d860298f17c0c1e197c952650ee6dd85b93a0ddaa8\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2d354a251f381a4669c0d52bf88b772c46452ca57c08697f454505f6941d78cd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"094af88ab05d94baf687ef14bc566d1c522551d61606eda3d14b4606826f794b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"19705b783bf3d2dc19bcaeabf02f8ca5e1ab5b6f2e3195a9d52b2d249d1396f7\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"09bf4acc3a8bce3f1fcc33fee54fc5b28723b16b7d740a3e60cef6852271200e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1803f8200db6013c50f83c0c8fab62843413732f301f7058543a073f3f3b5e4e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0f80afb5046244de30595b160b8d1f38bf6fb02d4454c0add41f7fef2faf3e5c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"126ee1f8504f15c3d77f0088c1cfc964abcfcf643f4a6fea7dc3f98219529d78\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"23c203d10cfcc60f69bfb3d919552ca10ffb4ee63175ddf8ef86f991d7d0a591\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2a2ae15d8b143709ec0d09705fa3a6303dec1ee4eec2cf747c5a339f7744fb94\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"07b60dee586ed6ef47e5c381ab6343ecc3d3b3006cb461bbb6b5d89081970b2b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"27316b559be3edfd885d95c494c1ae3d8a98a320baa7d152132cfe583c9311bd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1d5c49ba157c32b8d8937cb2d3f84311ef834cc2a743ed662f5f9af0c0342e76\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2f8b124e78163b2f332774e0b850b5ec09c01bf6979938f67c24bd5940968488\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1e6843a5457416b6dc5b7aa09a9ce21b1d4cba6554e51d84665f75260113b3d5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"11cdf00a35f650c55fca25c9929c8ad9a68daf9ac6a189ab1f5bc79f21641d4b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"21632de3d3bbc5e42ef36e588158d6d4608b2815c77355b7e82b5b9b7eb560bc\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0de625758452efbd97b27025fbd245e0255ae48ef2a329e449d7b5c51c18498a\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2ad253c053e75213e2febfd4d976cc01dd9e1e1c6f0fb6b09b09546ba0838098\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1d6b169ed63872dc6ec7681ec39b3be93dd49cdd13c813b7d35702e38d60b077\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1660b740a143664bb9127c4941b67fed0be3ea70a24d5568c3a54e706cfef7fe\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0065a92d1de81f34114f4ca2deef76e0ceacdddb12cf879096a29f10376ccbfe\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1f11f065202535987367f823da7d672c353ebe2ccbc4869bcf30d50a5871040d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"26596f5c5dd5a5d1b437ce7b14a2c3dd3bd1d1a39b6759ba110852d17df0693e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"16f49bc727e45a2f7bf3056efcf8b6d38539c4163a5f1e706743db15af91860f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1abe1deb45b3e3119954175efb331bf4568feaf7ea8b3dc5e1a4e7438dd39e5f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0e426ccab66984d1d8993a74ca548b779f5db92aaec5f102020d34aea15fba59\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0e7c30c2e2e8957f4933bd1942053f1f0071684b902d534fa841924303f6a6c6\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0812a017ca92cf0a1622708fc7edff1d6166ded6e3528ead4c76e1f31d3fc69d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"21a5ade3df2bc1b5bba949d1db96040068afe5026edd7a9c2e276b47cf010d54\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"01f3035463816c84ad711bf1a058c6c6bd101945f50e5afe72b1a5233f8749ce\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0b115572f038c0e2028c2aafc2d06a5e8bf2f9398dbd0fdf4dcaa82b0f0c1c8b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1c38ec0b99b62fd4f0ef255543f50d2e27fc24db42bc910a3460613b6ef59e2f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1c89c6d9666272e8425c3ff1f4ac737b2f5d314606a297d4b1d0b254d880c53e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"03326e643580356bf6d44008ae4c042a21ad4880097a5eb38b71e2311bb88f8f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"268076b0054fb73f67cee9ea0e51e3ad50f27a6434b5dceb5bdde2299910a4c9\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1acd63c67fbc9ab1626ed93491bda32e5da18ea9d8e4f10178d04aa6f8747ad0\"),\n            fp_from_hex!(\"19f8a5d670e8ab66c4e3144be58ef6901bf93375e2323ec3ca8c86cd2a28b5a5\"),\n            fp_from_hex!(\"1c0dc443519ad7a86efa40d2df10a011068193ea51f6c92ae1cfbb5f7b9b6893\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"14b39e7aa4068dbe50fe7190e421dc19fbeab33cb4f6a2c4180e4c3224987d3d\"),\n            fp_from_hex!(\"1d449b71bd826ec58f28c63ea6c561b7b820fc519f01f021afb1e35e28b0795e\"),\n            fp_from_hex!(\"1ea2c9a89baaddbb60fa97fe60fe9d8e89de141689d1252276524dc0a9e987fc\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0478d66d43535a8cb57e9c1c3d6a2bd7591f9a46a0e9c058134d5cefdb3c7ff1\"),\n            fp_from_hex!(\"19272db71eece6a6f608f3b2717f9cd2662e26ad86c400b21cde5e4a7b00bebe\"),\n            fp_from_hex!(\"14226537335cab33c749c746f09208abb2dd1bd66a87ef75039be846af134166\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"01fd6af15956294f9dfe38c0d976a088b21c21e4a1c2e823f912f44961f9a9ce\"),\n            fp_from_hex!(\"18e5abedd626ec307bca190b8b2cab1aaee2e62ed229ba5a5ad8518d4e5f2a57\"),\n            fp_from_hex!(\"0fc1bbceba0590f5abbdffa6d3b35e3297c021a3a409926d0e2d54dc1c84fda6\"),\n        ],\n    ];\n}\n\n#[allow(unused_imports)]\n#[cfg(test)]\nmod tests {\n    use crate::{\n        field::instance::FpBN256,\n        fp_from_hex,\n        poseidon2::{instance::bn256::BN256Params, *},\n    };\n\n    type Scalar = FpBN256;\n\n    #[test]\n    fn smoke() {\n        let mut poseidon2 = Poseidon2::\u003cBN256Params, _\u003e::new();\n        for i in 1..BN256Params::T {\n            poseidon2.absorb(\u0026Scalar::from(i as u64));\n        }\n        let perm = poseidon2.squeeze_batch(2);\n        assert_eq!(\n            perm[0],\n            fp_from_hex!(\n                \"303b6f7c86d043bfcbcc80214f26a30277a15d3f74ca654992defe7ff8d03570\"\n            )\n        );\n        assert_eq!(\n            perm[1],\n            fp_from_hex!(\n                \"1ed25194542b12eef8617361c3ba7c52e660b145994427cc86296242cf766ec8\"\n            )\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","poseidon2","instance","goldilocks.rs"],"content":"//! This module contains the poseidon sponge hash function parameters for\n//! [`FpGoldiLocks`] field instance.\n\nuse crate::{\n    field::instance::FpGoldiLocks, fp_from_hex,\n    poseidon2::params::PoseidonParams,\n};\n\n/// Poseidon sponge hash function parameters for [`FpGoldiLocks`] field\n/// instance.\npub struct Goldilocks12Params;\n\n#[rustfmt::skip]\nimpl PoseidonParams\u003cFpGoldiLocks\u003e for Goldilocks12Params {\n    const T: usize = 12;\n    const D: u8 = 7;\n    // Capacity 4 will give `4*64 = 256` bits security.\n    const CAPACITY: usize = 4;\n    const ROUNDS_F: usize = 8;\n    const ROUNDS_P: usize = 22;\n    const MAT_INTERNAL_DIAG_M_1: \u0026'static [FpGoldiLocks] = \u0026[\n        fp_from_hex!(\"c3b6c08e23ba9300\"),\n        fp_from_hex!(\"d84b5de94a324fb6\"),\n        fp_from_hex!(\"0d0c371c5b35b84f\"),\n        fp_from_hex!(\"7964f570e7188037\"),\n        fp_from_hex!(\"5daf18bbd996604b\"),\n        fp_from_hex!(\"6743bc47b9595257\"),\n        fp_from_hex!(\"5528b9362c59bb70\"),\n        fp_from_hex!(\"ac45e25b7127b68b\"),\n        fp_from_hex!(\"a2077d7dfbb606b5\"),\n        fp_from_hex!(\"f3faac6faee378ae\"),\n        fp_from_hex!(\"0c6388b51545e883\"),\n        fp_from_hex!(\"d27dbb6944917b60\"),\n    ];\n    const ROUND_CONSTANTS: \u0026'static [\u0026'static [FpGoldiLocks]] = \u0026[\n        \u0026[\n            fp_from_hex!(\"13dcf33aba214f46\"),\n            fp_from_hex!(\"30b3b654a1da6d83\"),\n            fp_from_hex!(\"1fc634ada6159b56\"),\n            fp_from_hex!(\"937459964dc03466\"),\n            fp_from_hex!(\"edd2ef2ca7949924\"),\n            fp_from_hex!(\"ede9affde0e22f68\"),\n            fp_from_hex!(\"8515b9d6bac9282d\"),\n            fp_from_hex!(\"6b5c07b4e9e900d8\"),\n            fp_from_hex!(\"1ec66368838c8a08\"),\n            fp_from_hex!(\"9042367d80d1fbab\"),\n            fp_from_hex!(\"400283564a3c3799\"),\n            fp_from_hex!(\"4a00be0466bca75e\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"7913beee58e3817f\"),\n            fp_from_hex!(\"f545e88532237d90\"),\n            fp_from_hex!(\"22f8cb8736042005\"),\n            fp_from_hex!(\"6f04990e247a2623\"),\n            fp_from_hex!(\"fe22e87ba37c38cd\"),\n            fp_from_hex!(\"d20e32c85ffe2815\"),\n            fp_from_hex!(\"117227674048fe73\"),\n            fp_from_hex!(\"4e9fb7ea98a6b145\"),\n            fp_from_hex!(\"e0866c232b8af08b\"),\n            fp_from_hex!(\"00bbc77916884964\"),\n            fp_from_hex!(\"7031c0fb990d7116\"),\n            fp_from_hex!(\"240a9e87cf35108f\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2e6363a5a12244b3\"),\n            fp_from_hex!(\"5e1c3787d1b5011c\"),\n            fp_from_hex!(\"4132660e2a196e8b\"),\n            fp_from_hex!(\"3a013b648d3d4327\"),\n            fp_from_hex!(\"f79839f49888ea43\"),\n            fp_from_hex!(\"fe85658ebafe1439\"),\n            fp_from_hex!(\"b6889825a14240bd\"),\n            fp_from_hex!(\"578453605541382b\"),\n            fp_from_hex!(\"4508cda8f6b63ce9\"),\n            fp_from_hex!(\"9c3ef35848684c91\"),\n            fp_from_hex!(\"0812bde23c87178c\"),\n            fp_from_hex!(\"fe49638f7f722c14\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"8e3f688ce885cbf5\"),\n            fp_from_hex!(\"b8e110acf746a87d\"),\n            fp_from_hex!(\"b4b2e8973a6dabef\"),\n            fp_from_hex!(\"9e714c5da3d462ec\"),\n            fp_from_hex!(\"6438f9033d3d0c15\"),\n            fp_from_hex!(\"24312f7cf1a27199\"),\n            fp_from_hex!(\"23f843bb47acbf71\"),\n            fp_from_hex!(\"9183f11a34be9f01\"),\n            fp_from_hex!(\"839062fbb9d45dbf\"),\n            fp_from_hex!(\"24b56e7e6c2e43fa\"),\n            fp_from_hex!(\"e1683da61c962a72\"),\n            fp_from_hex!(\"a95c63971a19bfa7\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4adf842aa75d4316\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"f8fbb871aa4ab4eb\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"68e85b6eb2dd6aeb\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"07a0b06b2d270380\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"d94e0228bd282de4\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"8bdd91d3250c5278\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"209c68b88bba778f\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"b5e18cdab77f3877\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"b296a3e808da93fa\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"8370ecbda11a327e\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3f9075283775dad8\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"b78095bb23c6aa84\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3f36b9fe72ad4e5f\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"69bc96780b10b553\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3f1d341f2eb7b881\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"4e939e9815838818\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"da366b3ae2a31604\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"bc89db1e7287d509\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"6102f411f9ef5659\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"58725c5e7ac1f0ab\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0df5856c798883e7\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"f7bb62a8da4c961b\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n            fp_from_hex!(\"0000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"c68be7c94882a24d\"),\n            fp_from_hex!(\"af996d5d5cdaedd9\"),\n            fp_from_hex!(\"9717f025e7daf6a5\"),\n            fp_from_hex!(\"6436679e6e7216f4\"),\n            fp_from_hex!(\"8a223d99047af267\"),\n            fp_from_hex!(\"bb512e35a133ba9a\"),\n            fp_from_hex!(\"fbbf44097671aa03\"),\n            fp_from_hex!(\"f04058ebf6811e61\"),\n            fp_from_hex!(\"5cca84703fac7ffb\"),\n            fp_from_hex!(\"9b55c7945de6469f\"),\n            fp_from_hex!(\"8e05bf09808e934f\"),\n            fp_from_hex!(\"2ea900de876307d7\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"7748fff2b38dfb89\"),\n            fp_from_hex!(\"6b99a676dd3b5d81\"),\n            fp_from_hex!(\"ac4bb7c627cf7c13\"),\n            fp_from_hex!(\"adb6ebe5e9e2f5ba\"),\n            fp_from_hex!(\"2d33378cafa24ae3\"),\n            fp_from_hex!(\"1e5b73807543f8c2\"),\n            fp_from_hex!(\"09208814bfebb10f\"),\n            fp_from_hex!(\"782e64b6bb5b93dd\"),\n            fp_from_hex!(\"add5a48eac90b50f\"),\n            fp_from_hex!(\"add4c54c736ea4b1\"),\n            fp_from_hex!(\"d58dbb86ed817fd8\"),\n            fp_from_hex!(\"6d5ed1a533f34ddd\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"28686aa3e36b7cb9\"),\n            fp_from_hex!(\"591abd3476689f36\"),\n            fp_from_hex!(\"047d766678f13875\"),\n            fp_from_hex!(\"a2a11112625f5b49\"),\n            fp_from_hex!(\"21fd10a3f8304958\"),\n            fp_from_hex!(\"f9b40711443b0280\"),\n            fp_from_hex!(\"d2697eb8b2bde88e\"),\n            fp_from_hex!(\"3493790b51731b3f\"),\n            fp_from_hex!(\"11caf9dd73764023\"),\n            fp_from_hex!(\"7acfb8f72878164e\"),\n            fp_from_hex!(\"744ec4db23cefc26\"),\n            fp_from_hex!(\"1e00e58f422c6340\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"21dd28d906a62dda\"),\n            fp_from_hex!(\"f32a46ab5f465b5f\"),\n            fp_from_hex!(\"bfce13201f3f7e6b\"),\n            fp_from_hex!(\"f30d2e7adb5304e2\"),\n            fp_from_hex!(\"ecdf4ee4abad48e9\"),\n            fp_from_hex!(\"f94e82182d395019\"),\n            fp_from_hex!(\"4ee52e3744d887c5\"),\n            fp_from_hex!(\"a1341c7cac0083b2\"),\n            fp_from_hex!(\"2302fb26c30c834a\"),\n            fp_from_hex!(\"aea3c587273bf7d3\"),\n            fp_from_hex!(\"f798e24961823ec7\"),\n            fp_from_hex!(\"962deba3e9a2cd94\"),\n        ],\n    ];\n}\n\n#[allow(unused_imports)]\n#[cfg(test)]\nmod tests {\n    use crate::{\n        field::instance::FpGoldiLocks,\n        fp_from_hex,\n        poseidon2::{instance::goldilocks::Goldilocks12Params, *},\n    };\n\n    type Scalar = FpGoldiLocks;\n\n    #[test]\n    fn smoke() {\n        let mut poseidon2 = Poseidon2::\u003cGoldilocks12Params, _\u003e::new();\n        for i in 1..Goldilocks12Params::T {\n            poseidon2.absorb(\u0026Scalar::from(i as u64));\n        }\n        let mut perm = poseidon2\n            .squeeze_batch(Goldilocks12Params::T - Goldilocks12Params::CAPACITY)\n            .into_iter();\n\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"919ad117c013584c\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"da52e5769cff16e3\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"61018d9476a8588e\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"eded3197110731fb\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"57224df1bb91d294\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"655c1fb6ef455b96\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"aff582f1574c02b1\"));\n        assert_eq!(perm.next().unwrap(), fp_from_hex!(\"5fde11bb5be4f4f9\"));\n        assert!(perm.next().is_none());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","poseidon2","instance","mod.rs"],"content":"//! This module contains the poseidon hash instances for some popular finite\n//! field instances.\npub mod babybear;\npub mod bls12;\npub mod bn256;\npub mod goldilocks;\npub mod pallas;\npub mod vesta;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","poseidon2","instance","pallas.rs"],"content":"//! This module contains the poseidon sponge hash function parameters for\n//! [`FpPallas`] field instance.\n\nuse crate::{\n    field::instance::FpPallas, fp_from_hex, poseidon2::params::PoseidonParams,\n};\n\n/// Poseidon sponge hash function parameters for [`FpPallas`] field instance.\npub struct PallasParams;\n\n#[rustfmt::skip]\nimpl PoseidonParams\u003cFpPallas\u003e for PallasParams {\n    const T: usize = 3;\n    const D: u8 = 5;\n    const CAPACITY: usize = 1;\n    const ROUNDS_F: usize = 8;\n    const ROUNDS_P: usize = 56;\n    const MAT_INTERNAL_DIAG_M_1: \u0026'static [FpPallas] = \u0026[\n        fp_from_hex!(\n            \"0000000000000000000000000000000000000000000000000000000000000001\"\n        ),\n        fp_from_hex!(\n            \"0000000000000000000000000000000000000000000000000000000000000001\"\n        ),\n        fp_from_hex!(\n            \"0000000000000000000000000000000000000000000000000000000000000002\"\n        ),\n    ];\n    const ROUND_CONSTANTS: \u0026'static [\u0026'static [FpPallas]] = \u0026[\n        \u0026[\n            fp_from_hex!(\"360d7470611e473d353f628f76d110f34e71162f31003b7057538c2596426303\"),\n            fp_from_hex!(\"2bab94d7ae222d135dc3c6c5febfaa314908ac2f12ebe06fbdb74213bf63188b\"),\n            fp_from_hex!(\"150c93fef652fb1c2bf03e1a29aa871fef77e7d736766c5d0939d92753cc5dc8\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3270661e68928b3a955d55db56dc57c103cc0a60141e894e14259dce537782b2\"),\n            fp_from_hex!(\"073f116f04122e25a0b7afe4e2057299b407c370f2b5a1ccce9fb9ffc345afb3\"),\n            fp_from_hex!(\"2a32ec5c4ee5b1837affd09c1f53f5fd55c9cd2061ae93ca8ebad76fc71554d8\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"270326ee039df19e651e2cfc740628ca634d24fc6e2559f22d8ccbe292efeead\"),\n            fp_from_hex!(\"27c6642ac633bc66dc100fe7fcfa54918af895bce012f182a068fc37c182e274\"),\n            fp_from_hex!(\"1bdfd8b01401c70ad27f57396989129d710e1fb6ab976a459ca18682e26d7ff9\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"162a14c62f9a89b814b9d6a9c84dd678f4f6fb3f9054d373c832d824261a35ea\"),\n            fp_from_hex!(\"2d193e0f76de586b2af6f79e3127feeaac0a1fc71e2cf0c0f79824667b5b6bec\"),\n            fp_from_hex!(\"044ca3cc4a85d73b81696ef1104e674f4feff82984990ff85d0bf58dc8a4aa94\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1cbaf2b371dac6a81d0453416d3e235cb8d9e2d4f314f46f6198785f0cd6b9af\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1d5b2777692c205b0e6c49d061b6b5f4293c4ab038fdbbdc343e07610f3fede5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2e9bdbba3dd34bffaa30535bdd749a7e06a9adb0c1e6f962f60e971b8d73b04f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2de11886b18011ca8bd5bae36969299fde40fbe26d047b05035a13661f22418b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2e07de1780b8a70d0d5b4a3f1841dcd82ab9395c449be947bc998884ba96a721\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0f69f1854d20ca0cbbdb63dbd52dad16250440a99d6b8af3825e4c2bb74925ca\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2eb1b25417fe17670d135dc639fb09a46ce5113507f96de9816c059422dc705e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"115cd0a0643cfb988c24cb44c3fab48aff36c661d26cc42db8b1bdf4953bd82c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"26ca293f7b2c462d066d7378b999868bbb57ddf14e0f958ade801612311d04cd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"17bf1b93c4c7e01a2a830aa162412cd90f160bf9f71e967ff5209d14b24820ca\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"35b41a7ac4f3c571a24f8456369c85dfe03c0354bd8cfd3805c86f2e7dc293c5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3b1480080523c439435927994849bea964e14d3beb2dddde72ac156af435d09e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[fp_from_hex!(\"2cc6810031dc1b0d4950856dc907d57508e286442a2d3eb2271618d874b14c6d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"25bdbbeda1bde8c1059618e2afd2ef999e517aa93b78341d91f318c09f0cb566\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"392a4a8758e06ee8b95f33c25dde8ac02a5ed0a27b61926cc6313487073f7f7b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"272a55878a08442b9aa6111f4de009485e6a6fd15db89365e7bbcef02eb5866c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2d5b308b0cf02cdfefa13c4e60e26239a6ebba011694dd129b925b3c5b21e0e2\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"16549fc6af2f3b72dd5d293d72e2e5f244dff42f18b46c56ef38c57c311673ac\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1b10bb7a82afce39fa69c3a2ad52f76d76398265344203119b7126d9b46860df\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0f1e7505ebd91d2fc79c2df7dc98a3bed1b36968ba0405c090d27f6a00b7dfc8\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2f313faf0d3f6187537a7497a3b43f46797fd6e3f18eb1caff457756b819bb20\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3a5cbb6de450b481fa3ca61c0ed15bc55cad11ebf0f7ceb8f0bc3e732ecb26f6\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3dab54bc9bef688dd92086e253b439d651baa6e20f892b62865527cbca915982\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"06dbfb42b979884de280d31670123f744c24b33b410fefd4368045acf2b71ae3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"068d6b4608aae810c6f039ea1973a63eb8d2de72e3d2c9eca7fc32d22f18b9d3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"366ebfafa3ad381c0ee258c9b8fdfccdb868a7d7e1f1f69a2b5dfcc5572555df\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"39678f65512f1ee404db3024f41d3f567ef66d89d044d022e6bc229e95bc76b1\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"21668f016a8063c0d58b7750a3bc2fe1cf82c25f99dc01a4e534c88fe53d85fe\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"39d00994a8a5046a1bc749363e98a768e34dea56439fe1954bef429bc5331608\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1f9dbdc3f84312636b203bbe12fb3425b163d41605d39f99770c956f60d881b3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"027745a9cddfad95e5f17b9e0ee0cab6be0bc829fe5e66c69794a9f7c336eab2\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1cec0803c504b635788d695c61e932122fa43fe20a45c78d52025657abd8aee0\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"123523d75e9fabc172077448ef87cc6eed5082c8dbf31365d3872a9559a03a73\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1723d1452c9cf02df419b848e5d694bf27feba35975ee7e5001779e3a1d357f4\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1739d180a16010bdfcc0573d7e61369421c3f776f572836d9dab1ee4dcf96622\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2d4e6354da9cc554acce32391794b627fafa96fbeb0ab89370290452042d048d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"153ee6142e535e334a869553c9d007f88f3bd43f99260621670bcf6f8b485dcd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0c45bfd3a69aaa65635ef7e7a430b486968ad4424af83700d258d2e2b7782172\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0adfd53b256a6957f2d56aec831446006897ac0a8ffa5ff10e5633d251f73307\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"315d2ac8ebdbac3c8cd1726b7cbab8ee3f87b28f1c1be4bdac9d36a8b7516d63\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1b8472712d02eef4cfaec23d2b16883fc9bb60d1f6959879299ce44ea423d8e1\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3c1cd07efda6ff24bd0b70fa2255eb6f367d2c54e36928c9c4a5404198adf70c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"136052d26bb3d373687f4e51b2e1dcd34a16073f738f7e0cbbe523aef9ab107a\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"16c96beef6a0a848c1bdd859a1232a1d7b3cfbb873032681676c36c24ef967dd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"284b38c57ff65c262ab7fed8f499a9fb012387bab4f1662d067eec7f2d6340c4\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0c5993d175e81f6639e242198897d17cfc06772c1c0411a6af1dff204c922f86\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"03bf7a3f7bd043dafcda655d1ba9c8f9f24887ad48e17759bbf53f67b1f87b15\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3188fe4ee9f9fafbb0cf999567f00e734c8f9cbe69f0e8279b5cd09e36d8be62\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"171f528ccf6584375a39768c480d61e13af5bf77c1c42652afea99a2ec6c595a\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"12f4175c4ab45afc196e41859b35ef88812c3286ee7000675a0563b9b8e9f1d5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3a509e155cb7ebfd8f8fdcf800a9ac697e23e1aabe96cfab0e74d4d369118b79\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"10f2a685df4a27c81a89920e2504c3b3984bc8f2e4c1b69e98712c65678cfd30\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"09e5f49790c8a0e21d8d93d54ab91a0e54573c9333c56321e8a16728cc9d4918\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"352d69bed80ee3e52bf35705d9f84a3442d17ed6ee0fab7e609a740347cf5fea\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"058ee73ba9f3f293491562faf2b190d3c634debd281b76a63a758af6fa84e0e8\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"232f99cc911eddd9cd0f1fc55b1a3250092cb92119bc76be621a132510a43904\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"201beed7b8f3ab8186c22c6c5d4869f0f9efd52ca6bc2961c3b97c1e301bc213\"),\n            fp_from_hex!(\"1376dce6580030c6a1c9291d58602f5129388842744a1210bf6b3431ba94e9bc\"),\n            fp_from_hex!(\"1793199e6fd6ba342b3356c38238f761072ba8b02d92e7226454843c5486d7b3\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"22de7a7488dcc7359fee9c20c87a67df3c66160dc62aacac06a3f1d3b433311b\"),\n            fp_from_hex!(\"3514d5e9066bb160df8ff37fe2d8edf8dbe0b77fae77e1d030d6e3fd516b47a8\"),\n            fp_from_hex!(\"30cd3006931ad636f919a00dabbf5fa5ff453d6f900f144a19377427137a81c7\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"253d1a5c5293412741f81a5cf613c8df8f9e4b2cae2ebb515b6a74220692b506\"),\n            fp_from_hex!(\"035b461c02d79d19a35e9613e7f5fe92851b3a59c990fafc73f666cb86a48e8e\"),\n            fp_from_hex!(\"23a9928079d175bd5bc00eedd56b93e092b1283c2d5fccde7cfbf86a3aa04780\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"13a7785ae134ea92f1594a0763c611abb5e2ea3436eef957f1e4ccd73fa00a82\"),\n            fp_from_hex!(\"39fce308b7d43c574962ae3c0da17e313889c57863446d88bbf04f5252de4279\"),\n            fp_from_hex!(\"1aae18833f8e1d3ac0fdf01662f60d22bef00a08c6ed38d23b57e34489b53fad\"),\n        ],\n    ];\n}\n\n#[allow(unused_imports)]\n#[cfg(test)]\nmod tests {\n    use crate::{\n        field::instance::FpPallas,\n        fp_from_hex,\n        poseidon2::{instance::pallas::PallasParams, *},\n    };\n\n    type Scalar = FpPallas;\n\n    #[test]\n    fn smoke() {\n        let mut poseidon2 = Poseidon2::\u003cPallasParams, _\u003e::new();\n        for i in 1..PallasParams::T {\n            poseidon2.absorb(\u0026Scalar::from(i as u64));\n        }\n        let perm = poseidon2.squeeze_batch(2);\n        assert_eq!(\n            perm[0],\n            fp_from_hex!(\n                \"1c48ea0994a7d7984ea338a54dbf0c8681f5af883fe988d59ba3380c9f7901fc\"\n            )\n        );\n        assert_eq!(\n            perm[1],\n            fp_from_hex!(\n                \"079ddd0a80a3e9414489b526a2770448964766685f4c4842c838f8a23120b401\"\n            )\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","poseidon2","instance","vesta.rs"],"content":"//! This module contains the poseidon sponge hash function parameters for\n//! [`FpVesta`] field instance.\n\nuse crate::{\n    field::instance::FpVesta, fp_from_hex, poseidon2::params::PoseidonParams,\n};\n\n/// Poseidon sponge hash function parameters for [`FpVesta`] field instance.\npub struct VestaParams;\n\n#[rustfmt::skip]\nimpl PoseidonParams\u003cFpVesta\u003e for VestaParams {\n    const T: usize = 3;\n    const D: u8 = 5;\n    const CAPACITY: usize = 1;\n    const ROUNDS_F: usize = 8;\n    const ROUNDS_P: usize = 56;\n    const MAT_INTERNAL_DIAG_M_1: \u0026'static [FpVesta] = \u0026[\n        fp_from_hex!(\n            \"0000000000000000000000000000000000000000000000000000000000000001\"\n        ),\n        fp_from_hex!(\n            \"0000000000000000000000000000000000000000000000000000000000000001\"\n        ),\n        fp_from_hex!(\n            \"0000000000000000000000000000000000000000000000000000000000000002\"\n        ),\n    ];\n    const ROUND_CONSTANTS: \u0026'static [\u0026'static [FpVesta]] = \u0026[\n        \u0026[\n            fp_from_hex!(\"360d7470611e473d353f628f76d110f34e71162f31003b7057538c2596426303\"),\n            fp_from_hex!(\"2bab94d7ae222d135dc3c6c5febfaa314908ac2f12ebe06fbdb74213bf63188b\"),\n            fp_from_hex!(\"150c93fef652fb1c2bf03e1a29aa871fef77e7d736766c5d0939d92753cc5dc8\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3270661e68928b3a955d55db56dc57c103cc0a60141e894e14259dce537782b2\"),\n            fp_from_hex!(\"073f116f04122e25a0b7afe4e2057299b407c370f2b5a1ccce9fb9ffc345afb3\"),\n            fp_from_hex!(\"2a32ec5c4ee5b1837affd09c1f53f5fd55c9cd2061ae93ca8ebad76fc71554d8\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"270326ee039df19e651e2cfc740628ca634d24fc6e2559f22d8ccbe292efeead\"),\n            fp_from_hex!(\"27c6642ac633bc66dc100fe7fcfa54918af895bce012f182a068fc37c182e274\"),\n            fp_from_hex!(\"1bdfd8b01401c70ad27f57396989129d710e1fb6ab976a459ca18682e26d7ff9\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"162a14c62f9a89b814b9d6a9c84dd678f4f6fb3f9054d373c832d824261a35ea\"),\n            fp_from_hex!(\"2d193e0f76de586b2af6f79e3127feeaac0a1fc71e2cf0c0f79824667b5b6bec\"),\n            fp_from_hex!(\"044ca3cc4a85d73b81696ef1104e674f4feff82984990ff85d0bf58dc8a4aa94\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1cbaf2b371dac6a81d0453416d3e235cb8d9e2d4f314f46f6198785f0cd6b9af\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1d5b2777692c205b0e6c49d061b6b5f4293c4ab038fdbbdc343e07610f3fede5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2e9bdbba3dd34bffaa30535bdd749a7e06a9adb0c1e6f962f60e971b8d73b04f\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2de11886b18011ca8bd5bae36969299fde40fbe26d047b05035a13661f22418b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2e07de1780b8a70d0d5b4a3f1841dcd82ab9395c449be947bc998884ba96a721\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0f69f1854d20ca0cbbdb63dbd52dad16250440a99d6b8af3825e4c2bb74925ca\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2eb1b25417fe17670d135dc639fb09a46ce5113507f96de9816c059422dc705e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"115cd0a0643cfb988c24cb44c3fab48aff36c661d26cc42db8b1bdf4953bd82c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"26ca293f7b2c462d066d7378b999868bbb57ddf14e0f958ade801612311d04cd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"17bf1b93c4c7e01a2a830aa162412cd90f160bf9f71e967ff5209d14b24820ca\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"35b41a7ac4f3c571a24f8456369c85dfe03c0354bd8cfd3805c86f2e7dc293c5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3b1480080523c439435927994849bea964e14d3beb2dddde72ac156af435d09e\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[fp_from_hex!(\"2cc6810031dc1b0d4950856dc907d57508e286442a2d3eb2271618d874b14c6d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"25bdbbeda1bde8c1059618e2afd2ef999e517aa93b78341d91f318c09f0cb566\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"392a4a8758e06ee8b95f33c25dde8ac02a5ed0a27b61926cc6313487073f7f7b\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"272a55878a08442b9aa6111f4de009485e6a6fd15db89365e7bbcef02eb5866c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2d5b308b0cf02cdfefa13c4e60e26239a6ebba011694dd129b925b3c5b21e0e2\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"16549fc6af2f3b72dd5d293d72e2e5f244dff42f18b46c56ef38c57c311673ac\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1b10bb7a82afce39fa69c3a2ad52f76d76398265344203119b7126d9b46860df\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0f1e7505ebd91d2fc79c2df7dc98a3bed1b36968ba0405c090d27f6a00b7dfc8\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2f313faf0d3f6187537a7497a3b43f46797fd6e3f18eb1caff457756b819bb20\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3a5cbb6de450b481fa3ca61c0ed15bc55cad11ebf0f7ceb8f0bc3e732ecb26f6\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3dab54bc9bef688dd92086e253b439d651baa6e20f892b62865527cbca915982\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"06dbfb42b979884de280d31670123f744c24b33b410fefd4368045acf2b71ae3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"068d6b4608aae810c6f039ea1973a63eb8d2de72e3d2c9eca7fc32d22f18b9d3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"366ebfafa3ad381c0ee258c9b8fdfccdb868a7d7e1f1f69a2b5dfcc5572555df\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"39678f65512f1ee404db3024f41d3f567ef66d89d044d022e6bc229e95bc76b1\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"21668f016a8063c0d58b7750a3bc2fe1cf82c25f99dc01a4e534c88fe53d85fe\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"39d00994a8a5046a1bc749363e98a768e34dea56439fe1954bef429bc5331608\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1f9dbdc3f84312636b203bbe12fb3425b163d41605d39f99770c956f60d881b3\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"027745a9cddfad95e5f17b9e0ee0cab6be0bc829fe5e66c69794a9f7c336eab2\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1cec0803c504b635788d695c61e932122fa43fe20a45c78d52025657abd8aee0\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"123523d75e9fabc172077448ef87cc6eed5082c8dbf31365d3872a9559a03a73\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1723d1452c9cf02df419b848e5d694bf27feba35975ee7e5001779e3a1d357f4\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1739d180a16010bdfcc0573d7e61369421c3f776f572836d9dab1ee4dcf96622\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"2d4e6354da9cc554acce32391794b627fafa96fbeb0ab89370290452042d048d\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"153ee6142e535e334a869553c9d007f88f3bd43f99260621670bcf6f8b485dcd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0c45bfd3a69aaa65635ef7e7a430b486968ad4424af83700d258d2e2b7782172\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0adfd53b256a6957f2d56aec831446006897ac0a8ffa5ff10e5633d251f73307\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"315d2ac8ebdbac3c8cd1726b7cbab8ee3f87b28f1c1be4bdac9d36a8b7516d63\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"1b8472712d02eef4cfaec23d2b16883fc9bb60d1f6959879299ce44ea423d8e1\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3c1cd07efda6ff24bd0b70fa2255eb6f367d2c54e36928c9c4a5404198adf70c\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"136052d26bb3d373687f4e51b2e1dcd34a16073f738f7e0cbbe523aef9ab107a\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"16c96beef6a0a848c1bdd859a1232a1d7b3cfbb873032681676c36c24ef967dd\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"284b38c57ff65c262ab7fed8f499a9fb012387bab4f1662d067eec7f2d6340c4\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"0c5993d175e81f6639e242198897d17cfc06772c1c0411a6af1dff204c922f86\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"03bf7a3f7bd043dafcda655d1ba9c8f9f24887ad48e17759bbf53f67b1f87b15\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3188fe4ee9f9fafbb0cf999567f00e734c8f9cbe69f0e8279b5cd09e36d8be62\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"171f528ccf6584375a39768c480d61e13af5bf77c1c42652afea99a2ec6c595a\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"12f4175c4ab45afc196e41859b35ef88812c3286ee7000675a0563b9b8e9f1d5\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"3a509e155cb7ebfd8f8fdcf800a9ac697e23e1aabe96cfab0e74d4d369118b79\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"10f2a685df4a27c81a89920e2504c3b3984bc8f2e4c1b69e98712c65678cfd30\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"09e5f49790c8a0e21d8d93d54ab91a0e54573c9333c56321e8a16728cc9d4918\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"352d69bed80ee3e52bf35705d9f84a3442d17ed6ee0fab7e609a740347cf5fea\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"058ee73ba9f3f293491562faf2b190d3c634debd281b76a63a758af6fa84e0e8\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"232f99cc911eddd9cd0f1fc55b1a3250092cb92119bc76be621a132510a43904\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n            fp_from_hex!(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"201beed7b8f3ab8186c22c6c5d4869f0f9efd52ca6bc2961c3b97c1e301bc213\"),\n            fp_from_hex!(\"1376dce6580030c6a1c9291d58602f5129388842744a1210bf6b3431ba94e9bc\"),\n            fp_from_hex!(\"1793199e6fd6ba342b3356c38238f761072ba8b02d92e7226454843c5486d7b3\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"22de7a7488dcc7359fee9c20c87a67df3c66160dc62aacac06a3f1d3b433311b\"),\n            fp_from_hex!(\"3514d5e9066bb160df8ff37fe2d8edf8dbe0b77fae77e1d030d6e3fd516b47a8\"),\n            fp_from_hex!(\"30cd3006931ad636f919a00dabbf5fa5ff453d6f900f144a19377427137a81c7\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"253d1a5c5293412741f81a5cf613c8df8f9e4b2cae2ebb515b6a74220692b506\"),\n            fp_from_hex!(\"035b461c02d79d19a35e9613e7f5fe92851b3a59c990fafc73f666cb86a48e8e\"),\n            fp_from_hex!(\"23a9928079d175bd5bc00eedd56b93e092b1283c2d5fccde7cfbf86a3aa04780\"),\n        ],\n        \u0026[\n            fp_from_hex!(\"13a7785ae134ea92f1594a0763c611abb5e2ea3436eef957f1e4ccd73fa00a82\"),\n            fp_from_hex!(\"39fce308b7d43c574962ae3c0da17e313889c57863446d88bbf04f5252de4279\"),\n            fp_from_hex!(\"1aae18833f8e1d3ac0fdf01662f60d22bef00a08c6ed38d23b57e34489b53fad\"),\n        ],\n    ];\n}\n\n#[allow(unused_imports)]\n#[cfg(test)]\nmod tests {\n    use crate::{\n        field::instance::FpVesta,\n        fp_from_hex,\n        poseidon2::{\n            instance::vesta::VestaParams, params::PoseidonParams, Poseidon2,\n        },\n    };\n\n    type Scalar = FpVesta;\n\n    #[test]\n    fn smoke() {\n        let mut poseidon2 = Poseidon2::\u003cVestaParams, _\u003e::new();\n        for i in 1..VestaParams::T {\n            poseidon2.absorb(\u0026Scalar::from(i as u64));\n        }\n        let perm = poseidon2.squeeze_batch(2);\n        assert_eq!(perm[0], fp_from_hex!(\"2c76327e0b7653873263158cf8545c282364b183880fcdea93ca8526d518c66f\"));\n        assert_eq!(perm[1], fp_from_hex!(\"262316c0ce5244838c75873299b59d763ae0849d2dd31bdc95caf7db1c2901bf\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","poseidon2","mod.rs"],"content":"//! This module contains the Poseidon hash ([whitepaper]) function implemented\n//! as a [Sponge Function].\n//!\n//! Poseidon permutation here follows referenced in [whitepaper] original [rust\n//! implementation] with slight improvements.\n//!\n//! ## Important Usage Notes\n//!\n//! This interface provides low-level primitives and does not implement padding\n//! or domain separation. Users are responsible for:\n//! - Padding inputs appropriately\n//! - Prepending domain separation tags when needed\n//! - Managing absorb/squeeze transitions correctly\n//! - Ensuring proper security practices for their specific use case\n//!\n//! [Sponge function]: https://en.wikipedia.org/wiki/Sponge_function\n//! [whitepaper]: https://eprint.iacr.org/2023/323.pdf\n//! [rust implementation]: https://github.com/HorizenLabs/poseidon2\n\npub mod instance;\npub mod params;\n\nuse alloc::{boxed::Box, vec, vec::Vec};\n\nuse crate::{field::prime::PrimeField, poseidon2::params::PoseidonParams};\n\n/// Determines whether poseidon sponge in absorbing or squeezing state.\n/// In squeezing state, sponge can only squeeze elements.\n#[derive(Clone, Copy, Debug, PartialEq)]\nenum Mode {\n    Absorbing,\n    Squeezing,\n}\n\n/// Poseidon2 sponge that can absorb any number of `F` field elements and be\n/// squeezed to a finite number of `F` field elements.\n///\n/// ## Security Notice\n///\n/// This is a low-level primitive that does not implement padding or domain\n/// separation. Users must ensure proper input formatting and security practices\n/// for their specific cryptographic protocols.\n#[derive(Clone, Debug)]\npub struct Poseidon2\u003cP: PoseidonParams\u003cF\u003e, F: PrimeField\u003e {\n    phantom: core::marker::PhantomData\u003cP\u003e,\n    state: Box\u003c[F]\u003e,\n    mode: Mode,\n    index: usize,\n}\n\nimpl\u003cP: PoseidonParams\u003cF\u003e, F: PrimeField\u003e Default for Poseidon2\u003cP, F\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cP: PoseidonParams\u003cF\u003e, F: PrimeField\u003e Poseidon2\u003cP, F\u003e {\n    /// Create a new Poseidon sponge.\n    #[must_use]\n    #[inline]\n    pub fn new() -\u003e Self {\n        Self {\n            phantom: core::marker::PhantomData,\n            state: vec![F::zero(); P::T].into_boxed_slice(),\n            mode: Mode::Absorbing,\n            // Begin index from `CAPACITY`. Skip capacity elements.\n            index: P::CAPACITY,\n        }\n    }\n\n    /// Size of poseidon sponge's state.\n    #[must_use]\n    pub const fn state_size() -\u003e usize {\n        P::T\n    }\n\n    /// Start index of partial rounds.\n    ///\n    /// This represents the point where the algorithm transitions from full\n    /// rounds to partial rounds in the Poseidon permutation.\n    #[must_use]\n    const fn partial_round_start() -\u003e usize {\n        P::ROUNDS_F / 2\n    }\n\n    /// End index of partial rounds (noninclusive).\n    ///\n    /// This represents the point where the algorithm transitions from partial\n    /// rounds back to full rounds in the Poseidon permutation.\n    #[must_use]\n    const fn partial_round_end() -\u003e usize {\n        Self::partial_round_start() + P::ROUNDS_P\n    }\n\n    /// Total number of rounds.\n    ///\n    /// This is the sum of full rounds and partial rounds in the Poseidon\n    /// permutation.\n    #[must_use]\n    const fn rounds() -\u003e usize {\n        P::ROUNDS_F + P::ROUNDS_P\n    }\n\n    /// Absorb a single element into the sponge.\n    ///\n    /// Transitions from [`Mode::Absorbing`] to [`Mode::Squeezing`] mode are\n    /// unidirectional.\n    ///\n    /// # Panics\n    ///\n    /// May panic if absorbing while squeezing.\n    #[inline]\n    pub fn absorb(\u0026mut self, elem: \u0026F) {\n        if let Mode::Squeezing = self.mode {\n            panic!(\"cannot absorb while squeezing\");\n        }\n\n        if self.index == Self::state_size() {\n            self.permute();\n            self.index = P::CAPACITY;\n        }\n\n        self.state[self.index] += elem;\n        self.index += 1;\n    }\n\n    /// Absorb batch of elements into the sponge.\n    #[inline]\n    pub fn absorb_batch(\u0026mut self, elems: \u0026[F]) {\n        for elem in elems {\n            self.absorb(elem);\n        }\n    }\n\n    /// Permute elements in the sponge.\n    #[inline]\n    pub fn permute(\u0026mut self) {\n        // Linear layer at the beginning.\n        self.matmul_external();\n\n        // Run the first half of the full round.\n        for round in 0..Self::partial_round_start() {\n            self.external_round(round);\n        }\n\n        // Run the partial round.\n        for round in Self::partial_round_start()..Self::partial_round_end() {\n            self.internal_round(round);\n        }\n\n        // Run the second half of the full round.\n        for round in Self::partial_round_end()..Self::rounds() {\n            self.external_round(round);\n        }\n    }\n\n    /// Apply external round to the state.\n    ///\n    /// External rounds apply S-box to all elements of the state vector,\n    /// followed by the MDS matrix multiplication.\n    #[inline]\n    fn external_round(\u0026mut self, round: usize) {\n        self.add_rc_external(round);\n        self.apply_sbox_external();\n        self.matmul_external();\n    }\n\n    /// Apply internal round to the state.\n    ///\n    /// Internal rounds apply S-box only to the first element of the state\n    /// vector, followed by the MDS matrix multiplication, which is more\n    /// efficient.\n    #[inline]\n    fn internal_round(\u0026mut self, round: usize) {\n        self.add_rc_internal(round);\n        self.apply_sbox_internal();\n        self.matmul_internal();\n    }\n\n    /// Squeeze a single element from the sponge.\n    ///\n    /// When invoked from [`Mode::Absorbing`] mode, this function triggers a\n    /// permutation and transitions to [`Mode::Squeezing`] mode.\n    #[inline]\n    pub fn squeeze(\u0026mut self) -\u003e F {\n        if self.mode == Mode::Absorbing || self.index == Self::state_size() {\n            self.permute();\n            self.mode = Mode::Squeezing;\n            self.index = P::CAPACITY;\n        }\n\n        let elem = self.state[self.index];\n        self.index += 1;\n        elem\n    }\n\n    /// Squeeze a batch of elements from the sponge.\n    #[inline]\n    pub fn squeeze_batch(\u0026mut self, n: usize) -\u003e Vec\u003cF\u003e {\n        (0..n).map(|_| self.squeeze()).collect()\n    }\n\n    /// Apply sbox to the entire state in the external round.\n    ///\n    /// This raises each element in the state to the power of D, which is\n    /// the S-box degree defined in the Poseidon parameters.\n    #[inline]\n    fn apply_sbox_external(\u0026mut self) {\n        for elem in \u0026mut self.state {\n            *elem = elem.pow(P::D);\n        }\n    }\n\n    /// Apply sbox to the first element in the internal round.\n    ///\n    /// This applies the S-box (raising to power D) only to the first element of\n    /// the state, which is more efficient than applying it to all elements.\n    #[inline]\n    fn apply_sbox_internal(\u0026mut self) {\n        self.state[0] = self.state[0].pow(P::D);\n    }\n\n    /// Apply the external MDS matrix `M_E` to the state.\n    ///\n    /// This function applies the Maximum Distance Separable (MDS) matrix\n    /// multiplication to the entire state vector for external rounds of the\n    /// Poseidon permutation. The implementation is optimized for different\n    /// state sizes.\n    #[allow(clippy::needless_range_loop)]\n    #[inline(always)]\n    fn matmul_external(\u0026mut self) {\n        let t = Self::state_size();\n        match t {\n            2 =\u003e {\n                // Matrix circ(2, 1)\n                let sum = self.state[0] + self.state[1];\n                self.state[0] += sum;\n                self.state[1] += sum;\n            }\n            3 =\u003e {\n                // Matrix circ(2, 1, 1).\n                let sum = self.state[0] + self.state[1] + self.state[2];\n                self.state[0] += sum;\n                self.state[1] += sum;\n                self.state[2] += sum;\n            }\n            4 =\u003e {\n                self.matmul_m4();\n            }\n            8 | 12 | 16 | 20 | 24 =\u003e {\n                self.matmul_m4();\n\n                // Applying second cheap matrix for t \u003e 4.\n                let t4 = t / 4;\n                let mut stored = [F::zero(); 4];\n                for l in 0..4 {\n                    stored[l] = self.state[l];\n                    for j in 1..t4 {\n                        stored[l] += \u0026self.state[4 * j + l];\n                    }\n                }\n                for i in 0..self.state.len() {\n                    self.state[i] += \u0026stored[i % 4];\n                }\n            }\n            _ =\u003e {\n                panic!(\"not supported state size\")\n            }\n        }\n    }\n\n    /// Apply the cheap 4x4 MDS matrix to each 4-element part of the state.\n    ///\n    /// Optimized matrix multiplication for state sizes that are multiples of 4.\n    /// Uses efficient in-place operations instead of constructing the full\n    /// matrix.\n    #[inline(always)]\n    fn matmul_m4(\u0026mut self) {\n        let state = \u0026mut self.state;\n        let t = Self::state_size();\n        let t4 = t / 4;\n        for i in 0..t4 {\n            let start_index = i * 4;\n            let mut t_0 = state[start_index];\n            t_0 += \u0026state[start_index + 1];\n            let mut t_1 = state[start_index + 2];\n            t_1 += \u0026state[start_index + 3];\n            let mut t_2 = state[start_index + 1];\n            t_2.double_in_place();\n            t_2 += \u0026t_1;\n            let mut t_3 = state[start_index + 3];\n            t_3.double_in_place();\n            t_3 += \u0026t_0;\n            let mut t_4 = t_1;\n            t_4.double_in_place();\n            t_4.double_in_place();\n            t_4 += \u0026t_3;\n            let mut t_5 = t_0;\n            t_5.double_in_place();\n            t_5.double_in_place();\n            t_5 += \u0026t_2;\n            let mut t_6 = t_3;\n            t_6 += \u0026t_5;\n            let mut t_7 = t_2;\n            t_7 += \u0026t_4;\n            state[start_index] = t_6;\n            state[start_index + 1] = t_5;\n            state[start_index + 2] = t_7;\n            state[start_index + 3] = t_4;\n        }\n    }\n\n    /// Apply the internal MDS matrix to the state.\n    ///\n    /// Optimized matrix multiplication for internal rounds.\n    #[inline(always)]\n    fn matmul_internal(\u0026mut self) {\n        let t = Self::state_size();\n\n        match t {\n            2 =\u003e {\n                // [2, 1]\n                // [1, 3]\n                let sum = self.state[0] + self.state[1];\n                self.state[0] += \u0026sum;\n                self.state[1].double_in_place();\n                self.state[1] += \u0026sum;\n            }\n            3 =\u003e {\n                // [2, 1, 1]\n                // [1, 2, 1]\n                // [1, 1, 3]\n                let sum = self.state[0] + self.state[1] + self.state[2];\n                self.state[0] += \u0026sum;\n                self.state[1] += \u0026sum;\n                self.state[2].double_in_place();\n                self.state[2] += \u0026sum;\n            }\n            4 | 8 | 12 | 16 | 20 | 24 =\u003e {\n                let sum = self.state.iter().sum();\n\n                // Add sum + diag entry * element to each element.\n                for i in 0..self.state.len() {\n                    self.state[i] *= \u0026P::MAT_INTERNAL_DIAG_M_1[i];\n                    self.state[i] += \u0026sum;\n                }\n            }\n            _ =\u003e {\n                panic!(\"not supported state size\")\n            }\n        }\n    }\n\n    /// Add a round constant to the entire state in external round.\n    #[inline]\n    fn add_rc_external(\u0026mut self, round: usize) {\n        for (a, b) in\n            self.state.iter_mut().zip(P::ROUND_CONSTANTS[round].iter())\n        {\n            *a += b;\n        }\n    }\n\n    // Add a round constant to the first state element in internal round.\n    #[inline]\n    fn add_rc_internal(\u0026mut self, round: usize) {\n        self.state[0] += P::ROUND_CONSTANTS[round][0];\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":139},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","poseidon2","params.rs"],"content":"//! This module contains a trait with poseidon hash parameters.\n//!\n//! Consumer of this trait should implement the parameters for the specific\n//! poseidon hash instance.\n//! Or use the existing instances in the [`crate::poseidon2::instance`] module.\n\nuse crate::field::prime::PrimeField;\n\n/// Poseidon hash parameters.\npub trait PoseidonParams\u003cF: PrimeField\u003e {\n    /// State size.\n    const T: usize;\n\n    /// Sbox degree.\n    const D: u8;\n\n    /// Capacity of the sponge construction.\n    /// Determines the number of elements not affected directly by input\n    /// or not reflected in the output of the sponge hash function.\n    const CAPACITY: usize;\n\n    /// Number of full rounds.\n    const ROUNDS_F: usize;\n\n    /// Number of partial rounds.\n    const ROUNDS_P: usize;\n\n    /// MDS (Maximum Distance Separable) matrix used in the Poseidon\n    /// permutation.\n    const MAT_INTERNAL_DIAG_M_1: \u0026'static [F];\n\n    /// The round constants used in the full and partial rounds of the Poseidon\n    /// permutation.\n    const ROUND_CONSTANTS: \u0026'static [\u0026'static [F]];\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","crypto","src","test_helpers.rs"],"content":"use proptest::prelude::*;\n\n/// Creates a proptest strategy for non-empty vectors of random bytes.\n///\n/// Maximum vector size is determined by proptest's default configuration.\npub(crate) fn non_empty_u8_vec_strategy() -\u003e impl Strategy\u003cValue = Vec\u003cu8\u003e\u003e {\n    prop::collection::vec(\n        any::\u003cu8\u003e(),\n        1..ProptestConfig::default().max_default_size_range,\n    )\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e","src","account.rs"],"content":"use alloy::{\n    network::EthereumWallet,\n    primitives::{Address, B256},\n    providers::{Provider, ProviderBuilder},\n    signers::{local::PrivateKeySigner, Signature, Signer},\n};\nuse once_cell::sync::Lazy;\nuse tokio::sync::{Mutex, MutexGuard};\n\nuse crate::{\n    deploy::Deployer,\n    system::{fund_account, Wallet, RPC_URL_ENV_VAR_NAME},\n};\n\nconst DEFAULT_FUNDING_ETH: u32 = 100;\n\n/// Type that corresponds to a test account.\n#[derive(Clone, Debug)]\npub struct Account {\n    /// The account's local private key wrapper.\n    pub signer: PrivateKeySigner,\n    /// The account's wallet -- an `alloy` provider with a `WalletFiller`.\n    pub wallet: Wallet,\n}\n\nimpl Account {\n    /// Create a new account with a default funding of [`DEFAULT_FUNDING_ETH`].\n    ///\n    /// # Errors\n    ///\n    /// May fail if funding the newly created account fails.\n    pub async fn new() -\u003e eyre::Result\u003cSelf\u003e {\n        AccountFactory::create().await\n    }\n\n    /// Get a hex-encoded String representing this account's private key.\n    #[must_use]\n    pub fn pk(\u0026self) -\u003e String {\n        alloy::hex::encode(self.signer.to_bytes())\n    }\n\n    /// Retrieve this account's address.\n    #[must_use]\n    pub fn address(\u0026self) -\u003e Address {\n        self.signer.address()\n    }\n\n    /// The rpc endpoint this account's provider is connect to.\n    #[must_use]\n    pub fn url(\u0026self) -\u003e \u0026str {\n        self.wallet.client().transport().url()\n    }\n\n    /// Sign the given hash.\n    ///\n    /// # Panics\n    ///\n    /// May fail when the method is not implemented for `Signer`. Should not\n    /// happen.\n    pub async fn sign_hash(\u0026self, hash: \u0026B256) -\u003e Signature {\n        self.signer.sign_hash(hash).await.expect(\"should sign a hash\")\n    }\n\n    /// Sign the given message.\n    ///\n    /// # Panics\n    ///\n    /// May fail when the method is not implemented for `Signer`. Should not\n    /// happen.\n    pub async fn sign_message(\u0026self, message: \u0026[u8]) -\u003e Signature {\n        self.signer.sign_message(message).await.expect(\"should sign a message\")\n    }\n\n    /// Create a configurable smart contract deployer on behalf of this account.\n    #[must_use]\n    pub fn as_deployer(\u0026self) -\u003e Deployer {\n        Deployer::new(self.url().to_string(), self.pk())\n    }\n}\n\n/// A unit struct used as a synchronization mechanism in\n/// [`SYNC_ACCOUNT_FACTORY`].\nstruct AccountFactory;\n\nimpl AccountFactory {\n    /// Get access to the factory in a synchronized manner.\n    async fn lock() -\u003e MutexGuard\u003c'static, Self\u003e {\n        /// Since after wallet generation accounts get funded in the nitro test\n        /// node from a single \"god\" wallet, we must synchronize account\n        /// creation (otherwise the nonce will be too low).\n        static SYNC_ACCOUNT_FACTORY: Lazy\u003cMutex\u003cAccountFactory\u003e\u003e =\n            Lazy::new(|| Mutex::new(AccountFactory));\n\n        SYNC_ACCOUNT_FACTORY.lock().await\n    }\n\n    /// Create new account and fund it via nitro test node access.\n    ///\n    /// # Errors\n    ///\n    /// May fail if unable to find the path to the node or if funding the newly\n    /// created account fails.\n    async fn create() -\u003e eyre::Result\u003cAccount\u003e {\n        let _lock = AccountFactory::lock().await;\n\n        let signer = PrivateKeySigner::random();\n        let addr = signer.address();\n        fund_account(addr, DEFAULT_FUNDING_ETH)?;\n\n        let rpc_url = std::env::var(RPC_URL_ENV_VAR_NAME)\n            .expect(\"failed to load RPC_URL var from env\")\n            .parse()\n            .expect(\"failed to parse RPC_URL string into a URL\");\n        let wallet = ProviderBuilder::new()\n            .with_recommended_fillers()\n            .wallet(EthereumWallet::from(signer.clone()))\n            .on_http(rpc_url);\n\n        Ok(Account { signer, wallet })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e","src","constructor_macro.rs"],"content":"/// Constructor data.\npub struct Constructor {\n    /// Constructor signature.\n    pub signature: String,\n    /// Constructor arguments.\n    pub args: Vec\u003cString\u003e,\n}\n\n/// Generates a function selector for the given method and its args.\n#[macro_export]\nmacro_rules! constructor {\n    () =\u003e {{\n        $crate::Constructor {\n            signature: \"constructor()\".to_string(),\n            args: vec![],\n        }\n    }};\n\n    ($first:expr $(, $rest:expr)* $(,)?) =\u003e {{\n        fn get_abi_str\u003cT: stylus_sdk::abi::AbiType\u003e(_: T) -\u003e \u0026'static str {\n            \u003cT as stylus_sdk::abi::AbiType\u003e::ABI.as_str()\n        }\n\n        let signature_params = {\n            let mut params = vec![get_abi_str($first)];\n            $(params.push(get_abi_str($rest));)*\n            params.join(\",\")\n        };\n\n        let args = vec![$first.to_string()$(, $rest.to_string())*];\n\n        $crate::Constructor {\n            signature: format!(\"constructor({})\", signature_params),\n            args,\n        }\n    }};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e","src","deploy.rs"],"content":"use std::{path::PathBuf, process::Command, str::FromStr};\n\nuse alloy::{\n    consensus::Transaction,\n    hex::{self, ToHexExt},\n    network::EthereumWallet,\n    primitives::{Address, TxHash},\n    providers::{Provider, ProviderBuilder},\n    signers::local::PrivateKeySigner,\n    transports::{http::reqwest::Url, RpcError, TransportErrorKind},\n};\nuse eyre::{Context, ContextCompat};\nuse regex::Regex;\nuse stylus_sdk::{abi::Bytes, alloy_primitives, function_selector};\n\nuse crate::{project::Crate, system::DEPLOYER_ADDRESS, Constructor, Receipt};\n\nconst CONTRACT_INITIALIZATION_ERROR_SELECTOR: [u8; 4] =\n    function_selector!(\"ContractInitializationError\", Address, Bytes);\n\nconst PROGRAM_UP_TO_DATE_ERROR_SELECTOR: [u8; 4] =\n    function_selector!(\"ProgramUpToDate\");\n\nconst CONTRACT_DEPLOYMENT_ERROR_SELECTOR: [u8; 4] =\n    function_selector!(\"ContractDeploymentError\", Bytes);\n\n/// Represents the `ContractInitializationError(address)` error in\n/// StylusDeployer.\n///\n/// This error is returned when a revert happens inside the contract\n/// constructor. The StylusDeployer contract then returns this error, which\n/// contains the would-be address of the contract.\n///\n/// See: \u003chttps://github.com/OffchainLabs/nitro-contracts/blob/c32af127fe6a9124316abebbf756609649ede1f5/src/stylus/StylusDeployer.sol#L78-L81\u003e\n#[derive(Debug)]\npub struct ContractInitializationError;\n\nimpl ContractInitializationError {\n    /// Convert [`eyre::Report`] into [`ContractInitializationError`].\n    pub fn from_report(report: \u0026eyre::Report) -\u003e Option\u003c\u0026Self\u003e {\n        report.downcast_ref::\u003cContractInitializationError\u003e()\n    }\n}\n\nimpl std::fmt::Display for ContractInitializationError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.write_str(\"ContractInitializationError\")\n    }\n}\n\nimpl std::error::Error for ContractInitializationError {}\n\n/// Represents the `ContractDeploymentError(bytes)` error in StylusDeployer.\n///\n/// See: \u003chttps://github.com/OffchainLabs/nitro-contracts/blob/c32af127fe6a9124316abebbf756609649ede1f5/src/stylus/StylusDeployer.sol#L15\u003e\n#[derive(Debug)]\npub struct ContractDeploymentError {\n    /// Contract bytecode.\n    pub bytecode: alloy_primitives::Bytes,\n}\n\nimpl ContractDeploymentError {\n    /// Convert [`eyre::Report`] into [`ContractDeploymentError`].\n    pub fn from_report(report: \u0026eyre::Report) -\u003e Option\u003c\u0026Self\u003e {\n        report.downcast_ref::\u003cContractDeploymentError\u003e()\n    }\n}\n\nimpl std::fmt::Display for ContractDeploymentError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.write_str(\"ContractDeploymentError {\")\n    }\n}\n\nimpl std::error::Error for ContractDeploymentError {}\n\n/// A basic smart contract deployer.\npub struct Deployer {\n    rpc_url: String,\n    private_key: String,\n    ctor: Option\u003cConstructor\u003e,\n}\n\nimpl Deployer {\n    pub fn new(rpc_url: String, private_key: String) -\u003e Self {\n        Self { rpc_url, private_key, ctor: None }\n    }\n\n    /// Add solidity constructor to the deployer.\n    #[allow(clippy::needless_pass_by_value)]\n    pub fn with_constructor(mut self, ctor: Constructor) -\u003e Deployer {\n        self.ctor = Some(ctor);\n        self\n    }\n\n    /// See [`Deployer::deploy_wasm()`] for more details.\n    pub async fn deploy(self) -\u003e eyre::Result\u003cReceipt\u003e {\n        let pkg = Crate::new()?;\n        let wasm_path = pkg.wasm;\n\n        self.deploy_wasm(\u0026wasm_path).await\n    }\n\n    /// Deploy and activate the contract implemented as `#[entrypoint]` in the\n    /// current crate.\n    /// Consumes currently configured deployer.\n    ///\n    /// # Errors\n    ///\n    /// May error if:\n    ///\n    /// - Unable to collect information about the crate required for deployment.\n    /// - `cargo stylus deploy` errors.\n    pub async fn deploy_wasm(\n        self,\n        wasm_path: \u0026PathBuf,\n    ) -\u003e eyre::Result\u003cReceipt\u003e {\n        let wasm_path = wasm_path.to_str().expect(\"wasm file should exist\");\n        let mut command = self.create_command(wasm_path);\n\n        let output = command\n            .output()\n            .context(\"failed to execute `cargo stylus deploy` command\")?;\n\n        // Resources for context on the implementation:\n        // - https://github.com/OffchainLabs/nitro-contracts/blob/c32af127fe6a9124316abebbf756609649ede1f5/src/stylus/StylusDeployer.sol#L10\n        // - https://github.com/OffchainLabs/nitro/blob/98aefbacd814b002bd93a625edaaa0abd9e0d2f0/arbos/programs/programs.go#L113\n        if !output.status.success() {\n            self.parse_deployment_error(output).await\n        } else {\n            self.get_receipt(output).await\n        }\n    }\n\n    fn create_command(\u0026self, wasm_path: \u0026str) -\u003e Command {\n        let mut command = Command::new(\"cargo\");\n        command\n            .args([\"stylus\", \"deploy\"])\n            .args([\"-e\", \u0026self.rpc_url])\n            .args([\"--private-key\", \u0026self.private_key])\n            .args([\"--wasm-file\", wasm_path])\n            .args([\"--no-verify\"]);\n\n        // There are 3 possible cases when it comes to invoking constructors:\n        //      1. No constructor exists on a contract - `self.ctor_args` should\n        //         be None\n        //      2. Constructor exists, but accepts no arguments -\n        //         `self.ctor_args` should be Some(vec![])\n        //      3. Constructor exists and accepts arguments - `self.ctor_args`\n        //         should be Some(vec![\"arg1\", \"arg2\", ...])\n        //\n        // The deployer address and constructor-args must both be set if the\n        // constructor is to be invoked on a contract. Otherwise,\n        // neither should be set.\n        if let Some(ctor) = self.ctor.as_ref() {\n            let deployer_address = std::env::var(DEPLOYER_ADDRESS)\n                .expect(\"deployer address should be set\");\n\n            command\n                .args([\"--deployer-address\", \u0026deployer_address])\n                .args([\"--constructor-signature\", \u0026ctor.signature])\n                .args(\n                    [\u0026[\"--constructor-args\".to_string()], ctor.args.as_slice()]\n                        .concat(),\n                );\n        }\n\n        command\n    }\n\n    /// These are all band-aid solutions for peculiar nitro-testnode behavior\n    /// (as of commit de8cf4edec0d12e5ef1b7623e54e35ddb579ff0b on branch\n    /// \"v3-support\").\n    async fn parse_deployment_error(\n        \u0026self,\n        output: std::process::Output,\n    ) -\u003e eyre::Result\u003cReceipt\u003e {\n        let stderr = \u0026String::from_utf8_lossy(\u0026output.stderr);\n\n        // Look for the error pattern with hex data\n        let error_data_regex = Regex::new(r#\"data:.+\"(0x[a-fA-F0-9]+)\"\"#)\n            .context(\"failed to create error data regex\")?;\n\n        if let Some(captures) = error_data_regex.captures(stderr) {\n            if let Some(hex_data) = captures.get(1) {\n                let hex_str = hex_data.as_str();\n                let hex_str = \u0026hex_str[2..]; // Skip \"0x\" prefix\n                let data = hex::decode(hex_str)\n                    .context(format!(\"failed to decode hex: {hex_str}\"))?;\n                let error_selector = \u0026data[0..4];\n\n                if error_selector == CONTRACT_INITIALIZATION_ERROR_SELECTOR {\n                    return Err(eyre::Report::new(\n                        ContractInitializationError {},\n                    ));\n                } else if error_selector == PROGRAM_UP_TO_DATE_ERROR_SELECTOR {\n                    // For some reason, the error here is:\n                    // ```\n                    // did not estimate correctly: (code: 3, message: execution reverted: error ProgramUpToDate(), data: Some(String(\\\"0xcc944bf2\\\")))\n                    // ```\n                    // which is the same as the one handles later (the\n                    // activation error), but it still contains the stdout that\n                    // is the same as if the deployment was successful.\n                    //\n                    // This is probably some weird nitro-testnode issue, but for\n                    // now this quick-fix should work.\n                    return self.get_receipt(output).await;\n                } else if error_selector == CONTRACT_DEPLOYMENT_ERROR_SELECTOR {\n                    return Err(eyre::Report::new(ContractDeploymentError {\n                        bytecode: data[4..].to_vec().into(),\n                    }));\n                } else {\n                    return Err(eyre::eyre!(hex_str.to_string()));\n                }\n            }\n        }\n\n        // The pattern matches the contract address that is preceeded by\n        // ANSI escape codes (`cargo stylus deploy` outputs colored text).\n        let activation_error_regex =\n            Regex::new(r#\"activate tx reverted (?:\\x1B\\[[0-9;]*[a-zA-Z])*(0x[a-fA-F0-9]+)\"#)\n                .context(\"failed to create activation error regex\")?;\n\n        if let Some(captures) = activation_error_regex.captures(stderr) {\n            if let Some(tx_hash_match) = captures.get(1) {\n                let tx_hash = tx_hash_match.as_str();\n\n                let tx_hash = TxHash::from_str(tx_hash)\n                    .context(\"Failed to parse transaction hash\")?;\n\n                let provider = ProviderBuilder::new()\n                    .with_recommended_fillers()\n                    .wallet(EthereumWallet::from(\n                        self.private_key.parse::\u003cPrivateKeySigner\u003e()?,\n                    ))\n                    .on_http(\n                        Url::from_str(\u0026self.rpc_url).expect(\"invalid Url\"),\n                    );\n\n                // We extract the address of the contract that was supposed to\n                // be activated by StylusDeployer by getting the transaction\n                // that StylusDeployer sent to Arbitrum `activateProgram`\n                // precompile and extracting the address used in the transaction\n                // input.\n\n                let tx = provider\n                    .get_transaction_by_hash(tx_hash)\n                    .await\n                    .map_err(|e: RpcError\u003cTransportErrorKind\u003e| {\n                        eyre::eyre!(\"RPC error: {}\", e)\n                    })?\n                    .ok_or_else(|| {\n                        eyre::eyre!(\"Transaction receipt not found\")\n                    })?;\n\n                let input = tx.input().encode_hex();\n\n                // The pattern matches the contract address contained in the\n                // input\n                let contract_addr_regex =\n                    Regex::new(r\"[a-fA-F0-9]{8}0+([a-fA-F0-9]{40})$\")\n                        .context(\"Failed to create contract addr regex\")?;\n\n                let contract_addr = contract_addr_regex\n                    .captures(\u0026input)\n                    .and_then(|cap| cap.get(1))\n                    .context(format!(\n                        \"No contract address found in input {input}\"\n                    ))?\n                    .as_str();\n                let contract_address = Address::from_str(contract_addr)\n                    .context(format!(\n                        \"Failed to parse contract address from string: {contract_addr}\"\n                    ))?;\n\n                // now that we have the contract address, we only need the\n                // receipt\n                let receipt = provider\n                    .get_transaction_receipt(tx_hash)\n                    .await\n                    .map_err(|e: RpcError\u003cTransportErrorKind\u003e| {\n                        eyre::eyre!(\"RPC error: {}\", e)\n                    })?\n                    .ok_or_else(|| {\n                        eyre::eyre!(\"Transaction receipt not found\")\n                    })?;\n\n                return Ok(Receipt { inner: receipt, contract_address });\n            }\n        }\n\n        Err(eyre::eyre!(\"Deployment failed: {}\", stderr))\n    }\n\n    /// Constructs the receipt struct extracting the necessary receipt and\n    /// contract address data out of the `cargo stylus deploy` output with the\n    /// help of regex.\n    async fn get_receipt(\n        \u0026self,\n        output: std::process::Output,\n    ) -\u003e eyre::Result\u003cReceipt\u003e {\n        // Convert output to string\n        let output_str = String::from_utf8_lossy(\u0026output.stdout);\n\n        // first we get the contract address\n\n        // The pattern matches the contract address that is preceeded by\n        // ANSI escape codes (`cargo stylus deploy` outputs colored text).\n        let contract_addr_regex =\n            Regex::new(r\"deployed code at address:\\s*(?:\\x1B\\[[0-9;]*[a-zA-Z])*(0x[a-fA-F0-9]{40})\")\n                .context(\"Failed to create contract addr regex\")?;\n\n        let contract_addr = contract_addr_regex\n            .captures(\u0026output_str)\n            .and_then(|cap| cap.get(1))\n            .context(format!(\n                \"No contract address found in output {output_str}\"\n            ))?\n            .as_str();\n        let contract_address =\n            Address::from_str(contract_addr).context(format!(\n                \"Failed to parse contract address from string: {contract_addr}\"\n            ))?;\n\n        // Now we extract the transaction hash to fetch to receipt\n\n        let tx_hash_regex = Regex::new(r\"0x[a-fA-F0-9]{64}\")\n            .context(\"Failed to create tx hash regex\")?;\n\n        let tx_hash = tx_hash_regex\n            .find(\u0026*output_str)\n            .context(format!(\n                \"No transaction hash found in output {output_str}\"\n            ))?\n            .as_str();\n        let tx_hash = TxHash::from_str(tx_hash)\n            .context(\"Failed to parse transaction hash\")?;\n\n        // Finally we can fetch the receipt\n\n        let provider = ProviderBuilder::new()\n            .with_recommended_fillers()\n            .wallet(EthereumWallet::from(\n                self.private_key.parse::\u003cPrivateKeySigner\u003e()?,\n            ))\n            .on_http(Url::from_str(\u0026self.rpc_url).expect(\"invalid Url\"));\n\n        let receipt = provider\n            .get_transaction_receipt(tx_hash)\n            .await\n            .map_err(|e: RpcError\u003cTransportErrorKind\u003e| {\n                eyre::eyre!(\"RPC error: {}\", e)\n            })?\n            .ok_or_else(|| eyre::eyre!(\"Transaction receipt not found\"))?;\n\n        Ok(Receipt { inner: receipt, contract_address })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e","src","environment.rs"],"content":"use std::{path::PathBuf, process::Command};\n\nuse eyre::Context;\n\n/// Gets expected path to the nitro test node.\npub(crate) fn get_node_path() -\u003e eyre::Result\u003cPathBuf\u003e {\n    let manifest_dir = get_workspace_root()?;\n    Ok(manifest_dir.join(\"nitro-testnode\"))\n}\n\n/// Runs the following command to get the worskpace root:\n///\n/// ```bash\n/// git rev-parse --show-toplevel\n/// ```\npub(crate) fn get_workspace_root() -\u003e eyre::Result\u003cPathBuf\u003e {\n    let output = Command::new(\"git\")\n        .arg(\"rev-parse\")\n        .arg(\"--show-toplevel\")\n        .output()\n        .wrap_err(\"should run `git rev-parse --show-toplevel`\")?;\n\n    let path = String::from_utf8_lossy(\u0026output.stdout)\n        .trim()\n        .to_string()\n        .parse::\u003cPathBuf\u003e()\n        .wrap_err(\"failed to parse manifest dir path\")?;\n    Ok(path)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e","src","error.rs"],"content":"use alloy::{\n    sol_types::SolError,\n    transports::{RpcError, TransportErrorKind},\n};\nuse stylus_sdk::call::MethodError;\n\n/// Possible panic codes for a revert.\n///\n/// Taken from \u003chttps://github.com/NomicFoundation/hardhat/blob/main/packages/hardhat-chai-matchers/src/internal/reverted/panic.ts\u003e\n#[derive(Debug)]\n#[allow(missing_docs)] // Pretty straightforward variant names.\npub enum PanicCode {\n    AssertionError = 0x1,\n    ArithmeticOverflow = 0x11,\n    DivisionByZero = 0x12,\n    EnumConversionOutOfBounds = 0x21,\n    IncorrectlyEncodedStorageByteArray = 0x22,\n    PopOnEmptyArray = 0x31,\n    ArrayAccessOutOfBounds = 0x32,\n    TooMuchMemoryAllocated = 0x41,\n    ZeroInitializedVariable = 0x51,\n}\n\nimpl core::fmt::Display for PanicCode {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        let msg = match self {\n            PanicCode::AssertionError =\u003e\n                \"Assertion error\",\n            PanicCode::ArithmeticOverflow =\u003e\n                \"Arithmetic operation overflowed outside of an unchecked block\",\n            PanicCode::DivisionByZero =\u003e\n                \"Division or modulo division by zero\",\n            PanicCode::EnumConversionOutOfBounds =\u003e\n                \"Tried to convert a value into an enum, but the value was too big or negative\",\n            PanicCode::IncorrectlyEncodedStorageByteArray =\u003e\n                \"Incorrectly encoded storage byte array\",\n            PanicCode::PopOnEmptyArray =\u003e\n                \".pop() was called on an empty array\",\n            PanicCode::ArrayAccessOutOfBounds =\u003e\n                \"Array accessed at an out-of-bounds or negative index\",\n            PanicCode::TooMuchMemoryAllocated =\u003e\n                \"Too much memory was allocated, or an array was created that is too large\",\n            PanicCode::ZeroInitializedVariable =\u003e\n                \"Called a zero-initialized variable of internal function type\"\n        };\n\n        write!(f, \"{msg}\")\n    }\n}\n\n/// An error representing a panic.\npub trait Panic {\n    /// Checks that `Self` corresponds to a panic with code `code`.\n    fn panicked_with(\u0026self, code: PanicCode) -\u003e bool;\n}\n\n/// An error representing a revert with some data.\npub trait Revert\u003cE\u003e {\n    /// Checks that `Self` corresponds to the typed abi-encoded error\n    /// `expected`.\n    fn reverted_with(\u0026self, expected: E) -\u003e bool;\n}\n\nimpl Panic for alloy::contract::Error {\n    fn panicked_with(\u0026self, _code: PanicCode) -\u003e bool {\n        let Self::TransportError(e) = self else {\n            return false;\n        };\n\n        // FIXME: right now we cannot have any better error code for Panics\n        // check `e`:\n        //  ErrorResp(\n        //      ErrorPayload {\n        //          code: -32000,\n        //          message: \"execution reverted\",\n        //          data: None,\n        //      },\n        //  )\n        let payload = e.as_error_resp().expect(\"should contain payload\");\n        payload.code == -32000 \u0026\u0026 payload.message == \"execution reverted\"\n    }\n}\n\nimpl\u003cE: MethodError\u003e Revert\u003cE\u003e for alloy::contract::Error {\n    fn reverted_with(\u0026self, expected: E) -\u003e bool {\n        let Self::TransportError(e) = self else {\n            return false;\n        };\n\n        let raw_value = e\n            .as_error_resp()\n            .and_then(|payload| payload.data.clone())\n            .expect(\"should extract the error\");\n\n        let actual = \u0026raw_value.get().trim_matches('\"')[2..];\n        let expected = alloy::hex::encode(expected.encode());\n        expected == actual\n    }\n}\n\nimpl\u003cE: SolError\u003e Revert\u003cE\u003e for eyre::Report {\n    fn reverted_with(\u0026self, expected: E) -\u003e bool {\n        // Generic revert error\n        let Some(received) = self\n            .chain()\n            .find_map(|err| err.downcast_ref::\u003cRpcError\u003cTransportErrorKind\u003e\u003e())\n        else {\n            return false;\n        };\n        let RpcError::ErrorResp(received) = received else {\n            return false;\n        };\n        let Some(received) = \u0026received.data else {\n            return false;\n        };\n        let expected = alloy::hex::encode(expected.abi_encode());\n        received.to_string().contains(\u0026expected)\n    }\n}\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e","src","event.rs"],"content":"use std::fmt::Debug;\n\nuse alloy::{rpc::types::eth::TransactionReceipt, sol_types::SolEvent};\n\nuse crate::Receipt;\n\n/// Extension trait for asserting an event gets emitted.\npub trait Ext\u003cE\u003e {\n    /// Asserts the contract emitted the `expected` event.\n    fn emits(\u0026self, expected: E) -\u003e bool;\n}\n\nimpl\u003cE\u003e Ext\u003cE\u003e for TransactionReceipt\nwhere\n    E: SolEvent,\n    E: PartialEq,\n{\n    fn emits(\u0026self, expected: E) -\u003e bool {\n        // Extract all events that are the expected type.\n        self.inner\n            .logs()\n            .iter()\n            .filter_map(|log| log.log_decode().ok())\n            .map(|log| log.inner.data)\n            .any(|event| expected == event)\n    }\n}\n\nimpl\u003cE: Debug\u003e Ext\u003cE\u003e for Receipt\nwhere\n    E: SolEvent,\n    E: PartialEq,\n{\n    fn emits(\u0026self, expected: E) -\u003e bool {\n        self.inner.emits(expected)\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e","src","lib.rs"],"content":"#![doc = include_str!(\"../README.md\")]\nmod account;\nmod constructor_macro;\nmod deploy;\nmod environment;\nmod error;\nmod event;\nmod project;\nmod receipt;\nmod system;\n\npub use account::Account;\npub use constructor_macro::Constructor;\npub use deploy::{ContractDeploymentError, ContractInitializationError};\npub use e2e_proc::test;\npub use error::{Panic, PanicCode, Revert};\npub use event::Ext as EventExt;\npub use receipt::Receipt;\npub use system::{fund_account, Wallet, DEPLOYER_ADDRESS};\n\n/// This macro provides a shorthand for broadcasting the transaction to the\n/// network.\n///\n/// See: \u003chttps://docs.rs/alloy-contract/0.8.3/alloy_contract/struct.CallBuilder.html\u003e\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// #[e2e::test]\n/// async fn foo(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n///     let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n///     let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n///\n///     let alice_addr = alice.address();\n///     let token_id = random_token_id();\n///     let pending_tx = send!(contract.mint(alice_addr, token_id))?;\n///     // ...\n/// }\n#[macro_export]\nmacro_rules! send {\n    ($e:expr) =\u003e {\n        $e.send().await\n    };\n}\n\n/// This macro provides a shorthand for broadcasting the transaction\n/// to the network, and then waiting for the given number of confirmations.\n///\n/// See: \u003chttps://docs.rs/alloy-provider/0.8.3/alloy_provider/struct.PendingTransactionBuilder.html\u003e\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// #[e2e::test]\n/// async fn foo(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n///     let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n///     let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n///\n///     let alice_addr = alice.address();\n///     let token_id = random_token_id();\n///     let result = watch!(contract.mint(alice_addr, token_id))?;\n///     // ...\n/// }\n#[macro_export]\nmacro_rules! watch {\n    ($e:expr) =\u003e {\n        $crate::send!($e)?.watch().await\n    };\n}\n\n/// This macro provides a shorthand for broadcasting the transaction\n/// to the network, waiting for the given number of confirmations, and then\n/// fetching the transaction receipt.\n///\n/// See: \u003chttps://docs.rs/alloy-provider/0.8.3/alloy_provider/struct.PendingTransactionBuilder.html\u003e\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// #[e2e::test]\n/// async fn foo(alice: Account) -\u003e eyre::Result\u003c()\u003e {\n///     let contract_addr = alice.as_deployer().deploy().await?.contract_address;\n///     let contract = Erc721::new(contract_addr, \u0026alice.wallet);\n///\n///     let alice_addr = alice.address();\n///     let token_id = random_token_id();\n///     let receipt = receipt!(contract.mint(alice_addr, token_id))?;\n///     // ...\n/// }\n#[macro_export]\nmacro_rules! receipt {\n    ($e:expr) =\u003e {\n        $crate::send!($e)?.get_receipt().await\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e","src","project.rs"],"content":"use std::{\n    env,\n    ffi::OsStr,\n    fs::File,\n    io::{BufReader, Read},\n    path::{Path, PathBuf},\n};\n\nuse eyre::bail;\nuse toml::Table;\n\n/// Information about the crate subject of an integration test.\npub(crate) struct Crate {\n    /// Path to the compiled wasm binary.\n    pub(crate) wasm: PathBuf,\n}\n\nimpl Crate {\n    /// Collects crate information from the environment.\n    ///\n    /// # Errors\n    ///\n    /// May error if:\n    ///\n    /// - The current working directory is invalid.\n    /// - Could not read the package name from the manifest file.\n    /// - Could not read the path to the compiled wasm binary.\n    pub(crate) fn new() -\u003e eyre::Result\u003cSelf\u003e {\n        let manifest_dir = env::current_dir()?;\n        let name = read_pkg_name(\u0026manifest_dir)?;\n        let wasm = get_wasm(\u0026name)?;\n\n        Ok(Self { wasm })\n    }\n}\n\n/// Reads and parses the package name from a manifest in `path`.\n///\n/// # Errors\n///\n/// May error if:\n///\n/// - Unable to parse the `Cargo.toml` at `path`.\n/// - Unable to read the package name from the parsed toml file.\nfn read_pkg_name\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e eyre::Result\u003cString\u003e {\n    let cargo_toml = path.as_ref().join(\"Cargo.toml\");\n\n    let mut reader = BufReader::new(File::open(cargo_toml)?);\n    let mut buffer = String::new();\n    reader.read_to_string(\u0026mut buffer)?;\n\n    let table = buffer.parse::\u003cTable\u003e()?;\n    let name = table[\"package\"][\"name\"].as_str();\n\n    match name {\n        Some(x) =\u003e Ok(x.to_owned()),\n        None =\u003e Err(eyre::eyre!(\"unable to find package name in toml\")),\n    }\n}\n\n/// Returns the path to the compiled wasm binary with name `name`.\n///\n/// Note that this function works for both workspaces and standalone crates.\n///\n/// # Errors\n///\n/// May error if:\n///\n/// - Unable to read the current executable's path.\n/// - The output directory is not `target`.\nfn get_wasm(name: \u0026str) -\u003e eyre::Result\u003cPathBuf\u003e {\n    let name = name.replace('-', \"_\");\n    // Looks like\n    // \"rust-contracts-stylus/target/debug/deps/erc721-15764c2c9a33bee7\".\n    let mut target_dir = env::current_exe()?;\n\n    // Recursively find a `target` directory.\n    loop {\n        let Some(parent) = target_dir.parent() else {\n            // We've found `/`.\n            bail!(\"output directory is not 'target'\");\n        };\n\n        target_dir = parent.to_path_buf();\n        let Some(leaf) = target_dir.file_name() else {\n            // We've found the root because we are traversing a canonicalized\n            // path, which means there are no `..` segments, and we started at\n            // the executable.\n            bail!(\"output directory is not 'target'\");\n        };\n\n        if leaf == OsStr::new(\"target\") {\n            break;\n        }\n    }\n\n    let wasm = target_dir\n        .join(\"wasm32-unknown-unknown\")\n        .join(\"release\")\n        .join(format!(\"{name}.wasm\"));\n\n    Ok(wasm)\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e","src","receipt.rs"],"content":"use alloy::{primitives::Address, rpc::types::TransactionReceipt};\n\n/// Transaction receipt wrapper that contains both the receipt of the\n/// transaction sent to the StylusDeployer, and the contract address of the\n/// created/activated or even would-be created contract.\n///\n/// This is necessary because calling [`TransactionReceipt::contract_address`]\n/// would return the address of StylusDeployer, instead of the newly deployed\n/// contract.\n#[derive(Debug)]\npub struct Receipt {\n    /// Transaction receipt of the tx sent to StylusDeployer.\n    pub inner: TransactionReceipt,\n    /// Address of the contract.\n    pub contract_address: Address,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e","src","system.rs"],"content":"use alloy::{\n    network::{Ethereum, EthereumWallet},\n    primitives::Address,\n    providers::{\n        fillers::{\n            BlobGasFiller, ChainIdFiller, FillProvider, GasFiller, JoinFill,\n            NonceFiller, WalletFiller,\n        },\n        Identity, RootProvider,\n    },\n    transports::http::{Client, Http},\n};\nuse eyre::bail;\n\nuse crate::environment::get_node_path;\n\npub(crate) const RPC_URL_ENV_VAR_NAME: \u0026str = \"RPC_URL\";\n/// StylusDeployer contract address.\npub const DEPLOYER_ADDRESS: \u0026str = \"DEPLOYER_ADDRESS\";\n\n/// Convenience type alias that represents an Ethereum wallet.\npub type Wallet = FillProvider\u003c\n    JoinFill\u003c\n        JoinFill\u003c\n            Identity,\n            JoinFill\u003c\n                GasFiller,\n                JoinFill\u003cBlobGasFiller, JoinFill\u003cNonceFiller, ChainIdFiller\u003e\u003e,\n            \u003e,\n        \u003e,\n        WalletFiller\u003cEthereumWallet\u003e,\n    \u003e,\n    RootProvider\u003cHttp\u003cClient\u003e\u003e,\n    Http\u003cClient\u003e,\n    Ethereum,\n\u003e;\n\n/// Send `amount` eth to `address` in the nitro-tesnode.\n///\n/// # Errors\n///\n/// May fail if unable to find the path to the node or if funding the newly\n/// created account fails.\npub fn fund_account(address: Address, amount: u32) -\u003e eyre::Result\u003c()\u003e {\n    let node_script = get_node_path()?.join(\"test-node.bash\");\n    if !node_script.exists() {\n        bail!(\"Test nitro node wasn't setup properly. Try to setup it first with `./scripts/nitro-testnode.sh -i -d`\")\n    };\n\n    let output = std::process::Command::new(node_script)\n        .arg(\"script\")\n        .arg(\"send-l2\")\n        .arg(\"--to\")\n        .arg(format!(\"address_{address}\"))\n        .arg(\"--ethamount\")\n        .arg(amount.to_string())\n        .output()?;\n\n    if !output.status.success() {\n        let err = String::from_utf8_lossy(\u0026output.stderr);\n        bail!(\"account's wallet wasn't funded - address is {address}:\\n{err}\")\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e-proc","src","lib.rs"],"content":"#![doc = include_str!(\"../README.md\")]\nuse proc_macro::TokenStream;\n\nmod test;\n\n/// Defines an end-to-end Stylus contract test that sets up `e2e::Account`s\n/// based on the function's parameters.\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// #[e2e::test]\n/// async fn foo(alice: Account, bob: Account) -\u003e eyre::Result\u003c()\u003e {\n///     let charlie = Account::new().await?;\n///     // ...\n/// }\n/// ```\n#[proc_macro_attribute]\npub fn test(attr: TokenStream, input: TokenStream) -\u003e TokenStream {\n    test::test(\u0026attr, input)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubu","DEV","erc6909_gas_efficient","lib","e2e-proc","src","test.rs"],"content":"use proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, FnArg};\n\n/// Shorthand to print nice errors.\nmacro_rules! error {\n    ($tokens:expr, $($msg:expr),+ $(,)?) =\u003e {{\n        let error = syn::Error::new(syn::spanned::Spanned::span(\u0026$tokens), format!($($msg),+));\n        return error.to_compile_error().into();\n    }};\n    (@ $tokens:expr, $($msg:expr),+ $(,)?) =\u003e {{\n        return Err(syn::Error::new(syn::spanned::Spanned::span(\u0026$tokens), format!($($msg),+)))\n    }};\n}\n\n/// Defines an end-to-end test that injects test accounts through parameters.\n///\n/// For more information see [`crate::test`].\npub(crate) fn test(_attr: \u0026TokenStream, input: TokenStream) -\u003e TokenStream {\n    let item_fn = parse_macro_input!(input as syn::ItemFn);\n    let attrs = \u0026item_fn.attrs;\n    let sig = \u0026item_fn.sig;\n    let fn_name = \u0026sig.ident;\n    let fn_return_type = \u0026sig.output;\n    let fn_stmts = \u0026item_fn.block.stmts;\n    let fn_args = \u0026sig.inputs;\n\n    let account_declarations = fn_args.into_iter().map(|arg| {\n        let FnArg::Typed(arg) = arg else {\n            error!(arg, \"unexpected receiver argument in test signature\");\n        };\n        let account_arg_binding = \u0026arg.pat;\n        let account_ty = \u0026arg.ty;\n        quote! {\n            let #account_arg_binding = #account_ty::new().await?;\n        }\n    });\n    quote! {\n        #( #attrs )*\n        #[tokio::test]\n        async fn #fn_name() #fn_return_type {\n            #( #account_declarations )*\n            #( #fn_stmts )*\n        }\n    }\n    .into()\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>