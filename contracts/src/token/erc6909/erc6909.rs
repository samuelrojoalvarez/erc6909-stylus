// contracts/src/erc6909/erc6909.rs 
// FINAL VERSION WORKED FINE
// All test passed

#![no_std]
extern crate alloc;

// bring vec![] macro and Vec<T> into scope
use alloc::{vec, vec::Vec};

use alloy_primitives::{Address, U256};
use stylus_sdk::{
    prelude::{storage, HostAccess, StorageType},
    storage::{StorageBool, StorageMap, StorageUint},
};

use super::{
    error::Error,
    traits::{IErc6909, IErc6909Burnable, IErc6909Mintable},
};

// use stylus_sdk::testing::TestVM;


/// Core ERC-6909 (no supply tracking), single-ID multi-token standard.
///
/// All storage fields get a `::new(...)` constructor generated by the
/// `#[storage]` macro (requires `StorageType` in scope).
#[storage]
pub struct Erc6909 {
    /// owner ⇒ (id ⇒ balance)
    balances: StorageMap<Address, StorageMap<U256, StorageUint<256, 4>>>,

    /// owner ⇒ (spender ⇒ (id ⇒ allowance))
    allowances: StorageMap<
        Address,
        StorageMap<Address, StorageMap<U256, StorageUint<256, 4>>>,
    >,

    /// owner ⇒ (operator ⇒ approved?)
    operator_approvals: StorageMap<Address, StorageMap<Address, StorageBool>>,
}

impl Erc6909 {
    #[inline(always)]
    fn _update(
        &mut self,
        from: Address,
        to: Address,
        id: U256,
        amount: U256,
    ) -> Result<(), Error> {
        // debit from
        if from != Address::new([0u8; 20]) {
            let mut by_owner = self.balances.setter(from);
            let mut slot = by_owner.setter(id);
            let prev = slot.get();
            if prev < amount {
                return Err(Error::InsufficientBalance);
            }
            slot.set(prev - amount);
        }
        // credit to
        if to != Address::new([0u8; 20]) {
            let mut by_owner = self.balances.setter(to);
            let mut slot = by_owner.setter(id);
            let prev = slot.get();
            let next = prev.checked_add(amount).ok_or(Error::ArithmeticOverflow)?;
            slot.set(next);
        }
        Ok(())
    }

    #[inline(always)]
    pub fn _mint(
        &mut self,
        to: Address,
        id: U256,
        amount: U256,
    ) -> Result<(), Error> {
        if to == Address::new([0u8; 20]) {
            return Err(Error::InvalidReceiver);
        }
        self._update(Address::new([0u8; 20]), to, id, amount)
    }

    #[inline(always)]
    pub fn _burn(
        &mut self,
        from: Address,
        id: U256,
        amount: U256,
    ) -> Result<(), Error> {
        if from == Address::new([0u8; 20]) {
            return Err(Error::InvalidSender);
        }
        self._update(from, Address::new([0u8; 20]), id, amount)
    }
}

impl IErc6909 for Erc6909 {
    fn balance_of(&self, owner: Address, id: U256) -> U256 {
        self.balances.get(owner).get(id)
    }

    fn allowance(&self, owner: Address, spender: Address, id: U256) -> U256 {
        self.allowances.get(owner).get(spender).get(id)
    }

    fn is_operator(&self, owner: Address, operator: Address) -> bool {
        self.operator_approvals.get(owner).get(operator)
    }

    fn approve(
        &mut self,
        caller: Address,
        spender: Address,
        id: U256,
        amount: U256,
    ) -> Result<bool, Error> {
        // reject any zero-address as approver or spender
        if caller == Address::new([0u8; 20]) {
            return Err(Error::InvalidApprover);
        }
        if spender == Address::new([0u8; 20]) {
            return Err(Error::InvalidApprover);
        }
        let mut by_owner = self.allowances.setter(caller);
        let mut by_spender = by_owner.setter(spender);
        let mut slot = by_spender.setter(id);
        slot.set(amount);
        Ok(true)
    }

    fn set_operator(
        &mut self,
        caller: Address,
        operator: Address,
        approved: bool,
    ) -> Result<bool, Error> {
        if caller == Address::new([0u8; 20]) {
            return Err(Error::InvalidApprover);
        }
        if operator == Address::new([0u8; 20]) {
            return Err(Error::InvalidSpender);
        }
        let mut by_owner = self.operator_approvals.setter(caller);
        let mut slot = by_owner.setter(operator);
        slot.set(approved);
        Ok(true)
    }

    fn transfer(
        &mut self,
        caller: Address,
        to: Address,
        id: U256,
        amount: U256,
    ) -> Result<bool, Error> {
        self.transfer_from(caller, caller, to, id, amount)
    }

    fn transfer_from(
        &mut self,
        caller: Address,
        from: Address,
        to: Address,
        id: U256,
        amount: U256,
    ) -> Result<bool, Error> {
        if from == Address::new([0u8; 20]) {
            return Err(Error::InvalidSender);
        }
        if to == Address::new([0u8; 20]) {
            return Err(Error::InvalidReceiver);
        }
        if caller != from && !self.is_operator(from, caller) {
            let mut by_owner = self.allowances.setter(from);
            let mut by_caller = by_owner.setter(caller);
            let mut slot = by_caller.setter(id);
            let allowance = slot.get();
            if allowance < amount {
                return Err(Error::InsufficientAllowance);
            }
            slot.set(allowance - amount);
        }
        self._update(from, to, id, amount)?;
        Ok(true)
    }
}

impl IErc6909Mintable for Erc6909 {
    #[inline]
    fn mint(
        &mut self,
        caller: Address,
        to: Address,
        id: U256,
        amount: U256,
    ) -> Result<(), Error> {
        // guard against zero caller or recipient
        if caller == Address::new([0u8; 20]) {
            return Err(Error::InvalidApprover);
        }
        if to == Address::new([0u8; 20]) {
            return Err(Error::InvalidApprover);
        }
        // proceed with internal mint
        self._mint(to, id, amount)
    }
}

impl IErc6909Burnable for Erc6909 {
    #[inline]
    fn burn(
        &mut self,
        _caller: Address,
        from: Address,
        id: U256,
        amount: U256,
    ) -> Result<(), Error> {
        self._burn(from, id, amount)
    }
}


// Unit TESTS
#[cfg(test)]
mod tests {
    use super::*;
    use stylus_sdk::testing::TestVM;
    use alloy_primitives::{Address, U256};
    use crate::token::erc6909::Error;
    use motsu::prelude::*;

    // use crate::token::erc6909::extensions::composite_token::MyToken;


    // Core traits:
    use crate::token::erc6909::traits::{
        IErc6909,
        IErc6909Mintable,
        IErc6909Burnable,
    };

    // Extension traits & types:
    use crate::token::erc6909::traits::{
        IErc6909Supply,
        IErc6909MetadataUri,
        IErc6909Enumerable,
    };
    use crate::token::erc6909::extensions::{
        metadata_uri::Erc6909MetadataUri,
        token_supply::Erc6909Supply,
        enumerable::Erc6909Enumerable,
    };

    /// Helper: fresh core + VM + two addresses + an ID
    fn fresh_core() -> (Erc6909, TestVM, Address, Address, U256) {
        let vm    = TestVM::default();
        let t     = Erc6909::from(&vm);
        let alice = Address::new([0xAA;20]);
        let bob   = Address::new([0xBB;20]);
        let id    = U256::from(1u64);
        (t, vm, alice, bob, id)
    }

    #[motsu::test]
    fn zero_address_mint_reverts() {
        let (mut t, _, _, _, id) = fresh_core();
        let zero = Address::new([0u8;20]);
        let res = t.mint(zero, zero, id, U256::from(1u64));
        assert_eq!(res, Err(Error::InvalidApprover));
    }

    #[motsu::test]
    fn burn_underflow_reverts() {
        let (mut t, _, alice, _, id) = fresh_core();
        let res = t.burn(alice, alice, id, U256::from(1u64));
        assert_eq!(res, Err(Error::InsufficientBalance));
    }

    #[motsu::test]
    fn approve_zero_address_reverts() {
        let (mut t, _, alice, _, id) = fresh_core();
        let zero = Address::new([0u8;20]);
        let res = t.approve(alice, zero, id, U256::from(1u64));
        assert_eq!(res, Err(Error::InvalidApprover));
    }

    #[motsu::test]
    fn transfer_zero_amount_ok() {
        let (mut t, _, alice, bob, id) = fresh_core();
        t.mint(alice, alice, id, U256::from(10u64)).unwrap();
        assert!(t.transfer(alice, bob, id, U256::ZERO).unwrap());
    }

    #[motsu::test]
    fn supply_tracks_total() {
        let (_, vm, alice, _, id) = fresh_core();
        let mut sup = Erc6909Supply::from(&vm);
        // mint 7 for Alice
        sup.mint(alice, alice, id, U256::from(7u64)).unwrap();
        assert_eq!(sup.total_supply(id), U256::from(7u64));
        // burn 3
        sup.burn(alice, alice, id, U256::from(3u64)).unwrap();
        assert_eq!(sup.total_supply(id), U256::from(4u64));
    }

    #[motsu::test]
    fn metadata_round_trip() {
        let (_, vm, _, _, id) = fresh_core();
        let mut meta = Erc6909MetadataUri::from(&vm);
        let alice = Address::new([0xAA;20]);
        // only nonzero caller can set
        assert_eq!( meta.set_token_uri(alice, id, b"hello".to_vec()),
                    Ok(true) );
        assert_eq!( meta.token_uri(id), b"hello".to_vec() );
    }

    #[motsu::test]
    fn enumerable_behaviour() {
        let (_, vm, _, _, _) = fresh_core();
        let mut en = Erc6909Enumerable::from(&vm);

        en._record_id(U256::from(10u64));
        en._record_id(U256::from(20u64));
        en._record_id(U256::from(30u64));

        assert_eq!(en.total_ids(), U256::from(3u64));
        assert_eq!(en.id_by_index(U256::from(0u64)), U256::from(10u64));
        assert_eq!(en.id_by_index(U256::from(1u64)), U256::from(20u64));
        assert_eq!(en.id_by_index(U256::from(2u64)), U256::from(30u64));    
    }
}
