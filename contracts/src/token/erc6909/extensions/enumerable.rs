#![no_std]

use alloc::{vec, vec::Vec};
use core::convert::TryInto;

use alloy_primitives::U256;
use stylus_sdk::{
    host::VM,
    prelude::{storage, HostAccess, StorageType},
    storage::{StorageMap, StorageUint, StorageVec},
};

use crate::token::erc6909::traits::IErc6909Enumerable;

/// Enumerable extension: tracks all unique IDs and their indices.
#[storage]
pub struct Erc6909Enumerable {
    /// List of token IDs in insertion order.
    all_ids: StorageVec<StorageUint<256, 4>>,
    /// Mapping from token ID → its index in `all_ids`.
    index_of: StorageMap<U256, StorageUint<256, 4>>,
}

impl Erc6909Enumerable {
    /// Internal hook: record a new ID if not seen before.
    pub fn _record_id(&mut self, id: U256) {
        // 1) never record the zero‐ID
        if id == U256::ZERO {
            return;
        }

        // 2) if our map already holds a nonzero “sentinel,” skip
        //    (we store idx+1 below so that sentinel==0 always means “not seen”)
        if self.index_of.get(id) != U256::ZERO {
            return;
        }

        // 3) append into our Vec, then record idx+1 in the map
        let idx = U256::from(self.all_ids.len());
        self.all_ids.push(id);
        self.index_of.insert(id, idx + U256::ONE);    }
}

impl IErc6909Enumerable for Erc6909Enumerable {
    /// Returns the total number of unique IDs recorded.
    fn total_ids(&self) -> U256 {
        U256::from(self.all_ids.len())
    }

    /// Returns the token ID at the given index, or zero if out of bounds.
    fn id_by_index(&self, index: U256) -> U256 {
        // Convert U256 index to usize by taking the low 8 bytes
        let raw: [u8; 32] = index.to_le_bytes();
        let idx_u64 = u64::from_le_bytes(raw[0..8].try_into().unwrap());
        let idx_usize = idx_u64 as usize;

        self.all_ids.get(idx_usize).unwrap_or(U256::ZERO)
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use alloy_primitives::U256;
    use stylus_sdk::testing::TestVM;

    /// Pulls our extension out of storage so we can drive it like a normal Rust struct.
    fn fresh_ext() -> Erc6909Enumerable {
        let vm = TestVM::default();
        // this `.from(&vm)` is generated by #[storage]
        Erc6909Enumerable::from(&vm)
    }

    #[test]
    fn enumerable_tracks_unique_ids() {
        let mut ext = fresh_ext();
        // simulate: record [10, 20, 10, 30, 0]
        for &x in &[10u64, 20, 10, 30, 0] {
            ext._record_id(U256::from(x));
        }

        // duplicates & zero should have been ignored:
        assert_eq!(ext.total_ids(), U256::from(3u64));
        assert_eq!(ext.id_by_index(U256::ZERO), U256::from(10u64));
        assert_eq!(ext.id_by_index(U256::from(1u64)), U256::from(20u64));
        assert_eq!(ext.id_by_index(U256::from(2u64)), U256::from(30u64));
    }

    #[test]
    fn id_by_index_out_of_bounds_returns_zero() {
        let mut ext = fresh_ext();
        ext._record_id(U256::from(1u64));
        // we only have one entry, so asking at index 5 is out-of-bounds:
        assert_eq!(ext.id_by_index(U256::from(5u64)), U256::ZERO);
    }
}

// ——————————————————————————————————————————————————————————————————————————
// motsu-driven integration tests
// Run the tests: cargo test -p openzeppelin-stylus --features stylus-test
// ——————————————————————————————————————————————————————————————————————————
#[cfg(test)]
mod tests {
    use super::*;
    use alloy_primitives::{Address, U256};
    use stylus_sdk::testing::TestVM;
    use motsu::prelude::*;

    // Tell Motsu how to snapshot/rollback this pure-storage type
    #[cfg(not(feature = "erc6909"))]
    unsafe impl stylus_sdk::testing::TopLevelStorage for Erc6909Supply {}

    /// Helper to get a fresh `Contract<Erc6909Supply>` and a random account
    fn fresh() -> Contract<Erc6909Supply> {
        Contract::<Erc6909Supply>::new(&TestVM::default())
    }

    #[motsu::test]
    fn initial_total_is_zero(mut c: Contract<Erc6909Supply>, owner: Address) {
        let id = U256::from(1u64);
        // Nothing minted yet → total_supply must be zero
        assert_eq!(c.total_supply(id), U256::ZERO);
    }

    #[motsu::test]
    fn mint_increases_total(mut c: Contract<Erc6909Supply>, owner: Address) {
        let id     = U256::from(7u64);
        let amount = U256::from(42u64);

        // Mint `amount` to `owner`
        c.mint(owner, owner, id, amount).motsu_unwrap();

        // Now the total supply for `id` should be exactly `amount`
        assert_eq!(c.total_supply(id), amount);
    }

    #[motsu::test]
    fn burn_decreases_total(mut c: Contract<Erc6909Supply>, owner: Address) {
        let id         = U256::from(10u64);
        let minted_amt = U256::from(50u64);
        let burn_amt   = U256::from(15u64);

        // Mint then burn
        c.mint(owner, owner, id, minted_amt).motsu_unwrap();
        c.burn(owner, owner, id, burn_amt).motsu_unwrap();

        // Remaining supply = minted_amt - burn_amt
        assert_eq!(c.total_supply(id), minted_amt - burn_amt);
    }

    #[motsu::test]
    fn burn_without_mint_reverts(mut c: Contract<Erc6909Supply>, owner: Address) {
        let id = U256::from(99u64);

        // Trying to burn an ID that was never minted should revert
        c.burn(owner, owner, id, U256::ONE)
            .motsu_unwrap_err();
    }
}
