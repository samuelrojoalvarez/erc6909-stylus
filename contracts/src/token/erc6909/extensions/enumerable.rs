#![no_std]

use alloc::{vec, vec::Vec};
use core::convert::TryInto;

use alloy_primitives::U256;
use stylus_sdk::{
    host::VM,
    prelude::{storage, HostAccess, StorageType},
    storage::{StorageMap, StorageUint, StorageVec},
};

use crate::token::erc6909::traits::IErc6909Enumerable;

/// Enumerable extension: tracks all unique IDs and their indices.
#[storage]
pub struct Erc6909Enumerable {
    /// List of token IDs in insertion order.
    all_ids: StorageVec<StorageUint<256, 4>>,
    /// Mapping from token ID → its index in `all_ids`.
    index_of: StorageMap<U256, StorageUint<256, 4>>,
}

impl Erc6909Enumerable {
    /// Internal hook: record a new ID if not seen before.
    pub fn _record_id(&mut self, id: U256) {
        // 1) never record the zero‐ID
        if id == U256::ZERO {
            return;
        }

        // 2) if our map already holds a nonzero “sentinel,” skip
        //    (we store idx+1 below so that sentinel==0 always means “not seen”)
        if self.index_of.get(id) != U256::ZERO {
            return;
        }

        // 3) append into our Vec, then record idx+1 in the map
        let idx = U256::from(self.all_ids.len());
        self.all_ids.push(id);
        self.index_of.insert(id, idx + U256::ONE);    }
}

impl IErc6909Enumerable for Erc6909Enumerable {
    /// Returns the total number of unique IDs recorded.
    fn total_ids(&self) -> U256 {
        U256::from(self.all_ids.len())
    }

    /// Returns the token ID at the given index, or zero if out of bounds.
    fn id_by_index(&self, index: U256) -> U256 {
        // Convert U256 index to usize by taking the low 8 bytes
        let raw: [u8; 32] = index.to_le_bytes();
        let idx_u64 = u64::from_le_bytes(raw[0..8].try_into().unwrap());
        let idx_usize = idx_u64 as usize;

        self.all_ids.get(idx_usize).unwrap_or(U256::ZERO)
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use alloy_primitives::U256;
    use stylus_sdk::testing::TestVM;

    /// Pulls our extension out of storage so we can drive it like a normal Rust struct.
    fn fresh_ext() -> Erc6909Enumerable {
        let vm = TestVM::default();
        // this `.from(&vm)` is generated by #[storage]
        Erc6909Enumerable::from(&vm)
    }

    #[test]
    fn enumerable_tracks_unique_ids() {
        let mut ext = fresh_ext();
        // simulate: record [10, 20, 10, 30, 0]
        for &x in &[10u64, 20, 10, 30, 0] {
            ext._record_id(U256::from(x));
        }

        // duplicates & zero should have been ignored:
        assert_eq!(ext.total_ids(), U256::from(3u64));
        assert_eq!(ext.id_by_index(U256::ZERO), U256::from(10u64));
        assert_eq!(ext.id_by_index(U256::from(1u64)), U256::from(20u64));
        assert_eq!(ext.id_by_index(U256::from(2u64)), U256::from(30u64));
    }

    #[test]
    fn id_by_index_out_of_bounds_returns_zero() {
        let mut ext = fresh_ext();
        ext._record_id(U256::from(1u64));
        // we only have one entry, so asking at index 5 is out-of-bounds:
        assert_eq!(ext.id_by_index(U256::from(5u64)), U256::ZERO);
    }
}

// ——————————————————————————————————————————————————————————————————————————
// motsu-driven integration tests
// Run the tests: cargo test -p openzeppelin-stylus --features stylus-test
// ——————————————————————————————————————————————————————————————————————————
#[cfg(test)]
mod motsu_tests {
    use super::*;
    use alloy_primitives::U256;
    use stylus_sdk::testing::TestVM;
    use motsu::prelude::*;

    // Tell Motsu how to snapshot/rollback this pure‐storage type
    #[cfg_attr(feature = "enumerable", entrypoint)]
    unsafe impl stylus_sdk::testing::TopLevelStorage for Erc6909Enumerable {}

    /// Helper to get a fresh `Contract<Erc6909Enumerable>`
    fn fresh() -> Contract<Erc6909Enumerable> {
        Contract::<Erc6909Enumerable>::new(&TestVM::default())
    }

    #[motsu::test]
    fn initial_total_is_zero(mut c: Contract<Erc6909Enumerable>) {
        // With no IDs recorded, we expect zero
        assert_eq!(c.total_ids(), U256::ZERO);
    }

    #[motsu::test]
    fn record_zero_id_is_ignored(mut c: Contract<Erc6909Enumerable>) {
        // Recording the zero‐ID must do nothing
        c._record_id(U256::ZERO);
        assert_eq!(c.total_ids(), U256::ZERO);
    }

    #[motsu::test]
    fn tracks_unique_ids(mut c: Contract<Erc6909Enumerable>) {
        // simulate: record [10, 20, 10, 30, 0]
        for &x in &[10u64, 20, 10, 30, 0] {
            c._record_id(U256::from(x));
        }

        // duplicates & zero should have been ignored
        assert_eq!(c.total_ids(), U256::from(3u64));
        assert_eq!(c.id_by_index(U256::ZERO),     U256::from(10u64));
        assert_eq!(c.id_by_index(U256::from(1u64)), U256::from(20u64));
        assert_eq!(c.id_by_index(U256::from(2u64)), U256::from(30u64));
    }

    #[motsu::test]
    fn out_of_bounds_index_returns_zero(mut c: Contract<Erc6909Enumerable>) {
        // Record a single ID
        c._record_id(U256::from(55u64));
        // Asking at index 5 (which doesn't exist) must give zero
        assert_eq!(c.id_by_index(U256::from(5u64)), U256::ZERO);
    }
}
